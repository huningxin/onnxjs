/*!
* ONNX Runtime Web v1.8.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ort"] = factory();
	else
		root["ort"] = factory();
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../common/dist/lib/backend-impl.js":
/*!******************************************!*\
  !*** ../common/dist/lib/backend-impl.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerBackend": function() { return /* binding */ registerBackend; },
/* harmony export */   "resolveBackend": function() { return /* binding */ resolveBackend; }
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const backends = {};
const backendsSortedByPriority = [];
/**
 * Register a backend.
 *
 * @param name - the name as a key to lookup as an execution provider.
 * @param backend - the backend object.
 * @param priority - an integer indicating the priority of the backend. Higher number means higher priority.
 */
const registerBackend = (name, backend, priority) => {
    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {
        const currentBackend = backends[name];
        if (currentBackend === undefined) {
            backends[name] = { backend, priority };
        }
        else if (currentBackend.backend === backend) {
            return;
        }
        else {
            throw new Error(`backend "${name}" is already registered`);
        }
        for (let i = 0; i < backendsSortedByPriority.length; i++) {
            if (backends[backendsSortedByPriority[i]].priority <= priority) {
                backendsSortedByPriority.splice(i, 0, name);
                return;
            }
        }
        backendsSortedByPriority.push(name);
        return;
    }
    throw new TypeError('not a valid backend');
};
/**
 * Resolve backend by specified hints.
 *
 * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.
 * @returns a promise that resolves to the backend.
 */
const resolveBackend = async (backendHints) => {
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames) {
        const backendInfo = backends[backendName];
        if (backendInfo) {
            if (backendInfo.initialized) {
                return backendInfo.backend;
            }
            else if (backendInfo.initializing) {
                throw new Error(`backend "${backendName}" is being initialized; cannot initialize multiple times.`);
            }
            else if (backendInfo.aborted) {
                continue; // current backend is unavailable; try next
            }
            try {
                backendInfo.initializing = true;
                await backendInfo.backend.init();
                backendInfo.initialized = true;
                return backendInfo.backend;
            }
            catch (e) {
                errors.push({ name: backendName, err: e });
                backendInfo.aborted = true;
            }
            finally {
                backendInfo.initializing = false;
            }
        }
    }
    throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);
};
//# sourceMappingURL=backend-impl.js.map

/***/ }),

/***/ "../common/dist/lib/backend.js":
/*!*************************************!*\
  !*** ../common/dist/lib/backend.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerBackend": function() { return /* reexport safe */ _backend_impl__WEBPACK_IMPORTED_MODULE_0__.registerBackend; }
/* harmony export */ });
/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ "../common/dist/lib/backend-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//# sourceMappingURL=backend.js.map

/***/ }),

/***/ "../common/dist/lib/env-impl.js":
/*!**************************************!*\
  !*** ../common/dist/lib/env-impl.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EnvImpl": function() { return /* binding */ EnvImpl; }
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
class EnvImpl {
    constructor() {
        this.wasm = {};
        this.webgl = {};
        this.logLevelInternal = 'warning';
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        this.logLevelInternal = value;
    }
    get logLevel() {
        return this.logLevelInternal;
    }
}
//# sourceMappingURL=env-impl.js.map

/***/ }),

/***/ "../common/dist/lib/env.js":
/*!*********************************!*\
  !*** ../common/dist/lib/env.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "env": function() { return /* binding */ env; }
/* harmony export */ });
/* harmony import */ var _env_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl */ "../common/dist/lib/env-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

/**
 * Represent a set of flags as a global singleton.
 */
const env = new _env_impl__WEBPACK_IMPORTED_MODULE_0__.EnvImpl();
//# sourceMappingURL=env.js.map

/***/ }),

/***/ "../common/dist/lib/index.js":
/*!***********************************!*\
  !*** ../common/dist/lib/index.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "registerBackend": function() { return /* reexport safe */ _backend__WEBPACK_IMPORTED_MODULE_0__.registerBackend; },
/* harmony export */   "env": function() { return /* reexport safe */ _env__WEBPACK_IMPORTED_MODULE_1__.env; },
/* harmony export */   "InferenceSession": function() { return /* reexport safe */ _inference_session__WEBPACK_IMPORTED_MODULE_2__.InferenceSession; },
/* harmony export */   "Tensor": function() { return /* reexport safe */ _tensor__WEBPACK_IMPORTED_MODULE_3__.Tensor; }
/* harmony export */ });
/* harmony import */ var _backend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend */ "../common/dist/lib/backend.js");
/* harmony import */ var _env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env */ "../common/dist/lib/env.js");
/* harmony import */ var _inference_session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inference-session */ "../common/dist/lib/inference-session.js");
/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor */ "../common/dist/lib/tensor.js");
/* harmony import */ var _onnx_value__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./onnx-value */ "../common/dist/lib/onnx-value.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../common/dist/lib/inference-session-impl.js":
/*!****************************************************!*\
  !*** ../common/dist/lib/inference-session-impl.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InferenceSession": function() { return /* binding */ InferenceSession; }
/* harmony export */ });
/* harmony import */ var _backend_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl */ "../common/dist/lib/backend-impl.js");
/* harmony import */ var _tensor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor */ "../common/dist/lib/tensor.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.


class InferenceSession {
    constructor(handler) {
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1) {
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                }
                else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            }
            else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames) {
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    }
                    else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                }
                else {
                    options = arg1;
                }
            }
        }
        else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of this.inputNames) {
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames) {
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
                returnValue[key] = new _tensor__WEBPACK_IMPORTED_MODULE_1__.Tensor(results[key].type, results[key].data, results[key].dims);
            }
        }
        return returnValue;
    }
    static async create(arg0, arg1, arg2, arg3) {
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        }
        else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        }
        else if (arg0 instanceof ArrayBuffer ||
            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            }
            else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError('\'byteOffset\' must be an integer.');
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError('\'byteLength\' must be an integer.');
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    }
                    else if (typeof arg3 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                }
                else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'byteLength\' must be a number.');
                }
            }
            else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        }
        else {
            throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        }
        // get backend hints
        const eps = options.executionProviders || [];
        const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);
        const backend = await (0,_backend_impl__WEBPACK_IMPORTED_MODULE_0__.resolveBackend)(backendHints);
        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
}
//# sourceMappingURL=inference-session-impl.js.map

/***/ }),

/***/ "../common/dist/lib/inference-session.js":
/*!***********************************************!*\
  !*** ../common/dist/lib/inference-session.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InferenceSession": function() { return /* binding */ InferenceSession; }
/* harmony export */ });
/* harmony import */ var _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inference-session-impl */ "../common/dist/lib/inference-session-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// eslint-disable-next-line @typescript-eslint/naming-convention
const InferenceSession = _inference_session_impl__WEBPACK_IMPORTED_MODULE_0__.InferenceSession;
//# sourceMappingURL=inference-session.js.map

/***/ }),

/***/ "../common/dist/lib/onnx-value.js":
/*!****************************************!*\
  !*** ../common/dist/lib/onnx-value.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

//# sourceMappingURL=onnx-value.js.map

/***/ }),

/***/ "../common/dist/lib/tensor-impl.js":
/*!*****************************************!*\
  !*** ../common/dist/lib/tensor-impl.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tensor": function() { return /* binding */ Tensor; }
/* harmony export */ });
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';
const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    ['float32', Float32Array],
    ['uint8', Uint8Array],
    ['int8', Int8Array],
    ['uint16', Uint16Array],
    ['int16', Int16Array],
    ['int32', Int32Array],
    ['bool', Uint8Array],
    ['float64', Float64Array],
    ['uint32', Uint32Array],
]);
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [Float32Array, 'float32'],
    [Uint8Array, 'uint8'],
    [Int8Array, 'int8'],
    [Uint16Array, 'uint16'],
    [Int16Array, 'int16'],
    [Int32Array, 'int32'],
    [Float64Array, 'float64'],
    [Uint32Array, 'uint32'],
]);
if (isBigInt64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
}
if (isBigUint64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
}
/**
 * calculate size from dims.
 *
 * @param dims the dims array. May be an illegal input.
 */
const calculateSize = (dims) => {
    let size = 1;
    for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
class Tensor {
    constructor(arg0, arg1, arg2) {
        let type;
        let data;
        let dims;
        // check whether arg0 is type or data
        if (typeof arg0 === 'string') {
            //
            // Override: constructor(type, data, ...)
            //
            type = arg0;
            dims = arg2;
            if (arg0 === 'string') {
                // string tensor
                if (!Array.isArray(arg1)) {
                    throw new TypeError('A string tensor\'s data must be a string array.');
                }
                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                // error will be populated at inference
                data = arg1;
            }
            else {
                // numeric tensor
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === undefined) {
                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces
                    // incorrect results.
                    // 'typedArrayConstructor' should be one of the typed array prototype objects.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = typedArrayConstructor.from(arg1);
                }
                else if (arg1 instanceof typedArrayConstructor) {
                    data = arg1;
                }
                else {
                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
            }
        }
        else {
            //
            // Override: constructor(data, ...)
            //
            dims = arg1;
            if (Array.isArray(arg0)) {
                // only boolean[] and string[] is supported
                if (arg0.length === 0) {
                    throw new TypeError('Tensor type cannot be inferred from an empty array.');
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === 'string') {
                    type = 'string';
                    data = arg0;
                }
                else if (firstElementType === 'boolean') {
                    type = 'bool';
                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                    // wrong type. We use 'as any' to make it happy.
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data = Uint8Array.from(arg0);
                }
                else {
                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
            }
            else {
                // get tensor type from TypedArray
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === undefined) {
                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
            }
        }
        // type and data is processed, now processing dims
        if (dims === undefined) {
            // assume 1-D tensor if dims omitted
            dims = [data.length];
        }
        else if (!Array.isArray(dims)) {
            throw new TypeError('A tensor\'s dims must be a number array');
        }
        // perform check
        const size = calculateSize(dims);
        if (size !== data.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
        }
        this.dims = dims;
        this.type = type;
        this.data = data;
        this.size = size;
    }
    //#endregion
    //#region tensor utilities
    reshape(dims) {
        return new Tensor(this.type, this.data, dims);
    }
}
//# sourceMappingURL=tensor-impl.js.map

/***/ }),

/***/ "../common/dist/lib/tensor.js":
/*!************************************!*\
  !*** ../common/dist/lib/tensor.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tensor": function() { return /* binding */ Tensor; }
/* harmony export */ });
/* harmony import */ var _tensor_impl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl */ "../common/dist/lib/tensor-impl.js");
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// eslint-disable-next-line @typescript-eslint/naming-convention
const Tensor = _tensor_impl__WEBPACK_IMPORTED_MODULE_0__.Tensor;
//# sourceMappingURL=tensor.js.map

/***/ }),

/***/ "./lib/wasm/binding/ort-wasm-threaded.js":
/*!***********************************************!*\
  !*** ./lib/wasm/binding/ort-wasm-threaded.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var __filename = "/index.js";
var __dirname = "/";

var ortWasmThreaded = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (true) _scriptDir = _scriptDir || __filename;
  return (
function(ortWasmThreaded) {
  ortWasmThreaded = ortWasmThreaded || {};

function GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU8}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF64}var Module=typeof ortWasmThreaded!=="undefined"?ortWasmThreaded:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var ENVIRONMENT_IS_PTHREAD=Module["ENVIRONMENT_IS_PTHREAD"]||false;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;var nodeFS;var nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=__webpack_require__(/*! path */ "?75c6").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=__webpack_require__(/*! fs */ "?63c8");if(!nodePath)nodePath=__webpack_require__(/*! path */ "?75c6");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"};var nodeWorkerThreads;try{nodeWorkerThreads=__webpack_require__(/*! worker_threads */ "?c6f7")}catch(e){console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');throw e}__webpack_require__.g.Worker=nodeWorkerThreads.Worker}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs}else if(typeof arguments!="undefined"){arguments_=arguments}if(typeof quit==="function"){quit_=function(status){quit(status)}}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}if(ENVIRONMENT_IS_NODE){read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=__webpack_require__(/*! fs */ "?63c8");if(!nodePath)nodePath=__webpack_require__(/*! path */ "?75c6");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret}}else{read_=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=function(title){document.title=title}}else{}if(ENVIRONMENT_IS_NODE){if(typeof performance==="undefined"){__webpack_require__.g.performance=__webpack_require__(/*! perf_hooks */ "?674f").performance}}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}var Atomics_load=Atomics.load;var Atomics_store=Atomics.store;var Atomics_compareExchange=Atomics.compareExchange;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||false;if(typeof WebAssembly!=="object"){abort("no native wasm support detected")}var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var str="";while(!(idx>=endIdx)){var u0=heap[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,GROWABLE_HEAP_I8(),ret,size);return ret}function writeArrayToMemory(array,buffer){GROWABLE_HEAP_I8().set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){GROWABLE_HEAP_I8()[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)GROWABLE_HEAP_I8()[buffer>>0]=0}function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;if(ENVIRONMENT_IS_PTHREAD){buffer=Module["buffer"]}function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;if(ENVIRONMENT_IS_PTHREAD){wasmMemory=Module["wasmMemory"];buffer=Module["buffer"]}else{if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"]}else{wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,"maximum":2147483648/65536,"shared":true});if(!(wasmMemory.buffer instanceof SharedArrayBuffer)){err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");if(ENVIRONMENT_IS_NODE){console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)")}throw Error("bad memory")}}}if(wasmMemory){buffer=wasmMemory.buffer}INITIAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATINIT__)}function exitRuntime(){if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATEXIT__);flush_NO_FILESYSTEM();PThread.runExitHandlers();runtimeExited=true}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){assert(!ENVIRONMENT_IS_PTHREAD,"addRunDependency cannot be used in a pthread worker");runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(ENVIRONMENT_IS_PTHREAD)console.error("Pthread aborting at "+(new Error).stack);what+="";err(what);ABORT=true;EXITSTATUS=1;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile="ort-wasm-threaded.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmTable=Module["asm"]["eb"];addOnInit(Module["asm"]["Ma"]);PThread.tlsInitFunctions.push(Module["asm"]["jb"]);wasmModule=module;if(!ENVIRONMENT_IS_PTHREAD){removeRunDependency("wasm-instantiate")}}if(!ENVIRONMENT_IS_PTHREAD){addRunDependency("wasm-instantiate")}function receiveInstantiationResult(result){receiveInstance(result["instance"],result["module"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){var result=WebAssembly.instantiate(binary,info);return result}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}var ASM_CONSTS={653988:function(){throw"Canceled!"},654006:function($0,$1){setTimeout(function(){__emscripten_do_dispatch_to_thread($0,$1)},0)}};function initPthreadsJS(){PThread.initRuntime()}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)()}else{wasmTable.get(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var ERRNO_CODES={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function _emscripten_futex_wake(addr,count){if(addr<=0||addr>GROWABLE_HEAP_I8().length||addr&3!=0||count<0)return-28;if(count==0)return 0;if(count>=2147483647)count=Infinity;var mainThreadWaitAddress=Atomics.load(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2);var mainThreadWoken=0;if(mainThreadWaitAddress==addr){var loadedAddr=Atomics.compareExchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,mainThreadWaitAddress,0);if(loadedAddr==mainThreadWaitAddress){--count;mainThreadWoken=1;if(count<=0)return 1}}var ret=Atomics.notify(GROWABLE_HEAP_I32(),addr>>2,count);if(ret>=0)return ret+mainThreadWoken;throw"Atomics.notify returned an unexpected value "+ret}Module["_emscripten_futex_wake"]=_emscripten_futex_wake;function killThread(pthread_ptr){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!pthread_ptr)throw"Internal Error! Null pthread_ptr in killThread!";GROWABLE_HEAP_I32()[pthread_ptr+12>>2]=0;var pthread=PThread.pthreads[pthread_ptr];pthread.worker.terminate();PThread.freeThreadData(pthread);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker),1);pthread.worker.pthread=undefined}function cancelThread(pthread_ptr){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!pthread_ptr)throw"Internal Error! Null pthread_ptr in cancelThread!";var pthread=PThread.pthreads[pthread_ptr];pthread.worker.postMessage({"cmd":"cancel"})}function cleanupThread(pthread_ptr){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!pthread_ptr)throw"Internal Error! Null pthread_ptr in cleanupThread!";var pthread=PThread.pthreads[pthread_ptr];if(pthread){GROWABLE_HEAP_I32()[pthread_ptr+12>>2]=0;var worker=pthread.worker;PThread.returnWorkerToPool(worker)}}var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],initMainThreadBlock:function(){},initRuntime:function(){var tb=_malloc(228);for(var i=0;i<228/4;++i)GROWABLE_HEAP_U32()[tb/4+i]=0;GROWABLE_HEAP_I32()[tb+12>>2]=tb;var headPtr=tb+152;GROWABLE_HEAP_I32()[headPtr>>2]=headPtr;var tlsMemory=_malloc(512);for(var i=0;i<128;++i)GROWABLE_HEAP_U32()[tlsMemory/4+i]=0;Atomics.store(GROWABLE_HEAP_U32(),tb+100>>2,tlsMemory);Atomics.store(GROWABLE_HEAP_U32(),tb+40>>2,tb);__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1);_emscripten_register_main_browser_thread_id(tb)},initWorker:function(){},pthreads:{},threadExitHandlers:[],runExitHandlers:function(){while(PThread.threadExitHandlers.length>0){PThread.threadExitHandlers.pop()()}if(ENVIRONMENT_IS_PTHREAD&&_pthread_self())___pthread_tsd_run_dtors()},runExitHandlersAndDeinitThread:function(tb,exitCode){Atomics.store(GROWABLE_HEAP_U32(),tb+56>>2,1);Atomics.store(GROWABLE_HEAP_U32(),tb+60>>2,0);PThread.runExitHandlers();Atomics.store(GROWABLE_HEAP_U32(),tb+4>>2,exitCode);Atomics.store(GROWABLE_HEAP_U32(),tb+0>>2,1);_emscripten_futex_wake(tb+0,2147483647);__emscripten_thread_init(0,0,0)},setExitStatus:function(status){EXITSTATUS=status},threadExit:function(exitCode){var tb=_pthread_self();if(tb){PThread.runExitHandlersAndDeinitThread(tb,exitCode);if(ENVIRONMENT_IS_PTHREAD){postMessage({"cmd":"exit"})}}},threadCancel:function(){PThread.runExitHandlersAndDeinitThread(_pthread_self(),-1);postMessage({"cmd":"cancelDone"})},terminateAllThreads:function(){for(var t in PThread.pthreads){var pthread=PThread.pthreads[t];if(pthread&&pthread.worker){PThread.returnWorkerToPool(pthread.worker)}}PThread.pthreads={};for(var i=0;i<PThread.unusedWorkers.length;++i){var worker=PThread.unusedWorkers[i];worker.terminate()}PThread.unusedWorkers=[];for(var i=0;i<PThread.runningWorkers.length;++i){var worker=PThread.runningWorkers[i];var pthread=worker.pthread;PThread.freeThreadData(pthread);worker.terminate()}PThread.runningWorkers=[]},freeThreadData:function(pthread){if(!pthread)return;if(pthread.threadInfoStruct){var tlsMemory=GROWABLE_HEAP_I32()[pthread.threadInfoStruct+100>>2];GROWABLE_HEAP_I32()[pthread.threadInfoStruct+100>>2]=0;_free(tlsMemory);_free(pthread.threadInfoStruct)}pthread.threadInfoStruct=0;if(pthread.allocatedOwnStack&&pthread.stackBase)_free(pthread.stackBase);pthread.stackBase=0;if(pthread.worker)pthread.worker.pthread=null},returnWorkerToPool:function(worker){PThread.runWithoutMainThreadQueuedCalls(function(){delete PThread.pthreads[worker.pthread.threadInfoStruct];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);PThread.freeThreadData(worker.pthread);worker.pthread=undefined})},runWithoutMainThreadQueuedCalls:function(func){GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls>>2]=0;try{func()}finally{GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls>>2]=1}},receiveObjectTransfer:function(data){},threadInit:function(){for(var i in PThread.tlsInitFunctions){PThread.tlsInitFunctions[i]()}},loadWasmModuleToWorker:function(worker,onFinishedLoading){worker.onmessage=function(e){var d=e["data"];var cmd=d["cmd"];if(worker.pthread)PThread.currentProxiedOperationCallerThread=worker.pthread.threadInfoStruct;if(d["targetThread"]&&d["targetThread"]!=_pthread_self()){var thread=PThread.pthreads[d.targetThread];if(thread){thread.worker.postMessage(e.data,d["transferList"])}else{console.error('Internal error! Worker sent a message "'+cmd+'" to target pthread '+d["targetThread"]+", but that thread no longer exists!")}PThread.currentProxiedOperationCallerThread=undefined;return}if(cmd==="processQueuedMainThreadWork"){_emscripten_main_thread_process_queued_calls()}else if(cmd==="spawnThread"){spawnThread(e.data)}else if(cmd==="cleanupThread"){cleanupThread(d["thread"])}else if(cmd==="killThread"){killThread(d["thread"])}else if(cmd==="cancelThread"){cancelThread(d["thread"])}else if(cmd==="loaded"){worker.loaded=true;if(onFinishedLoading)onFinishedLoading(worker);if(worker.runPthread){worker.runPthread();delete worker.runPthread}}else if(cmd==="print"){out("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="printErr"){err("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="alert"){alert("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="exit"){var detached=worker.pthread&&Atomics.load(GROWABLE_HEAP_U32(),worker.pthread.threadInfoStruct+64>>2);if(detached){PThread.returnWorkerToPool(worker)}}else if(cmd==="exitProcess"){try{exit(d["returnCode"])}catch(e){if(e instanceof ExitStatus)return;throw e}}else if(cmd==="cancelDone"){PThread.returnWorkerToPool(worker)}else if(cmd==="objectTransfer"){PThread.receiveObjectTransfer(e.data)}else if(e.data.target==="setimmediate"){worker.postMessage(e.data)}else{err("worker sent an unknown command "+cmd)}PThread.currentProxiedOperationCallerThread=undefined};worker.onerror=function(e){err("pthread sent an error! "+e.filename+":"+e.lineno+": "+e.message)};if(ENVIRONMENT_IS_NODE){worker.on("message",function(data){worker.onmessage({data:data})});worker.on("error",function(data){worker.onerror(data)});worker.on("exit",function(data){})}worker.postMessage({"cmd":"load","urlOrBlob":Module["mainScriptUrlOrBlob"]||_scriptDir,"wasmMemory":wasmMemory,"wasmModule":wasmModule})},allocateUnusedWorker:function(){var pthreadMainJs=locateFile("ort-wasm-threaded.worker.js");PThread.unusedWorkers.push(new Worker(pthreadMainJs))},getNewWorker:function(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()},busySpinWait:function(msecs){var t=performance.now()+msecs;while(performance.now()<t){}}};function establishStackSpace(stackTop,stackMax){_emscripten_stack_set_limits(stackTop,stackMax);stackRestore(stackTop)}Module["establishStackSpace"]=establishStackSpace;function invokeEntryPoint(ptr,arg){return wasmTable.get(ptr)(arg)}Module["invokeEntryPoint"]=invokeEntryPoint;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}Module["keepRuntimeAlive"]=keepRuntimeAlive;function ___assert_fail(condition,filename,line,func){abort("Assertion failed: "+UTF8ToString(condition)+", at: "+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"])}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(ENVIRONMENT_IS_PTHREAD){_emscripten_get_now=function(){return performance.now()-Module["__performance_now_clock_drift"]}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else _emscripten_get_now=function(){return performance.now()};var _emscripten_get_now_is_monotonic=true;function setErrNo(value){GROWABLE_HEAP_I32()[___errno_location()>>2]=value;return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if((clk_id===1||clk_id===4)&&_emscripten_get_now_is_monotonic){now=_emscripten_get_now()}else{setErrNo(28);return-1}GROWABLE_HEAP_I32()[tp>>2]=now/1e3|0;GROWABLE_HEAP_I32()[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function ___clock_gettime(a0,a1){return _clock_gettime(a0,a1)}var ExceptionInfoAttrs={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};function ___cxa_allocate_exception(size){return _malloc(size+ExceptionInfoAttrs.SIZE)+ExceptionInfoAttrs.SIZE}function _atexit(func,arg){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(1,1,func,arg);__ATEXIT__.unshift({func:func,arg:arg})}function ___cxa_atexit(a0,a1){return _atexit(a0,a1)}function _pthread_cleanup_push(routine,arg){PThread.threadExitHandlers.push(function(){wasmTable.get(routine)(arg)})}function ___cxa_thread_atexit(a0,a1){return _pthread_cleanup_push(a0,a1)}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-ExceptionInfoAttrs.SIZE;this.set_type=function(type){GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]=type};this.get_type=function(){return GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]};this.set_destructor=function(destructor){GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]=destructor};this.get_destructor=function(){return GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]};this.set_refcount=function(refcount){GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]=caught};this.get_caught=function(){return GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]=rethrown};this.get_rethrown=function(){return GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]!=0};this.init=function(type,destructor){this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){Atomics.add(GROWABLE_HEAP_I32(),this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2,1)};this.release_ref=function(){var prev=Atomics.sub(GROWABLE_HEAP_I32(),this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2,1);return prev===1}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=GROWABLE_HEAP_I32()[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},get64:function(low,high){return low}};function ___sys_access(path,amode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(2,1,path,amode);path=SYSCALLS.getStr(path);return SYSCALLS.doAccess(path,amode)}function ___sys_fcntl64(fd,cmd,varargs){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(3,1,fd,cmd,varargs);SYSCALLS.varargs=varargs;return 0}function ___sys_fstat64(fd,buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(4,1,fd,buf)}function ___sys_getdents64(fd,dirp,count){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(5,1,fd,dirp,count)}function ___sys_getpid(){return 42}function ___sys_ioctl(fd,op,varargs){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(6,1,fd,op,varargs);SYSCALLS.varargs=varargs;return 0}function ___sys_lstat64(path,buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(7,1,path,buf)}function ___sys_mkdir(path,mode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(8,1,path,mode);path=SYSCALLS.getStr(path);return SYSCALLS.doMkdir(path,mode)}function syscallMmap2(addr,len,prot,flags,fd,off){off<<=12;var ptr;var allocated=false;if((flags&16)!==0&&addr%65536!==0){return-28}if((flags&32)!==0){ptr=_memalign(65536,len);if(!ptr)return-48;_memset(ptr,0,len);allocated=true}else{return-52}SYSCALLS.mappings[ptr]={malloc:ptr,len:len,allocated:allocated,fd:fd,prot:prot,flags:flags,offset:off};return ptr}function ___sys_mmap2(addr,len,prot,flags,fd,off){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(9,1,addr,len,prot,flags,fd,off);return syscallMmap2(addr,len,prot,flags,fd,off)}function syscallMunmap(addr,len){if((addr|0)===-1||len===0){return-28}var info=SYSCALLS.mappings[addr];if(!info)return 0;if(len===info.len){SYSCALLS.mappings[addr]=null;if(info.allocated){_free(info.malloc)}}return 0}function ___sys_munmap(addr,len){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(10,1,addr,len);return syscallMunmap(addr,len)}function ___sys_open(path,flags,varargs){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(11,1,path,flags,varargs);SYSCALLS.varargs=varargs}function ___sys_readlink(path,buf,bufsize){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(12,1,path,buf,bufsize);path=SYSCALLS.getStr(path);return SYSCALLS.doReadlink(path,buf,bufsize)}function ___sys_rmdir(path){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(13,1,path)}function ___sys_stat64(path,buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(14,1,path,buf)}function ___sys_unlink(path){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(15,1,path)}function __emscripten_notify_thread_queue(targetThreadId,mainThreadId){if(targetThreadId==mainThreadId){postMessage({"cmd":"processQueuedMainThreadWork"})}else if(ENVIRONMENT_IS_PTHREAD){postMessage({"targetThread":targetThreadId,"cmd":"processThreadQueue"})}else{var pthread=PThread.pthreads[targetThreadId];var worker=pthread&&pthread.worker;if(!worker){return}worker.postMessage({"cmd":"processThreadQueue"})}return 1}function _abort(){abort()}function _difftime(time1,time0){return time1-time0}function _dlclose(handle){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlerror(){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlopen(filename,flag){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlsym(handle,symbol){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}var readAsmConstArgsArray=[];function readAsmConstArgs(sigPtr,buf){readAsmConstArgsArray.length=0;var ch;buf>>=2;while(ch=GROWABLE_HEAP_U8()[sigPtr++]){var double=ch<105;if(double&&buf&1)buf++;readAsmConstArgsArray.push(double?GROWABLE_HEAP_F64()[buf++>>1]:GROWABLE_HEAP_I32()[buf]);++buf}return readAsmConstArgsArray}function _emscripten_asm_const_int(code,sigPtr,argbuf){var args=readAsmConstArgs(sigPtr,argbuf);return ASM_CONSTS[code].apply(null,args)}function _emscripten_check_blocking_allowed(){if(ENVIRONMENT_IS_NODE)return;if(ENVIRONMENT_IS_WORKER)return;warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function _emscripten_conditional_set_current_thread_status(expectedStatus,newStatus){}function _emscripten_futex_wait(addr,val,timeout){if(addr<=0||addr>GROWABLE_HEAP_I8().length||addr&3!=0)return-28;if(!ENVIRONMENT_IS_WEB){var ret=Atomics.wait(GROWABLE_HEAP_I32(),addr>>2,val,timeout);if(ret==="timed-out")return-73;if(ret==="not-equal")return-6;if(ret==="ok")return 0;throw"Atomics.wait returned an unexpected value "+ret}else{if(Atomics.load(GROWABLE_HEAP_I32(),addr>>2)!=val){return-6}var tNow=performance.now();var tEnd=tNow+timeout;var lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,addr);while(1){tNow=performance.now();if(tNow>tEnd){lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,0);return-73}lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,0);if(lastAddr==0){break}_emscripten_main_thread_process_queued_calls();if(Atomics.load(GROWABLE_HEAP_I32(),addr>>2)!=val){return-6}lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,addr)}return 0}}function _emscripten_get_heap_max(){return 2147483648}function _emscripten_memcpy_big(dest,src,num){GROWABLE_HEAP_U8().copyWithin(dest,src,src+num)}function _emscripten_num_logical_cores(){if(ENVIRONMENT_IS_NODE)return __webpack_require__(/*! os */ "?aedb").cpus().length;return navigator["hardwareConcurrency"]}function _emscripten_proxy_to_main_thread_js(index,sync){var numCallArgs=arguments.length-2;var stack=stackSave();var serializedNumCallArgs=numCallArgs;var args=stackAlloc(serializedNumCallArgs*8);var b=args>>3;for(var i=0;i<numCallArgs;i++){var arg=arguments[2+i];GROWABLE_HEAP_F64()[b+i]=arg}var ret=_emscripten_run_in_main_runtime_thread_js(index,serializedNumCallArgs,args,sync);stackRestore(stack);return ret}var _emscripten_receive_on_main_thread_js_callArgs=[];function _emscripten_receive_on_main_thread_js(index,numCallArgs,args){_emscripten_receive_on_main_thread_js_callArgs.length=numCallArgs;var b=args>>3;for(var i=0;i<numCallArgs;i++){_emscripten_receive_on_main_thread_js_callArgs[i]=GROWABLE_HEAP_F64()[b+i]}var isEmAsmConst=index<0;var func=!isEmAsmConst?proxiedFunctionTable[index]:ASM_CONSTS[-index-1];return func.apply(null,_emscripten_receive_on_main_thread_js_callArgs)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=GROWABLE_HEAP_U8().length;requestedSize=requestedSize>>>0;if(requestedSize<=oldSize){return false}var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var JSEvents={inEventHandler:0,removeAllEventListeners:function(){for(var i=JSEvents.eventHandlers.length-1;i>=0;--i){JSEvents._removeHandler(i)}JSEvents.eventHandlers=[];JSEvents.deferredCalls=[]},registerRemoveEventListeners:function(){if(!JSEvents.removeEventListenersRegistered){__ATEXIT__.push(JSEvents.removeAllEventListeners);JSEvents.removeEventListenersRegistered=true}},deferredCalls:[],deferCall:function(targetFunction,precedence,argsList){function arraysHaveEqualContent(arrA,arrB){if(arrA.length!=arrB.length)return false;for(var i in arrA){if(arrA[i]!=arrB[i])return false}return true}for(var i in JSEvents.deferredCalls){var call=JSEvents.deferredCalls[i];if(call.targetFunction==targetFunction&&arraysHaveEqualContent(call.argsList,argsList)){return}}JSEvents.deferredCalls.push({targetFunction:targetFunction,precedence:precedence,argsList:argsList});JSEvents.deferredCalls.sort(function(x,y){return x.precedence<y.precedence})},removeDeferredCalls:function(targetFunction){for(var i=0;i<JSEvents.deferredCalls.length;++i){if(JSEvents.deferredCalls[i].targetFunction==targetFunction){JSEvents.deferredCalls.splice(i,1);--i}}},canPerformEventHandlerRequests:function(){return JSEvents.inEventHandler&&JSEvents.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!JSEvents.canPerformEventHandlerRequests()){return}for(var i=0;i<JSEvents.deferredCalls.length;++i){var call=JSEvents.deferredCalls[i];JSEvents.deferredCalls.splice(i,1);--i;call.targetFunction.apply(null,call.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(target,eventTypeString){for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==target&&(!eventTypeString||eventTypeString==JSEvents.eventHandlers[i].eventTypeString)){JSEvents._removeHandler(i--)}}},_removeHandler:function(i){var h=JSEvents.eventHandlers[i];h.target.removeEventListener(h.eventTypeString,h.eventListenerFunc,h.useCapture);JSEvents.eventHandlers.splice(i,1)},registerOrRemoveHandler:function(eventHandler){var jsEventHandler=function jsEventHandler(event){++JSEvents.inEventHandler;JSEvents.currentEventHandler=eventHandler;JSEvents.runDeferredCalls();eventHandler.handlerFunc(event);JSEvents.runDeferredCalls();--JSEvents.inEventHandler};if(eventHandler.callbackfunc){eventHandler.eventListenerFunc=jsEventHandler;eventHandler.target.addEventListener(eventHandler.eventTypeString,jsEventHandler,eventHandler.useCapture);JSEvents.eventHandlers.push(eventHandler);JSEvents.registerRemoveEventListeners()}else{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==eventHandler.target&&JSEvents.eventHandlers[i].eventTypeString==eventHandler.eventTypeString){JSEvents._removeHandler(i--)}}}},queueEventHandlerOnThread_iiii:function(targetThread,eventHandlerFunc,eventTypeId,eventData,userData){var stackTop=stackSave();var varargs=stackAlloc(12);GROWABLE_HEAP_I32()[varargs>>2]=eventTypeId;GROWABLE_HEAP_I32()[varargs+4>>2]=eventData;GROWABLE_HEAP_I32()[varargs+8>>2]=userData;__emscripten_call_on_thread(0,targetThread,637534208,eventHandlerFunc,eventData,varargs);stackRestore(stackTop)},getTargetThreadForEventCallback:function(targetThread){switch(targetThread){case 1:return 0;case 2:return PThread.currentProxiedOperationCallerThread;default:return targetThread}},getNodeNameForTarget:function(target){if(!target)return"";if(target==window)return"#window";if(target==screen)return"#screen";return target&&target.nodeName?target.nodeName:""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function stringToNewUTF8(jsString){var length=lengthBytesUTF8(jsString)+1;var cString=_malloc(length);stringToUTF8(jsString,cString,length);return cString}function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread,targetCanvas,width,height){var stackTop=stackSave();var varargs=stackAlloc(12);var targetCanvasPtr=0;if(targetCanvas){targetCanvasPtr=stringToNewUTF8(targetCanvas)}GROWABLE_HEAP_I32()[varargs>>2]=targetCanvasPtr;GROWABLE_HEAP_I32()[varargs+4>>2]=width;GROWABLE_HEAP_I32()[varargs+8>>2]=height;__emscripten_call_on_thread(0,targetThread,657457152,0,targetCanvasPtr,varargs);stackRestore(stackTop)}function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread,targetCanvas,width,height){targetCanvas=targetCanvas?UTF8ToString(targetCanvas):"";_emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread,targetCanvas,width,height)}function maybeCStringToJsString(cString){return cString>2?UTF8ToString(cString):cString}var specialHTMLTargets=[0,typeof document!=="undefined"?document:0,typeof window!=="undefined"?window:0];function findEventTarget(target){target=maybeCStringToJsString(target);var domElement=specialHTMLTargets[target]||(typeof document!=="undefined"?document.querySelector(target):undefined);return domElement}function findCanvasEventTarget(target){return findEventTarget(target)}function _emscripten_set_canvas_element_size_calling_thread(target,width,height){var canvas=findCanvasEventTarget(target);if(!canvas)return-4;if(canvas.canvasSharedPtr){GROWABLE_HEAP_I32()[canvas.canvasSharedPtr>>2]=width;GROWABLE_HEAP_I32()[canvas.canvasSharedPtr+4>>2]=height}if(canvas.offscreenCanvas||!canvas.controlTransferredOffscreen){if(canvas.offscreenCanvas)canvas=canvas.offscreenCanvas;var autoResizeViewport=false;if(canvas.GLctxObject&&canvas.GLctxObject.GLctx){var prevViewport=canvas.GLctxObject.GLctx.getParameter(2978);autoResizeViewport=prevViewport[0]===0&&prevViewport[1]===0&&prevViewport[2]===canvas.width&&prevViewport[3]===canvas.height}canvas.width=width;canvas.height=height;if(autoResizeViewport){canvas.GLctxObject.GLctx.viewport(0,0,width,height)}}else if(canvas.canvasSharedPtr){var targetThread=GROWABLE_HEAP_I32()[canvas.canvasSharedPtr+8>>2];_emscripten_set_offscreencanvas_size_on_target_thread(targetThread,target,width,height);return 1}else{return-4}return 0}function _emscripten_set_canvas_element_size_main_thread(target,width,height){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(16,1,target,width,height);return _emscripten_set_canvas_element_size_calling_thread(target,width,height)}function _emscripten_set_canvas_element_size(target,width,height){var canvas=findCanvasEventTarget(target);if(canvas){return _emscripten_set_canvas_element_size_calling_thread(target,width,height)}else{return _emscripten_set_canvas_element_size_main_thread(target,width,height)}}function _emscripten_set_current_thread_status(newStatus){}function __webgl_enable_ANGLE_instanced_arrays(ctx){var ext=ctx.getExtension("ANGLE_instanced_arrays");if(ext){ctx["vertexAttribDivisor"]=function(index,divisor){ext["vertexAttribDivisorANGLE"](index,divisor)};ctx["drawArraysInstanced"]=function(mode,first,count,primcount){ext["drawArraysInstancedANGLE"](mode,first,count,primcount)};ctx["drawElementsInstanced"]=function(mode,count,type,indices,primcount){ext["drawElementsInstancedANGLE"](mode,count,type,indices,primcount)};return 1}}function __webgl_enable_OES_vertex_array_object(ctx){var ext=ctx.getExtension("OES_vertex_array_object");if(ext){ctx["createVertexArray"]=function(){return ext["createVertexArrayOES"]()};ctx["deleteVertexArray"]=function(vao){ext["deleteVertexArrayOES"](vao)};ctx["bindVertexArray"]=function(vao){ext["bindVertexArrayOES"](vao)};ctx["isVertexArray"]=function(vao){return ext["isVertexArrayOES"](vao)};return 1}}function __webgl_enable_WEBGL_draw_buffers(ctx){var ext=ctx.getExtension("WEBGL_draw_buffers");if(ext){ctx["drawBuffers"]=function(n,bufs){ext["drawBuffersWEBGL"](n,bufs)};return 1}}function __webgl_enable_WEBGL_multi_draw(ctx){return!!(ctx.multiDrawWebgl=ctx.getExtension("WEBGL_multi_draw"))}var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function recordError(errorCode){if(!GL.lastError){GL.lastError=errorCode}},getNewId:function(table){var ret=GL.counter++;for(var i=table.length;i<ret;i++){table[i]=null}return ret},getSource:function(shader,count,string,length){var source="";for(var i=0;i<count;++i){var len=length?GROWABLE_HEAP_I32()[length+i*4>>2]:-1;source+=UTF8ToString(GROWABLE_HEAP_I32()[string+i*4>>2],len<0?undefined:len)}return source},createContext:function(canvas,webGLContextAttributes){if(!canvas.getContextSafariWebGL2Fixed){canvas.getContextSafariWebGL2Fixed=canvas.getContext;canvas.getContext=function(ver,attrs){var gl=canvas.getContextSafariWebGL2Fixed(ver,attrs);return ver=="webgl"==gl instanceof WebGLRenderingContext?gl:null}}var ctx=canvas.getContext("webgl",webGLContextAttributes);if(!ctx)return 0;var handle=GL.registerContext(ctx,webGLContextAttributes);return handle},registerContext:function(ctx,webGLContextAttributes){var handle=_malloc(8);GROWABLE_HEAP_I32()[handle+4>>2]=_pthread_self();var context={handle:handle,attributes:webGLContextAttributes,version:webGLContextAttributes.majorVersion,GLctx:ctx};if(ctx.canvas)ctx.canvas.GLctxObject=context;GL.contexts[handle]=context;if(typeof webGLContextAttributes.enableExtensionsByDefault==="undefined"||webGLContextAttributes.enableExtensionsByDefault){GL.initExtensions(context)}return handle},makeContextCurrent:function(contextHandle){GL.currentContext=GL.contexts[contextHandle];Module.ctx=GLctx=GL.currentContext&&GL.currentContext.GLctx;return!(contextHandle&&!GLctx)},getContext:function(contextHandle){return GL.contexts[contextHandle]},deleteContext:function(contextHandle){if(GL.currentContext===GL.contexts[contextHandle])GL.currentContext=null;if(typeof JSEvents==="object")JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);if(GL.contexts[contextHandle]&&GL.contexts[contextHandle].GLctx.canvas)GL.contexts[contextHandle].GLctx.canvas.GLctxObject=undefined;_free(GL.contexts[contextHandle].handle);GL.contexts[contextHandle]=null},initExtensions:function(context){if(!context)context=GL.currentContext;if(context.initExtensionsDone)return;context.initExtensionsDone=true;var GLctx=context.GLctx;__webgl_enable_ANGLE_instanced_arrays(GLctx);__webgl_enable_OES_vertex_array_object(GLctx);__webgl_enable_WEBGL_draw_buffers(GLctx);{GLctx.disjointTimerQueryExt=GLctx.getExtension("EXT_disjoint_timer_query")}__webgl_enable_WEBGL_multi_draw(GLctx);var exts=GLctx.getSupportedExtensions()||[];exts.forEach(function(ext){if(!ext.includes("lose_context")&&!ext.includes("debug")){GLctx.getExtension(ext)}})}};var __emscripten_webgl_power_preferences=["default","low-power","high-performance"];function _emscripten_webgl_do_create_context(target,attributes){var a=attributes>>2;var powerPreference=GROWABLE_HEAP_I32()[a+(24>>2)];var contextAttributes={"alpha":!!GROWABLE_HEAP_I32()[a+(0>>2)],"depth":!!GROWABLE_HEAP_I32()[a+(4>>2)],"stencil":!!GROWABLE_HEAP_I32()[a+(8>>2)],"antialias":!!GROWABLE_HEAP_I32()[a+(12>>2)],"premultipliedAlpha":!!GROWABLE_HEAP_I32()[a+(16>>2)],"preserveDrawingBuffer":!!GROWABLE_HEAP_I32()[a+(20>>2)],"powerPreference":__emscripten_webgl_power_preferences[powerPreference],"failIfMajorPerformanceCaveat":!!GROWABLE_HEAP_I32()[a+(28>>2)],majorVersion:GROWABLE_HEAP_I32()[a+(32>>2)],minorVersion:GROWABLE_HEAP_I32()[a+(36>>2)],enableExtensionsByDefault:GROWABLE_HEAP_I32()[a+(40>>2)],explicitSwapControl:GROWABLE_HEAP_I32()[a+(44>>2)],proxyContextToMainThread:GROWABLE_HEAP_I32()[a+(48>>2)],renderViaOffscreenBackBuffer:GROWABLE_HEAP_I32()[a+(52>>2)]};var canvas=findCanvasEventTarget(target);if(!canvas){return 0}if(contextAttributes.explicitSwapControl){return 0}var contextHandle=GL.createContext(canvas,contextAttributes);return contextHandle}function _emscripten_webgl_create_context(a0,a1){return _emscripten_webgl_do_create_context(a0,a1)}var WebNN={initManagers:function(){if(this["mgrContext"])return;function makeManager(){return{objects:{},nextId:1,create:function(object,wrapper){wrapper=wrapper||{};var id=this.nextId++;wrapper.refcount=1;wrapper.object=object;this.objects[id]=wrapper;return id},get:function(id){if(id===0)return undefined;var o=this.objects[id];return o.object},reference:function(id){var o=this.objects[id];o.refcount++},release:function(id){var o=this.objects[id];o.refcount--;if(o.refcount<=0){delete this.objects[id]}}}}this["mgrContext"]=this["mgrContext"]||makeManager();this.mgrGraph=this.mgrGraph||makeManager();this.mgrGraphBuilder=this.mgrGraphBuilder||makeManager();this.mgrNamedInputs=this.mgrNamedInputs||makeManager();this.mgrNamedOperands=this.mgrNamedOperands||makeManager();this.mgrNamedOutputs=this.mgrNamedOutputs||makeManager();this.mgrNamedResults=this.mgrNamedResults||makeManager();this.mgrOperand=this.mgrOperand||makeManager();this.mgrResult=this.mgrResult||makeManager()},AutoPad:["explicit","same-upper","same-lower"],BuildGraphStatus:["success","error","context-lost","unknown"],ComputeGraphStatus:["success","error","context-lost","unknown"],ErrorFilter:["none","validation","out-of-memory"],ErrorType:["no-error","validation","out-of-memory","unknown","device-lost"],FilterOperandLayout:["oihw","hwio","ohwi","ihwo"],FusedActivation:["none","relu"],InputOperandLayout:["nchw","nhwc"],OperandType:["float32","float16","int32","uint32","int8","uint8"],PowerPreference:["default","high_performance","low_power"],makeI32Array:function(count,arrayPtr){if(count===0||arrayPtr===0){return undefined}var array=[];for(var i=0;i<count;++i,arrayPtr+=4){array.push(GROWABLE_HEAP_I32()[arrayPtr>>2])}return array},makeArrayBufferView:function(offset,byteSize,type="float32"){assert(type==="float32");return new Float32Array(GROWABLE_HEAP_U8().buffer,offset,byteSize/Float32Array.BYTES_PER_ELEMENT)},makeClampOptions:function(ptr){return{"minValue":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr>>2]),"maxValue":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr+4>>2])}},makeBatchNormOptions:function(ptr){return{"scale":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr>>2]),"bias":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr+4>>2]),"axis":GROWABLE_HEAP_I32()[ptr+8>>2],"epsilon":GROWABLE_HEAP_F32()[ptr+12>>2],"activation":this.FusedActivation[GROWABLE_HEAP_I32()[ptr+16>>2]]}},makeGemmOptions:function(ptr){return{"c":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr>>2]),"alpha":GROWABLE_HEAP_F32()[ptr+4>>2],"beta":GROWABLE_HEAP_F32()[ptr+8>>2],"aTranspose":GROWABLE_HEAP_I8()[ptr+12>>0]!==0,"bTranspose":GROWABLE_HEAP_I8()[ptr+13>>0]!==0}},makeOperandDescriptor:function(ptr){return{"type":this.OperandType[GROWABLE_HEAP_U32()[ptr>>2]],"dimensions":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+8>>2],GROWABLE_HEAP_I32()[ptr+4>>2])}},makeConv2dOptions:function(ptr){return{"padding":this.AutoPad[GROWABLE_HEAP_I32()[ptr+24>>2]]==="explicit"?this.makeI32Array(GROWABLE_HEAP_U32()[ptr>>2],GROWABLE_HEAP_I32()[ptr+4>>2]):undefined,"strides":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+8>>2],GROWABLE_HEAP_I32()[ptr+12>>2]),"dilations":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+16>>2],GROWABLE_HEAP_I32()[ptr+20>>2]),"autoPad":this.AutoPad[GROWABLE_HEAP_I32()[ptr+24>>2]],"groups":GROWABLE_HEAP_I32()[ptr+28>>2],"inputLayout":this.InputOperandLayout[GROWABLE_HEAP_I32()[ptr+32>>2]],"filterLayout":this.FilterOperandLayout[GROWABLE_HEAP_I32()[ptr+36>>2]],"bias":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr+40>>2]),"activation":this.FusedActivation[GROWABLE_HEAP_I32()[ptr+44>>2]]}},makePool2dOptions:function(ptr){return{"windowDimensions":this.makeI32Array(GROWABLE_HEAP_U32()[ptr>>2],GROWABLE_HEAP_I32()[ptr+4>>2]),"padding":this.AutoPad[GROWABLE_HEAP_I32()[ptr+32>>2]]==="explicit"?this.makeI32Array(GROWABLE_HEAP_U32()[ptr+8>>2],GROWABLE_HEAP_I32()[ptr+12>>2]):undefined,"strides":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+16>>2],GROWABLE_HEAP_I32()[ptr+20>>2]),"dilations":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+24>>2],GROWABLE_HEAP_I32()[ptr+28>>2]),"autoPad":this.AutoPad[GROWABLE_HEAP_I32()[ptr+32>>2]],"inputLayout":this.InputOperandLayout[GROWABLE_HEAP_I32()[ptr+36>>2]]}},makeInput:function(ptr){return{"data":this.makeArrayBufferView(GROWABLE_HEAP_I32()[ptr>>2],GROWABLE_HEAP_U32()[ptr+4>>2]),"dimensions":GROWABLE_HEAP_I32()[ptr+8>>2]===0?undefined:this.makeI32Array(GROWABLE_HEAP_U32()[ptr+12>>2],GROWABLE_HEAP_I32()[ptr+8>>2])}},makeOutput:function(ptr){return{"data":GROWABLE_HEAP_I32()[ptr>>2]===0?undefined:this.makeArrayBufferView(GROWABLE_HEAP_I32()[ptr>>2],GROWABLE_HEAP_U32()[ptr+4>>2]),"dimensions":GROWABLE_HEAP_I32()[ptr+8>>2]===0?undefined:this.makeI32Array(GROWABLE_HEAP_U32()[ptr+12>>2],GROWABLE_HEAP_I32()[ptr+8>>2])}}};function _emscripten_webnn_create_context(){var context=navigator.ml.createContext();return WebNN.mgrContext.create(context)}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(17,1,__environ,environ_buf);var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;GROWABLE_HEAP_I32()[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(18,1,penviron_count,penviron_buf_size);var strings=getEnvStrings();GROWABLE_HEAP_I32()[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});GROWABLE_HEAP_I32()[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(19,1,fd);return 0}function _fd_fdstat_get(fd,pbuf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(20,1,fd,pbuf);var type=fd==1||fd==2?2:abort();GROWABLE_HEAP_I8()[pbuf>>0]=type;return 0}function _fd_read(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(21,1,fd,iov,iovcnt,pnum);var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doReadv(stream,iov,iovcnt);GROWABLE_HEAP_I32()[pnum>>2]=num;return 0}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(22,1,fd,offset_low,offset_high,whence,newOffset)}function flush_NO_FILESYSTEM(){if(typeof _fflush!=="undefined")_fflush(0);var buffers=SYSCALLS.buffers;if(buffers[1].length)SYSCALLS.printChar(1,10);if(buffers[2].length)SYSCALLS.printChar(2,10)}function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(23,1,fd,iov,iovcnt,pnum);var num=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_I32()[iov+i*8>>2];var len=GROWABLE_HEAP_I32()[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,GROWABLE_HEAP_U8()[ptr+j])}num+=len}GROWABLE_HEAP_I32()[pnum>>2]=num;return 0}function _gettimeofday(ptr){var now=Date.now();GROWABLE_HEAP_I32()[ptr>>2]=now/1e3|0;GROWABLE_HEAP_I32()[ptr+4>>2]=now%1e3*1e3|0;return 0}function _gmtime_r(time,tmPtr){var date=new Date(GROWABLE_HEAP_I32()[time>>2]*1e3);GROWABLE_HEAP_I32()[tmPtr>>2]=date.getUTCSeconds();GROWABLE_HEAP_I32()[tmPtr+4>>2]=date.getUTCMinutes();GROWABLE_HEAP_I32()[tmPtr+8>>2]=date.getUTCHours();GROWABLE_HEAP_I32()[tmPtr+12>>2]=date.getUTCDate();GROWABLE_HEAP_I32()[tmPtr+16>>2]=date.getUTCMonth();GROWABLE_HEAP_I32()[tmPtr+20>>2]=date.getUTCFullYear()-1900;GROWABLE_HEAP_I32()[tmPtr+24>>2]=date.getUTCDay();GROWABLE_HEAP_I32()[tmPtr+36>>2]=0;GROWABLE_HEAP_I32()[tmPtr+32>>2]=0;var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;GROWABLE_HEAP_I32()[tmPtr+28>>2]=yday;if(!_gmtime_r.GMTString)_gmtime_r.GMTString=allocateUTF8("GMT");GROWABLE_HEAP_I32()[tmPtr+40>>2]=_gmtime_r.GMTString;return tmPtr}function _tzset(){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(24,1);if(_tzset.called)return;_tzset.called=true;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);GROWABLE_HEAP_I32()[__get_timezone()>>2]=stdTimezoneOffset*60;GROWABLE_HEAP_I32()[__get_daylight()>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){GROWABLE_HEAP_I32()[__get_tzname()>>2]=winterNamePtr;GROWABLE_HEAP_I32()[__get_tzname()+4>>2]=summerNamePtr}else{GROWABLE_HEAP_I32()[__get_tzname()>>2]=summerNamePtr;GROWABLE_HEAP_I32()[__get_tzname()+4>>2]=winterNamePtr}}function _localtime_r(time,tmPtr){_tzset();var date=new Date(GROWABLE_HEAP_I32()[time>>2]*1e3);GROWABLE_HEAP_I32()[tmPtr>>2]=date.getSeconds();GROWABLE_HEAP_I32()[tmPtr+4>>2]=date.getMinutes();GROWABLE_HEAP_I32()[tmPtr+8>>2]=date.getHours();GROWABLE_HEAP_I32()[tmPtr+12>>2]=date.getDate();GROWABLE_HEAP_I32()[tmPtr+16>>2]=date.getMonth();GROWABLE_HEAP_I32()[tmPtr+20>>2]=date.getFullYear()-1900;GROWABLE_HEAP_I32()[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;GROWABLE_HEAP_I32()[tmPtr+28>>2]=yday;GROWABLE_HEAP_I32()[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;GROWABLE_HEAP_I32()[tmPtr+32>>2]=dst;var zonePtr=GROWABLE_HEAP_I32()[__get_tzname()+(dst?4:0)>>2];GROWABLE_HEAP_I32()[tmPtr+40>>2]=zonePtr;return tmPtr}function _mktime(tmPtr){_tzset();var date=new Date(GROWABLE_HEAP_I32()[tmPtr+20>>2]+1900,GROWABLE_HEAP_I32()[tmPtr+16>>2],GROWABLE_HEAP_I32()[tmPtr+12>>2],GROWABLE_HEAP_I32()[tmPtr+8>>2],GROWABLE_HEAP_I32()[tmPtr+4>>2],GROWABLE_HEAP_I32()[tmPtr>>2],0);var dst=GROWABLE_HEAP_I32()[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){GROWABLE_HEAP_I32()[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}GROWABLE_HEAP_I32()[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;GROWABLE_HEAP_I32()[tmPtr+28>>2]=yday;GROWABLE_HEAP_I32()[tmPtr>>2]=date.getSeconds();GROWABLE_HEAP_I32()[tmPtr+4>>2]=date.getMinutes();GROWABLE_HEAP_I32()[tmPtr+8>>2]=date.getHours();GROWABLE_HEAP_I32()[tmPtr+12>>2]=date.getDate();GROWABLE_HEAP_I32()[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function _mlContextReference(id){WebNN.mgrContext.reference(id)}function _mlContextRelease(id){WebNN.mgrContext.release(id)}function _mlGraphBuilderAdd(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.add(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderAveragePool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.averagePool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderBatchNorm(builderId,inputId,meanId,varianceId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var mean=WebNN.mgrOperand.get(meanId);var variance=WebNN.mgrOperand.get(varianceId);var options=WebNN.makeBatchNormOptions(optionsPtr);var output=builder.batchNormalization(input,mean,variance,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderBuildSync(builderId,namedOperandsId){var builder=WebNN.mgrGraphBuilder.get(builderId);var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);try{var graph=builder.buildSync(namedOperands);return WebNN.mgrGraph.create(graph)}catch(error){console.log("builder.buildSync failed: "+error);return 0}}function _mlGraphBuilderConcat(builderId,inputsCount,inputsPtr,axis){var builder=WebNN.mgrGraphBuilder.get(builderId);var inputIds=WebNN.makeI32Array(inputsCount,inputsPtr);var inputs=[];for(var i=0;i<inputIds.length;++i){inputs.push(WebNN.mgrOperand.get(inputIds[i]))}var output=builder.concat(inputs,axis);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderConstant(builderId,descPtr,valuePtr,size){var builder=WebNN.mgrGraphBuilder.get(builderId);var desc=WebNN.makeOperandDescriptor(descPtr);var buffer=WebNN.makeArrayBufferView(valuePtr,size);var constant=builder.constant(desc,buffer);return WebNN.mgrOperand.create(constant)}function _mlGraphBuilderConv2d(builderId,inputId,filterId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var filter=WebNN.mgrOperand.get(filterId);var options=WebNN.makeConv2dOptions(optionsPtr);var conv2d=builder.conv2d(input,filter,options);return WebNN.mgrOperand.create(conv2d)}function _mlGraphBuilderGemm(builderId,aId,bId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var options=WebNN.makeGemmOptions(optionsPtr);var output=builder.gemm(a,b,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderInput(builderId,namePtr,descPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var name=UTF8ToString(namePtr);var desc=WebNN.makeOperandDescriptor(descPtr);var input=builder.input(name,desc);return WebNN.mgrOperand.create(input)}function _mlGraphBuilderMatmul(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.matmul(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderMaxPool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.maxPool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderRelease(id){WebNN.mgrGraphBuilder.release(id)}function _mlGraphBuilderRelu(builderId,inputId){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var output=builder.relu(input);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderReshape(builderId,inputId,newShapePtr,newShapeCount){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var newShape=WebNN.makeI32Array(newShapeCount,newShapePtr);var output=builder.reshape(input,newShape);return WebNN.mgrOperand.create(output)}function _mlGraphComputeSync(graphId,inputsId,outputsId){var graph=WebNN.mgrGraph.get(graphId);var inputs=WebNN.mgrNamedInputs.get(inputsId);var outputs=WebNN.mgrNamedOutputs.get(outputsId);return graph.computeSync(inputs,outputs)}function _mlGraphReference(id){WebNN.mgrGraph.reference(id)}function _mlGraphRelease(id){WebNN.mgrGraph.release(id)}function _mlNamedInputsRelease(id){WebNN.mgrNamedInputs.release(id)}function _mlNamedInputsSet(namedInputsId,namePtr,inputPtr){var namedInputs=WebNN.mgrNamedInputs.get(namedInputsId);var name=UTF8ToString(namePtr);var input=WebNN.makeInput(inputPtr);namedInputs[name]=input}function _mlNamedOperandsRelease(id){WebNN.mgrNamedOperands.release(id)}function _mlNamedOperandsSet(namedOperandsId,namePtr,operandId){var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);var name=UTF8ToString(namePtr);var operand=WebNN.mgrOperand.get(operandId);namedOperands[name]=operand}function _mlNamedOutputsRelease(id){WebNN.mgrNamedOutputs.release(id)}function _mlNamedOutputsSet(namedOutputsId,namePtr,outputPtr){var namedOutputs=WebNN.mgrNamedOutputs.get(namedOutputsId);var name=UTF8ToString(namePtr);var output=WebNN.makeOutput(outputPtr);namedOutputs[name]=output}function _mlOperandReference(id){WebNN.mgrOperand.reference(id)}function _mlOperandRelease(id){WebNN.mgrOperand.release(id)}function spawnThread(threadParams){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var worker=PThread.getNewWorker();if(!worker){return 6}if(worker.pthread!==undefined)throw"Internal error!";if(!threadParams.pthread_ptr)throw"Internal error, no pthread ptr!";PThread.runningWorkers.push(worker);var tlsMemory=_malloc(128*4);for(var i=0;i<128;++i){GROWABLE_HEAP_I32()[tlsMemory+i*4>>2]=0}var stackHigh=threadParams.stackBase+threadParams.stackSize;var pthread=PThread.pthreads[threadParams.pthread_ptr]={worker:worker,stackBase:threadParams.stackBase,stackSize:threadParams.stackSize,allocatedOwnStack:threadParams.allocatedOwnStack,threadInfoStruct:threadParams.pthread_ptr};var tis=pthread.threadInfoStruct>>2;Atomics.store(GROWABLE_HEAP_U32(),tis+(64>>2),threadParams.detached);Atomics.store(GROWABLE_HEAP_U32(),tis+(100>>2),tlsMemory);Atomics.store(GROWABLE_HEAP_U32(),tis+(40>>2),pthread.threadInfoStruct);Atomics.store(GROWABLE_HEAP_U32(),tis+(80>>2),threadParams.stackSize);Atomics.store(GROWABLE_HEAP_U32(),tis+(76>>2),stackHigh);Atomics.store(GROWABLE_HEAP_U32(),tis+(104>>2),threadParams.stackSize);Atomics.store(GROWABLE_HEAP_U32(),tis+(104+8>>2),stackHigh);Atomics.store(GROWABLE_HEAP_U32(),tis+(104+12>>2),threadParams.detached);var global_libc=_emscripten_get_global_libc();var global_locale=global_libc+40;Atomics.store(GROWABLE_HEAP_U32(),tis+(172>>2),global_locale);worker.pthread=pthread;var msg={"cmd":"run","start_routine":threadParams.startRoutine,"arg":threadParams.arg,"threadInfoStruct":threadParams.pthread_ptr,"stackBase":threadParams.stackBase,"stackSize":threadParams.stackSize};worker.runPthread=function(){msg.time=performance.now();worker.postMessage(msg,threadParams.transferList)};if(worker.loaded){worker.runPthread();delete worker.runPthread}return 0}function _pthread_create(pthread_ptr,attr,start_routine,arg){if(typeof SharedArrayBuffer==="undefined"){err("Current environment does not support SharedArrayBuffer, pthreads are not available!");return 6}if(!pthread_ptr){err("pthread_create called with a null thread pointer!");return 28}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return _emscripten_sync_run_in_main_thread_4(687865856,pthread_ptr,attr,start_routine,arg)}if(error)return error;var stackSize=0;var stackBase=0;var detached=0;if(attr&&attr!=-1){stackSize=GROWABLE_HEAP_I32()[attr>>2];stackSize+=81920;stackBase=GROWABLE_HEAP_I32()[attr+8>>2];detached=GROWABLE_HEAP_I32()[attr+12>>2]!==0}else{stackSize=2097152}var allocatedOwnStack=stackBase==0;if(allocatedOwnStack){stackBase=_memalign(16,stackSize)}else{stackBase-=stackSize;assert(stackBase>0)}var threadInfoStruct=_malloc(228);for(var i=0;i<228>>2;++i)GROWABLE_HEAP_U32()[(threadInfoStruct>>2)+i]=0;GROWABLE_HEAP_I32()[pthread_ptr>>2]=threadInfoStruct;GROWABLE_HEAP_I32()[threadInfoStruct+12>>2]=threadInfoStruct;var headPtr=threadInfoStruct+152;GROWABLE_HEAP_I32()[headPtr>>2]=headPtr;var threadParams={stackBase:stackBase,stackSize:stackSize,allocatedOwnStack:allocatedOwnStack,detached:detached,startRoutine:start_routine,pthread_ptr:threadInfoStruct,arg:arg,transferList:transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd="spawnThread";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}function __pthread_testcancel_js(){if(!ENVIRONMENT_IS_PTHREAD)return;var tb=_pthread_self();if(!tb)return;var cancelDisabled=Atomics.load(GROWABLE_HEAP_U32(),tb+56>>2);if(cancelDisabled)return;var canceled=Atomics.load(GROWABLE_HEAP_U32(),tb+0>>2);if(canceled==2)throw"Canceled!"}function __emscripten_do_pthread_join(thread,status,block){if(!thread){err("pthread_join attempted on a null thread pointer!");return ERRNO_CODES.ESRCH}if(ENVIRONMENT_IS_PTHREAD&&_pthread_self()==thread){err("PThread "+thread+" is attempting to join to itself!");return ERRNO_CODES.EDEADLK}else if(!ENVIRONMENT_IS_PTHREAD&&_emscripten_main_browser_thread_id()==thread){err("Main thread "+thread+" is attempting to join to itself!");return ERRNO_CODES.EDEADLK}var self=GROWABLE_HEAP_I32()[thread+12>>2];if(self!==thread){err("pthread_join attempted on thread "+thread+", which does not point to a valid thread, or does not exist anymore!");return ERRNO_CODES.ESRCH}var detached=Atomics.load(GROWABLE_HEAP_U32(),thread+64>>2);if(detached){err("Attempted to join thread "+thread+", which was already detached!");return ERRNO_CODES.EINVAL}if(block){_emscripten_check_blocking_allowed()}for(;;){var threadStatus=Atomics.load(GROWABLE_HEAP_U32(),thread+0>>2);if(threadStatus==1){var threadExitCode=Atomics.load(GROWABLE_HEAP_U32(),thread+4>>2);if(status)GROWABLE_HEAP_I32()[status>>2]=threadExitCode;Atomics.store(GROWABLE_HEAP_U32(),thread+64>>2,1);if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({"cmd":"cleanupThread","thread":thread});return 0}if(!block){return ERRNO_CODES.EBUSY}__pthread_testcancel_js();if(!ENVIRONMENT_IS_PTHREAD)_emscripten_main_thread_process_queued_calls();_emscripten_futex_wait(thread+0,threadStatus,ENVIRONMENT_IS_PTHREAD?100:1)}}function _pthread_join(thread,status){return __emscripten_do_pthread_join(thread,status,true)}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=GROWABLE_HEAP_I32()[tm+40>>2];var date={tm_sec:GROWABLE_HEAP_I32()[tm>>2],tm_min:GROWABLE_HEAP_I32()[tm+4>>2],tm_hour:GROWABLE_HEAP_I32()[tm+8>>2],tm_mday:GROWABLE_HEAP_I32()[tm+12>>2],tm_mon:GROWABLE_HEAP_I32()[tm+16>>2],tm_year:GROWABLE_HEAP_I32()[tm+20>>2],tm_wday:GROWABLE_HEAP_I32()[tm+24>>2],tm_yday:GROWABLE_HEAP_I32()[tm+28>>2],tm_isdst:GROWABLE_HEAP_I32()[tm+32>>2],tm_gmtoff:GROWABLE_HEAP_I32()[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value==="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return"\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}else{return"PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return"\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var janFirst=new Date(date.tm_year+1900,0,1);var firstSunday=janFirst.getDay()===0?janFirst:__addDays(janFirst,7-janFirst.getDay());var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstSunday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstSundayUntilEndJanuary=31-firstSunday.getDate();var days=firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstSunday,janFirst)===0?"01":"00"},"%V":function(date){var janFourthThisYear=new Date(date.tm_year+1900,0,4);var janFourthNextYear=new Date(date.tm_year+1901,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);var endDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);if(compareByDay(endDate,firstWeekStartThisYear)<0){return"53"}if(compareByDay(firstWeekStartNextYear,endDate)<=0){return"01"}var daysDifference;if(firstWeekStartThisYear.getFullYear()<date.tm_year+1900){daysDifference=date.tm_yday+32-firstWeekStartThisYear.getDate()}else{daysDifference=date.tm_yday+1-firstWeekStartThisYear.getDate()}return leadingNulls(Math.ceil(daysDifference/7),2)},"%w":function(date){return date.tm_wday},"%W":function(date){var janFirst=new Date(date.tm_year,0,1);var firstMonday=janFirst.getDay()===1?janFirst:__addDays(janFirst,janFirst.getDay()===0?1:7-janFirst.getDay()+1);var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstMonday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstMondayUntilEndJanuary=31-firstMonday.getDate();var days=firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstMonday,janFirst)===0?"01":"00"},"%y":function(date){return(date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return"%"}};for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _webnnCreateGraphBuilder(contextId){var context=WebNN.mgrContext.get(contextId);var builder=new MLGraphBuilder(context);return WebNN.mgrGraphBuilder.create(builder)}function _webnnCreateNamedInputs(){var inputs={};return WebNN.mgrNamedInputs.create(inputs)}function _webnnCreateNamedOperands(){var operands={};return WebNN.mgrNamedOperands.create(operands)}function _webnnCreateNamedOutputs(){var outputs={};return WebNN.mgrNamedOutputs.create(outputs)}if(!ENVIRONMENT_IS_PTHREAD)PThread.initMainThreadBlock();var GLctx;WebNN.initManagers();var proxiedFunctionTable=[null,_atexit,___sys_access,___sys_fcntl64,___sys_fstat64,___sys_getdents64,___sys_ioctl,___sys_lstat64,___sys_mkdir,___sys_mmap2,___sys_munmap,___sys_open,___sys_readlink,___sys_rmdir,___sys_stat64,___sys_unlink,_emscripten_set_canvas_element_size_main_thread,_environ_get,_environ_sizes_get,_fd_close,_fd_fdstat_get,_fd_read,_fd_seek,_fd_write,_tzset];function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var asmLibraryArg={"h":___assert_fail,"ba":___clock_gettime,"b":___cxa_allocate_exception,"d":___cxa_atexit,"e":___cxa_thread_atexit,"c":___cxa_throw,"Q":___sys_access,"r":___sys_fcntl64,"X":___sys_fstat64,"R":___sys_getdents64,"t":___sys_getpid,"I":___sys_ioctl,"S":___sys_lstat64,"W":___sys_mkdir,"V":___sys_mmap2,"U":___sys_munmap,"q":___sys_open,"P":___sys_readlink,"N":___sys_rmdir,"u":___sys_stat64,"O":___sys_unlink,"aa":__emscripten_notify_thread_queue,"g":_abort,"y":_clock_gettime,"Ka":_difftime,"M":_dlclose,"m":_dlerror,"T":_dlopen,"D":_dlsym,"w":_emscripten_asm_const_int,"H":_emscripten_check_blocking_allowed,"n":_emscripten_conditional_set_current_thread_status,"j":_emscripten_futex_wait,"k":_emscripten_futex_wake,"Y":_emscripten_get_heap_max,"i":_emscripten_get_now,"F":_emscripten_memcpy_big,"o":_emscripten_num_logical_cores,"Z":_emscripten_receive_on_main_thread_js,"G":_emscripten_resize_heap,"_":_emscripten_set_canvas_element_size,"v":_emscripten_set_current_thread_status,"$":_emscripten_webgl_create_context,"Ia":_emscripten_webnn_create_context,"K":_environ_get,"L":_environ_sizes_get,"l":_fd_close,"J":_fd_fdstat_get,"s":_fd_read,"C":_fd_seek,"p":_fd_write,"na":_gettimeofday,"La":_gmtime_r,"E":initPthreadsJS,"A":_localtime_r,"a":wasmMemory||Module["wasmMemory"],"z":_mktime,"Ha":_mlContextReference,"Ga":_mlContextRelease,"Ca":_mlGraphBuilderAdd,"Ba":_mlGraphBuilderAveragePool2d,"Aa":_mlGraphBuilderBatchNorm,"za":_mlGraphBuilderBuildSync,"ya":_mlGraphBuilderConcat,"xa":_mlGraphBuilderConstant,"wa":_mlGraphBuilderConv2d,"va":_mlGraphBuilderGemm,"ua":_mlGraphBuilderInput,"ta":_mlGraphBuilderMatmul,"sa":_mlGraphBuilderMaxPool2d,"pa":_mlGraphBuilderRelease,"ra":_mlGraphBuilderRelu,"qa":_mlGraphBuilderReshape,"Fa":_mlGraphComputeSync,"Ea":_mlGraphReference,"Da":_mlGraphRelease,"ma":_mlNamedInputsRelease,"oa":_mlNamedInputsSet,"ka":_mlNamedOperandsRelease,"la":_mlNamedOperandsSet,"ia":_mlNamedOutputsRelease,"ja":_mlNamedOutputsSet,"ha":_mlOperandReference,"ga":_mlOperandRelease,"x":_pthread_create,"B":_pthread_join,"Ja":_strftime,"f":_strftime_l,"fa":_webnnCreateGraphBuilder,"ea":_webnnCreateNamedInputs,"da":_webnnCreateNamedOperands,"ca":_webnnCreateNamedOutputs};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["Ma"]).apply(null,arguments)};var _OrtInit=Module["_OrtInit"]=function(){return(_OrtInit=Module["_OrtInit"]=Module["asm"]["Na"]).apply(null,arguments)};var _OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=function(){return(_OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=Module["asm"]["Oa"]).apply(null,arguments)};var _OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=function(){return(_OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=Module["asm"]["Pa"]).apply(null,arguments)};var _OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=function(){return(_OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=Module["asm"]["Qa"]).apply(null,arguments)};var _OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=function(){return(_OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=Module["asm"]["Ra"]).apply(null,arguments)};var _OrtCreateSession=Module["_OrtCreateSession"]=function(){return(_OrtCreateSession=Module["_OrtCreateSession"]=Module["asm"]["Sa"]).apply(null,arguments)};var _OrtReleaseSession=Module["_OrtReleaseSession"]=function(){return(_OrtReleaseSession=Module["_OrtReleaseSession"]=Module["asm"]["Ta"]).apply(null,arguments)};var _OrtGetInputCount=Module["_OrtGetInputCount"]=function(){return(_OrtGetInputCount=Module["_OrtGetInputCount"]=Module["asm"]["Ua"]).apply(null,arguments)};var _OrtGetOutputCount=Module["_OrtGetOutputCount"]=function(){return(_OrtGetOutputCount=Module["_OrtGetOutputCount"]=Module["asm"]["Va"]).apply(null,arguments)};var _OrtGetInputName=Module["_OrtGetInputName"]=function(){return(_OrtGetInputName=Module["_OrtGetInputName"]=Module["asm"]["Wa"]).apply(null,arguments)};var _OrtGetOutputName=Module["_OrtGetOutputName"]=function(){return(_OrtGetOutputName=Module["_OrtGetOutputName"]=Module["asm"]["Xa"]).apply(null,arguments)};var _OrtFree=Module["_OrtFree"]=function(){return(_OrtFree=Module["_OrtFree"]=Module["asm"]["Ya"]).apply(null,arguments)};var _OrtCreateTensor=Module["_OrtCreateTensor"]=function(){return(_OrtCreateTensor=Module["_OrtCreateTensor"]=Module["asm"]["Za"]).apply(null,arguments)};var _OrtGetTensorData=Module["_OrtGetTensorData"]=function(){return(_OrtGetTensorData=Module["_OrtGetTensorData"]=Module["asm"]["_a"]).apply(null,arguments)};var _OrtReleaseTensor=Module["_OrtReleaseTensor"]=function(){return(_OrtReleaseTensor=Module["_OrtReleaseTensor"]=Module["asm"]["$a"]).apply(null,arguments)};var _OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=function(){return(_OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=Module["asm"]["ab"]).apply(null,arguments)};var _OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=function(){return(_OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=Module["asm"]["bb"]).apply(null,arguments)};var _OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=function(){return(_OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=Module["asm"]["cb"]).apply(null,arguments)};var _OrtRun=Module["_OrtRun"]=function(){return(_OrtRun=Module["_OrtRun"]=Module["asm"]["db"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["fb"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["gb"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["hb"]).apply(null,arguments)};var _pthread_self=Module["_pthread_self"]=function(){return(_pthread_self=Module["_pthread_self"]=Module["asm"]["ib"]).apply(null,arguments)};var _emscripten_tls_init=Module["_emscripten_tls_init"]=function(){return(_emscripten_tls_init=Module["_emscripten_tls_init"]=Module["asm"]["jb"]).apply(null,arguments)};var _emscripten_current_thread_process_queued_calls=Module["_emscripten_current_thread_process_queued_calls"]=function(){return(_emscripten_current_thread_process_queued_calls=Module["_emscripten_current_thread_process_queued_calls"]=Module["asm"]["kb"]).apply(null,arguments)};var _emscripten_register_main_browser_thread_id=Module["_emscripten_register_main_browser_thread_id"]=function(){return(_emscripten_register_main_browser_thread_id=Module["_emscripten_register_main_browser_thread_id"]=Module["asm"]["lb"]).apply(null,arguments)};var _emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=function(){return(_emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=Module["asm"]["mb"]).apply(null,arguments)};var __emscripten_do_dispatch_to_thread=Module["__emscripten_do_dispatch_to_thread"]=function(){return(__emscripten_do_dispatch_to_thread=Module["__emscripten_do_dispatch_to_thread"]=Module["asm"]["nb"]).apply(null,arguments)};var _emscripten_sync_run_in_main_thread_4=Module["_emscripten_sync_run_in_main_thread_4"]=function(){return(_emscripten_sync_run_in_main_thread_4=Module["_emscripten_sync_run_in_main_thread_4"]=Module["asm"]["ob"]).apply(null,arguments)};var _emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=function(){return(_emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=Module["asm"]["pb"]).apply(null,arguments)};var _emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=function(){return(_emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=Module["asm"]["qb"]).apply(null,arguments)};var __emscripten_call_on_thread=Module["__emscripten_call_on_thread"]=function(){return(__emscripten_call_on_thread=Module["__emscripten_call_on_thread"]=Module["asm"]["rb"]).apply(null,arguments)};var __emscripten_thread_init=Module["__emscripten_thread_init"]=function(){return(__emscripten_thread_init=Module["__emscripten_thread_init"]=Module["asm"]["sb"]).apply(null,arguments)};var _memset=Module["_memset"]=function(){return(_memset=Module["_memset"]=Module["asm"]["tb"]).apply(null,arguments)};var ___pthread_tsd_run_dtors=Module["___pthread_tsd_run_dtors"]=function(){return(___pthread_tsd_run_dtors=Module["___pthread_tsd_run_dtors"]=Module["asm"]["ub"]).apply(null,arguments)};var _emscripten_get_global_libc=Module["_emscripten_get_global_libc"]=function(){return(_emscripten_get_global_libc=Module["_emscripten_get_global_libc"]=Module["asm"]["vb"]).apply(null,arguments)};var __get_tzname=Module["__get_tzname"]=function(){return(__get_tzname=Module["__get_tzname"]=Module["asm"]["wb"]).apply(null,arguments)};var __get_daylight=Module["__get_daylight"]=function(){return(__get_daylight=Module["__get_daylight"]=Module["asm"]["xb"]).apply(null,arguments)};var __get_timezone=Module["__get_timezone"]=function(){return(__get_timezone=Module["__get_timezone"]=Module["asm"]["yb"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["zb"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["Ab"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["Bb"]).apply(null,arguments)};var _emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=function(){return(_emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=Module["asm"]["Cb"]).apply(null,arguments)};var _memalign=Module["_memalign"]=function(){return(_memalign=Module["_memalign"]=Module["asm"]["Db"]).apply(null,arguments)};var __emscripten_allow_main_runtime_queued_calls=Module["__emscripten_allow_main_runtime_queued_calls"]=653536;var __emscripten_main_thread_futex=Module["__emscripten_main_thread_futex"]=658904;Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["PThread"]=PThread;Module["stackSave"]=stackSave;Module["stackRestore"]=stackRestore;Module["stackAlloc"]=stackAlloc;Module["PThread"]=PThread;Module["wasmMemory"]=wasmMemory;Module["ExitStatus"]=ExitStatus;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}if(ENVIRONMENT_IS_PTHREAD){readyPromiseResolve(Module);initRuntime();postMessage({"cmd":"loaded"});return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;function exit(status,implicit){EXITSTATUS=status;if(implicit&&keepRuntimeAlive()&&status===0){return}if(!implicit){if(ENVIRONMENT_IS_PTHREAD){postMessage({"cmd":"exitProcess","returnCode":status});throw new ExitStatus(status)}else{}}if(keepRuntimeAlive()){}else{PThread.terminateAllThreads();exitRuntime();if(Module["onExit"])Module["onExit"](status);ABORT=true}quit_(status,new ExitStatus(status))}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}if(ENVIRONMENT_IS_PTHREAD){noExitRuntime=false;PThread.initWorker()}run();


  return ortWasmThreaded.ready
}
);
})();
if (true)
  module.exports = ortWasmThreaded;
else {}


/***/ }),

/***/ "./lib/wasm/binding/ort-wasm-threaded.worker.js":
/*!******************************************************!*\
  !*** ./lib/wasm/binding/ort-wasm-threaded.worker.js ***!
  \******************************************************/
/***/ (function(module) {

"use strict";
module.exports = "\"use strict\";var Module={};if(typeof process===\"object\"&&typeof process.versions===\"object\"&&typeof process.versions.node===\"string\"){var nodeWorkerThreads=require(\"worker_threads\");var parentPort=nodeWorkerThreads.parentPort;parentPort.on(\"message\",function(data){onmessage({data:data})});var nodeFS=require(\"fs\");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(nodeFS.readFileSync(f,\"utf8\"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(\" \");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:text,threadId:Module[\"_pthread_self\"]()})}var err=threadPrintErr;self.alert=threadAlert;Module[\"instantiateWasm\"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module[\"wasmModule\"],info);receiveInstance(instance);Module[\"wasmModule\"]=null;return instance.exports};function moduleLoaded(){}self.onmessage=function(e){try{if(e.data.cmd===\"load\"){Module[\"wasmModule\"]=e.data.wasmModule;Module[\"wasmMemory\"]=e.data.wasmMemory;Module[\"buffer\"]=Module[\"wasmMemory\"].buffer;Module[\"ENVIRONMENT_IS_PTHREAD\"]=true;if(typeof e.data.urlOrBlob===\"string\"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}ortWasmThreaded(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd===\"objectTransfer\"){Module[\"PThread\"].receiveObjectTransfer(e.data)}else if(e.data.cmd===\"run\"){Module[\"__performance_now_clock_drift\"]=performance.now()-e.data.time;Module[\"__emscripten_thread_init\"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module[\"establishStackSpace\"](top,max);Module[\"PThread\"].receiveObjectTransfer(e.data);Module[\"PThread\"].threadInit();try{var result=Module[\"invokeEntryPoint\"](e.data.start_routine,e.data.arg);if(Module[\"keepRuntimeAlive\"]()){Module[\"PThread\"].setExitStatus(result)}else{Module[\"PThread\"].threadExit(result)}}catch(ex){if(ex===\"Canceled!\"){Module[\"PThread\"].threadCancel()}else if(ex!=\"unwind\"){if(ex instanceof Module[\"ExitStatus\"]){if(Module[\"keepRuntimeAlive\"]()){}else{Module[\"PThread\"].threadExit(ex.status)}}else{Module[\"PThread\"].threadExit(-2);throw ex}}}}else if(e.data.cmd===\"cancel\"){if(Module[\"_pthread_self\"]()){Module[\"PThread\"].threadCancel()}}else if(e.data.target===\"setimmediate\"){}else if(e.data.cmd===\"processThreadQueue\"){if(Module[\"_pthread_self\"]()){Module[\"_emscripten_current_thread_process_queued_calls\"]()}}else{err(\"worker.js received unknown command \"+e.data.cmd);err(e.data)}}catch(ex){err(\"worker.js onmessage() captured an uncaught exception: \"+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};\n";

/***/ }),

/***/ "./lib/wasm/binding/ort-wasm.js":
/*!**************************************!*\
  !*** ./lib/wasm/binding/ort-wasm.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var __filename = "/index.js";
var __dirname = "/";

var ortWasm = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (true) _scriptDir = _scriptDir || __filename;
  return (
function(ortWasm) {
  ortWasm = ortWasm || {};

var Module=typeof ortWasm!=="undefined"?ortWasm:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;var nodeFS;var nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=__webpack_require__(/*! path */ "?75c6").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=__webpack_require__(/*! fs */ "?63c8");if(!nodePath)nodePath=__webpack_require__(/*! path */ "?75c6");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs}else if(typeof arguments!="undefined"){arguments_=arguments}if(typeof quit==="function"){quit_=function(status){quit(status)}}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=function(title){document.title=title}}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||false;if(typeof WebAssembly!=="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heap[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heap.subarray&&UTF8Decoder){return UTF8Decoder.decode(heap.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=heap[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what+="";err(what);ABORT=true;EXITSTATUS=1;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile="ort-wasm.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["xa"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["bb"];addOnInit(Module["asm"]["ya"]);removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){var result=WebAssembly.instantiate(binary,info);return result}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)()}else{wasmTable.get(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var ExceptionInfoAttrs={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};function ___cxa_allocate_exception(size){return _malloc(size+ExceptionInfoAttrs.SIZE)+ExceptionInfoAttrs.SIZE}function _atexit(func,arg){__ATEXIT__.unshift({func:func,arg:arg})}function ___cxa_atexit(a0,a1){return _atexit(a0,a1)}function ___cxa_thread_atexit(a0,a1){return _atexit(a0,a1)}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-ExceptionInfoAttrs.SIZE;this.set_type=function(type){HEAP32[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]=type};this.get_type=function(){return HEAP32[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]};this.set_destructor=function(destructor){HEAP32[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]=destructor};this.get_destructor=function(){return HEAP32[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]!=0};this.init=function(type,destructor){this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2];HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2];HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=prev-1;return prev===1}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},get64:function(low,high){return low}};function ___sys_access(path,amode){path=SYSCALLS.getStr(path);return SYSCALLS.doAccess(path,amode)}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}function ___sys_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;return 0}function ___sys_fstat64(fd,buf){}function ___sys_getdents64(fd,dirp,count){}function ___sys_getpid(){return 42}function ___sys_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;return 0}function ___sys_lstat64(path,buf){}function ___sys_mkdir(path,mode){path=SYSCALLS.getStr(path);return SYSCALLS.doMkdir(path,mode)}function syscallMmap2(addr,len,prot,flags,fd,off){off<<=12;var ptr;var allocated=false;if((flags&16)!==0&&addr%65536!==0){return-28}if((flags&32)!==0){ptr=_memalign(65536,len);if(!ptr)return-48;_memset(ptr,0,len);allocated=true}else{return-52}SYSCALLS.mappings[ptr]={malloc:ptr,len:len,allocated:allocated,fd:fd,prot:prot,flags:flags,offset:off};return ptr}function ___sys_mmap2(addr,len,prot,flags,fd,off){return syscallMmap2(addr,len,prot,flags,fd,off)}function syscallMunmap(addr,len){if((addr|0)===-1||len===0){return-28}var info=SYSCALLS.mappings[addr];if(!info)return 0;if(len===info.len){SYSCALLS.mappings[addr]=null;if(info.allocated){_free(info.malloc)}}return 0}function ___sys_munmap(addr,len){return syscallMunmap(addr,len)}function ___sys_open(path,flags,varargs){SYSCALLS.varargs=varargs}function ___sys_readlink(path,buf,bufsize){path=SYSCALLS.getStr(path);return SYSCALLS.doReadlink(path,buf,bufsize)}function ___sys_rmdir(path){}function ___sys_stat64(path,buf){}function ___sys_unlink(path){}function _abort(){abort()}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else _emscripten_get_now=function(){return performance.now()};var _emscripten_get_now_is_monotonic=true;function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if((clk_id===1||clk_id===4)&&_emscripten_get_now_is_monotonic){now=_emscripten_get_now()}else{setErrNo(28);return-1}HEAP32[tp>>2]=now/1e3|0;HEAP32[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function _difftime(time1,time0){return time1-time0}function _dlclose(handle){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlerror(){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlopen(filename,flag){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlsym(handle,symbol){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _emscripten_get_heap_max(){return 2147483648}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_thread_sleep(msecs){var start=_emscripten_get_now();while(_emscripten_get_now()-start<msecs){}}var WebNN={initManagers:function(){if(this["mgrContext"])return;function makeManager(){return{objects:{},nextId:1,create:function(object,wrapper){wrapper=wrapper||{};var id=this.nextId++;wrapper.refcount=1;wrapper.object=object;this.objects[id]=wrapper;return id},get:function(id){if(id===0)return undefined;var o=this.objects[id];return o.object},reference:function(id){var o=this.objects[id];o.refcount++},release:function(id){var o=this.objects[id];o.refcount--;if(o.refcount<=0){delete this.objects[id]}}}}this["mgrContext"]=this["mgrContext"]||makeManager();this.mgrGraph=this.mgrGraph||makeManager();this.mgrGraphBuilder=this.mgrGraphBuilder||makeManager();this.mgrNamedInputs=this.mgrNamedInputs||makeManager();this.mgrNamedOperands=this.mgrNamedOperands||makeManager();this.mgrNamedOutputs=this.mgrNamedOutputs||makeManager();this.mgrNamedResults=this.mgrNamedResults||makeManager();this.mgrOperand=this.mgrOperand||makeManager();this.mgrResult=this.mgrResult||makeManager()},AutoPad:["explicit","same-upper","same-lower"],BuildGraphStatus:["success","error","context-lost","unknown"],ComputeGraphStatus:["success","error","context-lost","unknown"],ErrorFilter:["none","validation","out-of-memory"],ErrorType:["no-error","validation","out-of-memory","unknown","device-lost"],FilterOperandLayout:["oihw","hwio","ohwi","ihwo"],FusedActivation:["none","relu"],InputOperandLayout:["nchw","nhwc"],OperandType:["float32","float16","int32","uint32","int8","uint8"],PowerPreference:["default","high_performance","low_power"],makeI32Array:function(count,arrayPtr){if(count===0||arrayPtr===0){return undefined}var array=[];for(var i=0;i<count;++i,arrayPtr+=4){array.push(HEAP32[arrayPtr>>2])}return array},makeArrayBufferView:function(offset,byteSize,type="float32"){assert(type==="float32");return new Float32Array(HEAPU8.buffer,offset,byteSize/Float32Array.BYTES_PER_ELEMENT)},makeClampOptions:function(ptr){return{"minValue":this.mgrOperand.get(HEAP32[ptr>>2]),"maxValue":this.mgrOperand.get(HEAP32[ptr+4>>2])}},makeBatchNormOptions:function(ptr){return{"scale":this.mgrOperand.get(HEAP32[ptr>>2]),"bias":this.mgrOperand.get(HEAP32[ptr+4>>2]),"axis":HEAP32[ptr+8>>2],"epsilon":HEAPF32[ptr+12>>2],"activation":this.FusedActivation[HEAP32[ptr+16>>2]]}},makeGemmOptions:function(ptr){return{"c":this.mgrOperand.get(HEAP32[ptr>>2]),"alpha":HEAPF32[ptr+4>>2],"beta":HEAPF32[ptr+8>>2],"aTranspose":HEAP8[ptr+12>>0]!==0,"bTranspose":HEAP8[ptr+13>>0]!==0}},makeOperandDescriptor:function(ptr){return{"type":this.OperandType[HEAPU32[ptr>>2]],"dimensions":this.makeI32Array(HEAPU32[ptr+8>>2],HEAP32[ptr+4>>2])}},makeConv2dOptions:function(ptr){return{"padding":this.AutoPad[HEAP32[ptr+24>>2]]==="explicit"?this.makeI32Array(HEAPU32[ptr>>2],HEAP32[ptr+4>>2]):undefined,"strides":this.makeI32Array(HEAPU32[ptr+8>>2],HEAP32[ptr+12>>2]),"dilations":this.makeI32Array(HEAPU32[ptr+16>>2],HEAP32[ptr+20>>2]),"autoPad":this.AutoPad[HEAP32[ptr+24>>2]],"groups":HEAP32[ptr+28>>2],"inputLayout":this.InputOperandLayout[HEAP32[ptr+32>>2]],"filterLayout":this.FilterOperandLayout[HEAP32[ptr+36>>2]],"bias":this.mgrOperand.get(HEAP32[ptr+40>>2]),"activation":this.FusedActivation[HEAP32[ptr+44>>2]]}},makePool2dOptions:function(ptr){return{"windowDimensions":this.makeI32Array(HEAPU32[ptr>>2],HEAP32[ptr+4>>2]),"padding":this.AutoPad[HEAP32[ptr+32>>2]]==="explicit"?this.makeI32Array(HEAPU32[ptr+8>>2],HEAP32[ptr+12>>2]):undefined,"strides":this.makeI32Array(HEAPU32[ptr+16>>2],HEAP32[ptr+20>>2]),"dilations":this.makeI32Array(HEAPU32[ptr+24>>2],HEAP32[ptr+28>>2]),"autoPad":this.AutoPad[HEAP32[ptr+32>>2]],"inputLayout":this.InputOperandLayout[HEAP32[ptr+36>>2]]}},makeInput:function(ptr){return{"data":this.makeArrayBufferView(HEAP32[ptr>>2],HEAPU32[ptr+4>>2]),"dimensions":HEAP32[ptr+8>>2]===0?undefined:this.makeI32Array(HEAPU32[ptr+12>>2],HEAP32[ptr+8>>2])}},makeOutput:function(ptr){return{"data":HEAP32[ptr>>2]===0?undefined:this.makeArrayBufferView(HEAP32[ptr>>2],HEAPU32[ptr+4>>2]),"dimensions":HEAP32[ptr+8>>2]===0?undefined:this.makeI32Array(HEAPU32[ptr+12>>2],HEAP32[ptr+8>>2])}}};function _emscripten_webnn_create_context(){var context=navigator.ml.createContext();return WebNN.mgrContext.create(context)}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){return 0}function _fd_fdstat_get(fd,pbuf){var type=fd==1||fd==2?2:abort();HEAP8[pbuf>>0]=type;return 0}function _fd_read(fd,iov,iovcnt,pnum){var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doReadv(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j])}num+=len}HEAP32[pnum>>2]=num;return 0}function _gettimeofday(ptr){var now=Date.now();HEAP32[ptr>>2]=now/1e3|0;HEAP32[ptr+4>>2]=now%1e3*1e3|0;return 0}function _gmtime_r(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();HEAP32[tmPtr+36>>2]=0;HEAP32[tmPtr+32>>2]=0;var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;if(!_gmtime_r.GMTString)_gmtime_r.GMTString=allocateUTF8("GMT");HEAP32[tmPtr+40>>2]=_gmtime_r.GMTString;return tmPtr}function _tzset(){if(_tzset.called)return;_tzset.called=true;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[__get_timezone()>>2]=stdTimezoneOffset*60;HEAP32[__get_daylight()>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAP32[__get_tzname()>>2]=winterNamePtr;HEAP32[__get_tzname()+4>>2]=summerNamePtr}else{HEAP32[__get_tzname()>>2]=summerNamePtr;HEAP32[__get_tzname()+4>>2]=winterNamePtr}}function _localtime_r(time,tmPtr){_tzset();var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst;var zonePtr=HEAP32[__get_tzname()+(dst?4:0)>>2];HEAP32[tmPtr+40>>2]=zonePtr;return tmPtr}function _mktime(tmPtr){_tzset();var date=new Date(HEAP32[tmPtr+20>>2]+1900,HEAP32[tmPtr+16>>2],HEAP32[tmPtr+12>>2],HEAP32[tmPtr+8>>2],HEAP32[tmPtr+4>>2],HEAP32[tmPtr>>2],0);var dst=HEAP32[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){HEAP32[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}HEAP32[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function _mlContextReference(id){WebNN.mgrContext.reference(id)}function _mlContextRelease(id){WebNN.mgrContext.release(id)}function _mlGraphBuilderAdd(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.add(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderAveragePool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.averagePool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderBatchNorm(builderId,inputId,meanId,varianceId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var mean=WebNN.mgrOperand.get(meanId);var variance=WebNN.mgrOperand.get(varianceId);var options=WebNN.makeBatchNormOptions(optionsPtr);var output=builder.batchNormalization(input,mean,variance,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderBuildSync(builderId,namedOperandsId){var builder=WebNN.mgrGraphBuilder.get(builderId);var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);try{var graph=builder.buildSync(namedOperands);return WebNN.mgrGraph.create(graph)}catch(error){console.log("builder.buildSync failed: "+error);return 0}}function _mlGraphBuilderConcat(builderId,inputsCount,inputsPtr,axis){var builder=WebNN.mgrGraphBuilder.get(builderId);var inputIds=WebNN.makeI32Array(inputsCount,inputsPtr);var inputs=[];for(var i=0;i<inputIds.length;++i){inputs.push(WebNN.mgrOperand.get(inputIds[i]))}var output=builder.concat(inputs,axis);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderConstant(builderId,descPtr,valuePtr,size){var builder=WebNN.mgrGraphBuilder.get(builderId);var desc=WebNN.makeOperandDescriptor(descPtr);var buffer=WebNN.makeArrayBufferView(valuePtr,size);var constant=builder.constant(desc,buffer);return WebNN.mgrOperand.create(constant)}function _mlGraphBuilderConv2d(builderId,inputId,filterId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var filter=WebNN.mgrOperand.get(filterId);var options=WebNN.makeConv2dOptions(optionsPtr);var conv2d=builder.conv2d(input,filter,options);return WebNN.mgrOperand.create(conv2d)}function _mlGraphBuilderGemm(builderId,aId,bId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var options=WebNN.makeGemmOptions(optionsPtr);var output=builder.gemm(a,b,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderInput(builderId,namePtr,descPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var name=UTF8ToString(namePtr);var desc=WebNN.makeOperandDescriptor(descPtr);var input=builder.input(name,desc);return WebNN.mgrOperand.create(input)}function _mlGraphBuilderMatmul(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.matmul(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderMaxPool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.maxPool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderRelease(id){WebNN.mgrGraphBuilder.release(id)}function _mlGraphBuilderRelu(builderId,inputId){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var output=builder.relu(input);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderReshape(builderId,inputId,newShapePtr,newShapeCount){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var newShape=WebNN.makeI32Array(newShapeCount,newShapePtr);var output=builder.reshape(input,newShape);return WebNN.mgrOperand.create(output)}function _mlGraphComputeSync(graphId,inputsId,outputsId){var graph=WebNN.mgrGraph.get(graphId);var inputs=WebNN.mgrNamedInputs.get(inputsId);var outputs=WebNN.mgrNamedOutputs.get(outputsId);return graph.computeSync(inputs,outputs)}function _mlGraphReference(id){WebNN.mgrGraph.reference(id)}function _mlGraphRelease(id){WebNN.mgrGraph.release(id)}function _mlNamedInputsRelease(id){WebNN.mgrNamedInputs.release(id)}function _mlNamedInputsSet(namedInputsId,namePtr,inputPtr){var namedInputs=WebNN.mgrNamedInputs.get(namedInputsId);var name=UTF8ToString(namePtr);var input=WebNN.makeInput(inputPtr);namedInputs[name]=input}function _mlNamedOperandsRelease(id){WebNN.mgrNamedOperands.release(id)}function _mlNamedOperandsSet(namedOperandsId,namePtr,operandId){var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);var name=UTF8ToString(namePtr);var operand=WebNN.mgrOperand.get(operandId);namedOperands[name]=operand}function _mlNamedOutputsRelease(id){WebNN.mgrNamedOutputs.release(id)}function _mlNamedOutputsSet(namedOutputsId,namePtr,outputPtr){var namedOutputs=WebNN.mgrNamedOutputs.get(namedOutputsId);var name=UTF8ToString(namePtr);var output=WebNN.makeOutput(outputPtr);namedOutputs[name]=output}function _mlOperandReference(id){WebNN.mgrOperand.reference(id)}function _mlOperandRelease(id){WebNN.mgrOperand.release(id)}function _pthread_create(){return 6}function _pthread_join(){return 28}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value==="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return"\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}else{return"PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return"\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var janFirst=new Date(date.tm_year+1900,0,1);var firstSunday=janFirst.getDay()===0?janFirst:__addDays(janFirst,7-janFirst.getDay());var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstSunday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstSundayUntilEndJanuary=31-firstSunday.getDate();var days=firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstSunday,janFirst)===0?"01":"00"},"%V":function(date){var janFourthThisYear=new Date(date.tm_year+1900,0,4);var janFourthNextYear=new Date(date.tm_year+1901,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);var endDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);if(compareByDay(endDate,firstWeekStartThisYear)<0){return"53"}if(compareByDay(firstWeekStartNextYear,endDate)<=0){return"01"}var daysDifference;if(firstWeekStartThisYear.getFullYear()<date.tm_year+1900){daysDifference=date.tm_yday+32-firstWeekStartThisYear.getDate()}else{daysDifference=date.tm_yday+1-firstWeekStartThisYear.getDate()}return leadingNulls(Math.ceil(daysDifference/7),2)},"%w":function(date){return date.tm_wday},"%W":function(date){var janFirst=new Date(date.tm_year,0,1);var firstMonday=janFirst.getDay()===1?janFirst:__addDays(janFirst,janFirst.getDay()===0?1:7-janFirst.getDay()+1);var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstMonday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstMondayUntilEndJanuary=31-firstMonday.getDate();var days=firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstMonday,janFirst)===0?"01":"00"},"%y":function(date){return(date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return"%"}};for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _webnnCreateGraphBuilder(contextId){var context=WebNN.mgrContext.get(contextId);var builder=new MLGraphBuilder(context);return WebNN.mgrGraphBuilder.create(builder)}function _webnnCreateNamedInputs(){var inputs={};return WebNN.mgrNamedInputs.create(inputs)}function _webnnCreateNamedOperands(){var operands={};return WebNN.mgrNamedOperands.create(operands)}function _webnnCreateNamedOutputs(){var outputs={};return WebNN.mgrNamedOutputs.create(outputs)}WebNN.initManagers();function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var asmLibraryArg={"a":___cxa_allocate_exception,"c":___cxa_atexit,"f":___cxa_thread_atexit,"b":___cxa_throw,"L":___sys_access,"m":___sys_fcntl64,"R":___sys_fstat64,"M":___sys_getdents64,"q":___sys_getpid,"D":___sys_ioctl,"N":___sys_lstat64,"Q":___sys_mkdir,"P":___sys_mmap2,"O":___sys_munmap,"l":___sys_open,"K":___sys_readlink,"I":___sys_rmdir,"s":___sys_stat64,"J":___sys_unlink,"j":_abort,"u":_clock_gettime,"z":_difftime,"va":_dlclose,"i":_dlerror,"wa":_dlopen,"ua":_dlsym,"S":_emscripten_get_heap_max,"C":_emscripten_memcpy_big,"k":_emscripten_resize_heap,"H":_emscripten_thread_sleep,"sa":_emscripten_webnn_create_context,"F":_environ_get,"G":_environ_sizes_get,"h":_fd_close,"E":_fd_fdstat_get,"o":_fd_read,"B":_fd_seek,"p":_fd_write,"aa":_gettimeofday,"A":_gmtime_r,"n":_localtime_r,"y":_mktime,"x":_mlContextReference,"w":_mlContextRelease,"pa":_mlGraphBuilderAdd,"oa":_mlGraphBuilderAveragePool2d,"na":_mlGraphBuilderBatchNorm,"ma":_mlGraphBuilderBuildSync,"la":_mlGraphBuilderConcat,"ka":_mlGraphBuilderConstant,"ja":_mlGraphBuilderConv2d,"ia":_mlGraphBuilderGemm,"ha":_mlGraphBuilderInput,"ga":_mlGraphBuilderMatmul,"fa":_mlGraphBuilderMaxPool2d,"t":_mlGraphBuilderRelease,"ea":_mlGraphBuilderRelu,"da":_mlGraphBuilderReshape,"ra":_mlGraphComputeSync,"qa":_mlGraphReference,"v":_mlGraphRelease,"ba":_mlNamedInputsRelease,"ca":_mlNamedInputsSet,"_":_mlNamedOperandsRelease,"$":_mlNamedOperandsSet,"Y":_mlNamedOutputsRelease,"Z":_mlNamedOutputsSet,"e":_mlOperandReference,"d":_mlOperandRelease,"T":_pthread_create,"r":_pthread_join,"ta":_strftime,"g":_strftime_l,"X":_webnnCreateGraphBuilder,"W":_webnnCreateNamedInputs,"V":_webnnCreateNamedOperands,"U":_webnnCreateNamedOutputs};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["ya"]).apply(null,arguments)};var _OrtInit=Module["_OrtInit"]=function(){return(_OrtInit=Module["_OrtInit"]=Module["asm"]["za"]).apply(null,arguments)};var _OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=function(){return(_OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=Module["asm"]["Aa"]).apply(null,arguments)};var _OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=function(){return(_OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=Module["asm"]["Ba"]).apply(null,arguments)};var _OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=function(){return(_OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=Module["asm"]["Ca"]).apply(null,arguments)};var _OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=function(){return(_OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=Module["asm"]["Da"]).apply(null,arguments)};var _OrtCreateSession=Module["_OrtCreateSession"]=function(){return(_OrtCreateSession=Module["_OrtCreateSession"]=Module["asm"]["Ea"]).apply(null,arguments)};var _OrtReleaseSession=Module["_OrtReleaseSession"]=function(){return(_OrtReleaseSession=Module["_OrtReleaseSession"]=Module["asm"]["Fa"]).apply(null,arguments)};var _OrtGetInputCount=Module["_OrtGetInputCount"]=function(){return(_OrtGetInputCount=Module["_OrtGetInputCount"]=Module["asm"]["Ga"]).apply(null,arguments)};var _OrtGetOutputCount=Module["_OrtGetOutputCount"]=function(){return(_OrtGetOutputCount=Module["_OrtGetOutputCount"]=Module["asm"]["Ha"]).apply(null,arguments)};var _OrtGetInputName=Module["_OrtGetInputName"]=function(){return(_OrtGetInputName=Module["_OrtGetInputName"]=Module["asm"]["Ia"]).apply(null,arguments)};var _OrtGetOutputName=Module["_OrtGetOutputName"]=function(){return(_OrtGetOutputName=Module["_OrtGetOutputName"]=Module["asm"]["Ja"]).apply(null,arguments)};var _OrtFree=Module["_OrtFree"]=function(){return(_OrtFree=Module["_OrtFree"]=Module["asm"]["Ka"]).apply(null,arguments)};var _OrtCreateTensor=Module["_OrtCreateTensor"]=function(){return(_OrtCreateTensor=Module["_OrtCreateTensor"]=Module["asm"]["La"]).apply(null,arguments)};var _OrtGetTensorData=Module["_OrtGetTensorData"]=function(){return(_OrtGetTensorData=Module["_OrtGetTensorData"]=Module["asm"]["Ma"]).apply(null,arguments)};var _OrtReleaseTensor=Module["_OrtReleaseTensor"]=function(){return(_OrtReleaseTensor=Module["_OrtReleaseTensor"]=Module["asm"]["Na"]).apply(null,arguments)};var _OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=function(){return(_OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=Module["asm"]["Oa"]).apply(null,arguments)};var _OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=function(){return(_OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=Module["asm"]["Pa"]).apply(null,arguments)};var _OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=function(){return(_OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=Module["asm"]["Qa"]).apply(null,arguments)};var _OrtRun=Module["_OrtRun"]=function(){return(_OrtRun=Module["_OrtRun"]=Module["asm"]["Ra"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["Sa"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["Ta"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["Ua"]).apply(null,arguments)};var _memset=Module["_memset"]=function(){return(_memset=Module["_memset"]=Module["asm"]["Va"]).apply(null,arguments)};var __get_tzname=Module["__get_tzname"]=function(){return(__get_tzname=Module["__get_tzname"]=Module["asm"]["Wa"]).apply(null,arguments)};var __get_daylight=Module["__get_daylight"]=function(){return(__get_daylight=Module["__get_daylight"]=Module["asm"]["Xa"]).apply(null,arguments)};var __get_timezone=Module["__get_timezone"]=function(){return(__get_timezone=Module["__get_timezone"]=Module["asm"]["Ya"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["Za"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["_a"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["$a"]).apply(null,arguments)};var _memalign=Module["_memalign"]=function(){return(_memalign=Module["_memalign"]=Module["asm"]["ab"]).apply(null,arguments)};Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["stackSave"]=stackSave;Module["stackRestore"]=stackRestore;Module["stackAlloc"]=stackAlloc;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}run();


  return ortWasm.ready
}
);
})();
if (true)
  module.exports = ortWasm;
else {}


/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ (function(module) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ (function(module) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ (function(module) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ (function(module) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/flatbuffers/js/flatbuffers.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/flatbuffers/js/flatbuffers.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flatbuffers": function() { return /* binding */ flatbuffers; }
/* harmony export */ });
/// @file
/// @addtogroup flatbuffers_javascript_api
/// @{
/// @cond FLATBUFFERS_INTERNAL

/**
 * @fileoverview
 *
 * Need to suppress 'global this' error so the Node.js export line doesn't cause
 * closure compile to error out.
 * @suppress {globalThis}
 */

/**
 * @const
 * @namespace
 */
var flatbuffers = {};

/**
 * @typedef {number}
 */
flatbuffers.Offset;

/**
 * @typedef {{
 *   bb: flatbuffers.ByteBuffer,
 *   bb_pos: number
 * }}
 */
flatbuffers.Table;

/**
 * @type {number}
 * @const
 */
flatbuffers.SIZEOF_SHORT = 2;

/**
 * @type {number}
 * @const
 */
flatbuffers.SIZEOF_INT = 4;

/**
 * @type {number}
 * @const
 */
flatbuffers.FILE_IDENTIFIER_LENGTH = 4;

/**
 * @type {number}
 * @const
 */
flatbuffers.SIZE_PREFIX_LENGTH = 4;

/**
 * @enum {number}
 */
flatbuffers.Encoding = {
  UTF8_BYTES: 1,
  UTF16_STRING: 2
};

/**
 * @type {Int32Array}
 * @const
 */
flatbuffers.int32 = new Int32Array(2);

/**
 * @type {Float32Array}
 * @const
 */
flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);

/**
 * @type {Float64Array}
 * @const
 */
flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);

/**
 * @type {boolean}
 * @const
 */
flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

////////////////////////////////////////////////////////////////////////////////

/**
 * @constructor
 * @param {number} low
 * @param {number} high
 */
flatbuffers.Long = function(low, high) {
  /**
   * @type {number}
   * @const
   */
  this.low = low | 0;

  /**
   * @type {number}
   * @const
   */
  this.high = high | 0;
};

/**
 * @param {number} low
 * @param {number} high
 * @returns {!flatbuffers.Long}
 */
flatbuffers.Long.create = function(low, high) {
  // Special-case zero to avoid GC overhead for default values
  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
};

/**
 * @returns {number}
 */
flatbuffers.Long.prototype.toFloat64 = function() {
  return (this.low >>> 0) + this.high * 0x100000000;
};

/**
 * @param {flatbuffers.Long} other
 * @returns {boolean}
 */
flatbuffers.Long.prototype.equals = function(other) {
  return this.low == other.low && this.high == other.high;
};

/**
 * @type {!flatbuffers.Long}
 * @const
 */
flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);

/// @endcond
////////////////////////////////////////////////////////////////////////////////
/**
 * Create a FlatBufferBuilder.
 *
 * @constructor
 * @param {number=} opt_initial_size
 */
flatbuffers.Builder = function(opt_initial_size) {
  if (!opt_initial_size) {
    var initial_size = 1024;
  } else {
    var initial_size = opt_initial_size;
  }

  /**
   * @type {flatbuffers.ByteBuffer}
   * @private
   */
  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);

  /**
   * Remaining space in the ByteBuffer.
   *
   * @type {number}
   * @private
   */
  this.space = initial_size;

  /**
   * Minimum alignment encountered so far.
   *
   * @type {number}
   * @private
   */
  this.minalign = 1;

  /**
   * The vtable for the current table.
   *
   * @type {Array.<number>}
   * @private
   */
  this.vtable = null;

  /**
   * The amount of fields we're actually using.
   *
   * @type {number}
   * @private
   */
  this.vtable_in_use = 0;

  /**
   * Whether we are currently serializing a table.
   *
   * @type {boolean}
   * @private
   */
  this.isNested = false;

  /**
   * Starting offset of the current struct/table.
   *
   * @type {number}
   * @private
   */
  this.object_start = 0;

  /**
   * List of offsets of all vtables.
   *
   * @type {Array.<number>}
   * @private
   */
  this.vtables = [];

  /**
   * For the current vector being built.
   *
   * @type {number}
   * @private
   */
  this.vector_num_elems = 0;

  /**
   * False omits default values from the serialized data
   *
   * @type {boolean}
   * @private
   */
  this.force_defaults = false;
};

flatbuffers.Builder.prototype.clear = function() {
  this.bb.clear();
  this.space = this.bb.capacity();
  this.minalign = 1;
  this.vtable = null;
  this.vtable_in_use = 0;
  this.isNested = false;
  this.object_start = 0;
  this.vtables = [];
  this.vector_num_elems = 0;
  this.force_defaults = false;
};

/**
 * In order to save space, fields that are set to their default value
 * don't get serialized into the buffer. Forcing defaults provides a
 * way to manually disable this optimization.
 *
 * @param {boolean} forceDefaults true always serializes default values
 */
flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
  this.force_defaults = forceDefaults;
};

/**
 * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
 * called finish(). The actual data starts at the ByteBuffer's current position,
 * not necessarily at 0.
 *
 * @returns {flatbuffers.ByteBuffer}
 */
flatbuffers.Builder.prototype.dataBuffer = function() {
  return this.bb;
};

/**
 * Get the bytes representing the FlatBuffer. Only call this after you've
 * called finish().
 *
 * @returns {!Uint8Array}
 */
flatbuffers.Builder.prototype.asUint8Array = function() {
  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * Prepare to write an element of `size` after `additional_bytes` have been
 * written, e.g. if you write a string, you need to align such the int length
 * field is aligned to 4 bytes, and the string data follows it directly. If all
 * you need to do is alignment, `additional_bytes` will be 0.
 *
 * @param {number} size This is the of the new element to write
 * @param {number} additional_bytes The padding size
 */
flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
  // Track the biggest thing we've ever aligned to.
  if (size > this.minalign) {
    this.minalign = size;
  }

  // Find the amount of alignment needed such that `size` is properly
  // aligned after `additional_bytes`
  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);

  // Reallocate the buffer if needed.
  while (this.space < align_size + size + additional_bytes) {
    var old_buf_size = this.bb.capacity();
    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
    this.space += this.bb.capacity() - old_buf_size;
  }

  this.pad(align_size);
};

/**
 * @param {number} byte_size
 */
flatbuffers.Builder.prototype.pad = function(byte_size) {
  for (var i = 0; i < byte_size; i++) {
    this.bb.writeInt8(--this.space, 0);
  }
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeInt8 = function(value) {
  this.bb.writeInt8(this.space -= 1, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeInt16 = function(value) {
  this.bb.writeInt16(this.space -= 2, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeInt32 = function(value) {
  this.bb.writeInt32(this.space -= 4, value);
};

/**
 * @param {flatbuffers.Long} value
 */
flatbuffers.Builder.prototype.writeInt64 = function(value) {
  this.bb.writeInt64(this.space -= 8, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeFloat32 = function(value) {
  this.bb.writeFloat32(this.space -= 4, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeFloat64 = function(value) {
  this.bb.writeFloat64(this.space -= 8, value);
};
/// @endcond

/**
 * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `int8` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt8 = function(value) {
  this.prep(1, 0);
  this.writeInt8(value);
};

/**
 * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `int16` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt16 = function(value) {
  this.prep(2, 0);
  this.writeInt16(value);
};

/**
 * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `int32` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt32 = function(value) {
  this.prep(4, 0);
  this.writeInt32(value);
};

/**
 * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {flatbuffers.Long} value The `int64` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt64 = function(value) {
  this.prep(8, 0);
  this.writeInt64(value);
};

/**
 * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `float32` to add the the buffer.
 */
flatbuffers.Builder.prototype.addFloat32 = function(value) {
  this.prep(4, 0);
  this.writeFloat32(value);
};

/**
 * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `float64` to add the the buffer.
 */
flatbuffers.Builder.prototype.addFloat64 = function(value) {
  this.prep(8, 0);
  this.writeFloat64(value);
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt8(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt16(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt32(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {flatbuffers.Long} value
 * @param {flatbuffers.Long} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
  if (this.force_defaults || !value.equals(defaultValue)) {
    this.addInt64(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addFloat32(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addFloat64(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {flatbuffers.Offset} value
 * @param {flatbuffers.Offset} defaultValue
 */
flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addOffset(value);
    this.slot(voffset);
  }
};

/**
 * Structs are stored inline, so nothing additional is being added. `d` is always 0.
 *
 * @param {number} voffset
 * @param {flatbuffers.Offset} value
 * @param {flatbuffers.Offset} defaultValue
 */
flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
  if (value != defaultValue) {
    this.nested(value);
    this.slot(voffset);
  }
};

/**
 * Structures are always stored inline, they need to be created right
 * where they're used.  You'll get this assertion failure if you
 * created it elsewhere.
 *
 * @param {flatbuffers.Offset} obj The offset of the created object
 */
flatbuffers.Builder.prototype.nested = function(obj) {
  if (obj != this.offset()) {
    throw new Error('FlatBuffers: struct must be serialized inline.');
  }
};

/**
 * Should not be creating any other object, string or vector
 * while an object is being constructed
 */
flatbuffers.Builder.prototype.notNested = function() {
  if (this.isNested) {
    throw new Error('FlatBuffers: object serialization must not be nested.');
  }
};

/**
 * Set the current vtable at `voffset` to the current location in the buffer.
 *
 * @param {number} voffset
 */
flatbuffers.Builder.prototype.slot = function(voffset) {
  this.vtable[voffset] = this.offset();
};

/**
 * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.
 */
flatbuffers.Builder.prototype.offset = function() {
  return this.bb.capacity() - this.space;
};

/**
 * Doubles the size of the backing ByteBuffer and copies the old data towards
 * the end of the new buffer (since we build the buffer backwards).
 *
 * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data
 * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied
 * to it. The data is located at the end of the buffer.
 *
 * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
 * it a uint8Array we need to suppress the type check:
 * @suppress {checkTypes}
 */
flatbuffers.Builder.growByteBuffer = function(bb) {
  var old_buf_size = bb.capacity();

  // Ensure we don't grow beyond what fits in an int.
  if (old_buf_size & 0xC0000000) {
    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
  }

  var new_buf_size = old_buf_size << 1;
  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
  nbb.setPosition(new_buf_size - old_buf_size);
  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
  return nbb;
};
/// @endcond

/**
 * Adds on offset, relative to where it will be written.
 *
 * @param {flatbuffers.Offset} offset The offset to add.
 */
flatbuffers.Builder.prototype.addOffset = function(offset) {
  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.
  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * Start encoding a new object in the buffer.  Users will not usually need to
 * call this directly. The FlatBuffers compiler will generate helper methods
 * that call this method internally.
 *
 * @param {number} numfields
 */
flatbuffers.Builder.prototype.startObject = function(numfields) {
  this.notNested();
  if (this.vtable == null) {
    this.vtable = [];
  }
  this.vtable_in_use = numfields;
  for (var i = 0; i < numfields; i++) {
    this.vtable[i] = 0; // This will push additional elements as needed
  }
  this.isNested = true;
  this.object_start = this.offset();
};

/**
 * Finish off writing the object that is under construction.
 *
 * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`
 */
flatbuffers.Builder.prototype.endObject = function() {
  if (this.vtable == null || !this.isNested) {
    throw new Error('FlatBuffers: endObject called without startObject');
  }

  this.addInt32(0);
  var vtableloc = this.offset();

  // Trim trailing zeroes.
  var i = this.vtable_in_use - 1;
  for (; i >= 0 && this.vtable[i] == 0; i--) {}
  var trimmed_size = i + 1;

  // Write out the current vtable.
  for (; i >= 0; i--) {
    // Offset relative to the start of the table.
    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
  }

  var standard_fields = 2; // The fields below:
  this.addInt16(vtableloc - this.object_start);
  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
  this.addInt16(len);

  // Search for an existing vtable that matches the current one.
  var existing_vtable = 0;
  var vt1 = this.space;
outer_loop:
  for (i = 0; i < this.vtables.length; i++) {
    var vt2 = this.bb.capacity() - this.vtables[i];
    if (len == this.bb.readInt16(vt2)) {
      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
          continue outer_loop;
        }
      }
      existing_vtable = this.vtables[i];
      break;
    }
  }

  if (existing_vtable) {
    // Found a match:
    // Remove the current vtable.
    this.space = this.bb.capacity() - vtableloc;

    // Point table to existing vtable.
    this.bb.writeInt32(this.space, existing_vtable - vtableloc);
  } else {
    // No match:
    // Add the location of the current vtable to the list of vtables.
    this.vtables.push(this.offset());

    // Point table to current vtable.
    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
  }

  this.isNested = false;
  return vtableloc;
};
/// @endcond

/**
 * Finalize a buffer, poiting to the given `root_table`.
 *
 * @param {flatbuffers.Offset} root_table
 * @param {string=} opt_file_identifier
 * @param {boolean=} opt_size_prefix
 */
flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {
  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
  if (opt_file_identifier) {
    var file_identifier = opt_file_identifier;
    this.prep(this.minalign, flatbuffers.SIZEOF_INT +
      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: file identifier must be length ' +
        flatbuffers.FILE_IDENTIFIER_LENGTH);
    }
    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
      this.writeInt8(file_identifier.charCodeAt(i));
    }
  }
  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
  this.addOffset(root_table);
  if (size_prefix) {
    this.addInt32(this.bb.capacity() - this.space);
  }
  this.bb.setPosition(this.space);
};

/**
 * Finalize a size prefixed buffer, pointing to the given `root_table`.
 *
 * @param {flatbuffers.Offset} root_table
 * @param {string=} opt_file_identifier
 */
flatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {
  this.finish(root_table, opt_file_identifier, true);
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * This checks a required field has been set in a given table that has
 * just been constructed.
 *
 * @param {flatbuffers.Offset} table
 * @param {number} field
 */
flatbuffers.Builder.prototype.requiredField = function(table, field) {
  var table_start = this.bb.capacity() - table;
  var vtable_start = table_start - this.bb.readInt32(table_start);
  var ok = this.bb.readInt16(vtable_start + field) != 0;

  // If this fails, the caller will show what field needs to be set.
  if (!ok) {
    throw new Error('FlatBuffers: field ' + field + ' must be set');
  }
};

/**
 * Start a new array/vector of objects.  Users usually will not call
 * this directly. The FlatBuffers compiler will create a start/end
 * method for vector types in generated code.
 *
 * @param {number} elem_size The size of each element in the array
 * @param {number} num_elems The number of elements in the array
 * @param {number} alignment The alignment of the array
 */
flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
  this.notNested();
  this.vector_num_elems = num_elems;
  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
};

/**
 * Finish off the creation of an array and all its elements. The array must be
 * created with `startVector`.
 *
 * @returns {flatbuffers.Offset} The offset at which the newly created array
 * starts.
 */
flatbuffers.Builder.prototype.endVector = function() {
  this.writeInt32(this.vector_num_elems);
  return this.offset();
};
/// @endcond

/**
 * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
 * instead of a string, it is assumed to contain valid UTF-8 encoded data.
 *
 * @param {string|Uint8Array} s The string to encode
 * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts
 */
flatbuffers.Builder.prototype.createString = function(s) {
  if (s instanceof Uint8Array) {
    var utf8 = s;
  } else {
    var utf8 = [];
    var i = 0;

    while (i < s.length) {
      var codePoint;

      // Decode UTF-16
      var a = s.charCodeAt(i++);
      if (a < 0xD800 || a >= 0xDC00) {
        codePoint = a;
      } else {
        var b = s.charCodeAt(i++);
        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
      }

      // Encode UTF-8
      if (codePoint < 0x80) {
        utf8.push(codePoint);
      } else {
        if (codePoint < 0x800) {
          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);
        } else {
          if (codePoint < 0x10000) {
            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);
          } else {
            utf8.push(
              ((codePoint >> 18) & 0x07) | 0xF0,
              ((codePoint >> 12) & 0x3F) | 0x80);
          }
          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);
        }
        utf8.push((codePoint & 0x3F) | 0x80);
      }
    }
  }

  this.addInt8(0);
  this.startVector(1, utf8.length, 1);
  this.bb.setPosition(this.space -= utf8.length);
  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
    bytes[offset++] = utf8[i];
  }
  return this.endVector();
};

/**
 * A helper function to avoid generated code depending on this file directly.
 *
 * @param {number} low
 * @param {number} high
 * @returns {!flatbuffers.Long}
 */
flatbuffers.Builder.prototype.createLong = function(low, high) {
  return flatbuffers.Long.create(low, high);
};
////////////////////////////////////////////////////////////////////////////////
/// @cond FLATBUFFERS_INTERNAL
/**
 * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).
 *
 * @constructor
 * @param {Uint8Array} bytes
 */
flatbuffers.ByteBuffer = function(bytes) {
  /**
   * @type {Uint8Array}
   * @private
   */
  this.bytes_ = bytes;

  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * Create and allocate a new ByteBuffer with a given size.
 *
 * @param {number} byte_size
 * @returns {!flatbuffers.ByteBuffer}
 */
flatbuffers.ByteBuffer.allocate = function(byte_size) {
  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
};

flatbuffers.ByteBuffer.prototype.clear = function() {
  this.position_ = 0;
};

/**
 * Get the underlying `Uint8Array`.
 *
 * @returns {Uint8Array}
 */
flatbuffers.ByteBuffer.prototype.bytes = function() {
  return this.bytes_;
};

/**
 * Get the buffer's position.
 *
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.position = function() {
  return this.position_;
};

/**
 * Set the buffer's position.
 *
 * @param {number} position
 */
flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
  this.position_ = position;
};

/**
 * Get the buffer's capacity.
 *
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.capacity = function() {
  return this.bytes_.length;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
  return this.readUint8(offset) << 24 >> 24;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
  return this.bytes_[offset];
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
  return this.readUint16(offset) << 16 >> 16;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
  return this.readInt32(offset) >>> 0;
};

/**
 * @param {number} offset
 * @returns {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
};

/**
 * @param {number} offset
 * @returns {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
  flatbuffers.int32[0] = this.readInt32(offset);
  return flatbuffers.float32[0];
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
  return flatbuffers.float64[0];
};

/**
 * @param {number} offset
 * @param {number|boolean} value
 */
flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
  this.bytes_[offset] = /** @type {number} */(value);
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
  this.bytes_[offset] = value;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
  this.bytes_[offset + 2] = value >> 16;
  this.bytes_[offset + 3] = value >> 24;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
};

/**
 * @param {number} offset
 * @param {flatbuffers.Long} value
 */
flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
  this.writeInt32(offset, value.low);
  this.writeInt32(offset + 4, value.high);
};

/**
 * @param {number} offset
 * @param {flatbuffers.Long} value
 */
flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
    this.writeUint32(offset, value.low);
    this.writeUint32(offset + 4, value.high);
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
  flatbuffers.float32[0] = value;
  this.writeInt32(offset, flatbuffers.int32[0]);
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
  flatbuffers.float64[0] = value;
  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
};

/**
 * Return the file identifier.   Behavior is undefined for FlatBuffers whose
 * schema does not include a file_identifier (likely points at padding or the
 * start of a the root vtable).
 * @returns {string}
 */
flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +
      flatbuffers.FILE_IDENTIFIER_LENGTH) {
    throw new Error(
        'FlatBuffers: ByteBuffer is too short to contain an identifier.');
  }
  var result = "";
  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
    result += String.fromCharCode(
        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));
  }
  return result;
};

/**
 * Look up a field in the vtable, return an offset into the object, or 0 if the
 * field is not present.
 *
 * @param {number} bb_pos
 * @param {number} vtable_offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
  var vtable = bb_pos - this.readInt32(bb_pos);
  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
};

/**
 * Initialize any Table-derived type to point to the union at the given offset.
 *
 * @param {flatbuffers.Table} t
 * @param {number} offset
 * @returns {flatbuffers.Table}
 */
flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
  t.bb_pos = offset + this.readInt32(offset);
  t.bb = this;
  return t;
};

/**
 * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
 * This allocates a new string and converts to wide chars upon each access.
 *
 * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as
 * the "optionalEncoding" argument. This is useful for avoiding conversion to
 * and from UTF-16 when the data will just be packaged back up in another
 * FlatBuffer later on.
 *
 * @param {number} offset
 * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING
 * @returns {string|!Uint8Array}
 */
flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
  offset += this.readInt32(offset);

  var length = this.readInt32(offset);
  var result = '';
  var i = 0;

  offset += flatbuffers.SIZEOF_INT;

  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
    return this.bytes_.subarray(offset, offset + length);
  }

  while (i < length) {
    var codePoint;

    // Decode UTF-8
    var a = this.readUint8(offset + i++);
    if (a < 0xC0) {
      codePoint = a;
    } else {
      var b = this.readUint8(offset + i++);
      if (a < 0xE0) {
        codePoint =
          ((a & 0x1F) << 6) |
          (b & 0x3F);
      } else {
        var c = this.readUint8(offset + i++);
        if (a < 0xF0) {
          codePoint =
            ((a & 0x0F) << 12) |
            ((b & 0x3F) << 6) |
            (c & 0x3F);
        } else {
          var d = this.readUint8(offset + i++);
          codePoint =
            ((a & 0x07) << 18) |
            ((b & 0x3F) << 12) |
            ((c & 0x3F) << 6) |
            (d & 0x3F);
        }
      }
    }

    // Encode UTF-16
    if (codePoint < 0x10000) {
      result += String.fromCharCode(codePoint);
    } else {
      codePoint -= 0x10000;
      result += String.fromCharCode(
        (codePoint >> 10) + 0xD800,
        (codePoint & ((1 << 10) - 1)) + 0xDC00);
    }
  }

  return result;
};

/**
 * Retrieve the relative offset stored at "offset"
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
  return offset + this.readInt32(offset);
};

/**
 * Get the start of data of a vector whose offset is stored at "offset" in this object.
 *
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length
};

/**
 * Get the length of a vector whose offset is stored at "offset" in this object.
 *
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
  return this.readInt32(offset + this.readInt32(offset));
};

/**
 * @param {string} ident
 * @returns {boolean}
 */
flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
    throw new Error('FlatBuffers: file identifier must be length ' +
                    flatbuffers.FILE_IDENTIFIER_LENGTH);
  }
  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
      return false;
    }
  }
  return true;
};

/**
 * A helper function to avoid generated code depending on this file directly.
 *
 * @param {number} low
 * @param {number} high
 * @returns {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
  return flatbuffers.Long.create(low, high);
};

// Exports for Node.js and RequireJS


/// @endcond
/// @}


/***/ }),

/***/ "./node_modules/guid-typescript/dist/guid.js":
/*!***************************************************!*\
  !*** ./node_modules/guid-typescript/dist/guid.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

exports.__esModule = true;
var Guid = /** @class */ (function () {
    function Guid(guid) {
        if (!guid) {
            throw new TypeError("Invalid argument; `value` has no value.");
        }
        this.value = Guid.EMPTY;
        if (guid && Guid.isGuid(guid)) {
            this.value = guid;
        }
    }
    Guid.isGuid = function (guid) {
        var value = guid.toString();
        return guid && (guid instanceof Guid || Guid.validator.test(value));
    };
    Guid.create = function () {
        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-"));
    };
    Guid.createEmpty = function () {
        return new Guid("emptyguid");
    };
    Guid.parse = function (guid) {
        return new Guid(guid);
    };
    Guid.raw = function () {
        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-");
    };
    Guid.gen = function (count) {
        var out = "";
        for (var i = 0; i < count; i++) {
            // tslint:disable-next-line:no-bitwise
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    };
    Guid.prototype.equals = function (other) {
        // Comparing string `value` against provided `guid` will auto-call
        // toString on `guid` for comparison
        return Guid.isGuid(other) && this.value === other.toString();
    };
    Guid.prototype.isEmpty = function () {
        return this.value === Guid.EMPTY;
    };
    Guid.prototype.toString = function () {
        return this.value;
    };
    Guid.prototype.toJSON = function () {
        return {
            value: this.value
        };
    };
    Guid.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
    Guid.EMPTY = "00000000-0000-0000-0000-000000000000";
    return Guid;
}());
exports.Guid = Guid;


/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ (function(module) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/onnx-proto/dist/onnx.js":
/*!**********************************************!*\
  !*** ./node_modules/onnx-proto/dist/onnx.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.onnx = (function() {

    /**
     * Namespace onnx.
     * @exports onnx
     * @namespace
     */
    var onnx = {};

    /**
     * Version enum.
     * @name onnx.Version
     * @enum {string}
     * @property {number} _START_VERSION=0 _START_VERSION value
     * @property {number} IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_10 value
     * @property {number} IR_VERSION_2017_10_30=2 IR_VERSION_2017_10_30 value
     * @property {number} IR_VERSION_2017_11_3=3 IR_VERSION_2017_11_3 value
     * @property {number} IR_VERSION_2019_1_22=4 IR_VERSION_2019_1_22 value
     * @property {number} IR_VERSION=5 IR_VERSION value
     */
    onnx.Version = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "_START_VERSION"] = 0;
        values[valuesById[1] = "IR_VERSION_2017_10_10"] = 1;
        values[valuesById[2] = "IR_VERSION_2017_10_30"] = 2;
        values[valuesById[3] = "IR_VERSION_2017_11_3"] = 3;
        values[valuesById[4] = "IR_VERSION_2019_1_22"] = 4;
        values[valuesById[5] = "IR_VERSION"] = 5;
        return values;
    })();

    onnx.AttributeProto = (function() {

        /**
         * Properties of an AttributeProto.
         * @memberof onnx
         * @interface IAttributeProto
         * @property {string|null} [name] AttributeProto name
         * @property {string|null} [refAttrName] AttributeProto refAttrName
         * @property {string|null} [docString] AttributeProto docString
         * @property {onnx.AttributeProto.AttributeType|null} [type] AttributeProto type
         * @property {number|null} [f] AttributeProto f
         * @property {number|Long|null} [i] AttributeProto i
         * @property {Uint8Array|null} [s] AttributeProto s
         * @property {onnx.ITensorProto|null} [t] AttributeProto t
         * @property {onnx.IGraphProto|null} [g] AttributeProto g
         * @property {Array.<number>|null} [floats] AttributeProto floats
         * @property {Array.<number|Long>|null} [ints] AttributeProto ints
         * @property {Array.<Uint8Array>|null} [strings] AttributeProto strings
         * @property {Array.<onnx.ITensorProto>|null} [tensors] AttributeProto tensors
         * @property {Array.<onnx.IGraphProto>|null} [graphs] AttributeProto graphs
         */

        /**
         * Constructs a new AttributeProto.
         * @memberof onnx
         * @classdesc Represents an AttributeProto.
         * @implements IAttributeProto
         * @constructor
         * @param {onnx.IAttributeProto=} [properties] Properties to set
         */
        function AttributeProto(properties) {
            this.floats = [];
            this.ints = [];
            this.strings = [];
            this.tensors = [];
            this.graphs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttributeProto name.
         * @member {string} name
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.name = "";

        /**
         * AttributeProto refAttrName.
         * @member {string} refAttrName
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.refAttrName = "";

        /**
         * AttributeProto docString.
         * @member {string} docString
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.docString = "";

        /**
         * AttributeProto type.
         * @member {onnx.AttributeProto.AttributeType} type
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.type = 0;

        /**
         * AttributeProto f.
         * @member {number} f
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.f = 0;

        /**
         * AttributeProto i.
         * @member {number|Long} i
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AttributeProto s.
         * @member {Uint8Array} s
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.s = $util.newBuffer([]);

        /**
         * AttributeProto t.
         * @member {onnx.ITensorProto|null|undefined} t
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.t = null;

        /**
         * AttributeProto g.
         * @member {onnx.IGraphProto|null|undefined} g
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.g = null;

        /**
         * AttributeProto floats.
         * @member {Array.<number>} floats
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.floats = $util.emptyArray;

        /**
         * AttributeProto ints.
         * @member {Array.<number|Long>} ints
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.ints = $util.emptyArray;

        /**
         * AttributeProto strings.
         * @member {Array.<Uint8Array>} strings
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.strings = $util.emptyArray;

        /**
         * AttributeProto tensors.
         * @member {Array.<onnx.ITensorProto>} tensors
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.tensors = $util.emptyArray;

        /**
         * AttributeProto graphs.
         * @member {Array.<onnx.IGraphProto>} graphs
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.graphs = $util.emptyArray;

        /**
         * Creates a new AttributeProto instance using the specified properties.
         * @function create
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.IAttributeProto=} [properties] Properties to set
         * @returns {onnx.AttributeProto} AttributeProto instance
         */
        AttributeProto.create = function create(properties) {
            return new AttributeProto(properties);
        };

        /**
         * Encodes the specified AttributeProto message. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttributeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.f != null && message.hasOwnProperty("f"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.f);
            if (message.i != null && message.hasOwnProperty("i"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.i);
            if (message.s != null && message.hasOwnProperty("s"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);
            if (message.t != null && message.hasOwnProperty("t"))
                $root.onnx.TensorProto.encode(message.t, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.g != null && message.hasOwnProperty("g"))
                $root.onnx.GraphProto.encode(message.g, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.floats != null && message.floats.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.floats.length; ++i)
                    writer.float(message.floats[i]);
                writer.ldelim();
            }
            if (message.ints != null && message.ints.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (var i = 0; i < message.ints.length; ++i)
                    writer.int64(message.ints[i]);
                writer.ldelim();
            }
            if (message.strings != null && message.strings.length)
                for (var i = 0; i < message.strings.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.strings[i]);
            if (message.tensors != null && message.tensors.length)
                for (var i = 0; i < message.tensors.length; ++i)
                    $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.graphs != null && message.graphs.length)
                for (var i = 0; i < message.graphs.length; ++i)
                    $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.docString);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.type);
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.refAttrName);
            return writer;
        };

        /**
         * Encodes the specified AttributeProto message, length delimited. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttributeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.AttributeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.AttributeProto} AttributeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttributeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 21:
                    message.refAttrName = reader.string();
                    break;
                case 13:
                    message.docString = reader.string();
                    break;
                case 20:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.f = reader.float();
                    break;
                case 3:
                    message.i = reader.int64();
                    break;
                case 4:
                    message.s = reader.bytes();
                    break;
                case 5:
                    message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.floats && message.floats.length))
                        message.floats = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.floats.push(reader.float());
                    } else
                        message.floats.push(reader.float());
                    break;
                case 8:
                    if (!(message.ints && message.ints.length))
                        message.ints = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ints.push(reader.int64());
                    } else
                        message.ints.push(reader.int64());
                    break;
                case 9:
                    if (!(message.strings && message.strings.length))
                        message.strings = [];
                    message.strings.push(reader.bytes());
                    break;
                case 10:
                    if (!(message.tensors && message.tensors.length))
                        message.tensors = [];
                    message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.graphs && message.graphs.length))
                        message.graphs = [];
                    message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttributeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.AttributeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.AttributeProto} AttributeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttributeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AttributeProto message.
         * @function verify
         * @memberof onnx.AttributeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AttributeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
                if (!$util.isString(message.refAttrName))
                    return "refAttrName: string expected";
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.f != null && message.hasOwnProperty("f"))
                if (typeof message.f !== "number")
                    return "f: number expected";
            if (message.i != null && message.hasOwnProperty("i"))
                if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
                    return "i: integer|Long expected";
            if (message.s != null && message.hasOwnProperty("s"))
                if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                    return "s: buffer expected";
            if (message.t != null && message.hasOwnProperty("t")) {
                var error = $root.onnx.TensorProto.verify(message.t);
                if (error)
                    return "t." + error;
            }
            if (message.g != null && message.hasOwnProperty("g")) {
                var error = $root.onnx.GraphProto.verify(message.g);
                if (error)
                    return "g." + error;
            }
            if (message.floats != null && message.hasOwnProperty("floats")) {
                if (!Array.isArray(message.floats))
                    return "floats: array expected";
                for (var i = 0; i < message.floats.length; ++i)
                    if (typeof message.floats[i] !== "number")
                        return "floats: number[] expected";
            }
            if (message.ints != null && message.hasOwnProperty("ints")) {
                if (!Array.isArray(message.ints))
                    return "ints: array expected";
                for (var i = 0; i < message.ints.length; ++i)
                    if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))
                        return "ints: integer|Long[] expected";
            }
            if (message.strings != null && message.hasOwnProperty("strings")) {
                if (!Array.isArray(message.strings))
                    return "strings: array expected";
                for (var i = 0; i < message.strings.length; ++i)
                    if (!(message.strings[i] && typeof message.strings[i].length === "number" || $util.isString(message.strings[i])))
                        return "strings: buffer[] expected";
            }
            if (message.tensors != null && message.hasOwnProperty("tensors")) {
                if (!Array.isArray(message.tensors))
                    return "tensors: array expected";
                for (var i = 0; i < message.tensors.length; ++i) {
                    var error = $root.onnx.TensorProto.verify(message.tensors[i]);
                    if (error)
                        return "tensors." + error;
                }
            }
            if (message.graphs != null && message.hasOwnProperty("graphs")) {
                if (!Array.isArray(message.graphs))
                    return "graphs: array expected";
                for (var i = 0; i < message.graphs.length; ++i) {
                    var error = $root.onnx.GraphProto.verify(message.graphs[i]);
                    if (error)
                        return "graphs." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AttributeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.AttributeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.AttributeProto} AttributeProto
         */
        AttributeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.AttributeProto)
                return object;
            var message = new $root.onnx.AttributeProto();
            if (object.name != null)
                message.name = String(object.name);
            if (object.refAttrName != null)
                message.refAttrName = String(object.refAttrName);
            if (object.docString != null)
                message.docString = String(object.docString);
            switch (object.type) {
            case "UNDEFINED":
            case 0:
                message.type = 0;
                break;
            case "FLOAT":
            case 1:
                message.type = 1;
                break;
            case "INT":
            case 2:
                message.type = 2;
                break;
            case "STRING":
            case 3:
                message.type = 3;
                break;
            case "TENSOR":
            case 4:
                message.type = 4;
                break;
            case "GRAPH":
            case 5:
                message.type = 5;
                break;
            case "FLOATS":
            case 6:
                message.type = 6;
                break;
            case "INTS":
            case 7:
                message.type = 7;
                break;
            case "STRINGS":
            case 8:
                message.type = 8;
                break;
            case "TENSORS":
            case 9:
                message.type = 9;
                break;
            case "GRAPHS":
            case 10:
                message.type = 10;
                break;
            }
            if (object.f != null)
                message.f = Number(object.f);
            if (object.i != null)
                if ($util.Long)
                    (message.i = $util.Long.fromValue(object.i)).unsigned = false;
                else if (typeof object.i === "string")
                    message.i = parseInt(object.i, 10);
                else if (typeof object.i === "number")
                    message.i = object.i;
                else if (typeof object.i === "object")
                    message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
            if (object.s != null)
                if (typeof object.s === "string")
                    $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                else if (object.s.length)
                    message.s = object.s;
            if (object.t != null) {
                if (typeof object.t !== "object")
                    throw TypeError(".onnx.AttributeProto.t: object expected");
                message.t = $root.onnx.TensorProto.fromObject(object.t);
            }
            if (object.g != null) {
                if (typeof object.g !== "object")
                    throw TypeError(".onnx.AttributeProto.g: object expected");
                message.g = $root.onnx.GraphProto.fromObject(object.g);
            }
            if (object.floats) {
                if (!Array.isArray(object.floats))
                    throw TypeError(".onnx.AttributeProto.floats: array expected");
                message.floats = [];
                for (var i = 0; i < object.floats.length; ++i)
                    message.floats[i] = Number(object.floats[i]);
            }
            if (object.ints) {
                if (!Array.isArray(object.ints))
                    throw TypeError(".onnx.AttributeProto.ints: array expected");
                message.ints = [];
                for (var i = 0; i < object.ints.length; ++i)
                    if ($util.Long)
                        (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;
                    else if (typeof object.ints[i] === "string")
                        message.ints[i] = parseInt(object.ints[i], 10);
                    else if (typeof object.ints[i] === "number")
                        message.ints[i] = object.ints[i];
                    else if (typeof object.ints[i] === "object")
                        message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();
            }
            if (object.strings) {
                if (!Array.isArray(object.strings))
                    throw TypeError(".onnx.AttributeProto.strings: array expected");
                message.strings = [];
                for (var i = 0; i < object.strings.length; ++i)
                    if (typeof object.strings[i] === "string")
                        $util.base64.decode(object.strings[i], message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])), 0);
                    else if (object.strings[i].length)
                        message.strings[i] = object.strings[i];
            }
            if (object.tensors) {
                if (!Array.isArray(object.tensors))
                    throw TypeError(".onnx.AttributeProto.tensors: array expected");
                message.tensors = [];
                for (var i = 0; i < object.tensors.length; ++i) {
                    if (typeof object.tensors[i] !== "object")
                        throw TypeError(".onnx.AttributeProto.tensors: object expected");
                    message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);
                }
            }
            if (object.graphs) {
                if (!Array.isArray(object.graphs))
                    throw TypeError(".onnx.AttributeProto.graphs: array expected");
                message.graphs = [];
                for (var i = 0; i < object.graphs.length; ++i) {
                    if (typeof object.graphs[i] !== "object")
                        throw TypeError(".onnx.AttributeProto.graphs: object expected");
                    message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AttributeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.AttributeProto} message AttributeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AttributeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.floats = [];
                object.ints = [];
                object.strings = [];
                object.tensors = [];
                object.graphs = [];
            }
            if (options.defaults) {
                object.name = "";
                object.f = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.i = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.s = "";
                else {
                    object.s = [];
                    if (options.bytes !== Array)
                        object.s = $util.newBuffer(object.s);
                }
                object.t = null;
                object.g = null;
                object.docString = "";
                object.type = options.enums === String ? "UNDEFINED" : 0;
                object.refAttrName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.f != null && message.hasOwnProperty("f"))
                object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
            if (message.i != null && message.hasOwnProperty("i"))
                if (typeof message.i === "number")
                    object.i = options.longs === String ? String(message.i) : message.i;
                else
                    object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
            if (message.s != null && message.hasOwnProperty("s"))
                object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
            if (message.t != null && message.hasOwnProperty("t"))
                object.t = $root.onnx.TensorProto.toObject(message.t, options);
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = $root.onnx.GraphProto.toObject(message.g, options);
            if (message.floats && message.floats.length) {
                object.floats = [];
                for (var j = 0; j < message.floats.length; ++j)
                    object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];
            }
            if (message.ints && message.ints.length) {
                object.ints = [];
                for (var j = 0; j < message.ints.length; ++j)
                    if (typeof message.ints[j] === "number")
                        object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];
                    else
                        object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];
            }
            if (message.strings && message.strings.length) {
                object.strings = [];
                for (var j = 0; j < message.strings.length; ++j)
                    object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];
            }
            if (message.tensors && message.tensors.length) {
                object.tensors = [];
                for (var j = 0; j < message.tensors.length; ++j)
                    object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);
            }
            if (message.graphs && message.graphs.length) {
                object.graphs = [];
                for (var j = 0; j < message.graphs.length; ++j)
                    object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] : message.type;
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
                object.refAttrName = message.refAttrName;
            return object;
        };

        /**
         * Converts this AttributeProto to JSON.
         * @function toJSON
         * @memberof onnx.AttributeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AttributeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AttributeType enum.
         * @name onnx.AttributeProto.AttributeType
         * @enum {string}
         * @property {number} UNDEFINED=0 UNDEFINED value
         * @property {number} FLOAT=1 FLOAT value
         * @property {number} INT=2 INT value
         * @property {number} STRING=3 STRING value
         * @property {number} TENSOR=4 TENSOR value
         * @property {number} GRAPH=5 GRAPH value
         * @property {number} FLOATS=6 FLOATS value
         * @property {number} INTS=7 INTS value
         * @property {number} STRINGS=8 STRINGS value
         * @property {number} TENSORS=9 TENSORS value
         * @property {number} GRAPHS=10 GRAPHS value
         */
        AttributeProto.AttributeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "INT"] = 2;
            values[valuesById[3] = "STRING"] = 3;
            values[valuesById[4] = "TENSOR"] = 4;
            values[valuesById[5] = "GRAPH"] = 5;
            values[valuesById[6] = "FLOATS"] = 6;
            values[valuesById[7] = "INTS"] = 7;
            values[valuesById[8] = "STRINGS"] = 8;
            values[valuesById[9] = "TENSORS"] = 9;
            values[valuesById[10] = "GRAPHS"] = 10;
            return values;
        })();

        return AttributeProto;
    })();

    onnx.ValueInfoProto = (function() {

        /**
         * Properties of a ValueInfoProto.
         * @memberof onnx
         * @interface IValueInfoProto
         * @property {string|null} [name] ValueInfoProto name
         * @property {onnx.ITypeProto|null} [type] ValueInfoProto type
         * @property {string|null} [docString] ValueInfoProto docString
         */

        /**
         * Constructs a new ValueInfoProto.
         * @memberof onnx
         * @classdesc Represents a ValueInfoProto.
         * @implements IValueInfoProto
         * @constructor
         * @param {onnx.IValueInfoProto=} [properties] Properties to set
         */
        function ValueInfoProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValueInfoProto name.
         * @member {string} name
         * @memberof onnx.ValueInfoProto
         * @instance
         */
        ValueInfoProto.prototype.name = "";

        /**
         * ValueInfoProto type.
         * @member {onnx.ITypeProto|null|undefined} type
         * @memberof onnx.ValueInfoProto
         * @instance
         */
        ValueInfoProto.prototype.type = null;

        /**
         * ValueInfoProto docString.
         * @member {string} docString
         * @memberof onnx.ValueInfoProto
         * @instance
         */
        ValueInfoProto.prototype.docString = "";

        /**
         * Creates a new ValueInfoProto instance using the specified properties.
         * @function create
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.IValueInfoProto=} [properties] Properties to set
         * @returns {onnx.ValueInfoProto} ValueInfoProto instance
         */
        ValueInfoProto.create = function create(properties) {
            return new ValueInfoProto(properties);
        };

        /**
         * Encodes the specified ValueInfoProto message. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValueInfoProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && message.hasOwnProperty("type"))
                $root.onnx.TypeProto.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.docString);
            return writer;
        };

        /**
         * Encodes the specified ValueInfoProto message, length delimited. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValueInfoProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.ValueInfoProto} ValueInfoProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueInfoProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.docString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValueInfoProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.ValueInfoProto} ValueInfoProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValueInfoProto message.
         * @function verify
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValueInfoProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.onnx.TypeProto.verify(message.type);
                if (error)
                    return "type." + error;
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            return null;
        };

        /**
         * Creates a ValueInfoProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.ValueInfoProto} ValueInfoProto
         */
        ValueInfoProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ValueInfoProto)
                return object;
            var message = new $root.onnx.ValueInfoProto();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".onnx.ValueInfoProto.type: object expected");
                message.type = $root.onnx.TypeProto.fromObject(object.type);
            }
            if (object.docString != null)
                message.docString = String(object.docString);
            return message;
        };

        /**
         * Creates a plain object from a ValueInfoProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.ValueInfoProto} message ValueInfoProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValueInfoProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = null;
                object.docString = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.onnx.TypeProto.toObject(message.type, options);
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            return object;
        };

        /**
         * Converts this ValueInfoProto to JSON.
         * @function toJSON
         * @memberof onnx.ValueInfoProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValueInfoProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValueInfoProto;
    })();

    onnx.NodeProto = (function() {

        /**
         * Properties of a NodeProto.
         * @memberof onnx
         * @interface INodeProto
         * @property {Array.<string>|null} [input] NodeProto input
         * @property {Array.<string>|null} [output] NodeProto output
         * @property {string|null} [name] NodeProto name
         * @property {string|null} [opType] NodeProto opType
         * @property {string|null} [domain] NodeProto domain
         * @property {Array.<onnx.IAttributeProto>|null} [attribute] NodeProto attribute
         * @property {string|null} [docString] NodeProto docString
         */

        /**
         * Constructs a new NodeProto.
         * @memberof onnx
         * @classdesc Represents a NodeProto.
         * @implements INodeProto
         * @constructor
         * @param {onnx.INodeProto=} [properties] Properties to set
         */
        function NodeProto(properties) {
            this.input = [];
            this.output = [];
            this.attribute = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeProto input.
         * @member {Array.<string>} input
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.input = $util.emptyArray;

        /**
         * NodeProto output.
         * @member {Array.<string>} output
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.output = $util.emptyArray;

        /**
         * NodeProto name.
         * @member {string} name
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.name = "";

        /**
         * NodeProto opType.
         * @member {string} opType
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.opType = "";

        /**
         * NodeProto domain.
         * @member {string} domain
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.domain = "";

        /**
         * NodeProto attribute.
         * @member {Array.<onnx.IAttributeProto>} attribute
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.attribute = $util.emptyArray;

        /**
         * NodeProto docString.
         * @member {string} docString
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.docString = "";

        /**
         * Creates a new NodeProto instance using the specified properties.
         * @function create
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.INodeProto=} [properties] Properties to set
         * @returns {onnx.NodeProto} NodeProto instance
         */
        NodeProto.create = function create(properties) {
            return new NodeProto(properties);
        };

        /**
         * Encodes the specified NodeProto message. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.INodeProto} message NodeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.input != null && message.input.length)
                for (var i = 0; i < message.input.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input[i]);
            if (message.output != null && message.output.length)
                for (var i = 0; i < message.output.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.output[i]);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.opType != null && message.hasOwnProperty("opType"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.opType);
            if (message.attribute != null && message.attribute.length)
                for (var i = 0; i < message.attribute.length; ++i)
                    $root.onnx.AttributeProto.encode(message.attribute[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.domain);
            return writer;
        };

        /**
         * Encodes the specified NodeProto message, length delimited. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.INodeProto} message NodeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.NodeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.NodeProto} NodeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.input && message.input.length))
                        message.input = [];
                    message.input.push(reader.string());
                    break;
                case 2:
                    if (!(message.output && message.output.length))
                        message.output = [];
                    message.output.push(reader.string());
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.opType = reader.string();
                    break;
                case 7:
                    message.domain = reader.string();
                    break;
                case 5:
                    if (!(message.attribute && message.attribute.length))
                        message.attribute = [];
                    message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.docString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.NodeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.NodeProto} NodeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeProto message.
         * @function verify
         * @memberof onnx.NodeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.input != null && message.hasOwnProperty("input")) {
                if (!Array.isArray(message.input))
                    return "input: array expected";
                for (var i = 0; i < message.input.length; ++i)
                    if (!$util.isString(message.input[i]))
                        return "input: string[] expected";
            }
            if (message.output != null && message.hasOwnProperty("output")) {
                if (!Array.isArray(message.output))
                    return "output: array expected";
                for (var i = 0; i < message.output.length; ++i)
                    if (!$util.isString(message.output[i]))
                        return "output: string[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.opType != null && message.hasOwnProperty("opType"))
                if (!$util.isString(message.opType))
                    return "opType: string expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.attribute != null && message.hasOwnProperty("attribute")) {
                if (!Array.isArray(message.attribute))
                    return "attribute: array expected";
                for (var i = 0; i < message.attribute.length; ++i) {
                    var error = $root.onnx.AttributeProto.verify(message.attribute[i]);
                    if (error)
                        return "attribute." + error;
                }
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            return null;
        };

        /**
         * Creates a NodeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.NodeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.NodeProto} NodeProto
         */
        NodeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.NodeProto)
                return object;
            var message = new $root.onnx.NodeProto();
            if (object.input) {
                if (!Array.isArray(object.input))
                    throw TypeError(".onnx.NodeProto.input: array expected");
                message.input = [];
                for (var i = 0; i < object.input.length; ++i)
                    message.input[i] = String(object.input[i]);
            }
            if (object.output) {
                if (!Array.isArray(object.output))
                    throw TypeError(".onnx.NodeProto.output: array expected");
                message.output = [];
                for (var i = 0; i < object.output.length; ++i)
                    message.output[i] = String(object.output[i]);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.opType != null)
                message.opType = String(object.opType);
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.attribute) {
                if (!Array.isArray(object.attribute))
                    throw TypeError(".onnx.NodeProto.attribute: array expected");
                message.attribute = [];
                for (var i = 0; i < object.attribute.length; ++i) {
                    if (typeof object.attribute[i] !== "object")
                        throw TypeError(".onnx.NodeProto.attribute: object expected");
                    message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);
                }
            }
            if (object.docString != null)
                message.docString = String(object.docString);
            return message;
        };

        /**
         * Creates a plain object from a NodeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.NodeProto} message NodeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.input = [];
                object.output = [];
                object.attribute = [];
            }
            if (options.defaults) {
                object.name = "";
                object.opType = "";
                object.docString = "";
                object.domain = "";
            }
            if (message.input && message.input.length) {
                object.input = [];
                for (var j = 0; j < message.input.length; ++j)
                    object.input[j] = message.input[j];
            }
            if (message.output && message.output.length) {
                object.output = [];
                for (var j = 0; j < message.output.length; ++j)
                    object.output[j] = message.output[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.opType != null && message.hasOwnProperty("opType"))
                object.opType = message.opType;
            if (message.attribute && message.attribute.length) {
                object.attribute = [];
                for (var j = 0; j < message.attribute.length; ++j)
                    object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            return object;
        };

        /**
         * Converts this NodeProto to JSON.
         * @function toJSON
         * @memberof onnx.NodeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeProto;
    })();

    onnx.ModelProto = (function() {

        /**
         * Properties of a ModelProto.
         * @memberof onnx
         * @interface IModelProto
         * @property {number|Long|null} [irVersion] ModelProto irVersion
         * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] ModelProto opsetImport
         * @property {string|null} [producerName] ModelProto producerName
         * @property {string|null} [producerVersion] ModelProto producerVersion
         * @property {string|null} [domain] ModelProto domain
         * @property {number|Long|null} [modelVersion] ModelProto modelVersion
         * @property {string|null} [docString] ModelProto docString
         * @property {onnx.IGraphProto|null} [graph] ModelProto graph
         * @property {Array.<onnx.IStringStringEntryProto>|null} [metadataProps] ModelProto metadataProps
         */

        /**
         * Constructs a new ModelProto.
         * @memberof onnx
         * @classdesc Represents a ModelProto.
         * @implements IModelProto
         * @constructor
         * @param {onnx.IModelProto=} [properties] Properties to set
         */
        function ModelProto(properties) {
            this.opsetImport = [];
            this.metadataProps = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModelProto irVersion.
         * @member {number|Long} irVersion
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ModelProto opsetImport.
         * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.opsetImport = $util.emptyArray;

        /**
         * ModelProto producerName.
         * @member {string} producerName
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.producerName = "";

        /**
         * ModelProto producerVersion.
         * @member {string} producerVersion
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.producerVersion = "";

        /**
         * ModelProto domain.
         * @member {string} domain
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.domain = "";

        /**
         * ModelProto modelVersion.
         * @member {number|Long} modelVersion
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ModelProto docString.
         * @member {string} docString
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.docString = "";

        /**
         * ModelProto graph.
         * @member {onnx.IGraphProto|null|undefined} graph
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.graph = null;

        /**
         * ModelProto metadataProps.
         * @member {Array.<onnx.IStringStringEntryProto>} metadataProps
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.metadataProps = $util.emptyArray;

        /**
         * Creates a new ModelProto instance using the specified properties.
         * @function create
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.IModelProto=} [properties] Properties to set
         * @returns {onnx.ModelProto} ModelProto instance
         */
        ModelProto.create = function create(properties) {
            return new ModelProto(properties);
        };

        /**
         * Encodes the specified ModelProto message. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.IModelProto} message ModelProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModelProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.irVersion);
            if (message.producerName != null && message.hasOwnProperty("producerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerName);
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.producerVersion);
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.domain);
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.modelVersion);
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);
            if (message.graph != null && message.hasOwnProperty("graph"))
                $root.onnx.GraphProto.encode(message.graph, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.opsetImport != null && message.opsetImport.length)
                for (var i = 0; i < message.opsetImport.length; ++i)
                    $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.metadataProps != null && message.metadataProps.length)
                for (var i = 0; i < message.metadataProps.length; ++i)
                    $root.onnx.StringStringEntryProto.encode(message.metadataProps[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ModelProto message, length delimited. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.IModelProto} message ModelProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModelProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModelProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.ModelProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.ModelProto} ModelProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModelProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.irVersion = reader.int64();
                    break;
                case 8:
                    if (!(message.opsetImport && message.opsetImport.length))
                        message.opsetImport = [];
                    message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.producerName = reader.string();
                    break;
                case 3:
                    message.producerVersion = reader.string();
                    break;
                case 4:
                    message.domain = reader.string();
                    break;
                case 5:
                    message.modelVersion = reader.int64();
                    break;
                case 6:
                    message.docString = reader.string();
                    break;
                case 7:
                    message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());
                    break;
                case 14:
                    if (!(message.metadataProps && message.metadataProps.length))
                        message.metadataProps = [];
                    message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModelProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.ModelProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.ModelProto} ModelProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModelProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModelProto message.
         * @function verify
         * @memberof onnx.ModelProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModelProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
                if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))
                    return "irVersion: integer|Long expected";
            if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(message.opsetImport))
                    return "opsetImport: array expected";
                for (var i = 0; i < message.opsetImport.length; ++i) {
                    var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
                    if (error)
                        return "opsetImport." + error;
                }
            }
            if (message.producerName != null && message.hasOwnProperty("producerName"))
                if (!$util.isString(message.producerName))
                    return "producerName: string expected";
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
                if (!$util.isString(message.producerVersion))
                    return "producerVersion: string expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
                if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))
                    return "modelVersion: integer|Long expected";
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                var error = $root.onnx.GraphProto.verify(message.graph);
                if (error)
                    return "graph." + error;
            }
            if (message.metadataProps != null && message.hasOwnProperty("metadataProps")) {
                if (!Array.isArray(message.metadataProps))
                    return "metadataProps: array expected";
                for (var i = 0; i < message.metadataProps.length; ++i) {
                    var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);
                    if (error)
                        return "metadataProps." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ModelProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.ModelProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.ModelProto} ModelProto
         */
        ModelProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ModelProto)
                return object;
            var message = new $root.onnx.ModelProto();
            if (object.irVersion != null)
                if ($util.Long)
                    (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;
                else if (typeof object.irVersion === "string")
                    message.irVersion = parseInt(object.irVersion, 10);
                else if (typeof object.irVersion === "number")
                    message.irVersion = object.irVersion;
                else if (typeof object.irVersion === "object")
                    message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();
            if (object.opsetImport) {
                if (!Array.isArray(object.opsetImport))
                    throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                message.opsetImport = [];
                for (var i = 0; i < object.opsetImport.length; ++i) {
                    if (typeof object.opsetImport[i] !== "object")
                        throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                    message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
                }
            }
            if (object.producerName != null)
                message.producerName = String(object.producerName);
            if (object.producerVersion != null)
                message.producerVersion = String(object.producerVersion);
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.modelVersion != null)
                if ($util.Long)
                    (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;
                else if (typeof object.modelVersion === "string")
                    message.modelVersion = parseInt(object.modelVersion, 10);
                else if (typeof object.modelVersion === "number")
                    message.modelVersion = object.modelVersion;
                else if (typeof object.modelVersion === "object")
                    message.modelVersion = new $util.LongBits(object.modelVersion.low >>> 0, object.modelVersion.high >>> 0).toNumber();
            if (object.docString != null)
                message.docString = String(object.docString);
            if (object.graph != null) {
                if (typeof object.graph !== "object")
                    throw TypeError(".onnx.ModelProto.graph: object expected");
                message.graph = $root.onnx.GraphProto.fromObject(object.graph);
            }
            if (object.metadataProps) {
                if (!Array.isArray(object.metadataProps))
                    throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                message.metadataProps = [];
                for (var i = 0; i < object.metadataProps.length; ++i) {
                    if (typeof object.metadataProps[i] !== "object")
                        throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                    message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ModelProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.ModelProto} message ModelProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModelProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.opsetImport = [];
                object.metadataProps = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.irVersion = options.longs === String ? "0" : 0;
                object.producerName = "";
                object.producerVersion = "";
                object.domain = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.modelVersion = options.longs === String ? "0" : 0;
                object.docString = "";
                object.graph = null;
            }
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
                if (typeof message.irVersion === "number")
                    object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;
                else
                    object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;
            if (message.producerName != null && message.hasOwnProperty("producerName"))
                object.producerName = message.producerName;
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
                object.producerVersion = message.producerVersion;
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
                if (typeof message.modelVersion === "number")
                    object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;
                else
                    object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.graph != null && message.hasOwnProperty("graph"))
                object.graph = $root.onnx.GraphProto.toObject(message.graph, options);
            if (message.opsetImport && message.opsetImport.length) {
                object.opsetImport = [];
                for (var j = 0; j < message.opsetImport.length; ++j)
                    object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
            }
            if (message.metadataProps && message.metadataProps.length) {
                object.metadataProps = [];
                for (var j = 0; j < message.metadataProps.length; ++j)
                    object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);
            }
            return object;
        };

        /**
         * Converts this ModelProto to JSON.
         * @function toJSON
         * @memberof onnx.ModelProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModelProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModelProto;
    })();

    onnx.StringStringEntryProto = (function() {

        /**
         * Properties of a StringStringEntryProto.
         * @memberof onnx
         * @interface IStringStringEntryProto
         * @property {string|null} [key] StringStringEntryProto key
         * @property {string|null} [value] StringStringEntryProto value
         */

        /**
         * Constructs a new StringStringEntryProto.
         * @memberof onnx
         * @classdesc Represents a StringStringEntryProto.
         * @implements IStringStringEntryProto
         * @constructor
         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set
         */
        function StringStringEntryProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringStringEntryProto key.
         * @member {string} key
         * @memberof onnx.StringStringEntryProto
         * @instance
         */
        StringStringEntryProto.prototype.key = "";

        /**
         * StringStringEntryProto value.
         * @member {string} value
         * @memberof onnx.StringStringEntryProto
         * @instance
         */
        StringStringEntryProto.prototype.value = "";

        /**
         * Creates a new StringStringEntryProto instance using the specified properties.
         * @function create
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto instance
         */
        StringStringEntryProto.create = function create(properties) {
            return new StringStringEntryProto(properties);
        };

        /**
         * Encodes the specified StringStringEntryProto message. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringStringEntryProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified StringStringEntryProto message, length delimited. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StringStringEntryProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringStringEntryProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StringStringEntryProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StringStringEntryProto message.
         * @function verify
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StringStringEntryProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a StringStringEntryProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto
         */
        StringStringEntryProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.StringStringEntryProto)
                return object;
            var message = new $root.onnx.StringStringEntryProto();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a StringStringEntryProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.StringStringEntryProto} message StringStringEntryProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StringStringEntryProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this StringStringEntryProto to JSON.
         * @function toJSON
         * @memberof onnx.StringStringEntryProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StringStringEntryProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StringStringEntryProto;
    })();

    onnx.TensorAnnotation = (function() {

        /**
         * Properties of a TensorAnnotation.
         * @memberof onnx
         * @interface ITensorAnnotation
         * @property {string|null} [tensorName] TensorAnnotation tensorName
         * @property {Array.<onnx.IStringStringEntryProto>|null} [quantParameterTensorNames] TensorAnnotation quantParameterTensorNames
         */

        /**
         * Constructs a new TensorAnnotation.
         * @memberof onnx
         * @classdesc Represents a TensorAnnotation.
         * @implements ITensorAnnotation
         * @constructor
         * @param {onnx.ITensorAnnotation=} [properties] Properties to set
         */
        function TensorAnnotation(properties) {
            this.quantParameterTensorNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorAnnotation tensorName.
         * @member {string} tensorName
         * @memberof onnx.TensorAnnotation
         * @instance
         */
        TensorAnnotation.prototype.tensorName = "";

        /**
         * TensorAnnotation quantParameterTensorNames.
         * @member {Array.<onnx.IStringStringEntryProto>} quantParameterTensorNames
         * @memberof onnx.TensorAnnotation
         * @instance
         */
        TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;

        /**
         * Creates a new TensorAnnotation instance using the specified properties.
         * @function create
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.ITensorAnnotation=} [properties] Properties to set
         * @returns {onnx.TensorAnnotation} TensorAnnotation instance
         */
        TensorAnnotation.create = function create(properties) {
            return new TensorAnnotation(properties);
        };

        /**
         * Encodes the specified TensorAnnotation message. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.
         * @function encode
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorAnnotation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tensorName);
            if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)
                for (var i = 0; i < message.quantParameterTensorNames.length; ++i)
                    $root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TensorAnnotation message, length delimited. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorAnnotation message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TensorAnnotation} TensorAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorAnnotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tensorName = reader.string();
                    break;
                case 2:
                    if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))
                        message.quantParameterTensorNames = [];
                    message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorAnnotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TensorAnnotation} TensorAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorAnnotation message.
         * @function verify
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorAnnotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
                if (!$util.isString(message.tensorName))
                    return "tensorName: string expected";
            if (message.quantParameterTensorNames != null && message.hasOwnProperty("quantParameterTensorNames")) {
                if (!Array.isArray(message.quantParameterTensorNames))
                    return "quantParameterTensorNames: array expected";
                for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {
                    var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);
                    if (error)
                        return "quantParameterTensorNames." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TensorAnnotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TensorAnnotation} TensorAnnotation
         */
        TensorAnnotation.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorAnnotation)
                return object;
            var message = new $root.onnx.TensorAnnotation();
            if (object.tensorName != null)
                message.tensorName = String(object.tensorName);
            if (object.quantParameterTensorNames) {
                if (!Array.isArray(object.quantParameterTensorNames))
                    throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                message.quantParameterTensorNames = [];
                for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {
                    if (typeof object.quantParameterTensorNames[i] !== "object")
                        throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                    message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorAnnotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.TensorAnnotation} message TensorAnnotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorAnnotation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.quantParameterTensorNames = [];
            if (options.defaults)
                object.tensorName = "";
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
                object.tensorName = message.tensorName;
            if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {
                object.quantParameterTensorNames = [];
                for (var j = 0; j < message.quantParameterTensorNames.length; ++j)
                    object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j], options);
            }
            return object;
        };

        /**
         * Converts this TensorAnnotation to JSON.
         * @function toJSON
         * @memberof onnx.TensorAnnotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorAnnotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TensorAnnotation;
    })();

    onnx.GraphProto = (function() {

        /**
         * Properties of a GraphProto.
         * @memberof onnx
         * @interface IGraphProto
         * @property {Array.<onnx.INodeProto>|null} [node] GraphProto node
         * @property {string|null} [name] GraphProto name
         * @property {Array.<onnx.ITensorProto>|null} [initializer] GraphProto initializer
         * @property {string|null} [docString] GraphProto docString
         * @property {Array.<onnx.IValueInfoProto>|null} [input] GraphProto input
         * @property {Array.<onnx.IValueInfoProto>|null} [output] GraphProto output
         * @property {Array.<onnx.IValueInfoProto>|null} [valueInfo] GraphProto valueInfo
         * @property {Array.<onnx.ITensorAnnotation>|null} [quantizationAnnotation] GraphProto quantizationAnnotation
         */

        /**
         * Constructs a new GraphProto.
         * @memberof onnx
         * @classdesc Represents a GraphProto.
         * @implements IGraphProto
         * @constructor
         * @param {onnx.IGraphProto=} [properties] Properties to set
         */
        function GraphProto(properties) {
            this.node = [];
            this.initializer = [];
            this.input = [];
            this.output = [];
            this.valueInfo = [];
            this.quantizationAnnotation = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphProto node.
         * @member {Array.<onnx.INodeProto>} node
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.node = $util.emptyArray;

        /**
         * GraphProto name.
         * @member {string} name
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.name = "";

        /**
         * GraphProto initializer.
         * @member {Array.<onnx.ITensorProto>} initializer
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.initializer = $util.emptyArray;

        /**
         * GraphProto docString.
         * @member {string} docString
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.docString = "";

        /**
         * GraphProto input.
         * @member {Array.<onnx.IValueInfoProto>} input
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.input = $util.emptyArray;

        /**
         * GraphProto output.
         * @member {Array.<onnx.IValueInfoProto>} output
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.output = $util.emptyArray;

        /**
         * GraphProto valueInfo.
         * @member {Array.<onnx.IValueInfoProto>} valueInfo
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.valueInfo = $util.emptyArray;

        /**
         * GraphProto quantizationAnnotation.
         * @member {Array.<onnx.ITensorAnnotation>} quantizationAnnotation
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.quantizationAnnotation = $util.emptyArray;

        /**
         * Creates a new GraphProto instance using the specified properties.
         * @function create
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.IGraphProto=} [properties] Properties to set
         * @returns {onnx.GraphProto} GraphProto instance
         */
        GraphProto.create = function create(properties) {
            return new GraphProto(properties);
        };

        /**
         * Encodes the specified GraphProto message. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.node != null && message.node.length)
                for (var i = 0; i < message.node.length; ++i)
                    $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.initializer != null && message.initializer.length)
                for (var i = 0; i < message.initializer.length; ++i)
                    $root.onnx.TensorProto.encode(message.initializer[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.docString);
            if (message.input != null && message.input.length)
                for (var i = 0; i < message.input.length; ++i)
                    $root.onnx.ValueInfoProto.encode(message.input[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.output != null && message.output.length)
                for (var i = 0; i < message.output.length; ++i)
                    $root.onnx.ValueInfoProto.encode(message.output[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.valueInfo != null && message.valueInfo.length)
                for (var i = 0; i < message.valueInfo.length; ++i)
                    $root.onnx.ValueInfoProto.encode(message.valueInfo[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)
                for (var i = 0; i < message.quantizationAnnotation.length; ++i)
                    $root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphProto message, length delimited. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.GraphProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.GraphProto} GraphProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.node && message.node.length))
                        message.node = [];
                    message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 5:
                    if (!(message.initializer && message.initializer.length))
                        message.initializer = [];
                    message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.docString = reader.string();
                    break;
                case 11:
                    if (!(message.input && message.input.length))
                        message.input = [];
                    message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.output && message.output.length))
                        message.output = [];
                    message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.valueInfo && message.valueInfo.length))
                        message.valueInfo = [];
                    message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))
                        message.quantizationAnnotation = [];
                    message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.GraphProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.GraphProto} GraphProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphProto message.
         * @function verify
         * @memberof onnx.GraphProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
                if (!Array.isArray(message.node))
                    return "node: array expected";
                for (var i = 0; i < message.node.length; ++i) {
                    var error = $root.onnx.NodeProto.verify(message.node[i]);
                    if (error)
                        return "node." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.initializer != null && message.hasOwnProperty("initializer")) {
                if (!Array.isArray(message.initializer))
                    return "initializer: array expected";
                for (var i = 0; i < message.initializer.length; ++i) {
                    var error = $root.onnx.TensorProto.verify(message.initializer[i]);
                    if (error)
                        return "initializer." + error;
                }
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.input != null && message.hasOwnProperty("input")) {
                if (!Array.isArray(message.input))
                    return "input: array expected";
                for (var i = 0; i < message.input.length; ++i) {
                    var error = $root.onnx.ValueInfoProto.verify(message.input[i]);
                    if (error)
                        return "input." + error;
                }
            }
            if (message.output != null && message.hasOwnProperty("output")) {
                if (!Array.isArray(message.output))
                    return "output: array expected";
                for (var i = 0; i < message.output.length; ++i) {
                    var error = $root.onnx.ValueInfoProto.verify(message.output[i]);
                    if (error)
                        return "output." + error;
                }
            }
            if (message.valueInfo != null && message.hasOwnProperty("valueInfo")) {
                if (!Array.isArray(message.valueInfo))
                    return "valueInfo: array expected";
                for (var i = 0; i < message.valueInfo.length; ++i) {
                    var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);
                    if (error)
                        return "valueInfo." + error;
                }
            }
            if (message.quantizationAnnotation != null && message.hasOwnProperty("quantizationAnnotation")) {
                if (!Array.isArray(message.quantizationAnnotation))
                    return "quantizationAnnotation: array expected";
                for (var i = 0; i < message.quantizationAnnotation.length; ++i) {
                    var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);
                    if (error)
                        return "quantizationAnnotation." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.GraphProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.GraphProto} GraphProto
         */
        GraphProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.GraphProto)
                return object;
            var message = new $root.onnx.GraphProto();
            if (object.node) {
                if (!Array.isArray(object.node))
                    throw TypeError(".onnx.GraphProto.node: array expected");
                message.node = [];
                for (var i = 0; i < object.node.length; ++i) {
                    if (typeof object.node[i] !== "object")
                        throw TypeError(".onnx.GraphProto.node: object expected");
                    message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.initializer) {
                if (!Array.isArray(object.initializer))
                    throw TypeError(".onnx.GraphProto.initializer: array expected");
                message.initializer = [];
                for (var i = 0; i < object.initializer.length; ++i) {
                    if (typeof object.initializer[i] !== "object")
                        throw TypeError(".onnx.GraphProto.initializer: object expected");
                    message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);
                }
            }
            if (object.docString != null)
                message.docString = String(object.docString);
            if (object.input) {
                if (!Array.isArray(object.input))
                    throw TypeError(".onnx.GraphProto.input: array expected");
                message.input = [];
                for (var i = 0; i < object.input.length; ++i) {
                    if (typeof object.input[i] !== "object")
                        throw TypeError(".onnx.GraphProto.input: object expected");
                    message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);
                }
            }
            if (object.output) {
                if (!Array.isArray(object.output))
                    throw TypeError(".onnx.GraphProto.output: array expected");
                message.output = [];
                for (var i = 0; i < object.output.length; ++i) {
                    if (typeof object.output[i] !== "object")
                        throw TypeError(".onnx.GraphProto.output: object expected");
                    message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);
                }
            }
            if (object.valueInfo) {
                if (!Array.isArray(object.valueInfo))
                    throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                message.valueInfo = [];
                for (var i = 0; i < object.valueInfo.length; ++i) {
                    if (typeof object.valueInfo[i] !== "object")
                        throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                    message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);
                }
            }
            if (object.quantizationAnnotation) {
                if (!Array.isArray(object.quantizationAnnotation))
                    throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                message.quantizationAnnotation = [];
                for (var i = 0; i < object.quantizationAnnotation.length; ++i) {
                    if (typeof object.quantizationAnnotation[i] !== "object")
                        throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                    message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.GraphProto} message GraphProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.node = [];
                object.initializer = [];
                object.input = [];
                object.output = [];
                object.valueInfo = [];
                object.quantizationAnnotation = [];
            }
            if (options.defaults) {
                object.name = "";
                object.docString = "";
            }
            if (message.node && message.node.length) {
                object.node = [];
                for (var j = 0; j < message.node.length; ++j)
                    object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.initializer && message.initializer.length) {
                object.initializer = [];
                for (var j = 0; j < message.initializer.length; ++j)
                    object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.input && message.input.length) {
                object.input = [];
                for (var j = 0; j < message.input.length; ++j)
                    object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);
            }
            if (message.output && message.output.length) {
                object.output = [];
                for (var j = 0; j < message.output.length; ++j)
                    object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);
            }
            if (message.valueInfo && message.valueInfo.length) {
                object.valueInfo = [];
                for (var j = 0; j < message.valueInfo.length; ++j)
                    object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);
            }
            if (message.quantizationAnnotation && message.quantizationAnnotation.length) {
                object.quantizationAnnotation = [];
                for (var j = 0; j < message.quantizationAnnotation.length; ++j)
                    object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphProto to JSON.
         * @function toJSON
         * @memberof onnx.GraphProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphProto;
    })();

    onnx.TensorProto = (function() {

        /**
         * Properties of a TensorProto.
         * @memberof onnx
         * @interface ITensorProto
         * @property {Array.<number|Long>|null} [dims] TensorProto dims
         * @property {number|null} [dataType] TensorProto dataType
         * @property {onnx.TensorProto.ISegment|null} [segment] TensorProto segment
         * @property {Array.<number>|null} [floatData] TensorProto floatData
         * @property {Array.<number>|null} [int32Data] TensorProto int32Data
         * @property {Array.<Uint8Array>|null} [stringData] TensorProto stringData
         * @property {Array.<number|Long>|null} [int64Data] TensorProto int64Data
         * @property {string|null} [name] TensorProto name
         * @property {string|null} [docString] TensorProto docString
         * @property {Uint8Array|null} [rawData] TensorProto rawData
         * @property {Array.<onnx.IStringStringEntryProto>|null} [externalData] TensorProto externalData
         * @property {onnx.TensorProto.DataLocation|null} [dataLocation] TensorProto dataLocation
         * @property {Array.<number>|null} [doubleData] TensorProto doubleData
         * @property {Array.<number|Long>|null} [uint64Data] TensorProto uint64Data
         */

        /**
         * Constructs a new TensorProto.
         * @memberof onnx
         * @classdesc Represents a TensorProto.
         * @implements ITensorProto
         * @constructor
         * @param {onnx.ITensorProto=} [properties] Properties to set
         */
        function TensorProto(properties) {
            this.dims = [];
            this.floatData = [];
            this.int32Data = [];
            this.stringData = [];
            this.int64Data = [];
            this.externalData = [];
            this.doubleData = [];
            this.uint64Data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorProto dims.
         * @member {Array.<number|Long>} dims
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.dims = $util.emptyArray;

        /**
         * TensorProto dataType.
         * @member {number} dataType
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.dataType = 0;

        /**
         * TensorProto segment.
         * @member {onnx.TensorProto.ISegment|null|undefined} segment
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.segment = null;

        /**
         * TensorProto floatData.
         * @member {Array.<number>} floatData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.floatData = $util.emptyArray;

        /**
         * TensorProto int32Data.
         * @member {Array.<number>} int32Data
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.int32Data = $util.emptyArray;

        /**
         * TensorProto stringData.
         * @member {Array.<Uint8Array>} stringData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.stringData = $util.emptyArray;

        /**
         * TensorProto int64Data.
         * @member {Array.<number|Long>} int64Data
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.int64Data = $util.emptyArray;

        /**
         * TensorProto name.
         * @member {string} name
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.name = "";

        /**
         * TensorProto docString.
         * @member {string} docString
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.docString = "";

        /**
         * TensorProto rawData.
         * @member {Uint8Array} rawData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.rawData = $util.newBuffer([]);

        /**
         * TensorProto externalData.
         * @member {Array.<onnx.IStringStringEntryProto>} externalData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.externalData = $util.emptyArray;

        /**
         * TensorProto dataLocation.
         * @member {onnx.TensorProto.DataLocation} dataLocation
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.dataLocation = 0;

        /**
         * TensorProto doubleData.
         * @member {Array.<number>} doubleData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.doubleData = $util.emptyArray;

        /**
         * TensorProto uint64Data.
         * @member {Array.<number|Long>} uint64Data
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.uint64Data = $util.emptyArray;

        /**
         * Creates a new TensorProto instance using the specified properties.
         * @function create
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.ITensorProto=} [properties] Properties to set
         * @returns {onnx.TensorProto} TensorProto instance
         */
        TensorProto.create = function create(properties) {
            return new TensorProto(properties);
        };

        /**
         * Encodes the specified TensorProto message. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dims != null && message.dims.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.dims.length; ++i)
                    writer.int64(message.dims[i]);
                writer.ldelim();
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dataType);
            if (message.segment != null && message.hasOwnProperty("segment"))
                $root.onnx.TensorProto.Segment.encode(message.segment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.floatData != null && message.floatData.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.floatData.length; ++i)
                    writer.float(message.floatData[i]);
                writer.ldelim();
            }
            if (message.int32Data != null && message.int32Data.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.int32Data.length; ++i)
                    writer.int32(message.int32Data[i]);
                writer.ldelim();
            }
            if (message.stringData != null && message.stringData.length)
                for (var i = 0; i < message.stringData.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.stringData[i]);
            if (message.int64Data != null && message.int64Data.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.int64Data.length; ++i)
                    writer.int64(message.int64Data[i]);
                writer.ldelim();
            }
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.rawData);
            if (message.doubleData != null && message.doubleData.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (var i = 0; i < message.doubleData.length; ++i)
                    writer.double(message.doubleData[i]);
                writer.ldelim();
            }
            if (message.uint64Data != null && message.uint64Data.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (var i = 0; i < message.uint64Data.length; ++i)
                    writer.uint64(message.uint64Data[i]);
                writer.ldelim();
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.docString);
            if (message.externalData != null && message.externalData.length)
                for (var i = 0; i < message.externalData.length; ++i)
                    $root.onnx.StringStringEntryProto.encode(message.externalData[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.dataLocation);
            return writer;
        };

        /**
         * Encodes the specified TensorProto message, length delimited. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TensorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TensorProto} TensorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dims && message.dims.length))
                        message.dims = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dims.push(reader.int64());
                    } else
                        message.dims.push(reader.int64());
                    break;
                case 2:
                    message.dataType = reader.int32();
                    break;
                case 3:
                    message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.floatData && message.floatData.length))
                        message.floatData = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.floatData.push(reader.float());
                    } else
                        message.floatData.push(reader.float());
                    break;
                case 5:
                    if (!(message.int32Data && message.int32Data.length))
                        message.int32Data = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.int32Data.push(reader.int32());
                    } else
                        message.int32Data.push(reader.int32());
                    break;
                case 6:
                    if (!(message.stringData && message.stringData.length))
                        message.stringData = [];
                    message.stringData.push(reader.bytes());
                    break;
                case 7:
                    if (!(message.int64Data && message.int64Data.length))
                        message.int64Data = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.int64Data.push(reader.int64());
                    } else
                        message.int64Data.push(reader.int64());
                    break;
                case 8:
                    message.name = reader.string();
                    break;
                case 12:
                    message.docString = reader.string();
                    break;
                case 9:
                    message.rawData = reader.bytes();
                    break;
                case 13:
                    if (!(message.externalData && message.externalData.length))
                        message.externalData = [];
                    message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.dataLocation = reader.int32();
                    break;
                case 10:
                    if (!(message.doubleData && message.doubleData.length))
                        message.doubleData = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.doubleData.push(reader.double());
                    } else
                        message.doubleData.push(reader.double());
                    break;
                case 11:
                    if (!(message.uint64Data && message.uint64Data.length))
                        message.uint64Data = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.uint64Data.push(reader.uint64());
                    } else
                        message.uint64Data.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TensorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TensorProto} TensorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorProto message.
         * @function verify
         * @memberof onnx.TensorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dims != null && message.hasOwnProperty("dims")) {
                if (!Array.isArray(message.dims))
                    return "dims: array expected";
                for (var i = 0; i < message.dims.length; ++i)
                    if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                        return "dims: integer|Long[] expected";
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
                if (!$util.isInteger(message.dataType))
                    return "dataType: integer expected";
            if (message.segment != null && message.hasOwnProperty("segment")) {
                var error = $root.onnx.TensorProto.Segment.verify(message.segment);
                if (error)
                    return "segment." + error;
            }
            if (message.floatData != null && message.hasOwnProperty("floatData")) {
                if (!Array.isArray(message.floatData))
                    return "floatData: array expected";
                for (var i = 0; i < message.floatData.length; ++i)
                    if (typeof message.floatData[i] !== "number")
                        return "floatData: number[] expected";
            }
            if (message.int32Data != null && message.hasOwnProperty("int32Data")) {
                if (!Array.isArray(message.int32Data))
                    return "int32Data: array expected";
                for (var i = 0; i < message.int32Data.length; ++i)
                    if (!$util.isInteger(message.int32Data[i]))
                        return "int32Data: integer[] expected";
            }
            if (message.stringData != null && message.hasOwnProperty("stringData")) {
                if (!Array.isArray(message.stringData))
                    return "stringData: array expected";
                for (var i = 0; i < message.stringData.length; ++i)
                    if (!(message.stringData[i] && typeof message.stringData[i].length === "number" || $util.isString(message.stringData[i])))
                        return "stringData: buffer[] expected";
            }
            if (message.int64Data != null && message.hasOwnProperty("int64Data")) {
                if (!Array.isArray(message.int64Data))
                    return "int64Data: array expected";
                for (var i = 0; i < message.int64Data.length; ++i)
                    if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))
                        return "int64Data: integer|Long[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
                    return "rawData: buffer expected";
            if (message.externalData != null && message.hasOwnProperty("externalData")) {
                if (!Array.isArray(message.externalData))
                    return "externalData: array expected";
                for (var i = 0; i < message.externalData.length; ++i) {
                    var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);
                    if (error)
                        return "externalData." + error;
                }
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
                switch (message.dataLocation) {
                default:
                    return "dataLocation: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.doubleData != null && message.hasOwnProperty("doubleData")) {
                if (!Array.isArray(message.doubleData))
                    return "doubleData: array expected";
                for (var i = 0; i < message.doubleData.length; ++i)
                    if (typeof message.doubleData[i] !== "number")
                        return "doubleData: number[] expected";
            }
            if (message.uint64Data != null && message.hasOwnProperty("uint64Data")) {
                if (!Array.isArray(message.uint64Data))
                    return "uint64Data: array expected";
                for (var i = 0; i < message.uint64Data.length; ++i)
                    if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))
                        return "uint64Data: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a TensorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TensorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TensorProto} TensorProto
         */
        TensorProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorProto)
                return object;
            var message = new $root.onnx.TensorProto();
            if (object.dims) {
                if (!Array.isArray(object.dims))
                    throw TypeError(".onnx.TensorProto.dims: array expected");
                message.dims = [];
                for (var i = 0; i < object.dims.length; ++i)
                    if ($util.Long)
                        (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
                    else if (typeof object.dims[i] === "string")
                        message.dims[i] = parseInt(object.dims[i], 10);
                    else if (typeof object.dims[i] === "number")
                        message.dims[i] = object.dims[i];
                    else if (typeof object.dims[i] === "object")
                        message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
            }
            if (object.dataType != null)
                message.dataType = object.dataType | 0;
            if (object.segment != null) {
                if (typeof object.segment !== "object")
                    throw TypeError(".onnx.TensorProto.segment: object expected");
                message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);
            }
            if (object.floatData) {
                if (!Array.isArray(object.floatData))
                    throw TypeError(".onnx.TensorProto.floatData: array expected");
                message.floatData = [];
                for (var i = 0; i < object.floatData.length; ++i)
                    message.floatData[i] = Number(object.floatData[i]);
            }
            if (object.int32Data) {
                if (!Array.isArray(object.int32Data))
                    throw TypeError(".onnx.TensorProto.int32Data: array expected");
                message.int32Data = [];
                for (var i = 0; i < object.int32Data.length; ++i)
                    message.int32Data[i] = object.int32Data[i] | 0;
            }
            if (object.stringData) {
                if (!Array.isArray(object.stringData))
                    throw TypeError(".onnx.TensorProto.stringData: array expected");
                message.stringData = [];
                for (var i = 0; i < object.stringData.length; ++i)
                    if (typeof object.stringData[i] === "string")
                        $util.base64.decode(object.stringData[i], message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])), 0);
                    else if (object.stringData[i].length)
                        message.stringData[i] = object.stringData[i];
            }
            if (object.int64Data) {
                if (!Array.isArray(object.int64Data))
                    throw TypeError(".onnx.TensorProto.int64Data: array expected");
                message.int64Data = [];
                for (var i = 0; i < object.int64Data.length; ++i)
                    if ($util.Long)
                        (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;
                    else if (typeof object.int64Data[i] === "string")
                        message.int64Data[i] = parseInt(object.int64Data[i], 10);
                    else if (typeof object.int64Data[i] === "number")
                        message.int64Data[i] = object.int64Data[i];
                    else if (typeof object.int64Data[i] === "object")
                        message.int64Data[i] = new $util.LongBits(object.int64Data[i].low >>> 0, object.int64Data[i].high >>> 0).toNumber();
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.docString != null)
                message.docString = String(object.docString);
            if (object.rawData != null)
                if (typeof object.rawData === "string")
                    $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);
                else if (object.rawData.length)
                    message.rawData = object.rawData;
            if (object.externalData) {
                if (!Array.isArray(object.externalData))
                    throw TypeError(".onnx.TensorProto.externalData: array expected");
                message.externalData = [];
                for (var i = 0; i < object.externalData.length; ++i) {
                    if (typeof object.externalData[i] !== "object")
                        throw TypeError(".onnx.TensorProto.externalData: object expected");
                    message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);
                }
            }
            switch (object.dataLocation) {
            case "DEFAULT":
            case 0:
                message.dataLocation = 0;
                break;
            case "EXTERNAL":
            case 1:
                message.dataLocation = 1;
                break;
            }
            if (object.doubleData) {
                if (!Array.isArray(object.doubleData))
                    throw TypeError(".onnx.TensorProto.doubleData: array expected");
                message.doubleData = [];
                for (var i = 0; i < object.doubleData.length; ++i)
                    message.doubleData[i] = Number(object.doubleData[i]);
            }
            if (object.uint64Data) {
                if (!Array.isArray(object.uint64Data))
                    throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                message.uint64Data = [];
                for (var i = 0; i < object.uint64Data.length; ++i)
                    if ($util.Long)
                        (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;
                    else if (typeof object.uint64Data[i] === "string")
                        message.uint64Data[i] = parseInt(object.uint64Data[i], 10);
                    else if (typeof object.uint64Data[i] === "number")
                        message.uint64Data[i] = object.uint64Data[i];
                    else if (typeof object.uint64Data[i] === "object")
                        message.uint64Data[i] = new $util.LongBits(object.uint64Data[i].low >>> 0, object.uint64Data[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.TensorProto} message TensorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.dims = [];
                object.floatData = [];
                object.int32Data = [];
                object.stringData = [];
                object.int64Data = [];
                object.doubleData = [];
                object.uint64Data = [];
                object.externalData = [];
            }
            if (options.defaults) {
                object.dataType = 0;
                object.segment = null;
                object.name = "";
                if (options.bytes === String)
                    object.rawData = "";
                else {
                    object.rawData = [];
                    if (options.bytes !== Array)
                        object.rawData = $util.newBuffer(object.rawData);
                }
                object.docString = "";
                object.dataLocation = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.dims && message.dims.length) {
                object.dims = [];
                for (var j = 0; j < message.dims.length; ++j)
                    if (typeof message.dims[j] === "number")
                        object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
                    else
                        object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
                object.dataType = message.dataType;
            if (message.segment != null && message.hasOwnProperty("segment"))
                object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);
            if (message.floatData && message.floatData.length) {
                object.floatData = [];
                for (var j = 0; j < message.floatData.length; ++j)
                    object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];
            }
            if (message.int32Data && message.int32Data.length) {
                object.int32Data = [];
                for (var j = 0; j < message.int32Data.length; ++j)
                    object.int32Data[j] = message.int32Data[j];
            }
            if (message.stringData && message.stringData.length) {
                object.stringData = [];
                for (var j = 0; j < message.stringData.length; ++j)
                    object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];
            }
            if (message.int64Data && message.int64Data.length) {
                object.int64Data = [];
                for (var j = 0; j < message.int64Data.length; ++j)
                    if (typeof message.int64Data[j] === "number")
                        object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];
                    else
                        object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
            if (message.doubleData && message.doubleData.length) {
                object.doubleData = [];
                for (var j = 0; j < message.doubleData.length; ++j)
                    object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];
            }
            if (message.uint64Data && message.uint64Data.length) {
                object.uint64Data = [];
                for (var j = 0; j < message.uint64Data.length; ++j)
                    if (typeof message.uint64Data[j] === "number")
                        object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];
                    else
                        object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.externalData && message.externalData.length) {
                object.externalData = [];
                for (var j = 0; j < message.externalData.length; ++j)
                    object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
                object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;
            return object;
        };

        /**
         * Converts this TensorProto to JSON.
         * @function toJSON
         * @memberof onnx.TensorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * DataType enum.
         * @name onnx.TensorProto.DataType
         * @enum {string}
         * @property {number} UNDEFINED=0 UNDEFINED value
         * @property {number} FLOAT=1 FLOAT value
         * @property {number} UINT8=2 UINT8 value
         * @property {number} INT8=3 INT8 value
         * @property {number} UINT16=4 UINT16 value
         * @property {number} INT16=5 INT16 value
         * @property {number} INT32=6 INT32 value
         * @property {number} INT64=7 INT64 value
         * @property {number} STRING=8 STRING value
         * @property {number} BOOL=9 BOOL value
         * @property {number} FLOAT16=10 FLOAT16 value
         * @property {number} DOUBLE=11 DOUBLE value
         * @property {number} UINT32=12 UINT32 value
         * @property {number} UINT64=13 UINT64 value
         * @property {number} COMPLEX64=14 COMPLEX64 value
         * @property {number} COMPLEX128=15 COMPLEX128 value
         * @property {number} BFLOAT16=16 BFLOAT16 value
         */
        TensorProto.DataType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "UINT8"] = 2;
            values[valuesById[3] = "INT8"] = 3;
            values[valuesById[4] = "UINT16"] = 4;
            values[valuesById[5] = "INT16"] = 5;
            values[valuesById[6] = "INT32"] = 6;
            values[valuesById[7] = "INT64"] = 7;
            values[valuesById[8] = "STRING"] = 8;
            values[valuesById[9] = "BOOL"] = 9;
            values[valuesById[10] = "FLOAT16"] = 10;
            values[valuesById[11] = "DOUBLE"] = 11;
            values[valuesById[12] = "UINT32"] = 12;
            values[valuesById[13] = "UINT64"] = 13;
            values[valuesById[14] = "COMPLEX64"] = 14;
            values[valuesById[15] = "COMPLEX128"] = 15;
            values[valuesById[16] = "BFLOAT16"] = 16;
            return values;
        })();

        TensorProto.Segment = (function() {

            /**
             * Properties of a Segment.
             * @memberof onnx.TensorProto
             * @interface ISegment
             * @property {number|Long|null} [begin] Segment begin
             * @property {number|Long|null} [end] Segment end
             */

            /**
             * Constructs a new Segment.
             * @memberof onnx.TensorProto
             * @classdesc Represents a Segment.
             * @implements ISegment
             * @constructor
             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set
             */
            function Segment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Segment begin.
             * @member {number|Long} begin
             * @memberof onnx.TensorProto.Segment
             * @instance
             */
            Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Segment end.
             * @member {number|Long} end
             * @memberof onnx.TensorProto.Segment
             * @instance
             */
            Segment.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Segment instance using the specified properties.
             * @function create
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set
             * @returns {onnx.TensorProto.Segment} Segment instance
             */
            Segment.create = function create(properties) {
                return new Segment(properties);
            };

            /**
             * Encodes the specified Segment message. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.
             * @function encode
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Segment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.begin != null && message.hasOwnProperty("begin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.begin);
                if (message.end != null && message.hasOwnProperty("end"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end);
                return writer;
            };

            /**
             * Encodes the specified Segment message, length delimited. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Segment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Segment message from the specified reader or buffer.
             * @function decode
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {onnx.TensorProto.Segment} Segment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Segment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.begin = reader.int64();
                        break;
                    case 2:
                        message.end = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Segment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {onnx.TensorProto.Segment} Segment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Segment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Segment message.
             * @function verify
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Segment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.begin != null && message.hasOwnProperty("begin"))
                    if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))
                        return "begin: integer|Long expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                        return "end: integer|Long expected";
                return null;
            };

            /**
             * Creates a Segment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {onnx.TensorProto.Segment} Segment
             */
            Segment.fromObject = function fromObject(object) {
                if (object instanceof $root.onnx.TensorProto.Segment)
                    return object;
                var message = new $root.onnx.TensorProto.Segment();
                if (object.begin != null)
                    if ($util.Long)
                        (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;
                    else if (typeof object.begin === "string")
                        message.begin = parseInt(object.begin, 10);
                    else if (typeof object.begin === "number")
                        message.begin = object.begin;
                    else if (typeof object.begin === "object")
                        message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();
                if (object.end != null)
                    if ($util.Long)
                        (message.end = $util.Long.fromValue(object.end)).unsigned = false;
                    else if (typeof object.end === "string")
                        message.end = parseInt(object.end, 10);
                    else if (typeof object.end === "number")
                        message.end = object.end;
                    else if (typeof object.end === "object")
                        message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Segment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.Segment} message Segment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Segment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.begin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.end = options.longs === String ? "0" : 0;
                }
                if (message.begin != null && message.hasOwnProperty("begin"))
                    if (typeof message.begin === "number")
                        object.begin = options.longs === String ? String(message.begin) : message.begin;
                    else
                        object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;
                if (message.end != null && message.hasOwnProperty("end"))
                    if (typeof message.end === "number")
                        object.end = options.longs === String ? String(message.end) : message.end;
                    else
                        object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
                return object;
            };

            /**
             * Converts this Segment to JSON.
             * @function toJSON
             * @memberof onnx.TensorProto.Segment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Segment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Segment;
        })();

        /**
         * DataLocation enum.
         * @name onnx.TensorProto.DataLocation
         * @enum {string}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} EXTERNAL=1 EXTERNAL value
         */
        TensorProto.DataLocation = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "EXTERNAL"] = 1;
            return values;
        })();

        return TensorProto;
    })();

    onnx.TensorShapeProto = (function() {

        /**
         * Properties of a TensorShapeProto.
         * @memberof onnx
         * @interface ITensorShapeProto
         * @property {Array.<onnx.TensorShapeProto.IDimension>|null} [dim] TensorShapeProto dim
         */

        /**
         * Constructs a new TensorShapeProto.
         * @memberof onnx
         * @classdesc Represents a TensorShapeProto.
         * @implements ITensorShapeProto
         * @constructor
         * @param {onnx.ITensorShapeProto=} [properties] Properties to set
         */
        function TensorShapeProto(properties) {
            this.dim = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorShapeProto dim.
         * @member {Array.<onnx.TensorShapeProto.IDimension>} dim
         * @memberof onnx.TensorShapeProto
         * @instance
         */
        TensorShapeProto.prototype.dim = $util.emptyArray;

        /**
         * Creates a new TensorShapeProto instance using the specified properties.
         * @function create
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.ITensorShapeProto=} [properties] Properties to set
         * @returns {onnx.TensorShapeProto} TensorShapeProto instance
         */
        TensorShapeProto.create = function create(properties) {
            return new TensorShapeProto(properties);
        };

        /**
         * Encodes the specified TensorShapeProto message. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorShapeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dim != null && message.dim.length)
                for (var i = 0; i < message.dim.length; ++i)
                    $root.onnx.TensorShapeProto.Dimension.encode(message.dim[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TensorShapeProto message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorShapeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TensorShapeProto} TensorShapeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorShapeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dim && message.dim.length))
                        message.dim = [];
                    message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorShapeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TensorShapeProto} TensorShapeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorShapeProto message.
         * @function verify
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorShapeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dim != null && message.hasOwnProperty("dim")) {
                if (!Array.isArray(message.dim))
                    return "dim: array expected";
                for (var i = 0; i < message.dim.length; ++i) {
                    var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);
                    if (error)
                        return "dim." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TensorShapeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TensorShapeProto} TensorShapeProto
         */
        TensorShapeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorShapeProto)
                return object;
            var message = new $root.onnx.TensorShapeProto();
            if (object.dim) {
                if (!Array.isArray(object.dim))
                    throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                message.dim = [];
                for (var i = 0; i < object.dim.length; ++i) {
                    if (typeof object.dim[i] !== "object")
                        throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                    message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorShapeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.TensorShapeProto} message TensorShapeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorShapeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dim = [];
            if (message.dim && message.dim.length) {
                object.dim = [];
                for (var j = 0; j < message.dim.length; ++j)
                    object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);
            }
            return object;
        };

        /**
         * Converts this TensorShapeProto to JSON.
         * @function toJSON
         * @memberof onnx.TensorShapeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorShapeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TensorShapeProto.Dimension = (function() {

            /**
             * Properties of a Dimension.
             * @memberof onnx.TensorShapeProto
             * @interface IDimension
             * @property {number|Long|null} [dimValue] Dimension dimValue
             * @property {string|null} [dimParam] Dimension dimParam
             * @property {string|null} [denotation] Dimension denotation
             */

            /**
             * Constructs a new Dimension.
             * @memberof onnx.TensorShapeProto
             * @classdesc Represents a Dimension.
             * @implements IDimension
             * @constructor
             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set
             */
            function Dimension(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Dimension dimValue.
             * @member {number|Long} dimValue
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Dimension.prototype.dimValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Dimension dimParam.
             * @member {string} dimParam
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Dimension.prototype.dimParam = "";

            /**
             * Dimension denotation.
             * @member {string} denotation
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Dimension.prototype.denotation = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Dimension value.
             * @member {"dimValue"|"dimParam"|undefined} value
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Object.defineProperty(Dimension.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["dimValue", "dimParam"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Dimension instance using the specified properties.
             * @function create
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set
             * @returns {onnx.TensorShapeProto.Dimension} Dimension instance
             */
            Dimension.create = function create(properties) {
                return new Dimension(properties);
            };

            /**
             * Encodes the specified Dimension message. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.
             * @function encode
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dimension.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dimValue != null && message.hasOwnProperty("dimValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.dimValue);
                if (message.dimParam != null && message.hasOwnProperty("dimParam"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dimParam);
                if (message.denotation != null && message.hasOwnProperty("denotation"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.denotation);
                return writer;
            };

            /**
             * Encodes the specified Dimension message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.
             * @function encodeDelimited
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dimension.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Dimension message from the specified reader or buffer.
             * @function decode
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {onnx.TensorShapeProto.Dimension} Dimension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dimension.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dimValue = reader.int64();
                        break;
                    case 2:
                        message.dimParam = reader.string();
                        break;
                    case 3:
                        message.denotation = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Dimension message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {onnx.TensorShapeProto.Dimension} Dimension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dimension.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Dimension message.
             * @function verify
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Dimension.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                    properties.value = 1;
                    if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))
                        return "dimValue: integer|Long expected";
                }
                if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isString(message.dimParam))
                        return "dimParam: string expected";
                }
                if (message.denotation != null && message.hasOwnProperty("denotation"))
                    if (!$util.isString(message.denotation))
                        return "denotation: string expected";
                return null;
            };

            /**
             * Creates a Dimension message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {onnx.TensorShapeProto.Dimension} Dimension
             */
            Dimension.fromObject = function fromObject(object) {
                if (object instanceof $root.onnx.TensorShapeProto.Dimension)
                    return object;
                var message = new $root.onnx.TensorShapeProto.Dimension();
                if (object.dimValue != null)
                    if ($util.Long)
                        (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;
                    else if (typeof object.dimValue === "string")
                        message.dimValue = parseInt(object.dimValue, 10);
                    else if (typeof object.dimValue === "number")
                        message.dimValue = object.dimValue;
                    else if (typeof object.dimValue === "object")
                        message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();
                if (object.dimParam != null)
                    message.dimParam = String(object.dimParam);
                if (object.denotation != null)
                    message.denotation = String(object.denotation);
                return message;
            };

            /**
             * Creates a plain object from a Dimension message. Also converts values to other types if specified.
             * @function toObject
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.Dimension} message Dimension
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Dimension.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.denotation = "";
                if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                    if (typeof message.dimValue === "number")
                        object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;
                    else
                        object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;
                    if (options.oneofs)
                        object.value = "dimValue";
                }
                if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                    object.dimParam = message.dimParam;
                    if (options.oneofs)
                        object.value = "dimParam";
                }
                if (message.denotation != null && message.hasOwnProperty("denotation"))
                    object.denotation = message.denotation;
                return object;
            };

            /**
             * Converts this Dimension to JSON.
             * @function toJSON
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Dimension.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Dimension;
        })();

        return TensorShapeProto;
    })();

    onnx.TypeProto = (function() {

        /**
         * Properties of a TypeProto.
         * @memberof onnx
         * @interface ITypeProto
         * @property {onnx.TypeProto.ITensor|null} [tensorType] TypeProto tensorType
         * @property {string|null} [denotation] TypeProto denotation
         */

        /**
         * Constructs a new TypeProto.
         * @memberof onnx
         * @classdesc Represents a TypeProto.
         * @implements ITypeProto
         * @constructor
         * @param {onnx.ITypeProto=} [properties] Properties to set
         */
        function TypeProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TypeProto tensorType.
         * @member {onnx.TypeProto.ITensor|null|undefined} tensorType
         * @memberof onnx.TypeProto
         * @instance
         */
        TypeProto.prototype.tensorType = null;

        /**
         * TypeProto denotation.
         * @member {string} denotation
         * @memberof onnx.TypeProto
         * @instance
         */
        TypeProto.prototype.denotation = "";

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TypeProto value.
         * @member {"tensorType"|undefined} value
         * @memberof onnx.TypeProto
         * @instance
         */
        Object.defineProperty(TypeProto.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["tensorType"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TypeProto instance using the specified properties.
         * @function create
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.ITypeProto=} [properties] Properties to set
         * @returns {onnx.TypeProto} TypeProto instance
         */
        TypeProto.create = function create(properties) {
            return new TypeProto(properties);
        };

        /**
         * Encodes the specified TypeProto message. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tensorType != null && message.hasOwnProperty("tensorType"))
                $root.onnx.TypeProto.Tensor.encode(message.tensorType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.denotation != null && message.hasOwnProperty("denotation"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.denotation);
            return writer;
        };

        /**
         * Encodes the specified TypeProto message, length delimited. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TypeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TypeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TypeProto} TypeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.denotation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TypeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TypeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TypeProto} TypeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TypeProto message.
         * @function verify
         * @memberof onnx.TypeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TypeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
                properties.value = 1;
                {
                    var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);
                    if (error)
                        return "tensorType." + error;
                }
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
                if (!$util.isString(message.denotation))
                    return "denotation: string expected";
            return null;
        };

        /**
         * Creates a TypeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TypeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TypeProto} TypeProto
         */
        TypeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto)
                return object;
            var message = new $root.onnx.TypeProto();
            if (object.tensorType != null) {
                if (typeof object.tensorType !== "object")
                    throw TypeError(".onnx.TypeProto.tensorType: object expected");
                message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);
            }
            if (object.denotation != null)
                message.denotation = String(object.denotation);
            return message;
        };

        /**
         * Creates a plain object from a TypeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.TypeProto} message TypeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TypeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.denotation = "";
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
                object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);
                if (options.oneofs)
                    object.value = "tensorType";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
                object.denotation = message.denotation;
            return object;
        };

        /**
         * Converts this TypeProto to JSON.
         * @function toJSON
         * @memberof onnx.TypeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TypeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TypeProto.Tensor = (function() {

            /**
             * Properties of a Tensor.
             * @memberof onnx.TypeProto
             * @interface ITensor
             * @property {number|null} [elemType] Tensor elemType
             * @property {onnx.ITensorShapeProto|null} [shape] Tensor shape
             */

            /**
             * Constructs a new Tensor.
             * @memberof onnx.TypeProto
             * @classdesc Represents a Tensor.
             * @implements ITensor
             * @constructor
             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set
             */
            function Tensor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Tensor elemType.
             * @member {number} elemType
             * @memberof onnx.TypeProto.Tensor
             * @instance
             */
            Tensor.prototype.elemType = 0;

            /**
             * Tensor shape.
             * @member {onnx.ITensorShapeProto|null|undefined} shape
             * @memberof onnx.TypeProto.Tensor
             * @instance
             */
            Tensor.prototype.shape = null;

            /**
             * Creates a new Tensor instance using the specified properties.
             * @function create
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set
             * @returns {onnx.TypeProto.Tensor} Tensor instance
             */
            Tensor.create = function create(properties) {
                return new Tensor(properties);
            };

            /**
             * Encodes the specified Tensor message. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.
             * @function encode
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tensor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elemType != null && message.hasOwnProperty("elemType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemType);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Tensor message, length delimited. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tensor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Tensor message from the specified reader or buffer.
             * @function decode
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {onnx.TypeProto.Tensor} Tensor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tensor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.elemType = reader.int32();
                        break;
                    case 2:
                        message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Tensor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {onnx.TypeProto.Tensor} Tensor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tensor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Tensor message.
             * @function verify
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Tensor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elemType != null && message.hasOwnProperty("elemType"))
                    if (!$util.isInteger(message.elemType))
                        return "elemType: integer expected";
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.onnx.TensorShapeProto.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                return null;
            };

            /**
             * Creates a Tensor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {onnx.TypeProto.Tensor} Tensor
             */
            Tensor.fromObject = function fromObject(object) {
                if (object instanceof $root.onnx.TypeProto.Tensor)
                    return object;
                var message = new $root.onnx.TypeProto.Tensor();
                if (object.elemType != null)
                    message.elemType = object.elemType | 0;
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                    message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
                }
                return message;
            };

            /**
             * Creates a plain object from a Tensor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.Tensor} message Tensor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tensor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.elemType = 0;
                    object.shape = null;
                }
                if (message.elemType != null && message.hasOwnProperty("elemType"))
                    object.elemType = message.elemType;
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
                return object;
            };

            /**
             * Converts this Tensor to JSON.
             * @function toJSON
             * @memberof onnx.TypeProto.Tensor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Tensor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Tensor;
        })();

        return TypeProto;
    })();

    onnx.OperatorSetIdProto = (function() {

        /**
         * Properties of an OperatorSetIdProto.
         * @memberof onnx
         * @interface IOperatorSetIdProto
         * @property {string|null} [domain] OperatorSetIdProto domain
         * @property {number|Long|null} [version] OperatorSetIdProto version
         */

        /**
         * Constructs a new OperatorSetIdProto.
         * @memberof onnx
         * @classdesc Represents an OperatorSetIdProto.
         * @implements IOperatorSetIdProto
         * @constructor
         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set
         */
        function OperatorSetIdProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OperatorSetIdProto domain.
         * @member {string} domain
         * @memberof onnx.OperatorSetIdProto
         * @instance
         */
        OperatorSetIdProto.prototype.domain = "";

        /**
         * OperatorSetIdProto version.
         * @member {number|Long} version
         * @memberof onnx.OperatorSetIdProto
         * @instance
         */
        OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new OperatorSetIdProto instance using the specified properties.
         * @function create
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto instance
         */
        OperatorSetIdProto.create = function create(properties) {
            return new OperatorSetIdProto(properties);
        };

        /**
         * Encodes the specified OperatorSetIdProto message. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OperatorSetIdProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.version);
            return writer;
        };

        /**
         * Encodes the specified OperatorSetIdProto message, length delimited. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OperatorSetIdProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OperatorSetIdProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.domain = reader.string();
                    break;
                case 2:
                    message.version = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OperatorSetIdProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OperatorSetIdProto message.
         * @function verify
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OperatorSetIdProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                    return "version: integer|Long expected";
            return null;
        };

        /**
         * Creates an OperatorSetIdProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto
         */
        OperatorSetIdProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.OperatorSetIdProto)
                return object;
            var message = new $root.onnx.OperatorSetIdProto();
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an OperatorSetIdProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.OperatorSetIdProto} message OperatorSetIdProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OperatorSetIdProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.domain = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            return object;
        };

        /**
         * Converts this OperatorSetIdProto to JSON.
         * @function toJSON
         * @memberof onnx.OperatorSetIdProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OperatorSetIdProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OperatorSetIdProto;
    })();

    return onnx;
})();

module.exports = $root;


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ (function(module) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof __webpack_require__.g !== "undefined"
                   && __webpack_require__.g
                   && __webpack_require__.g.process
                   && __webpack_require__.g.process.versions
                   && __webpack_require__.g.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && __webpack_require__.g
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./lib/backend-onnxjs.ts":
/*!*******************************!*\
  !*** ./lib/backend-onnxjs.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onnxjsBackend = void 0;
var session_1 = __webpack_require__(/*! ./onnxjs/session */ "./lib/onnxjs/session.ts");
var session_handler_1 = __webpack_require__(/*! ./onnxjs/session-handler */ "./lib/onnxjs/session-handler.ts");
var OnnxjsBackend = /** @class */ (function () {
    function OnnxjsBackend() {
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    OnnxjsBackend.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    OnnxjsBackend.prototype.createSessionHandler = function (pathOrBuffer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var session;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        session = new session_1.Session(options);
                        if (!(typeof pathOrBuffer === 'string')) return [3 /*break*/, 2];
                        return [4 /*yield*/, session.loadModel(pathOrBuffer)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, session.loadModel(pathOrBuffer)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/, new session_handler_1.OnnxjsSessionHandler(session)];
                }
            });
        });
    };
    return OnnxjsBackend;
}());
exports.onnxjsBackend = new OnnxjsBackend();


/***/ }),

/***/ "./lib/backend-wasm.ts":
/*!*****************************!*\
  !*** ./lib/backend-wasm.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wasmBackend = exports.initializeFlags = void 0;
var fs_1 = __webpack_require__(/*! fs */ "?d87b");
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var os_1 = __webpack_require__(/*! os */ "?0757");
var util_1 = __webpack_require__(/*! util */ "?334c");
var session_handler_1 = __webpack_require__(/*! ./wasm/session-handler */ "./lib/wasm/session-handler.ts");
var wasm_factory_1 = __webpack_require__(/*! ./wasm/wasm-factory */ "./lib/wasm/wasm-factory.ts");
/**
 * This function initializes all flags for WebAssembly.
 *
 * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session
 * being created, to override default value.
 */
var initializeFlags = function () {
    if (typeof onnxruntime_common_1.env.wasm.initTimeout !== 'number' || onnxruntime_common_1.env.wasm.initTimeout < 0) {
        onnxruntime_common_1.env.wasm.initTimeout = 0;
    }
    if (typeof onnxruntime_common_1.env.wasm.simd !== 'boolean') {
        onnxruntime_common_1.env.wasm.simd = true;
    }
    if (typeof onnxruntime_common_1.env.wasm.numThreads !== 'number' || !Number.isInteger(onnxruntime_common_1.env.wasm.numThreads) || onnxruntime_common_1.env.wasm.numThreads <= 0) {
        var numCpuLogicalCores = typeof navigator === 'undefined' ? os_1.cpus().length : navigator.hardwareConcurrency;
        onnxruntime_common_1.env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
    }
};
exports.initializeFlags = initializeFlags;
var OnnxruntimeWebAssemblyBackend = /** @class */ (function () {
    function OnnxruntimeWebAssemblyBackend() {
    }
    OnnxruntimeWebAssemblyBackend.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // populate wasm flags
                        exports.initializeFlags();
                        // init wasm
                        return [4 /*yield*/, wasm_factory_1.initializeWebAssembly()];
                    case 1:
                        // init wasm
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    OnnxruntimeWebAssemblyBackend.prototype.createSessionHandler = function (pathOrBuffer, options) {
        return __awaiter(this, void 0, void 0, function () {
            var buffer, response, arrayBuffer, handler;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(typeof pathOrBuffer === 'string')) return [3 /*break*/, 6];
                        if (!(typeof fetch === 'undefined')) return [3 /*break*/, 2];
                        return [4 /*yield*/, util_1.promisify(fs_1.readFile)(pathOrBuffer)];
                    case 1:
                        // node
                        buffer = _a.sent();
                        return [3 /*break*/, 5];
                    case 2: return [4 /*yield*/, fetch(pathOrBuffer)];
                    case 3:
                        response = _a.sent();
                        return [4 /*yield*/, response.arrayBuffer()];
                    case 4:
                        arrayBuffer = _a.sent();
                        buffer = new Uint8Array(arrayBuffer);
                        _a.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        buffer = pathOrBuffer;
                        _a.label = 7;
                    case 7:
                        handler = new session_handler_1.OnnxruntimeWebAssemblySessionHandler();
                        handler.loadModel(buffer, options);
                        return [2 /*return*/, Promise.resolve(handler)];
                }
            });
        });
    };
    return OnnxruntimeWebAssemblyBackend;
}());
exports.wasmBackend = new OnnxruntimeWebAssemblyBackend();


/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js"), exports);
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var backend_onnxjs_1 = __webpack_require__(/*! ./backend-onnxjs */ "./lib/backend-onnxjs.ts");
var backend_wasm_1 = __webpack_require__(/*! ./backend-wasm */ "./lib/backend-wasm.ts");
onnxruntime_common_1.registerBackend('webgl', backend_onnxjs_1.onnxjsBackend, 1);
onnxruntime_common_1.registerBackend('wasm', backend_wasm_1.wasmBackend, 2);


/***/ }),

/***/ "./lib/onnxjs/attribute.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/attribute.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Attribute = void 0;
var onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
var ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
var tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
var util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
var Attribute = /** @class */ (function () {
    function Attribute(attributes) {
        var e_1, _a;
        this._attributes = new Map();
        if (attributes !== null && attributes !== undefined) {
            try {
                for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
                    var attr = attributes_1_1.value;
                    if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                        this._attributes.set(attr.name, [Attribute.getValue(attr), Attribute.getType(attr)]);
                    }
                    else if (attr instanceof ortFbs.Attribute) {
                        this._attributes.set(attr.name(), [Attribute.getValue(attr), Attribute.getType(attr)]);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this._attributes.size < attributes.length) {
                throw new Error('duplicated attribute names');
            }
        }
    }
    Attribute.prototype.set = function (key, type, value) {
        this._attributes.set(key, [value, type]);
    };
    Attribute.prototype.delete = function (key) {
        this._attributes.delete(key);
    };
    Attribute.prototype.getFloat = function (key, defaultValue) {
        return this.get(key, 'float', defaultValue);
    };
    Attribute.prototype.getInt = function (key, defaultValue) {
        return this.get(key, 'int', defaultValue);
    };
    Attribute.prototype.getString = function (key, defaultValue) {
        return this.get(key, 'string', defaultValue);
    };
    Attribute.prototype.getTensor = function (key, defaultValue) {
        return this.get(key, 'tensor', defaultValue);
    };
    Attribute.prototype.getFloats = function (key, defaultValue) {
        return this.get(key, 'floats', defaultValue);
    };
    Attribute.prototype.getInts = function (key, defaultValue) {
        return this.get(key, 'ints', defaultValue);
    };
    Attribute.prototype.getStrings = function (key, defaultValue) {
        return this.get(key, 'strings', defaultValue);
    };
    Attribute.prototype.getTensors = function (key, defaultValue) {
        return this.get(key, 'tensors', defaultValue);
    };
    Attribute.prototype.get = function (key, type, defaultValue) {
        var valueAndType = this._attributes.get(key);
        if (valueAndType === undefined) {
            if (defaultValue !== undefined) {
                return defaultValue;
            }
            throw new Error("required attribute not found: " + key);
        }
        if (valueAndType[1] !== type) {
            throw new Error("type mismatch: expected " + type + " but got " + valueAndType[1]);
        }
        return valueAndType[0];
    };
    Attribute.getType = function (attr) {
        var type = attr instanceof onnx_proto_1.onnx.AttributeProto ? (attr).type : attr.type();
        switch (type) {
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOAT:
                return 'float';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INT:
                return 'int';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRING:
                return 'string';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSOR:
                return 'tensor';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOATS:
                return 'floats';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INTS:
                return 'ints';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRINGS:
                return 'strings';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSORS:
                return 'tensors';
            default:
                throw new Error("attribute type is not supported yet: " + onnx_proto_1.onnx.AttributeProto.AttributeType[type]);
        }
    };
    Attribute.getValue = function (attr) {
        var attrType = attr instanceof onnx_proto_1.onnx.AttributeProto ? attr.type : attr.type();
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPH || attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPHS) {
            throw new Error('graph attribute is not supported yet');
        }
        var value = this.getValueNoCheck(attr);
        // cast LONG to number
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.INT && util_1.LongUtil.isLong(value)) {
            return util_1.LongUtil.longToNumber(value);
        }
        // cast LONG[] to number[]
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.INTS) {
            var arr = value;
            var numberValue = new Array(arr.length);
            for (var i = 0; i < arr.length; i++) {
                var maybeLong = arr[i];
                numberValue[i] = util_1.LongUtil.longToNumber(maybeLong);
            }
            return numberValue;
        }
        // cast onnx.TensorProto to onnxjs.Tensor
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.TENSOR) {
            return attr instanceof onnx_proto_1.onnx.AttributeProto ? tensor_1.Tensor.fromProto(value) :
                tensor_1.Tensor.fromOrtTensor(value);
        }
        // cast onnx.TensorProto[] to onnxjs.Tensor[]
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.TENSORS) {
            if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                var tensorProtos = value;
                return tensorProtos.map(function (value) { return tensor_1.Tensor.fromProto(value); });
            }
            else if (attr instanceof ortFbs.Attribute) {
                var tensorProtos = value;
                return tensorProtos.map(function (value) { return tensor_1.Tensor.fromOrtTensor(value); });
            }
        }
        // cast Uint8Array to string
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.STRING) {
            // string in onnx attribute is of uint8array type, so we need to convert it to string below. While in ort format,
            // string attributes are returned as string, so no conversion is needed.
            if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                var utf8String = value;
                return Buffer.from(utf8String.buffer, utf8String.byteOffset, utf8String.byteLength).toString();
            }
        }
        // cast Uint8Array[] to string[]
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.STRINGS) {
            // strings in onnx attribute is returned as uint8array[], so we need to convert it to string[] below. While in ort
            // format strings attributes are returned as string[], so no conversion is needed.
            if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                var utf8Strings = value;
                return utf8Strings.map(function (utf8String) { return Buffer.from(utf8String.buffer, utf8String.byteOffset, utf8String.byteLength).toString(); });
            }
        }
        return value;
    };
    Attribute.getValueNoCheck = function (attr) {
        return attr instanceof (onnx_proto_1.onnx.AttributeProto) ? this.getValueNoCheckFromOnnxFormat(attr) :
            this.getValueNoCheckFromOrtFormat(attr);
    };
    Attribute.getValueNoCheckFromOnnxFormat = function (attr) {
        switch (attr.type) {
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOAT:
                return attr.f;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INT:
                return attr.i;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRING:
                return attr.s;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSOR:
                return attr.t;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPH:
                return attr.g;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOATS:
                return attr.floats;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INTS:
                return attr.ints;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRINGS:
                return attr.strings;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSORS:
                return attr.tensors;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPHS:
                return attr.graphs;
            default:
                throw new Error("unsupported attribute type: " + onnx_proto_1.onnx.AttributeProto.AttributeType[attr.type]);
        }
    };
    Attribute.getValueNoCheckFromOrtFormat = function (attr) {
        switch (attr.type()) {
            case ortFbs.AttributeType.FLOAT:
                return attr.f();
            case ortFbs.AttributeType.INT:
                return attr.i();
            case ortFbs.AttributeType.STRING:
                return attr.s();
            case ortFbs.AttributeType.TENSOR:
                return attr.t();
            case ortFbs.AttributeType.GRAPH:
                return attr.g();
            case ortFbs.AttributeType.FLOATS:
                return attr.floatsArray();
            case ortFbs.AttributeType.INTS: {
                var ints = [];
                for (var i = 0; i < attr.intsLength(); i++) {
                    ints.push(attr.ints(i));
                }
                return ints;
            }
            case ortFbs.AttributeType.STRINGS: {
                var strings = [];
                for (var i = 0; i < attr.stringsLength(); i++) {
                    strings.push(attr.strings(i));
                }
                return strings;
            }
            case ortFbs.AttributeType.TENSORS: {
                var tensors = [];
                for (var i = 0; i < attr.tensorsLength(); i++) {
                    tensors.push(attr.tensors(i));
                }
                return tensors;
            }
            // case ortFbs.AttributeType.GRAPHS:
            // TODO: Subgraph not supported yet.
            // const graphs = [];
            // for (let i = 0; i < attr.graphsLength(); i++) {
            //   graphs.push(attr.graphs(i)!);
            // }
            // return graphs;
            default:
                throw new Error("unsupported attribute type: " + ortFbs.AttributeType[attr.type()]);
        }
    };
    return Attribute;
}());
exports.Attribute = Attribute;


/***/ }),

/***/ "./lib/onnxjs/backend.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/backend.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveBackend = exports.backend = void 0;
var backend_webgl_1 = __webpack_require__(/*! ./backends/backend-webgl */ "./lib/onnxjs/backends/backend-webgl.ts");
// caches all initialized backend instances
var backendsCache = new Map();
exports.backend = {
    webgl: new backend_webgl_1.WebGLBackend(),
};
/**
 * Resolve a reference to the backend. If a hint is specified, the corresponding
 * backend will be used.
 */
function resolveBackend(hint) {
    return __awaiter(this, void 0, void 0, function () {
        var hints, hints_1, hints_1_1, backendHint, cache, backend_1, e_1_1;
        var e_1, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!!hint) return [3 /*break*/, 1];
                    return [2 /*return*/, resolveBackend(['webgl'])];
                case 1:
                    hints = typeof hint === 'string' ? [hint] : hint;
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 7, 8, 9]);
                    hints_1 = __values(hints), hints_1_1 = hints_1.next();
                    _b.label = 3;
                case 3:
                    if (!!hints_1_1.done) return [3 /*break*/, 6];
                    backendHint = hints_1_1.value;
                    cache = backendsCache.get(backendHint);
                    if (cache) {
                        return [2 /*return*/, cache];
                    }
                    return [4 /*yield*/, tryLoadBackend(backendHint)];
                case 4:
                    backend_1 = _b.sent();
                    if (backend_1) {
                        return [2 /*return*/, backend_1];
                    }
                    _b.label = 5;
                case 5:
                    hints_1_1 = hints_1.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _b.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (hints_1_1 && !hints_1_1.done && (_a = hints_1.return)) _a.call(hints_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9: throw new Error('no available backend to use');
            }
        });
    });
}
exports.resolveBackend = resolveBackend;
function tryLoadBackend(backendHint) {
    return __awaiter(this, void 0, void 0, function () {
        var backendObj, backend_2, init;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    backendObj = exports.backend;
                    if (!(typeof backendObj[backendHint] !== 'undefined' && isBackend(backendObj[backendHint]))) return [3 /*break*/, 3];
                    backend_2 = backendObj[backendHint];
                    init = backend_2.initialize();
                    if (!(typeof init === 'object' && 'then' in init)) return [3 /*break*/, 2];
                    return [4 /*yield*/, init];
                case 1:
                    init = _a.sent();
                    _a.label = 2;
                case 2:
                    if (init) {
                        backendsCache.set(backendHint, backend_2);
                        return [2 /*return*/, backend_2];
                    }
                    _a.label = 3;
                case 3: return [2 /*return*/, undefined];
            }
        });
    });
}
function isBackend(obj) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var o = obj;
    // check if an object is a Backend instance
    if ('initialize' in o && typeof o.initialize === 'function' && // initialize()
        'createSessionHandler' in o && typeof o.createSessionHandler === 'function' && // createSessionHandler()
        'dispose' in o && typeof o.dispose === 'function' // dispose()
    ) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./lib/onnxjs/backends/backend-webgl.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/backend-webgl.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLBackend = void 0;
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var instrument_1 = __webpack_require__(/*! ../instrument */ "./lib/onnxjs/instrument.ts");
var session_handler_1 = __webpack_require__(/*! ./webgl/session-handler */ "./lib/onnxjs/backends/webgl/session-handler.ts");
var webgl_context_factory_1 = __webpack_require__(/*! ./webgl/webgl-context-factory */ "./lib/onnxjs/backends/webgl/webgl-context-factory.ts");
/**
 * WebGLBackend is the entry point for all WebGL opeartions
 * When it starts it created the WebGLRenderingContext
 * and other main framework components such as Program and Texture Managers
 */
var WebGLBackend = /** @class */ (function () {
    function WebGLBackend() {
    }
    Object.defineProperty(WebGLBackend.prototype, "contextId", {
        get: function () {
            return onnxruntime_common_1.env.webgl.contextId;
        },
        set: function (value) {
            onnxruntime_common_1.env.webgl.contextId = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebGLBackend.prototype, "matmulMaxBatchSize", {
        get: function () {
            return onnxruntime_common_1.env.webgl.matmulMaxBatchSize;
        },
        set: function (value) {
            onnxruntime_common_1.env.webgl.matmulMaxBatchSize = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebGLBackend.prototype, "textureCacheMode", {
        get: function () {
            return onnxruntime_common_1.env.webgl.textureCacheMode;
        },
        set: function (value) {
            onnxruntime_common_1.env.webgl.textureCacheMode = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WebGLBackend.prototype, "pack", {
        get: function () {
            return onnxruntime_common_1.env.webgl.pack;
        },
        set: function (value) {
            onnxruntime_common_1.env.webgl.pack = value;
        },
        enumerable: false,
        configurable: true
    });
    WebGLBackend.prototype.initialize = function () {
        try {
            this.glContext = webgl_context_factory_1.createWebGLContext(this.contextId);
            if (typeof this.matmulMaxBatchSize !== 'number') {
                this.matmulMaxBatchSize = 16;
            }
            if (typeof this.textureCacheMode !== 'string') {
                this.textureCacheMode = 'full';
            }
            if (typeof this.pack !== 'boolean') {
                this.pack = false;
            }
            instrument_1.Logger.setWithEnv(onnxruntime_common_1.env);
            instrument_1.Logger.verbose('WebGLBackend', "Created WebGLContext: " + typeof this.glContext + " with matmulMaxBatchSize: " + this.matmulMaxBatchSize + "; textureCacheMode: " + this.textureCacheMode + "; pack: " + this.pack + ".");
            return true;
        }
        catch (e) {
            instrument_1.Logger.warning('WebGLBackend', "Unable to initialize WebGLBackend. " + e);
            return false;
        }
    };
    WebGLBackend.prototype.createSessionHandler = function (context) {
        return new session_handler_1.WebGLSessionHandler(this, context);
    };
    WebGLBackend.prototype.dispose = function () {
        this.glContext.dispose();
    };
    return WebGLBackend;
}());
exports.WebGLBackend = WebGLBackend;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts":
/*!**********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoordsGlslLib = void 0;
var util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
var glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
var glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var texture_layout_strategy_1 = __webpack_require__(/*! ./texture-layout-strategy */ "./lib/onnxjs/backends/webgl/texture-layout-strategy.ts");
var utils_1 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var utils_2 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var utils_3 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
/**
 * GLSL Library responsible for data types and routines for manipulating
 * coordinates and mapping to/from tensor indices
 */
var CoordsGlslLib = /** @class */ (function (_super) {
    __extends(CoordsGlslLib, _super);
    function CoordsGlslLib(context) {
        return _super.call(this, context) || this;
    }
    CoordsGlslLib.prototype.getFunctions = function () {
        return __assign(__assign(__assign(__assign(__assign(__assign(__assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
    };
    CoordsGlslLib.prototype.getCustomTypes = function () {
        return {};
    };
    /**
     * Produces a function that can map from
     * 2D normalzied coordinates (s,t) to a flat offset
     */
    CoordsGlslLib.prototype.offsetToCoords = function () {
        var funcName = 'offsetToCoords';
        return {
            offsetToCoords: new glsl_definitions_1.GlslLibRoutine("\n      vec2 " + funcName + "(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")
        };
    };
    /**
     * Produces a function that can map from
     * 2D normalzied coordinates (s,t) to a flat offset
     */
    CoordsGlslLib.prototype.coordsToOffset = function () {
        var funcName = 'coordsToOffset';
        return {
            coordsToOffset: new glsl_definitions_1.GlslLibRoutine("\n      int " + funcName + "(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")
        };
    };
    /**
     * Generates code for output sampler.
     */
    CoordsGlslLib.prototype.getOutputSamplingSnippet = function () {
        var outputLayout = this.context.programInfo.outputLayout;
        if (outputLayout.isPacked) {
            return this.getPackedOutputSamplingSnippet(outputLayout);
        }
        else {
            return this.getUnpackedOutputSamplingSnippet(outputLayout);
        }
    };
    /**
     * Generates code for packed output sampler.
     */
    CoordsGlslLib.prototype.getPackedOutputSamplingSnippet = function (outputLayout) {
        var outShape = outputLayout.unpackedShape;
        var outTexShape = [outputLayout.width, outputLayout.height];
        var result = {};
        var funcName = 'getOutputCoords';
        switch (outShape.length) {
            case 0:
                result[funcName] = this.getOutputScalarCoords();
                break;
            case 1:
                result[funcName] = this.getOutputPacked1DCoords(outShape, outTexShape);
                break;
            case 2:
                result[funcName] = this.getOutputPacked2DCoords(outShape, outTexShape);
                break;
            case 3:
                result[funcName] =
                    this.getOutputPacked3DCoords(outShape, outTexShape);
                break;
            default:
                result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape);
        }
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        // TODO we need this to properly return a packed vec4 from kernels.
        // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.
        var floatTextureSetRGBASource = "\n      void setOutput(vec4 val) {\n        " + glsl.output + " = val;\n      }\n    ";
        var floatTextureSetRGBAFuncName = 'floatTextureSetRGBA';
        result[floatTextureSetRGBAFuncName] = new glsl_definitions_1.GlslLibRoutine(floatTextureSetRGBASource);
        return result;
    };
    /**
     * Generates code for unpacked output sampler.
     */
    CoordsGlslLib.prototype.getUnpackedOutputSamplingSnippet = function (outputLayout) {
        var outShape = outputLayout.unpackedShape;
        var outTexShape = [outputLayout.width, outputLayout.height];
        var result = {};
        var funcName = 'getOutputCoords';
        switch (outShape.length) {
            case 0:
                result[funcName] = this.getOutputScalarCoords();
                break;
            case 1:
                result[funcName] = this.getOutputUnpacked1DCoords(outShape, outTexShape);
                break;
            case 2:
                result[funcName] =
                    this.getOutputUnpacked2DCoords(outShape, outTexShape);
                break;
            case 3:
                result[funcName] =
                    this.getOutputUnpacked3DCoords(outShape, outTexShape);
                break;
            case 4:
                result[funcName] = this.getOutputUnpacked4DCoords(outShape, outTexShape);
                break;
            case 5:
                result[funcName] = this.getOutputUnpacked5DCoords(outShape, outTexShape);
                break;
            case 6:
                result[funcName] = this.getOutputUnpacked6DCoords(outShape, outTexShape);
                break;
            default:
                throw new Error("Unsupported output dimensionality: " + outShape.length);
        }
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        // TODO we need this to properly return a packed vec4 from kernels.
        // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.
        var floatTextureSetRSource = "\n        void setOutput(float val) {\n          " + glsl.output + " = vec4(val, 0, 0, 0);\n        }\n    ";
        var floatTextureSetRFuncName = 'floatTextureSetR';
        result[floatTextureSetRFuncName] = new glsl_definitions_1.GlslLibRoutine(floatTextureSetRSource);
        return result;
    };
    /**
     * Scalar output coordinates.
     */
    CoordsGlslLib.prototype.getOutputScalarCoords = function () {
        return new glsl_definitions_1.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
    };
    /**
     * 1D packed output coordinates.
     */
    CoordsGlslLib.prototype.getOutputPacked1DCoords = function (shape, texShape) {
        var packedTexShape = texShape;
        var source = '';
        if (packedTexShape[0] === 1) {
            source = "\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * " + packedTexShape[1] + ".0);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source);
        }
        if (packedTexShape[1] === 1) {
            source = "\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * " + packedTexShape[0] + ".0);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source);
        }
        source = "\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(" + packedTexShape[0] + ", " + packedTexShape[1] + "));\n          return 2 * (resTexRC.y * " + packedTexShape[0] + " + resTexRC.x);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * 2D packed output coordinates.
     */
    CoordsGlslLib.prototype.getOutputPacked2DCoords = function (shape, texShape) {
        var source = '';
        if (util_1.ArrayUtil.arraysEqual(shape, texShape)) {
            source = "\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(" + texShape[0] + ", " + texShape[1] + "));\n        }\n      ";
            return new glsl_definitions_1.GlslLibRoutine(source);
        }
        var packedTexShape = texShape;
        // texels needed to accommodate a logical row
        var texelsInLogicalRow = Math.ceil(shape[1] / 2);
        /**
         * getOutputCoords
         *
         * resTexRC: The rows and columns of the texels. If you move over one
         * texel to the right in the packed texture, you are moving over one column
         * (not two).
         *
         * index: The texel index
         */
        source = "\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + packedTexShape[0] + ", " + packedTexShape[1] + "));\n\n          int index = resTexRC.y * " + packedTexShape[0] + " + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, " + texelsInLogicalRow + ") * 2;\n          int c = 2 * (index / " + texelsInLogicalRow + ");\n\n          return ivec2(r, c);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * 3D packed output coordinates.
     */
    CoordsGlslLib.prototype.getOutputPacked3DCoords = function (shape, texShape) {
        var packedTexShape = [texShape[0], texShape[1]];
        var texelsInLogicalRow = Math.ceil(shape[2] / 2);
        var texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
        var source = "\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + packedTexShape[0] + ", " + packedTexShape[1] + "));\n          int index = resTexRC.y * " + packedTexShape[0] + " + resTexRC.x;\n\n          int b = index / " + texelsInBatch + ";\n          index -= b * " + texelsInBatch + ";\n\n          // reverse r and c order for packed texture\n          int r = imod(index, " + texelsInLogicalRow + ") * 2;\n          int c = 2 * (index / " + texelsInLogicalRow + ");\n\n          return ivec3(b, r, c);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * ND packed output coordinates.
     */
    CoordsGlslLib.prototype.getOutputPackedNDCoords = function (shape, texShape) {
        var packedTexShape = [texShape[0], texShape[1]];
        var texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
        var texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
        var texelsInBatchN = texelsInBatch;
        var batches = '';
        var coords = 'b, r, c';
        for (var b = 2; b < shape.length - 1; b++) {
            texelsInBatchN *= shape[shape.length - b - 1];
            batches = "\n      int b" + b + " = index / " + texelsInBatchN + ";\n      index -= b" + b + " * " + texelsInBatchN + ";\n    " + batches;
            coords = "b" + b + ", " + coords;
        }
        var source = "\n      ivec" + shape.length + " getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(" + packedTexShape[0] + ", " + packedTexShape[1] + "));\n        int index = resTexRC.y * " + packedTexShape[0] + " + resTexRC.x;\n\n        " + batches + "\n\n        int b = index / " + texelsInBatch + ";\n        index -= b * " + texelsInBatch + ";\n\n        // reverse r and c order for packed texture\n        int r = imod(index, " + texelsInLogicalRow + ") * 2;\n        int c = 2 * (index / " + texelsInLogicalRow + ");\n\n        return ivec" + shape.length + "(" + coords + ");\n      }\n    ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked 1D output coordinates.
     */
    CoordsGlslLib.prototype.getOutputUnpacked1DCoords = function (shape, texShape) {
        var source = "\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + texShape[0] + ", " + texShape[1] + "));\n          return resTexRC.y * " + texShape[0] + " + resTexRC.x;\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked 2D output coordinates.
     */
    CoordsGlslLib.prototype.getOutputUnpacked2DCoords = function (shape, texShape) {
        var source = "\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + texShape[0] + ", " + texShape[1] + "));\n          int index = resTexRC.y * " + texShape[0] + " + resTexRC.x;\n          int r = index / " + shape[1] + ";\n          int c = index - r * " + shape[1] + ";\n          return ivec2(r, c);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked 3D output coordinates.
     */
    CoordsGlslLib.prototype.getOutputUnpacked3DCoords = function (shape, texShape) {
        var source = '';
        var rank = shape.length;
        var strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        var coordsToCompute = ['r', 'c', 'd'];
        var coordsFromIndexSnippet = strides
            .map(function (stride, i) {
            var line1 = "int " + coordsToCompute[i] + " = index / " + stride;
            var line2 = i === strides.length - 1 ?
                "int " + coordsToCompute[i + 1] + " = index - " + coordsToCompute[i] + " * " + stride :
                "index -= " + coordsToCompute[i] + " * " + stride;
            return line1 + "; " + line2 + ";";
        })
            .join('');
        source = "\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + texShape[0] + ", " + texShape[1] + "));\n          int index = resTexRC.y * " + texShape[0] + " + resTexRC.x;\n          " + coordsFromIndexSnippet + "\n          return ivec3(r, c, d);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked 4D output coordinates.
     */
    CoordsGlslLib.prototype.getOutputUnpacked4DCoords = function (shape, texShape) {
        var source = '';
        var rank = shape.length;
        var strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        var coordsToCompute = ['r', 'c', 'd', 'd2'];
        var coordsFromIndexSnippet = strides
            .map(function (stride, i) {
            var line1 = "int " + coordsToCompute[i] + " = index / " + stride;
            var line2 = i === strides.length - 1 ?
                "int " + coordsToCompute[i + 1] + " = index - " + coordsToCompute[i] + " * " + stride :
                "index -= " + coordsToCompute[i] + " * " + stride;
            return line1 + "; " + line2 + ";";
        })
            .join('');
        source = "\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + texShape[0] + ", " + texShape[1] + "));\n          int index = resTexRC.y * " + texShape[0] + " + resTexRC.x;\n          " + coordsFromIndexSnippet + "\n          return ivec4(r, c, d, d2);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked 5D output coordinates.
     */
    CoordsGlslLib.prototype.getOutputUnpacked5DCoords = function (shape, texShape) {
        var source = '';
        var rank = shape.length;
        var strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        var coordsToCompute = ['r', 'c', 'd', 'd2', 'd3'];
        var coordsFromIndexSnippet = strides
            .map(function (stride, i) {
            var line1 = "int " + coordsToCompute[i] + " = index / " + stride;
            var line2 = i === strides.length - 1 ?
                "int " + coordsToCompute[i + 1] + " = index - " + coordsToCompute[i] + " * " + stride :
                "index -= " + coordsToCompute[i] + " * " + stride;
            return line1 + "; " + line2 + ";";
        })
            .join('');
        source = "\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(" + texShape[0] + ", " + texShape[1] + "));\n          int index = resTexRC.y * " + texShape[0] + " + resTexRC.x;\n          " + coordsFromIndexSnippet + "\n          return ivec5(r, c, d, d2, d3);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked 6D output coordinates.
     */
    CoordsGlslLib.prototype.getOutputUnpacked6DCoords = function (shape, texShape) {
        var source = '';
        var rank = shape.length;
        var strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        var coordsToCompute = ['r', 'c', 'd', 'd2', 'd3', 'd4'];
        var coordsFromIndexSnippet = strides
            .map(function (stride, i) {
            var line1 = "int " + coordsToCompute[i] + " = index / " + stride;
            var line2 = i === strides.length - 1 ?
                "int " + coordsToCompute[i + 1] + " = index - " + coordsToCompute[i] + " * " + stride :
                "index -= " + coordsToCompute[i] + " * " + stride;
            return line1 + "; " + line2 + ";";
        })
            .join('');
        source = "\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n         int index = resTexRC.y * " + texShape[0] + " + resTexRC.x;\n         " + coordsFromIndexSnippet + "\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Generates code for common UV coords computation utility functions.
     */
    CoordsGlslLib.prototype.getCommonUtilFuncs = function () {
        var result = {};
        var funcName = 'uvFromFlat';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    ");
        funcName = 'packedUVfrom1D';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      ");
        funcName = 'packedUVfrom2D';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      ");
        funcName = 'packedUVfrom3D';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      ");
        funcName = 'sampleTexture';
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        result[funcName] = new glsl_definitions_1.GlslLibRoutine("\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return " + glsl.texture2D + "(textureSampler, uv).r;\n        }");
        return result;
    };
    /**
     * Constructing snippets for inputs
     */
    CoordsGlslLib.prototype.getInputsSamplingSnippets = function () {
        var _this = this;
        var result = {};
        var outputLayout = this.context.programInfo.outputLayout;
        this.context.programInfo.samplers.forEach(function (samplerName, i) {
            var inputLayout = _this.context.programInfo.inputLayouts[i];
            var funcName = utils_1.generateShaderFuncNameFromInputSamplerName(samplerName);
            if (inputLayout.isPacked) {
                result[funcName] = _this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);
            }
            else {
                result[funcName] = _this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);
            }
            var outCoordFuncName = utils_2.generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);
            if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {
                if (inputLayout.isPacked) {
                    result[outCoordFuncName] =
                        _this.getPackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
                }
                else {
                    result[outCoordFuncName] =
                        _this.getUnpackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
                }
            }
        });
        return result;
    };
    /**
     * Constructing snippets for output coordinates of samplers
     */
    CoordsGlslLib.prototype.getPackedSamplerAtOutputCoords = function (funcName, inputLayout, outputLayout, name) {
        var inShape = inputLayout.unpackedShape;
        var outShape = outputLayout.unpackedShape;
        var texName = name;
        var texFuncSnippet = utils_1.generateShaderFuncNameFromInputSamplerName(texName);
        var inRank = inShape.length;
        var outRank = outShape.length;
        var broadcastDims = util_1.BroadcastUtil.getBroadcastDims(inShape, outShape);
        var type = utils_3.getCoordsDataType(outRank);
        var rankDiff = outRank - inRank;
        var coordsSnippet;
        var fields = ['x', 'y', 'z', 'w', 'u', 'v'];
        if (inRank === 0) {
            coordsSnippet = '';
        }
        else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = 'coords = 0;';
        }
        else {
            coordsSnippet = broadcastDims.map(function (d) { return "coords." + fields[d + rankDiff] + " = 0;"; }).join('\n');
        }
        var unpackedCoordsSnippet = '';
        if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = 'coords';
        }
        else {
            unpackedCoordsSnippet = inShape.map(function (s, i) { return "coords." + fields[i + rankDiff]; }).join(', ');
        }
        var output = 'return outputValue;';
        var inSize = util_1.ShapeUtil.size(inShape);
        var isInputScalar = inSize === 1;
        var outSize = util_1.ShapeUtil.size(outShape);
        var isOutputScalar = outSize === 1;
        if (inRank === 1 && !isInputScalar && !isOutputScalar) {
            output = "\n        return vec4(outputValue.xx, outputValue.yy);\n      ";
        }
        else if (isInputScalar && !isOutputScalar) {
            if (outRank === 1) {
                output = "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ";
            }
            else {
                output = "\n          return vec4(outputValue.x);\n        ";
            }
        }
        else if (broadcastDims.length) {
            var rows = inRank - 2;
            var cols = inRank - 1;
            if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
                output = 'return vec4(outputValue.x);';
            }
            else if (broadcastDims.indexOf(rows) > -1) {
                output = 'return vec4(outputValue.x, outputValue.y, ' +
                    'outputValue.x, outputValue.y);';
            }
            else if (broadcastDims.indexOf(cols) > -1) {
                output = 'return vec4(outputValue.xx, outputValue.zz);';
            }
        }
        var source = "\n      vec4 " + funcName + "() {\n        " + type + " coords = getOutputCoords();\n        " + coordsSnippet + "\n        vec4 outputValue = " + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n        " + output + "\n      }\n    ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.getOutputCoords']);
    };
    /**
     * Constructing snippets for unpacked output coordinates of samplers
     */
    CoordsGlslLib.prototype.getUnpackedSamplerAtOutputCoords = function (funcName, inputLayout, outputLayout, name) {
        var outTexShape = [outputLayout.width, outputLayout.height];
        var inTexShape = [inputLayout.width, inputLayout.height];
        var inRank = inputLayout.unpackedShape.length;
        var outRank = outputLayout.unpackedShape.length;
        var inShape = inputLayout.unpackedShape;
        var outShape = outputLayout.unpackedShape;
        var texFuncSnippet = utils_1.generateShaderFuncNameFromInputSamplerName(name);
        if (inRank === outRank && util_1.ArrayUtil.arraysEqual(inTexShape, outTexShape)) {
            var source_1 = "\n          float " + funcName + "() {\n            return sampleTexture(" + name + ", TexCoords);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_1, ['coordinates.sampleTexture']);
        }
        var type = utils_3.getCoordsDataType(outRank);
        var broadcastDims = util_1.BroadcastUtil.getBroadcastDims(inShape, outShape);
        var rankDiff = outRank - inRank;
        var coordsSnippet;
        var fields = ['x', 'y', 'z', 'w', 'u', 'v'];
        if (inRank === 0) {
            coordsSnippet = '';
        }
        else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = 'coords = 0;';
        }
        else {
            coordsSnippet = broadcastDims.map(function (d) { return "coords." + fields[d + rankDiff] + " = 0;"; }).join('\n');
        }
        var unpackedCoordsSnippet = '';
        if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = 'coords';
        }
        else {
            unpackedCoordsSnippet = inputLayout.unpackedShape.map(function (s, i) { return "coords." + fields[i + rankDiff]; }).join(', ');
        }
        var source = "\n        float " + funcName + "() {\n          " + type + " coords = getOutputCoords();\n          " + coordsSnippet + "\n          return " + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.getOutputCoords']);
    };
    /**
     * Constructing snippets for packed operations.
     */
    CoordsGlslLib.prototype.getPackedSamplerFromInput = function (funcName, name, inputLayout) {
        switch (inputLayout.unpackedShape.length) {
            case 0:
                return this.getPackedSamplerScalar(funcName, name);
            case 1:
                return this.getPackedSampler1D(funcName, name, inputLayout);
            case 2:
                return this.getPackedSampler2D(funcName, name, inputLayout);
            case 3:
                return this.getPackedSampler3D(funcName, name, inputLayout);
            default:
                return this.getPackedSamplerND(funcName, name, inputLayout);
        }
    };
    /**
     * Constructing snippets for unpacked operations.
     */
    CoordsGlslLib.prototype.getUnpackedSamplerFromInput = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        switch (shape.length) {
            case 0:
                return this.getUnpackedSamplerScalar(funcName, name, inputLayout);
            case 1:
                return this.getUnpackedSampler1D(funcName, name, inputLayout);
            case 2:
                return this.getUnpackedSampler2D(funcName, name, inputLayout);
            case 3:
                return this.getUnpackedSampler3D(funcName, name, inputLayout);
            case 4:
                return this.getUnpackedSampler4D(funcName, name, inputLayout);
            case 5:
                return this.getUnpackedSampler5D(funcName, name, inputLayout);
            case 6:
                return this.getUnpackedSampler6D(funcName, name, inputLayout);
            default:
                // TODO support more dimensionalities
                throw new Error("Unsupported dimension " + shape.length + "-D");
        }
    };
    /**
     * Packed scalar snippet.
     */
    CoordsGlslLib.prototype.getPackedSamplerScalar = function (funcName, name) {
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        var source = "\n          vec4 " + funcName + "() {\n            return " + glsl.texture2D + "(" + name + ", halfCR);\n          }\n        ";
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Packed 1D snippet.
     */
    CoordsGlslLib.prototype.getPackedSampler1D = function (funcName, name, inputLayout) {
        var texShape = [inputLayout.width, inputLayout.height];
        var packedTexShape = [texShape[1], texShape[0]];
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        var packedSampler = "vec4 " + funcName + "(int index) {\n      vec2 uv = packedUVfrom1D(\n      " + packedTexShape[0] + ", " + packedTexShape[1] + ", index);\n      return " + glsl.texture2D + "(" + name + ", uv);\n    }";
        var source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.packedUVfrom1D']);
    };
    /**
     * Packed 2D snippet.
     */
    CoordsGlslLib.prototype.getPackedSampler2D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var texShape = [inputLayout.width, inputLayout.height];
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        var texNumR = texShape[0];
        var texNumC = texShape[1];
        if (texShape != null && util_1.ArrayUtil.arraysEqual(shape, texShape)) {
            var packedSampler_1 = "vec4 " + funcName + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return " + glsl.texture2D + "(" + name + ", uv);\n      }";
            return new glsl_definitions_1.GlslLibRoutine(packedSampler_1);
        }
        var packedTexShape = texShape;
        var valuesPerRow = Math.ceil(shape[1] / 2);
        var packedSampler = "vec4 " + funcName + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + packedTexShape[1] + ", " + packedTexShape[0] + ", " + valuesPerRow + ", row, col);\n      return " + glsl.texture2D + "(" + name + ", uv);\n    }";
        var source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.packedUVfrom2D']);
    };
    /**
     * Packed 3D snippet.
     */
    CoordsGlslLib.prototype.getPackedSampler3D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var texShape = [inputLayout.width, inputLayout.height];
        var packedTexShape = [texShape[0], texShape[1]];
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        if (shape[0] === 1) {
            var squeezedShape = shape.slice(1);
            var keptDims = [1, 2];
            var newInputShape = utils_3.squeezeInputShape(shape, squeezedShape);
            var params = ['b', 'row', 'col'];
            // Deep copy of input texture layout.
            var newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            var samplerRoutine = this.getPackedSamplerFromInput(funcName, name, newInputLayout);
            var packedSampler_2 = samplerRoutine.routineBody + "\n      vec4 " + funcName + "(int b, int row, int col) {\n        return " + funcName + "(" + utils_3.getSqueezedParams(params, keptDims) + ");\n      } ";
            var source_2 = packedSampler_2;
            return new glsl_definitions_1.GlslLibRoutine(source_2, samplerRoutine.dependencies);
        }
        var texNumR = packedTexShape[0];
        var texNumC = packedTexShape[1];
        var valuesPerRow = Math.ceil(shape[2] / 2);
        var texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
        var packedSampler = "vec4 " + funcName + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + texNumC + ", " + texNumR + ", " + texelsInBatch + ", " + valuesPerRow + ", b, row, col);\n      return " + glsl.texture2D + "(" + name + ", uv);}";
        var source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.packedUVfrom3D']);
    };
    /*
     * Packed ND snippet.
     */
    CoordsGlslLib.prototype.getPackedSamplerND = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var rank = shape.length;
        var texShape = [inputLayout.width, inputLayout.height];
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        var packedTexShape = [texShape[0], texShape[1]];
        var texNumR = packedTexShape[1];
        var texNumC = packedTexShape[0];
        var valuesPerRow = Math.ceil(shape[rank - 1] / 2);
        var texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
        var params = 'int b, int row, int col';
        var index = "b * " + texelsInBatch + " + (row / 2) * " + valuesPerRow + " + (col / 2)";
        for (var b = 2; b < rank - 1; b++) {
            params = "int b" + b + ", " + params;
            texelsInBatch *= shape[rank - b - 1];
            index = "b" + b + " * " + texelsInBatch + " + " + index;
        }
        var packedSampler = "vec4 " + funcName + "(" + params + ") {\n      int index = " + index + ";\n      int texR = index / " + texNumC + ";\n      int texC = index - texR * " + texNumC + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ", " + texNumR + ");\n      return " + glsl.texture2D + "(" + name + ", uv);\n    }";
        var source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source);
    };
    /**
     * Unpacked scalar snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSamplerScalar = function (funcName, name, inputLayout) {
        var _a = __read([inputLayout.width, inputLayout.height], 2), texNumR = _a[0], texNumC = _a[1];
        if (texNumR === 1 && texNumC === 1) {
            var source_3 = "\n          float " + funcName + "() {\n            return sampleTexture(" + name + ", halfCR);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_3, ['coordinates.sampleTexture']);
        }
        var source = "\n        float " + funcName + "() {\n          int offset_" + name + " = coordsToOffset(TexCoords, " + texNumR + ", " + texNumC + ");\n          vec2 uv = uvFromFlat(" + texNumR + ", " + texNumC + ", offset_" + name + ");\n          return sampleTexture(" + name + ", uv);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    };
    /**
     * Unpacked 1D snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSampler1D = function (funcName, name, inputLayout) {
        var tNumR = inputLayout.width;
        var tNumC = inputLayout.height;
        if (tNumC === 1 && tNumR === 1) {
            var source_4 = "\n        float " + funcName + "(int index) {\n          return sampleTexture(" + name + ", halfCR);\n        }\n      ";
            return new glsl_definitions_1.GlslLibRoutine(source_4, ['coordinates.sampleTexture']);
        }
        if (tNumC === 1) {
            var source_5 = "\n          float " + funcName + "(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / " + tNumR + ".0, 0.5);\n            return sampleTexture(" + name + ", uv);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_5, ['coordinates.sampleTexture']);
        }
        if (tNumR === 1) {
            var source_6 = "\n          float " + funcName + "(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumC + ".0);\n            return sampleTexture(" + name + ", uv);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_6, ['coordinates.sampleTexture']);
        }
        var source = "\n        float " + funcName + "(int index) {\n          vec2 uv = uvFromFlat(" + tNumR + ", " + tNumC + ", index);\n          return sampleTexture(" + name + ", uv);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);
    };
    /**
     * Unpacked 2D snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSampler2D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        // TODO: modify row/col order for other dimensions.
        var texShape = [inputLayout.height, inputLayout.width];
        if (texShape != null && util_1.ArrayUtil.arraysEqual(shape, texShape)) {
            var texNumR_1 = texShape[1];
            var texNumC_1 = texShape[0];
            var source_7 = "\n          float " + funcName + "(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(" + texNumR_1 + ".0, " + texNumC_1 + ".0);\n            return sampleTexture(" + name + ", uv);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_7, ['coordinates.sampleTexture']);
        }
        var _a = texture_layout_strategy_1.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        var squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            var newInputShape = utils_3.squeezeInputShape(shape, squeezedShape);
            // Deep copy of input texture layout.
            var newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            var params = ['col', 'row'];
            var source_8 = "\n          " + this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody + "\n          float " + funcName + "(int row, int col) {\n            return " + funcName + "(" + utils_3.getSqueezedParams(params, keptDims) + ");\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_8, ['coordinates.sampleTexture']);
        }
        var texNumR = texShape[1];
        var texNumC = texShape[0];
        if (texNumC === 1) {
            var source_9 = "\n          float " + funcName + "(int row, int col) {\n            int offset_" + name + " = coordsToOffset(TexCoords, " + texNumR + ", " + texNumC + ");\n            float index = dot(vec3(row, col, offset_" + name + "), vec3(" + shape[1] + ", 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / " + texNumR + ".0);\n            return sampleTexture(" + name + ", uv);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_9, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);
        }
        if (texNumR === 1) {
            var source_10 = "\n          float " + funcName + "(int row, int col) {\n            int offset_" + name + " = coordsToOffset(TexCoords, " + texNumR + ", " + texNumC + ");\n            float index = dot(vec3(row, col, offset_" + name + "), vec3(" + shape[1] + ", 1, 1));\n            vec2 uv = vec2((index + 0.5) / " + texNumC + ".0, 0.5);\n            return sampleTexture(" + name + ", uv);\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_10, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);
        }
        var source = "\n        float " + funcName + "(int row, int col) {\n          int index = col * " + shape[1] + " + row;\n          vec2 uv = uvFromFlat(" + texNumR + ", " + texNumC + ", index);\n          return sampleTexture(" + name + ", uv);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    };
    /**
     * Unpacked 3D snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSampler3D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var stride0 = shape[1] * shape[2];
        var stride1 = shape[2];
        var _a = texture_layout_strategy_1.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        var squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            var newInputShape = utils_3.squeezeInputShape(shape, squeezedShape);
            var params = ['batch', 'col', 'row'];
            // Deep copy of input texture layout.
            var newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            var routine = this.getUnpackedSamplerFromInput(funcName, name, newInputLayout);
            // TODO: revisit the logic here to make it simpler
            var revDims = keptDims.reverse();
            var source_11 = "\n          " + routine.routineBody + "\n          float " + funcName + "(int batch, int row, int col) {\n            return " + funcName + "(" + utils_3.getSqueezedParams(params, revDims) + ");\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_11, routine.dependencies);
        }
        var texNumR = inputLayout.width;
        var texNumC = inputLayout.height;
        var source = "\n          float " + funcName + "(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * " + stride0 + " + col * " + stride1 + " + row;\n            vec2 uv = uvFromFlat(" + texNumR + ", " + texNumC + ", index);\n            return sampleTexture(" + name + ", uv);\n          }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    };
    /**
     * Unpacked 4D snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSampler4D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var stride2 = shape[3];
        var stride1 = shape[2] * stride2;
        var stride0 = shape[1] * stride1;
        //
        // TODO: re-enable this shortcut once the index calculation bug is fixed.
        //
        // const {newShape, keptDims} = squeezeShape(shape as number[]);
        // if (newShape.length < shape.length) {
        //   const newInputShape = squeezeInputShape(shape, newShape);
        //   const params = ['row', 'col', 'depth', 'depth2'];
        //   // Deep copy of input texture layout.
        //   const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));
        //   newInputLayout.unpackedShape = newInputShape;
        //   const source = `
        //       ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}
        //       float ${funcName}(int row, int col, int depth, int depth2) {
        //         return ${funcName}(${getSqueezedParams(params, keptDims)});
        //       }
        //     `;
        //   return new GlslLibRoutine(
        //       source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
        // }
        var texNumR = inputLayout.width;
        var texNumC = inputLayout.height;
        var source = "\n        float " + funcName + "(int row, int col, int depth, int depth2) {\n          int index = row * " + stride0 + " + col * " + stride1 + " +\n              depth2 * " + stride2 + " + depth;\n          vec2 uv = uvFromFlat(" + texNumR + ", " + texNumC + ", index);\n          return sampleTexture(" + name + ", uv);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);
    };
    /**
     * Unpacked 5D snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSampler5D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var stride3 = shape[4];
        var stride2 = shape[3] * stride3;
        var stride1 = shape[2] * stride2;
        var stride0 = shape[1] * stride1;
        var _a = texture_layout_strategy_1.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        if (newShape.length < shape.length) {
            var newInputShape = utils_3.squeezeInputShape(shape, newShape);
            var params = ['row', 'col', 'depth', 'depth2', 'depth3'];
            // Deep copy of input texture layout.
            var newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            var source_12 = "\n          " + this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody + "\n          float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n            return " + funcName + "(" + utils_3.getSqueezedParams(params, keptDims) + ");\n          }\n        ";
            return new glsl_definitions_1.GlslLibRoutine(source_12, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);
        }
        var texNumR = inputLayout.width;
        var texNumC = inputLayout.height;
        var source = "\n        float " + funcName + "(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * " + stride0 + " + col * " + stride1 + " + depth * " + stride2 + " +\n          depth3 * " + stride3 + " + depth2;\n          vec2 uv = uvFromFlat(" + texNumR + ", " + texNumC + ", index);\n          return sampleTexture(" + name + ", uv);\n        }\n      ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);
    };
    /**
     * Unpacked 6D snippet.
     */
    CoordsGlslLib.prototype.getUnpackedSampler6D = function (funcName, name, inputLayout) {
        var shape = inputLayout.unpackedShape;
        var stride4 = shape[5];
        var stride3 = shape[4] * stride4;
        var stride2 = shape[3] * stride3;
        var stride1 = shape[2] * stride2;
        var stride0 = shape[1] * stride1;
        var _a = texture_layout_strategy_1.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
        if (newShape.length < shape.length) {
            var newInputShape = utils_3.squeezeInputShape(shape, newShape);
            var params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];
            // Deep copy of input texture layout.
            var newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            var source_13 = "\n            " + this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody + "\n            float " + funcName + "(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return " + funcName + "(" + utils_3.getSqueezedParams(params, keptDims) + ");\n            }\n          ";
            return new glsl_definitions_1.GlslLibRoutine(source_13, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);
        }
        var texNumR = inputLayout.width;
        var texNumC = inputLayout.height;
        var source = "\n          float " + funcName + "(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * " + stride0 + " + col * " + stride1 + " + depth * " + stride2 + " +\n            depth2 * " + stride3 + " + depth3 * " + stride4 + " + depth4;\n            vec2 uv = uvFromFlat(" + texNumR + ", " + texNumC + ", index);\n            return sampleTexture(" + name + ", uv);\n          }\n        ";
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    };
    /**
     * This is the main function to map from the given texture coordiantes (s,t)
     * to logical indices for the output
     * There will only be one single variation of this
     * Also see coordsToOffset and offsetToIndices for input-specific versions
     */
    CoordsGlslLib.prototype.toVec = function () {
        var output = this.context.programInfo.outputLayout;
        var rank = output.shape.length;
        var strides = output.strides;
        var xScale = output.width;
        var yScale = output.height;
        var stridesBlock = [];
        for (var i = 0; i < rank - 1; ++i) {
            stridesBlock.push("\n        c[" + i + "] = offset / " + strides[i] + ";");
            stridesBlock.push("\n        offset -= c[" + i + "] * " + strides[i] + ";");
        }
        stridesBlock.push("\n        c[" + (rank - 1) + "] = offset;");
        var body = "\n      void toVec(vec2 texCoords, out int c[" + rank + "]) {\n        int offset = coordsToOffset(texCoords, " + xScale + ", " + yScale + ");\n        " + stridesBlock.join('') + "\n      }\n      void toVec(int offset, out int c[" + rank + "]) {\n        " + stridesBlock.join('') + "\n      }\n    ";
        return { toVec: new glsl_definitions_1.GlslLibRoutine(body, ['coordinates.coordsToOffset']) };
    };
    /**
     * These are value getter functions generated for each input
     * Each function is hardwired to the name and dimensions of the input
     * An '_T' variation is also produced which accesses values as if the
     * input was transposed
     */
    CoordsGlslLib.prototype.valueFrom = function () {
        var _this = this;
        var programInfo = this.context.programInfo;
        var result = {};
        this.context.programInfo.samplers.forEach(function (name, i) {
            var layout = programInfo.inputLayouts[i];
            var shape = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;
            var rank = shape.length;
            var funcName = "_" + name;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(_this.getValueFromSingle(name, rank, layout.width, layout.height, false), ["shapeUtils.indicesToOffset" + funcName, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);
            funcName = funcName + '_T';
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(_this.getValueFromSingle(name, rank, layout.width, layout.height, true), ["shapeUtils.indicesToOffset" + funcName, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);
        });
        return result;
    };
    /**
     * Produces one value getter function for the name and rank given
     * If a transpose is set proper offsetToCoords mapping will be used
     * @param name name of the function
     * @param rank rank of the input
     * @param transpose whether or not should generate a transpose variation
     */
    CoordsGlslLib.prototype.getValueFromSingle = function (varName, rank, width, height, transpose) {
        var name = "_" + varName;
        if (transpose) {
            name = name + '_T';
        }
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        return "\n        float " + name + "(int m[" + rank + "]) {\n          int offset = indicesToOffset" + name + "(m);\n          vec2 coords = offsetToCoords(offset, " + width + ", " + height + ");\n          float value = getColorAsFloat(" + glsl.texture2D + "(" + varName + ", coords));\n          return value;\n        }\n        ";
    };
    /**
     * Produces a packed value getter function for the name and rank given
     * If a transpose is set proper offsetToCoords mapping will be used
     * @param name name of the function
     * @param rank rank of the input
     * @param transpose whether or not should generate a transpose variation
     */
    CoordsGlslLib.prototype.getPackedValueFrom = function (varName, rank, width, height, transpose) {
        var name = "_" + varName + "_Pack";
        if (transpose) {
            name = name + '_T';
        }
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        return "\n        vec4 " + name + "(int m[" + rank + "]) {\n          int offset = indicesToOffset_" + varName + "(m);\n          vec2 coords = offsetToCoords(offset, " + width + ", " + height + ");\n          return " + glsl.texture2D + "(" + varName + ", coords);\n        }\n        ";
    };
    return CoordsGlslLib;
}(glsl_definitions_1.GlslLib));
exports.CoordsGlslLib = CoordsGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-definitions.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-definitions.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TopologicalSortGlslRoutines = exports.GlslLibRoutineNode = exports.GlslLibRoutine = exports.GlslLib = exports.GlslContext = exports.FunctionType = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
var FunctionType;
(function (FunctionType) {
    FunctionType[FunctionType["ValueBased"] = 0] = "ValueBased";
    FunctionType[FunctionType["Positional"] = 1] = "Positional";
})(FunctionType = exports.FunctionType || (exports.FunctionType = {}));
var GlslContext = /** @class */ (function () {
    function GlslContext(glContext, programInfo) {
        this.glContext = glContext;
        this.programInfo = programInfo;
    }
    return GlslContext;
}());
exports.GlslContext = GlslContext;
var GlslLib = /** @class */ (function () {
    function GlslLib(context) {
        this.context = context;
    }
    return GlslLib;
}());
exports.GlslLib = GlslLib;
// abstraction to represent a GLSL library routine and it's dependencies
var GlslLibRoutine = /** @class */ (function () {
    function GlslLibRoutine(routineBody, dependencies) {
        this.routineBody = routineBody;
        this.dependencies = dependencies;
    }
    return GlslLibRoutine;
}());
exports.GlslLibRoutine = GlslLibRoutine;
// abstraction to represent a GLSL library routine and it's dependencies AS GRAPH Nodes
// this level of abstraction is used to topologically sort routines before fragment shade inclusion
var GlslLibRoutineNode = /** @class */ (function () {
    function GlslLibRoutineNode(name, routineBody, dependencies) {
        this.name = name;
        if (dependencies) {
            this.dependencies = dependencies;
        }
        else {
            this.dependencies = [];
        }
        if (routineBody) {
            this.routineBody = routineBody;
        }
    }
    GlslLibRoutineNode.prototype.addDependency = function (node) {
        if (node) {
            this.dependencies.push(node);
        }
    };
    return GlslLibRoutineNode;
}());
exports.GlslLibRoutineNode = GlslLibRoutineNode;
// topologically sort GLSL library routines (graph nodes abstraction) before shader script inclusion
var TopologicalSortGlslRoutines = /** @class */ (function () {
    function TopologicalSortGlslRoutines() {
    }
    TopologicalSortGlslRoutines.returnOrderedNodes = function (nodes) {
        if (!nodes || nodes.length === 0) {
            return [];
        }
        if (nodes.length === 1) {
            return nodes;
        }
        var cycleCheck = new Set();
        var alreadyTraversed = new Set();
        var result = new Array();
        this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);
        return result;
    };
    TopologicalSortGlslRoutines.createOrderedNodes = function (graphNodes, cycleCheck, alreadyTraversed, result) {
        for (var i = 0; i < graphNodes.length; ++i) {
            this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);
        }
    };
    TopologicalSortGlslRoutines.dfsTraverse = function (root, cycleCheck, alreadyTraversed, result) {
        // if this root has already been traversed return
        if (!root || alreadyTraversed.has(root.name)) {
            return;
        }
        // cyclic dependency has been detected
        if (cycleCheck.has(root.name)) {
            throw new Error('Cyclic dependency detected. Can\'t topologically sort routines needed for shader.');
        }
        // hold this node to detect cycles if any
        cycleCheck.add(root.name);
        // traverse children in a dfs fashion
        var dependencies = root.dependencies;
        if (dependencies && dependencies.length > 0) {
            for (var i = 0; i < dependencies.length; ++i) {
                this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);
            }
        }
        // add to result holder
        result.push(root);
        // mark this node as traversed so that we don't traverse from this again
        alreadyTraversed.add(root.name);
        // release the hold
        cycleCheck.delete(root.name);
    };
    return TopologicalSortGlslRoutines;
}());
exports.TopologicalSortGlslRoutines = TopologicalSortGlslRoutines;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EncodingGlslLib = void 0;
var glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
/**
 * This GLSL library handles routines converting
 * float32 to/from Unsigned byte or float 16
 */
var EncodingGlslLib = /** @class */ (function (_super) {
    __extends(EncodingGlslLib, _super);
    function EncodingGlslLib(context) {
        return _super.call(this, context) || this;
    }
    EncodingGlslLib.prototype.getFunctions = function () {
        return __assign(__assign({}, this.encodeFloat32()), this.decodeFloat32());
    };
    EncodingGlslLib.prototype.getCustomTypes = function () {
        return {};
    };
    EncodingGlslLib.prototype.encodeFloat32 = function () {
        return {
            encode: new glsl_definitions_1.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")
        };
    };
    EncodingGlslLib.prototype.decodeFloat32 = function () {
        return {
            decode: new glsl_definitions_1.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")
        };
    };
    /**
     * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)
     * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
     */
    EncodingGlslLib.prototype.encodeUint8 = function () {
        var endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';
        return {
            encode: new glsl_definitions_1.GlslLibRoutine("\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        " + endianness + "\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        ")
        };
    };
    /**
     * returns the routine to encode a vec4 of unsigned bytes to float32
     * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
     */
    EncodingGlslLib.prototype.decodeUint8 = function () {
        var endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';
        return {
            decode: new glsl_definitions_1.GlslLibRoutine("\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          " + endianness + "\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        ")
        };
    };
    /**
     * Determines if the machine is little endian or not
     * @credit: https://gist.github.com/TooTallNate/4750953
     */
    EncodingGlslLib.isLittleEndian = function () {
        var b = new ArrayBuffer(4);
        var a = new Uint32Array(b);
        var c = new Uint8Array(b);
        a[0] = 0xdeadbeef;
        if (c[0] === 0xef) {
            return true;
        }
        if (c[0] === 0xde) {
            return false;
        }
        throw new Error('unknown endianness');
    };
    return EncodingGlslLib;
}(glsl_definitions_1.GlslLib));
exports.EncodingGlslLib = EncodingGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts":
/*!*********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FragColorGlslLib = void 0;
var glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
var glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
/**
 * This GLSL library handles routines around reading a texlet and writing to it
 * Reading and writing could be more than just dealing with one channel
 * It may require encoding/decoding to/from 4 channels into one
 */
var FragColorGlslLib = /** @class */ (function (_super) {
    __extends(FragColorGlslLib, _super);
    function FragColorGlslLib(context) {
        return _super.call(this, context) || this;
    }
    FragColorGlslLib.prototype.getFunctions = function () {
        return __assign(__assign({}, this.setFragColor()), this.getColorAsFloat());
    };
    FragColorGlslLib.prototype.getCustomTypes = function () {
        return {};
    };
    FragColorGlslLib.prototype.setFragColor = function () {
        var glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        return {
            setFragColor: new glsl_definitions_1.GlslLibRoutine("\n        void setFragColor(float value) {\n            " + glsl.output + " = encode(value);\n        }\n        ", ['encoding.encode'])
        };
    };
    FragColorGlslLib.prototype.getColorAsFloat = function () {
        return {
            getColorAsFloat: new glsl_definitions_1.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ['encoding.decode'])
        };
    };
    return FragColorGlslLib;
}(glsl_definitions_1.GlslLib));
exports.FragColorGlslLib = FragColorGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-function-inliner.ts":
/*!************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-function-inliner.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceInlines = void 0;
var INLINE_FUNC_DEF_REGEX = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
var FUNC_CALL_REGEX = '(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;';
/**
 * GLSL preprocessor responsible for resolving @inline directives
 */
function replaceInlines(script) {
    var inlineDefs = {};
    var match;
    while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {
        var params = match[3]
            .split(',')
            .map(function (s) {
            var tokens = s.trim().split(' ');
            if (tokens && tokens.length === 2) {
                return { type: tokens[0], name: tokens[1] };
            }
            return null;
        })
            .filter(function (v) { return v !== null; });
        inlineDefs[match[2]] = { params: params, body: match[4] };
    }
    for (var name_1 in inlineDefs) {
        var regexString = FUNC_CALL_REGEX.replace('__FUNC__', name_1);
        var regex = new RegExp(regexString, 'gm');
        var _loop_1 = function () {
            var type = match[1];
            var variable = match[2];
            var params = match[3].split(',');
            var declLine = (type) ? type + " " + variable + ";" : '';
            var newBody = inlineDefs[name_1].body;
            var paramRedecLine = '';
            inlineDefs[name_1].params.forEach(function (v, i) {
                if (v) {
                    paramRedecLine += v.type + " " + v.name + " = " + params[i] + ";\n";
                }
            });
            newBody = paramRedecLine + "\n " + newBody;
            newBody = newBody.replace('return', variable + " = ");
            var replacement = "\n      " + declLine + "\n      {\n        " + newBody + "\n      }\n      ";
            script = script.replace(match[0], replacement);
        };
        while ((match = regex.exec(script)) !== null) {
            _loop_1();
        }
    }
    script = script.replace(INLINE_FUNC_DEF_REGEX, '');
    return script;
}
exports.replaceInlines = replaceInlines;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-preprocessor.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-preprocessor.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlslPreprocessor = void 0;
var glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
var glsl_function_inliner_1 = __webpack_require__(/*! ./glsl-function-inliner */ "./lib/onnxjs/backends/webgl/glsl-function-inliner.ts");
var glsl_registered_libs_1 = __webpack_require__(/*! ./glsl-registered-libs */ "./lib/onnxjs/backends/webgl/glsl-registered-libs.ts");
var glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
/**
 * Preprocessor for the additions to the GLSL language
 * It deals with:
 *  @include directives
 *  @inline
 *  Loop unrolling (not implemented)
 *  Macro resolution (not implemented)
 */
var GlslPreprocessor = /** @class */ (function () {
    function GlslPreprocessor(glContext, programInfo) {
        var _this = this;
        this.libs = {};
        this.glslLibRoutineDependencyGraph = {};
        this.context = new glsl_definitions_1.GlslContext(glContext, programInfo);
        // construct GlslLibs
        Object.keys(glsl_registered_libs_1.glslRegistry).forEach(function (name) {
            var lib = new glsl_registered_libs_1.glslRegistry[name](_this.context);
            _this.libs[name] = lib;
        });
        // construct GlslRoutineDependencyGraph
        var map = this.glslLibRoutineDependencyGraph;
        for (var libName in this.libs) {
            var lib = this.libs[libName];
            var routinesInLib = lib.getFunctions();
            for (var routine in routinesInLib) {
                var key = libName + '.' + routine;
                var currentNode = void 0;
                if (map[key]) {
                    currentNode = map[key];
                    currentNode.routineBody = routinesInLib[routine].routineBody;
                }
                else {
                    currentNode = new glsl_definitions_1.GlslLibRoutineNode(key, routinesInLib[routine].routineBody);
                    map[key] = currentNode;
                }
                var dependencies = routinesInLib[routine].dependencies;
                if (dependencies) {
                    for (var i = 0; i < dependencies.length; ++i) {
                        if (!map[dependencies[i]]) {
                            var node = new glsl_definitions_1.GlslLibRoutineNode(dependencies[i]);
                            map[dependencies[i]] = node;
                            currentNode.addDependency(node);
                        }
                        else {
                            currentNode.addDependency(map[dependencies[i]]);
                        }
                    }
                }
            }
        }
    }
    GlslPreprocessor.prototype.preprocess = function () {
        var programInfo = this.context.programInfo;
        var source = programInfo.shaderSource;
        // append main() function
        if (!this.context.programInfo.hasMain) {
            source = source + "\n      " + glsl_source_1.getDefaultFragShaderMain(this.context.glContext.version, programInfo.outputLayout.shape.length);
        }
        // replace inlines
        source = glsl_function_inliner_1.replaceInlines(source);
        // concat final source string
        return glsl_source_1.getFragShaderPreamble(this.context.glContext.version) + "\n    " + this.getUniforms(programInfo.samplers, programInfo.variables) + "\n    " + this.getImports(source) + "\n    " + source;
    };
    GlslPreprocessor.prototype.getImports = function (script) {
        var routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);
        if (routinesIncluded.length === 0) {
            return '';
        }
        var routines = '';
        for (var i = 0; i < routinesIncluded.length; ++i) {
            if (routinesIncluded[i].routineBody) {
                routines += routinesIncluded[i].routineBody + '\n';
            }
            else {
                throw new Error("Missing body for the Glsl Library routine: " + routinesIncluded[i].name);
            }
        }
        return routines;
    };
    GlslPreprocessor.prototype.selectGlslLibRoutinesToBeIncluded = function (script) {
        var _this = this;
        var nodes = [];
        Object.keys(this.glslLibRoutineDependencyGraph).forEach(function (classAndRoutine) {
            var routine = classAndRoutine.split('.')[1];
            if (script.indexOf(routine) !== -1) {
                nodes.push(_this.glslLibRoutineDependencyGraph[classAndRoutine]);
            }
        });
        return glsl_definitions_1.TopologicalSortGlslRoutines.returnOrderedNodes(nodes);
    };
    GlslPreprocessor.prototype.getUniforms = function (samplers, variables) {
        var e_1, _a, e_2, _b;
        var uniformLines = [];
        if (samplers) {
            try {
                for (var samplers_1 = __values(samplers), samplers_1_1 = samplers_1.next(); !samplers_1_1.done; samplers_1_1 = samplers_1.next()) {
                    var sampler = samplers_1_1.value;
                    uniformLines.push("uniform sampler2D " + sampler + ";");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (samplers_1_1 && !samplers_1_1.done && (_a = samplers_1.return)) _a.call(samplers_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (variables) {
            try {
                for (var variables_1 = __values(variables), variables_1_1 = variables_1.next(); !variables_1_1.done; variables_1_1 = variables_1.next()) {
                    var variable = variables_1_1.value;
                    uniformLines.push("uniform " + variable.type + " " + variable.name + (variable.arrayLength ? "[" + variable.arrayLength + "]" : '') + ";");
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (variables_1_1 && !variables_1_1.done && (_b = variables_1.return)) _b.call(variables_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return uniformLines.join('\n');
    };
    return GlslPreprocessor;
}());
exports.GlslPreprocessor = GlslPreprocessor;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-registered-libs.ts":
/*!***********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-registered-libs.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.glslRegistry = void 0;
var glsl_coordinate_lib_1 = __webpack_require__(/*! ./glsl-coordinate-lib */ "./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts");
var glsl_encoding_lib_1 = __webpack_require__(/*! ./glsl-encoding-lib */ "./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts");
var glsl_fragcolor_lib_1 = __webpack_require__(/*! ./glsl-fragcolor-lib */ "./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts");
var glsl_shape_utils_lib_1 = __webpack_require__(/*! ./glsl-shape-utils-lib */ "./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts");
var glsl_vec_lib_1 = __webpack_require__(/*! ./glsl-vec-lib */ "./lib/onnxjs/backends/webgl/glsl-vec-lib.ts");
exports.glslRegistry = {
    'encoding': glsl_encoding_lib_1.EncodingGlslLib,
    'fragcolor': glsl_fragcolor_lib_1.FragColorGlslLib,
    'vec': glsl_vec_lib_1.VecGlslLib,
    'shapeUtils': glsl_shape_utils_lib_1.ShapeUtilsGlslLib,
    'coordinates': glsl_coordinate_lib_1.CoordsGlslLib,
    //  'arrays': ArrayGlslSLib
};


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts":
/*!***********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShapeUtilsGlslLib = void 0;
var glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
/**
 * GLSL Library responsible for data types and routines for manipulating
 * coordinates and mapping to/from tensor indices
 */
var ShapeUtilsGlslLib = /** @class */ (function (_super) {
    __extends(ShapeUtilsGlslLib, _super);
    function ShapeUtilsGlslLib(context) {
        return _super.call(this, context) || this;
    }
    ShapeUtilsGlslLib.prototype.getFunctions = function () {
        return __assign(__assign(__assign(__assign(__assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
    };
    ShapeUtilsGlslLib.prototype.getCustomTypes = function () {
        return {};
    };
    ShapeUtilsGlslLib.prototype.bcastIndex = function () {
        var programInfo = this.context.programInfo;
        var outputRank = programInfo.outputLayout.shape.length;
        var result = {};
        this.context.programInfo.samplers.forEach(function (name, i) {
            var shape = programInfo.inputLayouts[i].shape;
            if (shape.length <= outputRank) {
                var rank = shape.length;
                var dimOffset = outputRank - rank;
                var funcName = "bcastIndices_" + name;
                var block = '';
                for (var i_1 = 0; i_1 < rank; ++i_1) {
                    block += "\n          realIndices[" + i_1 + "] = int( mod(float(bcastedIndices[" + (dimOffset + i_1) + "]), " + shape[i_1] + ".0) );\n          ";
                }
                var body = "\n        void " + funcName + " (int bcastedIndices[" + outputRank + "], out int realIndices[" + rank + "]) {\n          " + block + "\n        }\n        ";
                result[funcName] = new glsl_definitions_1.GlslLibRoutine(body);
            }
        });
        return result;
    };
    ShapeUtilsGlslLib.prototype.bcastMatmulIndex = function () {
        var programInfo = this.context.programInfo;
        var outputRank = programInfo.outputLayout.shape.length;
        var result = {};
        this.context.programInfo.samplers.forEach(function (name, i) {
            var shape = programInfo.inputLayouts[i].shape;
            if (!(shape.length < 2 || shape.length > outputRank)) {
                var rank = shape.length;
                var dimOffset = outputRank - rank;
                var funcName = "bcastMatmulIndices_" + name;
                var block = '';
                for (var i_2 = 0; i_2 < rank - 2; ++i_2) {
                    block += "\n          realIndices[" + i_2 + "] = int( mod(float(bcastedIndices[" + (dimOffset + i_2) + "]), " + shape[i_2] + ".0) );\n          ";
                }
                var body = "\n        void " + funcName + "(int bcastedIndices[" + outputRank + "], out int realIndices[" + rank + "]) {\n          " + block + "\n          realIndices[" + (rank - 1) + "] = bcastedIndices[" + (outputRank - 1) + "];\n          realIndices[" + (rank - 2) + "] = bcastedIndices[" + (outputRank - 2) + "];\n        }\n        ";
                result[funcName] = new glsl_definitions_1.GlslLibRoutine(body);
            }
        });
        return result;
    };
    ShapeUtilsGlslLib.prototype.indicesToOffset = function () {
        var programInfo = this.context.programInfo;
        var result = {};
        this.context.programInfo.samplers.forEach(function (name, i) {
            var shape = programInfo.inputLayouts[i].shape;
            var strides = programInfo.inputLayouts[i].strides;
            var rank = shape.length;
            var funcName = "indicesToOffset_" + name;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));
            funcName = "indicesToOffset_" + name + "_T";
            result[funcName] =
                new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
    };
    ShapeUtilsGlslLib.indexToOffsetSingle = function (name, rank, strides) {
        var block = '';
        for (var i = rank - 1; i >= 0; --i) {
            block += "\n        offset += indices[" + i + "] * " + strides[i] + ";\n        ";
        }
        return "\n      int " + name + "(int indices[" + rank + "]) {\n        int offset = 0;\n        " + block + "\n        return offset;\n      }\n      ";
    };
    ShapeUtilsGlslLib.prototype.offsetToIndices = function () {
        var programInfo = this.context.programInfo;
        var result = {};
        this.context.programInfo.samplers.forEach(function (name, i) {
            var shape = programInfo.inputLayouts[i].shape;
            var strides = programInfo.inputLayouts[i].strides;
            var rank = shape.length;
            var funcName = "offsetToIndices_" + name;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));
            funcName = "offsetToIndices_" + name + "_T";
            result[funcName] =
                new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
    };
    ShapeUtilsGlslLib.offsetToIndicesSingle = function (name, rank, strides) {
        var stridesBlock = [];
        for (var i = 0; i < rank - 1; ++i) {
            stridesBlock.push("\n      indices[" + i + "] = offset / " + strides[i] + ";");
            stridesBlock.push("\n        offset -= indices[" + i + "] * " + strides[i] + ";");
        }
        stridesBlock.push("\n      indices[" + (rank - 1) + "] = offset;");
        return "\n      void " + name + "(int offset, out int indices[" + rank + "]) {\n        " + stridesBlock.join('') + "\n      }\n      ";
    };
    ShapeUtilsGlslLib.prototype.incrementIndices = function () {
        var programInfo = this.context.programInfo;
        var result = {};
        this.context.programInfo.samplers.forEach(function (name, i) {
            var shape = programInfo.inputLayouts[i].shape;
            var rank = shape.length;
            var funcName = "incrementIndices_" + name;
            var shapeInit = '';
            for (var i_3 = 0; i_3 < rank; ++i_3) {
                shapeInit += "\n        shape[" + i_3 + "] = " + shape[i_3] + ";";
            }
            var body = "\n        void " + funcName + "(int axis, out int indices[" + rank + "]) {\n          int shape[" + rank + "];\n          " + shapeInit + ";\n          for(int i = " + rank + " -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        ";
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(body);
        });
        return result;
    };
    return ShapeUtilsGlslLib;
}(glsl_definitions_1.GlslLib));
exports.ShapeUtilsGlslLib = ShapeUtilsGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-source.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-source.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultFragShaderMain = exports.getFragShaderPreamble = exports.getVertexShaderSource = exports.getGlsl = void 0;
var GLSL_ES_2_0 = {
    version: '',
    attribute: 'attribute',
    varyingVertex: 'varying',
    varyingFrag: 'varying',
    texture2D: 'texture2D',
    output: 'gl_FragColor',
    outputDeclaration: '',
};
var GLSL_ES_3_0 = {
    version: '#version 300 es',
    attribute: 'in',
    varyingVertex: 'out',
    varyingFrag: 'in',
    texture2D: 'texture',
    output: 'outputColor',
    outputDeclaration: 'out vec4 outputColor;',
};
function getGlsl(version) {
    return version === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;
}
exports.getGlsl = getGlsl;
function getVertexShaderSource(version) {
    var glsl = getGlsl(version);
    return glsl.version + "\n      precision highp float;\n      " + glsl.attribute + " vec3 position;\n      " + glsl.attribute + " vec2 textureCoord;\n\n      " + glsl.varyingVertex + " vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }";
}
exports.getVertexShaderSource = getVertexShaderSource;
function getFragShaderPreamble(version) {
    var glsl = getGlsl(version);
    return glsl.version + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + glsl.varyingFrag + " vec2 TexCoords;\n    " + glsl.outputDeclaration + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    ";
}
exports.getFragShaderPreamble = getFragShaderPreamble;
function getDefaultFragShaderMain(version, outputShapeLength) {
    var glsl = getGlsl(version);
    return "\n  void main() {\n    int indices[" + outputShapeLength + "];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    " + glsl.output + " = result;\n  }\n  ";
}
exports.getDefaultFragShaderMain = getDefaultFragShaderMain;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-vec-lib.ts":
/*!***************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-vec-lib.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VecGlslLib = void 0;
var glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
/**
 * GLSL Library responsible for vec routines
 * Vec is an varible length int array. The length is fixed at the time of
 * generating the library functions from the dimensions of the output.
 */
var VecGlslLib = /** @class */ (function (_super) {
    __extends(VecGlslLib, _super);
    function VecGlslLib(context) {
        return _super.call(this, context) || this;
    }
    VecGlslLib.prototype.getCustomTypes = function () {
        return {};
    };
    VecGlslLib.prototype.getFunctions = function () {
        return __assign(__assign(__assign(__assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
    };
    VecGlslLib.prototype.binaryVecFunctions = function () {
        var outputLayout = this.context.programInfo.outputLayout;
        var rank = outputLayout.shape.length;
        var nameOp = { add: '+=', sub: '-=', mul: '*=', div: '/=' };
        var result = {};
        for (var name_1 in nameOp) {
            var fname = name_1 + "Vec";
            var assignmentBlock = '';
            for (var i = 0; i < rank; ++i) {
                assignmentBlock += "\n          dest[" + i + "] " + nameOp[name_1] + " src[" + i + "];\n          ";
            }
            var body = "\n        void " + fname + "(int src[" + rank + "], out int dest[" + rank + "]) {\n          " + assignmentBlock + "\n        }\n        ";
            result[fname] = new glsl_definitions_1.GlslLibRoutine(body);
        }
        return result;
    };
    VecGlslLib.prototype.copyVec = function () {
        var outputLayout = this.context.programInfo.outputLayout;
        var rank = outputLayout.shape.length;
        var assignmentBlock = '';
        for (var i = 0; i < rank; ++i) {
            assignmentBlock += "\n        dest[" + i + "] = src[" + i + "];\n        ";
        }
        var body = "\n      void copyVec(int src[" + rank + "], out int dest[" + rank + "]) {\n        " + assignmentBlock + "\n      }\n      ";
        return { copyVec: new glsl_definitions_1.GlslLibRoutine(body) };
    };
    VecGlslLib.prototype.setVecItem = function () {
        var outputLayout = this.context.programInfo.outputLayout;
        var rank = outputLayout.shape.length;
        var block = "\n        if(index < 0)\n            index =" + rank + " + index;\n        if (index == 0)\n            m[0] = value;\n        ";
        for (var i = 1; i < rank - 1; ++i) {
            block += "\n        else if (index == " + i + ")\n            m[" + i + "] = value;\n            ";
        }
        block += "\n        else\n            m[" + (rank - 1) + "] = value;\n        ";
        var body = "\n      void setVecItem(out int m[" + rank + "], int index, int value) {\n        " + block + "\n      }\n        ";
        return { setVecItem: new glsl_definitions_1.GlslLibRoutine(body) };
    };
    VecGlslLib.prototype.getVecItem = function () {
        var outputLayout = this.context.programInfo.outputLayout;
        var rank = outputLayout.shape.length;
        var block = "\n        if(index < 0)\n            index = " + rank + " + index;\n        if (index == 0)\n            return m[0];\n      ";
        for (var i = 1; i < rank - 1; ++i) {
            block += "\n        else if (index == " + i + ")\n            return m[" + i + "];\n      ";
        }
        block += "\n        else\n            return m[" + (rank - 1) + "];\n        ";
        var body = "\n      int getVecItem(int m[" + rank + "], int index) {\n        " + block + "\n      }\n    ";
        return { getVecItem: new glsl_definitions_1.GlslLibRoutine(body) };
    };
    return VecGlslLib;
}(glsl_definitions_1.GlslLib));
exports.VecGlslLib = VecGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/inference-handler.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/inference-handler.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLInferenceHandler = void 0;
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
var tensor_1 = __webpack_require__(/*! ../../tensor */ "./lib/onnxjs/tensor.ts");
var util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
var pack_1 = __webpack_require__(/*! ./ops/pack */ "./lib/onnxjs/backends/webgl/ops/pack.ts");
var uint8_encode_1 = __webpack_require__(/*! ./ops/uint8-encode */ "./lib/onnxjs/backends/webgl/ops/uint8-encode.ts");
var unpack_1 = __webpack_require__(/*! ./ops/unpack */ "./lib/onnxjs/backends/webgl/ops/unpack.ts");
var utils_1 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var WebGLInferenceHandler = /** @class */ (function () {
    function WebGLInferenceHandler(session) {
        this.session = session;
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache = new Map();
        this.pack2unpackMap = new Map();
        this.unpack2packMap = new Map();
    }
    WebGLInferenceHandler.prototype.run = function (op, inputs) {
        var _a;
        var artifact = this.session.programManager.getArtifact(op);
        if (!artifact) {
            var programInfo = op.createProgramInfo(this, inputs);
            if (!programInfo.name) {
                programInfo.name = (_a = op.constructor) === null || _a === void 0 ? void 0 : _a.name;
            }
            artifact = this.session.programManager.build(programInfo);
            this.session.programManager.setArtifact(op, artifact);
        }
        var runData = op.createRunData(this, artifact.programInfo, inputs);
        this.runProgram(artifact, runData);
        return [runData.outputTextureData.tensor];
    };
    WebGLInferenceHandler.prototype.checkAndUpdateTextureForm = function (artifact, runData) {
        // pack/unpack inputs
        for (var i = 0; i < runData.inputTextureDatas.length; ++i) {
            var input = runData.inputTextureDatas[i];
            if (input.isPacked && !artifact.programInfo.expectPackedInputs) {
                runData.inputTextureDatas[i] = this.unpack(input);
            }
            else if (!input.isPacked && artifact.programInfo.expectPackedInputs) {
                runData.inputTextureDatas[i] = this.pack(input);
            }
        }
    };
    WebGLInferenceHandler.prototype.runProgram = function (artifact, runData) {
        this.checkAndUpdateTextureForm(artifact, runData);
        // output should match
        if (!!runData.outputTextureData.isPacked !== !!artifact.programInfo.expectPackedOutputs) {
            throw new Error('output property packed inconsistent');
        }
        this.session.programManager.run(artifact, runData);
    };
    /**
     * Create a TextureData object from a tensor.
     * Usage = Encoder.Usage.UploadOnly.
     * If a related texture data is found in cache, returns it;
     * Otherwise:
     *   Creates a new texture layout if not provided;
     *   Creates WebGLTexture with the layout;
     *   Upload tensor data to the texture;
     *   Creates a texture data object associated with the given tensor.
     * @param tensor the tensor with data to upload
     */
    WebGLInferenceHandler.prototype.getOrCreateTextureData = function (tensor, layout, isPacked) {
        if (isPacked === void 0) { isPacked = false; }
        var td = this.getTextureData(tensor.dataId, isPacked);
        if (!td) {
            instrument_1.Logger.verbose('InferenceHandler', "Creating new TextureData for dims: [" + tensor.dims + "]");
            if (!layout) {
                layout = this.createTextureLayoutFromShape(tensor.dims.slice());
            }
            // if we don't find the texture data with specific pack mode in the cache, try with the different
            // pack mode to see if the tensor is cached using that pack mode. If succeed, we can return this
            // tensor data and later apply a pack/unpack op on this texture, no need to create a new one here.
            td = this.getTextureData(tensor.dataId, !isPacked);
            if (!td) {
                if (isPacked) {
                    var unpackedTextureLayout = this.getOrCreateTextureLayout(tensor, 1, false, [], true);
                    var unpackedTextureData = this.createTextureData(unpackedTextureLayout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
                    td = this.pack(unpackedTextureData);
                }
                else {
                    td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
                }
            }
        }
        else {
            instrument_1.Logger.verbose('InferenceHandler', "Retrieving TextureData from cache: [" + tensor.dims + "]");
        }
        return td;
    };
    /**
     * Create a TextureData object from the given data type and texture layout.
     * Usage = Encoder.Usage.Default.
     * @param dataType the tensor data type
     */
    WebGLInferenceHandler.prototype.createTextureDataFromLayout = function (layout, dataType) {
        return this.createTextureData(layout, dataType);
    };
    /**
     * Create a TextureData object using the given data and bind to the given tensor.
     * Usage = Encoder.Usage.UploadOnly.
     * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv
     * implementation by Graph.Transformer
     * @param dataType the tensor data type
     * @param data the actual data to upload
     * @param tensor the tensor to bind. tensor's data is ignored.
     */
    WebGLInferenceHandler.prototype.createTextureDataFromLayoutBindTensor = function (layout, dataType, data, tensor) {
        return this.createTextureData(layout, dataType, data, tensor, 1 /* UploadOnly */);
    };
    WebGLInferenceHandler.prototype.createTextureData = function (layout, dataType, data, tensor, usage) {
        instrument_1.Logger.verbose('InferenceHandler', "Creating TextureData: layout:[" + JSON.stringify(layout) + "]");
        var texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);
        return this.createTextureDataFromTexture(layout, dataType, texture, tensor);
    };
    /**
     * Create a TextureData object, using the given texture.
     * This function does not create new texture. Usually used in scenarios using texture sharing. (eg. Reshape)
     * @param dataType the tensor data type
     * @param texture the WebGLTexture object to share
     * @param tensorId the tensor ID of the shared tensor data
     */
    WebGLInferenceHandler.prototype.createSharedTextureData = function (layout, dataType, texture, tensorId) {
        return this.createTextureDataFromTexture(layout, dataType, texture, undefined, tensorId);
    };
    WebGLInferenceHandler.prototype.createTextureDataFromTexture = function (layout, dataType, texture, tensor, tensorId) {
        var _this = this;
        var textureData = __assign(__assign({}, layout), { tensor: tensor ||
                new tensor_1.Tensor(layout.unpackedShape, dataType, function (_id) { return _this.readTexture(textureData); }, undefined, undefined, tensorId), texture: texture });
        this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);
        return textureData;
    };
    WebGLInferenceHandler.prototype.getTextureData = function (tensorId, isPacked) {
        if (isPacked === void 0) { isPacked = false; }
        return this.session.isInitializer(tensorId) ?
            this.session.getTextureData(tensorId, isPacked) :
            isPacked ? this.packedTextureDataCache.get(tensorId) : this.unpackedTextureDataCache.get(tensorId);
    };
    WebGLInferenceHandler.prototype.setTextureData = function (tensorId, td, isPacked) {
        if (isPacked === void 0) { isPacked = false; }
        if (this.session.isInitializer(tensorId)) {
            this.session.setTextureData(tensorId, td, isPacked);
        }
        else {
            (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);
        }
    };
    WebGLInferenceHandler.prototype.isTextureLayoutCached = function (tensor, isPacked) {
        if (isPacked === void 0) { isPacked = false; }
        return !!this.getTextureData(tensor.dataId, isPacked);
    };
    /**
     * Create a TextureLayout object from a tensor. If a related texture data is found, returns the cached texture layout.
     */
    WebGLInferenceHandler.prototype.getOrCreateTextureLayout = function (tensor, channels, isPacked, unpackedShape, reverseWH) {
        if (channels === void 0) { channels = 1; }
        if (isPacked === void 0) { isPacked = false; }
        if (reverseWH === void 0) { reverseWH = false; }
        var td = this.getTextureData(tensor.dataId, isPacked);
        if (td) {
            return td;
        }
        return this.createTextureLayoutFromShape(channels === 1 || isPacked ? tensor.dims : utils_1.getPackedShape(tensor.dims), channels, unpackedShape, isPacked || reverseWH ? { isPacked: isPacked, reverseWH: reverseWH } : undefined);
    };
    /**
     * Create a TextureLayout object from shape.
     */
    WebGLInferenceHandler.prototype.createTextureLayoutFromShape = function (shape, channels, unpackedShape, prefs) {
        if (channels === void 0) { channels = 1; }
        var isPacked = !!(prefs && prefs.isPacked);
        var _a = __read(this.session.layoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape : shape, prefs), 2), texWidth = _a[0], texHeight = _a[1];
        var _b = __read([texWidth, texHeight], 2), width = _b[0], height = _b[1];
        if (prefs && prefs.reverseWH) {
            width = texHeight;
            height = texWidth;
        }
        var rank = shape.length;
        var inferredDims = shape.slice(0);
        if (rank === 0) {
            inferredDims = [1];
        }
        if (channels === 1) {
            // unpackedShape will take `shape` and not `inferredDims` so as to create a scalar Tensor if need be
            unpackedShape = shape;
        }
        else if (isPacked) {
            if (channels !== 4) {
                throw new Error('a packed texture must be 4-channel');
            }
            unpackedShape = shape;
            if (rank > 0) {
                inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);
            }
            if (rank > 1) {
                inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);
            }
        }
        else if (!unpackedShape) {
            throw new Error('Unpacked shape is needed when using channels > 1');
        }
        return {
            width: width,
            height: height,
            channels: channels,
            isPacked: isPacked,
            shape: inferredDims,
            strides: util_1.ShapeUtil.computeStrides(inferredDims),
            unpackedShape: unpackedShape,
            reversedWH: (prefs && prefs.reverseWH)
        };
    };
    WebGLInferenceHandler.prototype.dispose = function () {
        var _this = this;
        this.session.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach(function (td) { return _this.session.textureManager.releaseTexture(td); });
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache.forEach(function (td) { return _this.session.textureManager.releaseTexture(td); });
        this.unpackedTextureDataCache = new Map();
    };
    WebGLInferenceHandler.prototype.readTexture = function (textureData) {
        if (textureData.isPacked) {
            return this.readTexture(this.unpack(textureData));
        }
        if (!this.session.backend.glContext.isFloat32DownloadSupported) {
            var op = new uint8_encode_1.WebGLUint8Encode();
            var uint8TD = op.runInternal(this, textureData);
            return this.session.textureManager.readUint8TextureAsFloat(uint8TD);
        }
        return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);
    };
    WebGLInferenceHandler.prototype.pack = function (input) {
        var cachedId = this.unpack2packMap.get(input.tensor.dataId);
        if (cachedId) {
            return this.packedTextureDataCache.get(cachedId);
        }
        var key = "" + input.shape;
        var op = this.session.packOpCache.get(key);
        if (!op) {
            op = new pack_1.WebGLPack();
            this.session.packOpCache.set(key, op);
        }
        var artifact = this.session.programManager.getArtifact(op);
        if (!artifact) {
            var programInfo = op.createProgramInfo(this, [input.tensor]);
            artifact = this.session.programManager.build(programInfo);
            this.session.programManager.setArtifact(op, artifact);
        }
        var runData = op.createRunData(this, artifact.programInfo, [input.tensor]);
        this.runProgram(artifact, runData);
        this.unpack2packMap.set(input.tensor.dataId, runData.outputTextureData.tensor.dataId);
        return runData.outputTextureData;
    };
    WebGLInferenceHandler.prototype.unpack = function (input) {
        var cachedId = this.pack2unpackMap.get(input.tensor.dataId);
        if (cachedId) {
            return this.unpackedTextureDataCache.get(cachedId);
        }
        // For unpacked kernel, cache it by using input's unpackedShape as cache key.
        // Note that we need to use input.unpackedShape instead of input.shape here,
        // as the shape infers the packed texture shape. Different unpackedShape can have the
        // same packed texture shape. For example, for unpacked shape, both [2, 3] and
        // [2, 4] has the same packed shape [1, 2], but those two shapes should have different
        // unpack shaders.
        var key = "" + input.unpackedShape;
        var op = this.session.unpackOpCache.get(key);
        if (!op) {
            op = new unpack_1.WebGLUnpack();
            this.session.unpackOpCache.set(key, op);
        }
        var artifact = this.session.programManager.getArtifact(op);
        if (!artifact) {
            var programInfo = op.createProgramInfo(this, [input.tensor]);
            artifact = this.session.programManager.build(programInfo);
            this.session.programManager.setArtifact(op, artifact);
        }
        var runData = op.createRunData(this, artifact.programInfo, [input.tensor]);
        this.runProgram(artifact, runData);
        this.pack2unpackMap.set(input.tensor.dataId, runData.outputTextureData.tensor.dataId);
        return runData.outputTextureData;
    };
    return WebGLInferenceHandler;
}());
exports.WebGLInferenceHandler = WebGLInferenceHandler;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/op-resolve-rules.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/op-resolve-rules.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WEBGL_OP_RESOLVE_RULES = void 0;
var operators_1 = __webpack_require__(/*! ../../operators */ "./lib/onnxjs/operators.ts");
var batch_normalization_1 = __webpack_require__(/*! ./ops/batch-normalization */ "./lib/onnxjs/backends/webgl/ops/batch-normalization.ts");
var binaryOps = __importStar(__webpack_require__(/*! ./ops/binary-op */ "./lib/onnxjs/backends/webgl/ops/binary-op.ts"));
var clip_1 = __webpack_require__(/*! ./ops/clip */ "./lib/onnxjs/backends/webgl/ops/clip.ts");
var concat_1 = __webpack_require__(/*! ./ops/concat */ "./lib/onnxjs/backends/webgl/ops/concat.ts");
var conv_1 = __webpack_require__(/*! ./ops/conv */ "./lib/onnxjs/backends/webgl/ops/conv.ts");
var depth_to_space_1 = __webpack_require__(/*! ./ops/depth-to-space */ "./lib/onnxjs/backends/webgl/ops/depth-to-space.ts");
var dropout_1 = __webpack_require__(/*! ./ops/dropout */ "./lib/onnxjs/backends/webgl/ops/dropout.ts");
var elu_1 = __webpack_require__(/*! ./ops/elu */ "./lib/onnxjs/backends/webgl/ops/elu.ts");
var flatten_1 = __webpack_require__(/*! ./ops/flatten */ "./lib/onnxjs/backends/webgl/ops/flatten.ts");
var gather_1 = __webpack_require__(/*! ./ops/gather */ "./lib/onnxjs/backends/webgl/ops/gather.ts");
var gemm_1 = __webpack_require__(/*! ./ops/gemm */ "./lib/onnxjs/backends/webgl/ops/gemm.ts");
var image_scaler_1 = __webpack_require__(/*! ./ops/image-scaler */ "./lib/onnxjs/backends/webgl/ops/image-scaler.ts");
var instance_normalization_1 = __webpack_require__(/*! ./ops/instance-normalization */ "./lib/onnxjs/backends/webgl/ops/instance-normalization.ts");
var leaky_relu_1 = __webpack_require__(/*! ./ops/leaky-relu */ "./lib/onnxjs/backends/webgl/ops/leaky-relu.ts");
var matmul_1 = __webpack_require__(/*! ./ops/matmul */ "./lib/onnxjs/backends/webgl/ops/matmul.ts");
var pad_1 = __webpack_require__(/*! ./ops/pad */ "./lib/onnxjs/backends/webgl/ops/pad.ts");
var pool_1 = __webpack_require__(/*! ./ops/pool */ "./lib/onnxjs/backends/webgl/ops/pool.ts");
var reduceOps = __importStar(__webpack_require__(/*! ./ops/reduce */ "./lib/onnxjs/backends/webgl/ops/reduce.ts"));
var reshape_1 = __webpack_require__(/*! ./ops/reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
var resize_packed_1 = __webpack_require__(/*! ./ops/resize-packed */ "./lib/onnxjs/backends/webgl/ops/resize-packed.ts");
var shape_1 = __webpack_require__(/*! ./ops/shape */ "./lib/onnxjs/backends/webgl/ops/shape.ts");
var slice_1 = __webpack_require__(/*! ./ops/slice */ "./lib/onnxjs/backends/webgl/ops/slice.ts");
var softmax_1 = __webpack_require__(/*! ./ops/softmax */ "./lib/onnxjs/backends/webgl/ops/softmax.ts");
var split_1 = __webpack_require__(/*! ./ops/split */ "./lib/onnxjs/backends/webgl/ops/split.ts");
var squeeze_1 = __webpack_require__(/*! ./ops/squeeze */ "./lib/onnxjs/backends/webgl/ops/squeeze.ts");
var sum_1 = __webpack_require__(/*! ./ops/sum */ "./lib/onnxjs/backends/webgl/ops/sum.ts");
var tile_1 = __webpack_require__(/*! ./ops/tile */ "./lib/onnxjs/backends/webgl/ops/tile.ts");
var transpose_1 = __webpack_require__(/*! ./ops/transpose */ "./lib/onnxjs/backends/webgl/ops/transpose.ts");
var unaryOps = __importStar(__webpack_require__(/*! ./ops/unary-op */ "./lib/onnxjs/backends/webgl/ops/unary-op.ts"));
var unsqueeze_1 = __webpack_require__(/*! ./ops/unsqueeze */ "./lib/onnxjs/backends/webgl/ops/unsqueeze.ts");
var upsample_1 = __webpack_require__(/*! ./ops/upsample */ "./lib/onnxjs/backends/webgl/ops/upsample.ts");
exports.WEBGL_OP_RESOLVE_RULES = [
    ['Abs', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.NUMBER_TYPES, unaryOps.glslAbs()); }],
    ['Acos', '', '7+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslAcos()); }],
    ['Add', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslAdd()); }],
    ['And', '', '7+', function () { return new binaryOps.WebGLBinaryOp(['bool'], binaryOps.glslAnd()); }],
    ['Asin', '', '7+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslAsin()); }],
    ['Atan', '', '7+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslAtan()); }],
    ['AveragePool', '', '7-10', function () { return new pool_1.WebGLAveragePool(); }],
    ['BatchNormalization', '', '7+', function () { return new batch_normalization_1.WebGLBatchNormalization(); }],
    ['Ceil', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslCeil()); }],
    ['Clip', '', '6-10', function () { return new clip_1.WebGLClip(); }],
    ['Concat', '', '4+', function () { return new concat_1.WebGLConcat(); }],
    ['Conv', '', '1+', function () { return new conv_1.WebGLConv(); }],
    ['Cos', '', '7+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslCos()); }],
    ['Div', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslDiv()); }],
    ['Dropout', '', '7+', function () { return new dropout_1.WebGLDropout(); }],
    ['DepthToSpace', '', '1+', function () { return new depth_to_space_1.WebGLDepthToSpace(); }],
    ['Equal', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslEqual(), undefined, 'bool'); }],
    ['Elu', '', '6+', function () { return new elu_1.WebGLElu(); }],
    ['Exp', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslExp()); }],
    ['Flatten', '', '1+', function () { return new flatten_1.WebGLFlatten(); }],
    ['Floor', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslFloor()); }],
    ['Gather', '', '1+', function () { return new gather_1.WebGLGather(); }],
    ['Gemm', '', '7-10', function () { return new gemm_1.WebGLGemm(false); }],
    ['Gemm', '', '11+', function () { return new gemm_1.WebGLGemm(true); }],
    ['GlobalAveragePool', '', '1+', function () { return new pool_1.WebGLGlobalAveragePool(); }],
    ['GlobalMaxPool', '', '1+', function () { return new pool_1.WebGLGlobalMaxPool(); }],
    ['Greater', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslGreater(), undefined, 'bool'); }],
    ['Identity', '', '1+', function () { return new unaryOps.WebGLUnaryOp(operators_1.NUMBER_TYPES, unaryOps.glslIdentity()); }],
    ['ImageScaler', '', '1+', function () { return new image_scaler_1.WebGLImageScaler(); }],
    ['InstanceNormalization', '', '6+', function () { return new instance_normalization_1.WebGLInstanceNormalization(); }],
    ['LeakyRelu', '', '6+', function () { return new leaky_relu_1.WebGLLeakyRelu(); }],
    ['Less', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslLess(), undefined, 'bool'); }],
    ['Log', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslLog()); }],
    ['MatMul', '', '1+', function () { return new matmul_1.WebGLMatMul(); }],
    ['MaxPool', '', '1-9', function () { return new pool_1.WebGLMaxPool(); }],
    ['Mul', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslMul()); }],
    ['Neg', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.NUMBER_TYPES, unaryOps.glslNeg()); }],
    ['Not', '', '1+', function () { return new unaryOps.WebGLUnaryOp(['bool'], unaryOps.glslNot()); }],
    ['Or', '', '7+', function () { return new binaryOps.WebGLBinaryOp(['bool'], binaryOps.glslOr()); }],
    ['Pad', '', '2-10', function () { return new pad_1.WebGLPad(); }],
    ['Pow', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.FLOAT_TYPES, binaryOps.glslPow()); }],
    ['PRelu', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.FLOAT_TYPES, binaryOps.glslPRelu()); }],
    ['ReduceLogSum', '', '1+', function () { return new reduceOps.WebGLReduceLogSum(); }],
    ['ReduceMax', '', '1+', function () { return new reduceOps.WebGLReduceMax(); }],
    ['ReduceMean', '', '1+', function () { return new reduceOps.WebGLReduceMean(); }],
    ['ReduceMin', '', '1+', function () { return new reduceOps.WebGLReduceMin(); }],
    ['ReduceProd', '', '1+', function () { return new reduceOps.WebGLReduceProd(); }],
    ['ReduceSum', '', '1+', function () { return new reduceOps.WebGLReduceSum(); }],
    ['ReduceSumSquare', '', '1+', function () { return new reduceOps.WebGLReduceSumSquare(); }],
    ['Relu', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslRelu()); }],
    ['Reshape', '', '5+', function () { return new reshape_1.WebGLReshape(); }],
    ['Resize', '', '10', function () { return new resize_packed_1.WebGLResizePacked(10); }],
    ['Resize', '', '11+', function () { return new resize_packed_1.WebGLResizePacked(11); }],
    ['Shape', '', '1+', function () { return new shape_1.WebGLShape(); }],
    ['Sigmoid', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslSigmoid()); }],
    ['Sin', '', '7+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslSin()); }],
    ['Slice', '', '10+', function () { return new slice_1.WebGLSliceV10(); }],
    ['Slice', '', '1-9', function () { return new slice_1.WebGLSlice(); }],
    ['Softmax', '', '1+', function () { return new softmax_1.WebGLSoftmax(); }],
    // 'Split' operator has an optional attribute 'split'
    // this attribute determines how the specified axis of input data
    // is split. When the attribute is missing, we need the count of number of outputs
    // so that we can determine the 'split' attribute from the runtime input to the Operator
    ['Split', '', '2+', function (node) { return new split_1.WebGLSplit(node.outputs.length); }],
    ['Sqrt', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslSqrt()); }],
    ['Squeeze', '', '1+', function () { return new squeeze_1.WebGLSqueeze(); }],
    ['Sub', '', '7+', function () { return new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslSub()); }],
    ['Sum', '', '6+', function () { return new sum_1.WebGLSum(); }],
    ['Tan', '', '7+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslTan()); }],
    ['Tanh', '', '6+', function () { return new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslTanh()); }],
    ['Tile', '', '6+', function () { return new tile_1.WebGLTile(); }],
    ['Transpose', '', '1+', function () { return new transpose_1.WebGLTranspose(); }],
    ['Upsample', '', '7-8', function () { return new upsample_1.WebGLUpsample(7); }],
    ['Upsample', '', '9', function () { return new upsample_1.WebGLUpsample(9); }],
    ['Unsqueeze', '', '1+', function () { return new unsqueeze_1.WebGLUnsqueeze(); }],
    ['Xor', '', '7+', function () { return new binaryOps.WebGLBinaryOp(['bool'], binaryOps.glslXor()); }],
];


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/batch-normalization.ts":
/*!**************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/batch-normalization.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLBatchNormalization = void 0;
var batch_normalization_1 = __webpack_require__(/*! ../../../ops/batch-normalization */ "./lib/onnxjs/ops/batch-normalization.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLBatchNormalization = /** @class */ (function (_super) {
    __extends(WebGLBatchNormalization, _super);
    function WebGLBatchNormalization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLBatchNormalization.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLBatchNormalization.prototype.createProgramInfo = function (handler, inputs) {
        var inputLayouts = inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); });
        var outputShape = inputs[0].dims.slice();
        var rank = outputShape.length;
        var scale = inputLayouts[1];
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n      float process(int[" + rank + "] indices) {\n        vec2 position = offsetToCoords(indices[1], " + scale.width + ", " + scale.height + ");\n        float scale = getColorAsFloat(" + glsl.texture2D + "(Scale, position));\n        float mean = getColorAsFloat(" + glsl.texture2D + "(Mean, position));\n        float variance = getColorAsFloat(" + glsl.texture2D + "(Variance, position));\n        float b = getColorAsFloat(" + glsl.texture2D + "(B, position));\n\n        return scale * ( (_A(indices) - mean) / sqrt(variance + float(" + this.epsilon + ")) ) + b;\n      }";
        return {
            inputLayouts: inputLayouts,
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'Scale', 'B', 'Mean', 'Variance'],
            shaderSource: shaderSource
        };
    };
    WebGLBatchNormalization.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        inputs.slice(1).forEach(function (t) { return inputTDs.push(handler.getOrCreateTextureData(t)); });
        var outputTD = handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type);
        return { inputTextureDatas: inputTDs, outputTextureData: outputTD, uniformData: {} };
    };
    return WebGLBatchNormalization;
}(batch_normalization_1.BatchNormalization));
exports.WebGLBatchNormalization = WebGLBatchNormalization;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/binary-op.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/binary-op.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.glslPRelu = exports.glslPow = exports.glslXor = exports.glslOr = exports.glslAnd = exports.glslLess = exports.glslGreater = exports.glslEqual = exports.glslSub = exports.glslMul = exports.glslDiv = exports.glslAdd = exports.WebGLBinaryOp = void 0;
var binary_op_1 = __webpack_require__(/*! ../../../ops/binary-op */ "./lib/onnxjs/ops/binary-op.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_definitions_1 = __webpack_require__(/*! ../glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLBinaryOp = /** @class */ (function (_super) {
    __extends(WebGLBinaryOp, _super);
    function WebGLBinaryOp(typeConstraint, glslFunc, opType, resultType) {
        var _this = _super.call(this, typeConstraint, opType, resultType) || this;
        _this.glslFunc = glslFunc;
        return _this;
    }
    WebGLBinaryOp.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLBinaryOp.prototype.createProgramInfo = function (handler, inputs) {
        var isBroadcast = !util_1.ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
        // TODO fix bcast in packed mode.
        if (this.usePackedTexture === undefined) {
            this.usePackedTexture = !isBroadcast && handler.session.pack;
        }
        var inputLayouts = this.usePackedTexture ?
            inputs.map(function (t) { return handler.getOrCreateTextureLayout(t, 4, true, t.dims, true); }) :
            inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); });
        var ouputLayout = this.usePackedTexture ?
            handler.createTextureLayoutFromShape(inputs[0].dims, 4, inputs[0].dims, { isPacked: true, reverseWH: true }) :
            handler.createTextureLayoutFromShape(inputs[0].dims);
        if (isBroadcast) {
            var outputShape = util_1.BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);
            if (!outputShape) {
                throw new Error('Can\'t perform binary op on the given tensors');
            }
            var outputRank = outputShape.length;
            var aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;
            var bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;
            var aBcast = inputs[0].dims.length !== 0 ? 'bcastIndices_A(indices, aindices);' : 'aindices[0] = 0;';
            var bBcast = inputs[1].dims.length !== 0 ? 'bcastIndices_B(indices, bindices);' : 'bindices[0] = 0;';
            // TODO: for packed tensors, we need to implement logic to caculate textCoords for broadcast tensor
            var shaderSource_1 = "\n      " + this.glslFunc.body + "\n      float process(int indices[" + outputRank + "]) {\n        int aindices[" + aRank + "];\n        int bindices[" + bRank + "];\n        " + aBcast + "\n        " + bBcast + "\n        return " + this.glslFunc.name + "(_A(aindices), _B(bindices));\n    }";
            var outputLayout = this.usePackedTexture ?
                handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }) :
                handler.createTextureLayoutFromShape(outputShape);
            return {
                inputLayouts: inputLayouts,
                outputLayout: outputLayout,
                samplers: ['A', 'B'],
                shaderSource: shaderSource_1,
                expectPackedInputs: this.usePackedTexture,
                expectPackedOutputs: this.usePackedTexture
            };
        }
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n    " + this.glslFunc.body + "\n    void main() {\n      vec4 v1 = " + glsl.texture2D + "(A, TexCoords);\n      vec4 v2 = " + glsl.texture2D + "(B, TexCoords);\n      vec4 result = " + this.glslFunc.name + "(v1, v2);\n      " + glsl.output + " = result;\n    }\n    ";
        if (this.usePackedTexture) {
            return {
                hasMain: true,
                inputLayouts: inputLayouts,
                outputLayout: ouputLayout,
                samplers: ['A', 'B'],
                shaderSource: shaderSource,
                expectPackedInputs: true,
                expectPackedOutputs: true
            };
        }
        else {
            return {
                hasMain: true,
                inputLayouts: inputLayouts,
                outputLayout: handler.createTextureLayoutFromShape(inputs[0].dims),
                samplers: ['A', 'B'],
                shaderSource: shaderSource,
            };
        }
    };
    WebGLBinaryOp.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = this.usePackedTexture ?
            inputs.map(function (t) { return handler.getOrCreateTextureData(t, handler.getOrCreateTextureLayout(t, 1, false, [], true)); }) :
            inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, this.resultType ? this.resultType : inputs[0].type),
            uniformData: {}
        };
    };
    return WebGLBinaryOp;
}(binary_op_1.BinaryOp));
exports.WebGLBinaryOp = WebGLBinaryOp;
function glslAdd() {
    var name = 'add_';
    var body = "\n  float " + name + "(float a, float b) {\n    return a + b;\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslAdd = glslAdd;
function glslDiv() {
    var name = 'div_';
    var body = "\n  float " + name + "(float a, float b) {\n    return a / b;\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslDiv = glslDiv;
function glslMul() {
    var name = 'mul_';
    var body = "\n  float " + name + "(float a, float b) {\n    return a * b;\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslMul = glslMul;
function glslSub() {
    var name = 'sub_';
    var body = "\n  float " + name + "(float a, float b) {\n    return a - b;\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslSub = glslSub;
function glslEqual() {
    var name = 'equal_';
    var body = "\n  float " + name + "(float a, float b) {\n    return float(a == b);\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslEqual = glslEqual;
function glslGreater() {
    var name = 'greater_';
    var body = "\n  float " + name + "(float a, float b) {\n    return float(a > b);\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslGreater = glslGreater;
function glslLess() {
    var name = 'less_';
    var body = "\n  float " + name + "(float a, float b) {\n    return float(a < b);\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslLess = glslLess;
function glslAnd() {
    var name = 'and_';
    var body = "\n  float " + name + "(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslAnd = glslAnd;
function glslOr() {
    var name = 'or_';
    var body = "\n  float " + name + "(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslOr = glslOr;
function glslXor() {
    var name = 'xor_';
    var body = "\n  float " + name + "(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslXor = glslXor;
function glslPow() {
    return glslBuiltinBinary('pow');
}
exports.glslPow = glslPow;
function glslPRelu() {
    var name = 'prelu_';
    var body = "\n  float " + name + "(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslPRelu = glslPRelu;
function glslBuiltinBinary(fname) {
    var name = fname + "_";
    var body = "\n  float " + name + "(float a, float b) {\n    return " + fname + "(a, b);\n  }\n  vec4 " + name + "(vec4 v1, vec4 v2) {\n    return " + fname + "(v1, v2);\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/clip.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/clip.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLClip = void 0;
var clip_1 = __webpack_require__(/*! ../../../ops/clip */ "./lib/onnxjs/ops/clip.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLClip = /** @class */ (function (_super) {
    __extends(WebGLClip, _super);
    function WebGLClip() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLClip.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLClip.prototype.createProgramInfo = function (handler, inputs) {
        var outputShape = inputs[0].dims.slice();
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n      const float min = float(" + this.min + ");\n      const float max = float(" + this.max + ");\n      void main() {\n        float v = " + glsl.texture2D + "(A, TexCoords).r;\n        " + glsl.output + " = vec4(clamp(v, min, max));\n      }\n      ";
        return {
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
            hasMain: true,
        };
    };
    WebGLClip.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLClip;
}(clip_1.Clip));
exports.WebGLClip = WebGLClip;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/concat-packed.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/concat-packed.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLPackedConcat = void 0;
var concat_1 = __webpack_require__(/*! ../../../ops/concat */ "./lib/onnxjs/ops/concat.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
var WebGLPackedConcat = /** @class */ (function (_super) {
    __extends(WebGLPackedConcat, _super);
    function WebGLPackedConcat() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLPackedConcat.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLPackedConcat.prototype.createProgramInfo = function (handler, inputs) {
        var inputShape = inputs[0].dims.slice();
        if (this.axis >= inputShape.length || this.axis < (-1 * inputShape.length)) {
            throw new Error('axis specified for concat doesn\'t match input dimensionality');
        }
        if (this.axis < 0) {
            this.axis = inputShape.length + this.axis;
        }
        // ensure all of the non-concatenated axes match each other
        // calculate the shape of the output tensor while we do that
        var outputShape = inputShape.slice(0);
        for (var i = 1; i < inputs.length; i++) {
            var dataNShape = inputs[i].dims.slice();
            for (var axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
                // add to the placeholder for computing output shape
                if (axisIndex === this.axis) {
                    outputShape[this.axis] += dataNShape[axisIndex];
                }
                // ensure all non-cancatenated axes match each other
                else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
                    throw new Error('non concat dimensions must match');
                }
            }
        }
        var rank = outputShape.length;
        var coords = packing_utils_1.getChannels('coords', rank);
        var dtype = utils_1.getCoordsDataType(rank);
        var unpackChannel = packing_utils_1.unpackFromChannel();
        var shapes = inputs.map(function (i) { return i.dims; });
        var allGlChannels = ['x', 'y', 'z', 'w', 'u', 'v'];
        var channels = allGlChannels.slice(0, rank);
        var offsets = new Array(shapes.length - 1);
        var samplers = inputs.map(function (v, i) { return "X" + i; });
        offsets[0] = shapes[0][this.axis];
        for (var i = 1; i < offsets.length; i++) {
            offsets[i] = offsets[i - 1] + shapes[i][this.axis];
        }
        var channel = channels[this.axis];
        var lastChannels = channels.slice(-2);
        var allChannels = channels.join();
        var getValueSnippet = "if (" + channel + " < " + offsets[0] + ") {\n      return getChannel(\n          getX0(" + allChannels + "), vec2(" + lastChannels.join() + "));\n      }";
        for (var i = 1; i < offsets.length; i++) {
            var shift_1 = offsets[i - 1];
            getValueSnippet += "\n          if (" + channel + " < " + offsets[i] + "  && " + channel + " >= " + offsets[i - 1] + ") {\n            return getChannel(\n              getX" + i + "(" + this.getShiftedChannelsSnippet(channels, channel, shift_1) + "),\n              vec2(" + this.getShiftedChannelsSnippet(lastChannels, channel, shift_1) + "));\n          }";
        }
        var lastIndex = offsets.length;
        var shift = offsets[offsets.length - 1];
        getValueSnippet += "\n          return getChannel(\n            getX" + lastIndex + "(" + this.getShiftedChannelsSnippet(channels, channel, shift) + "),\n            vec2(" + this.getShiftedChannelsSnippet(lastChannels, channel, shift) + "));";
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n        " + unpackChannel + "\n        float getValue(" + channels.map(function (x) { return 'int ' + x; }) + ") {\n          " + getValueSnippet + "\n        }\n\n        void main() {\n          " + dtype + " coords = getOutputCoords();\n          int lastDim = coords." + allGlChannels[rank - 1] + ";\n          coords." + allGlChannels[rank - 1] + " = coords." + allGlChannels[rank - 2] + ";\n          coords." + allGlChannels[rank - 2] + " = lastDim;\n\n          vec4 result = vec4(getValue(" + coords + "), 0., 0., 0.);\n\n          " + coords[rank - 1] + " = " + coords[rank - 1] + " + 1;\n          if (" + coords[rank - 1] + " < " + outputShape[rank - 1] + ") {\n            result.g = getValue(" + coords + ");\n          }\n\n          " + coords[rank - 2] + " = " + coords[rank - 2] + " + 1;\n          if (" + coords[rank - 2] + " < " + outputShape[rank - 2] + ") {\n            result.a = getValue(" + coords + ");\n          }\n\n          " + coords[rank - 1] + " = " + coords[rank - 1] + " - 1;\n          if (" + coords[rank - 2] + " < " + outputShape[rank - 2] + " &&\n              " + coords[rank - 1] + " < " + outputShape[rank - 1] + ") {\n            result.b = getValue(" + coords + ");\n          }\n          " + glsl.output + " = result;\n        }\n      ";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t, 4, true, t.dims, true); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }),
            samplers: samplers,
            shaderSource: shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true
        };
    };
    WebGLPackedConcat.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i], true); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    /**
     * Generates the snippet to shift a given channel in a list of channels by shift
     *
     * i.e: returns a string of the form 'x, y-[shift], z' where any one channel can
     * have the shift applied.
     */
    WebGLPackedConcat.prototype.getShiftedChannelsSnippet = function (channels, channel, shift) {
        var channelIdx = channels.indexOf(channel);
        var res = channels.map(function (c, idx) {
            if (idx === channelIdx) {
                return c + " - " + shift;
            }
            else {
                return c;
            }
        });
        return res.join();
    };
    return WebGLPackedConcat;
}(concat_1.Concat));
exports.WebGLPackedConcat = WebGLPackedConcat;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/concat.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/concat.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnpackedConcat = exports.WebGLConcat = void 0;
var concat_1 = __webpack_require__(/*! ../../../ops/concat */ "./lib/onnxjs/ops/concat.ts");
var concat_packed_1 = __webpack_require__(/*! ./concat-packed */ "./lib/onnxjs/backends/webgl/ops/concat-packed.ts");
// We provide a wrapper class so that the kernel can switch between packed and unpacked depending on the inputs on the
// fly.
var WebGLConcat = /** @class */ (function (_super) {
    __extends(WebGLConcat, _super);
    function WebGLConcat() {
        var _this = _super.call(this) || this;
        _this.unpackedImpl = new WebGLUnpackedConcat();
        _this.packedImpl = new concat_packed_1.WebGLPackedConcat();
        return _this;
    }
    // No need to call super since this class only serves as a wrapper.
    WebGLConcat.prototype.initialize = function (attributes) {
        this.unpackedImpl.initialize(attributes);
        this.packedImpl.initialize(attributes);
    };
    WebGLConcat.prototype.run = function (inferenceHandler, inputs) {
        if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {
            return inferenceHandler.run(this.packedImpl, inputs);
        }
        else {
            return inferenceHandler.run(this.unpackedImpl, inputs);
        }
    };
    WebGLConcat.prototype.createProgramInfo = function (handler, inputs) {
        if (handler.session.pack && inputs[0].dims.length > 1) {
            return this.packedImpl.createProgramInfo(handler, inputs);
        }
        else {
            return this.unpackedImpl.createProgramInfo(handler, inputs);
        }
    };
    WebGLConcat.prototype.createRunData = function (handler, programInfo, inputs) {
        if (handler.session.pack && inputs[0].dims.length > 1) {
            return this.packedImpl.createRunData(handler, programInfo, inputs);
        }
        else {
            return this.unpackedImpl.createRunData(handler, programInfo, inputs);
        }
    };
    return WebGLConcat;
}(concat_1.Concat));
exports.WebGLConcat = WebGLConcat;
var WebGLUnpackedConcat = /** @class */ (function (_super) {
    __extends(WebGLUnpackedConcat, _super);
    function WebGLUnpackedConcat() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLUnpackedConcat.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLUnpackedConcat.prototype.createProgramInfo = function (handler, inputs) {
        var inputShape = inputs[0].dims.slice();
        if (this.axis >= inputShape.length || this.axis < (-1 * inputShape.length)) {
            throw new Error('axis specified for concat doesn\'t match input dimensionality');
        }
        if (this.axis < 0) {
            this.axis = inputShape.length + this.axis;
        }
        // ensure all of the non-concatenated axes match each other
        // calculate the shape of the output tensor while we do that
        var outputShape = inputShape.slice(0);
        for (var i = 1; i < inputs.length; i++) {
            var dataNShape = inputs[i].dims.slice();
            for (var axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
                // add to the placeholder for computing output shape
                if (axisIndex === this.axis) {
                    outputShape[this.axis] += dataNShape[axisIndex];
                }
                // ensure all non-cancatenated axes match each other
                else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
                    throw new Error('non concat dimensions must match');
                }
            }
        }
        var rank = outputShape.length;
        var getTextureIndexWhereDataResidesMethod = '';
        // in most cases linear search is sufficient, as in most scenarios, only 2 tensors are concatenated
        if (inputs.length < 5) {
            getTextureIndexWhereDataResidesMethod = this.getTextureIndexWhereDataResidesLinearSearch(inputs.length);
        }
        else {
            getTextureIndexWhereDataResidesMethod = this.getTextureIndexWhereDataResidesBinarySearch(inputs.length);
        }
        var fetchDataFromCorrectTextureMethod = this.fetchDataFromCorrectTextureMethod(inputs.length, rank);
        var getValueFromArrayIndexMethod = this.getValueFromArrayIndexMethod(inputs.length);
        var samplers = inputs.map(function (v, i) { return "X" + i; });
        var shaderSource = "\n      " + fetchDataFromCorrectTextureMethod + "\n      " + getValueFromArrayIndexMethod + "\n      " + getTextureIndexWhereDataResidesMethod + "\n      float process(int indices[" + rank + "]) {\n        int textureIndex = getTextureWhereDataResides (indices[" + this.axis + "]);\n\n        if(textureIndex != 0) {\n          indices[" + this.axis + "] = indices[" + this.axis + "] - int(getValueFromArrayIndex(sizeInConcatAxis, textureIndex-int(1)));\n        }\n\n        return fetchDataFromCorrectTexture(textureIndex, indices);\n      }";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: samplers,
            variables: [{ name: 'sizeInConcatAxis', type: 'int', arrayLength: inputs.length }],
            shaderSource: shaderSource,
        };
    };
    WebGLUnpackedConcat.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        var sizeInConcatAxis = new Array(programInfo.inputLayouts.length);
        var previousSum = 0;
        for (var i = 0; i < programInfo.inputLayouts.length; ++i) {
            previousSum += programInfo.inputLayouts[i].shape[this.axis];
            sizeInConcatAxis[i] = previousSum;
        }
        var uniformData = { sizeInConcatAxis: sizeInConcatAxis };
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: uniformData
        };
    };
    WebGLUnpackedConcat.prototype.getTextureIndexWhereDataResidesLinearSearch = function (numberOfTensors) {
        return "int getTextureWhereDataResides(int index) {\n      for(int i=0; i<" + numberOfTensors + "; i++) {\n          if(index < int(sizeInConcatAxis[i])){\n              return i;\n          }\n        }\n      }";
    };
    // TODO: Implement BinarySearch in GLSL
    WebGLUnpackedConcat.prototype.getTextureIndexWhereDataResidesBinarySearch = function (numberOfTensors) {
        return this.getTextureIndexWhereDataResidesLinearSearch(numberOfTensors);
    };
    WebGLUnpackedConcat.prototype.fetchDataFromCorrectTextureMethod = function (numberOfTensors, tensorRank) {
        var codeLines = ["float fetchDataFromCorrectTexture(int textureIndex, int indices[" + tensorRank + "]) {"];
        for (var i = 0; i < numberOfTensors; ++i) {
            if (i === 0) {
                codeLines.push('\t' +
                    ("if (textureIndex == " + i + ") { return _X" + i + "(indices); }"));
            }
            else if (i === numberOfTensors - 1) {
                codeLines.push('\t' +
                    ("else { return _X" + i + "(indices); }"));
            }
            else {
                codeLines.push('\t' +
                    ("else if (textureIndex == " + i + ") { return _X" + i + "(indices); }"));
            }
        }
        codeLines.push('\t' +
            '}');
        return codeLines.join('\n');
    };
    WebGLUnpackedConcat.prototype.getValueFromArrayIndexMethod = function (arrayRank) {
        var codeLines = ["int getValueFromArrayIndex(int arr[" + arrayRank + "], int index) {"];
        for (var i = 0; i < arrayRank; ++i) {
            if (i === 0) {
                codeLines.push('\t' +
                    ("if (index == " + i + ") { return arr[" + i + "]; }"));
            }
            else if (i === arrayRank - 1) {
                codeLines.push('\t' +
                    ("else { return arr[" + i + "]; }"));
            }
            else {
                codeLines.push('\t' +
                    ("else if (index == " + i + ") { return arr[" + i + "]; }"));
            }
        }
        codeLines.push('\t' +
            '}');
        return codeLines.join('\n');
    };
    return WebGLUnpackedConcat;
}(concat_1.Concat));
exports.WebGLUnpackedConcat = WebGLUnpackedConcat;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/conv-pack.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/conv-pack.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLConvPacked = void 0;
var attribute_1 = __webpack_require__(/*! ../../../attribute */ "./lib/onnxjs/attribute.ts");
var instrument_1 = __webpack_require__(/*! ../../../instrument */ "./lib/onnxjs/instrument.ts");
var conv_1 = __webpack_require__(/*! ../../../ops/conv */ "./lib/onnxjs/ops/conv.ts");
var tensor_1 = __webpack_require__(/*! ../../../tensor */ "./lib/onnxjs/tensor.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var conv_2 = __webpack_require__(/*! ./conv */ "./lib/onnxjs/backends/webgl/ops/conv.ts");
var im2col_pack_1 = __webpack_require__(/*! ./im2col-pack */ "./lib/onnxjs/backends/webgl/ops/im2col-pack.ts");
var matmul_pack_1 = __webpack_require__(/*! ./matmul-pack */ "./lib/onnxjs/backends/webgl/ops/matmul-pack.ts");
var reshape_packed_1 = __webpack_require__(/*! ./reshape-packed */ "./lib/onnxjs/backends/webgl/ops/reshape-packed.ts");
var WebGLConvPacked = /** @class */ (function (_super) {
    __extends(WebGLConvPacked, _super);
    function WebGLConvPacked() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.kernelReshape = new reshape_packed_1.WebGLReshapePacked();
        _this.matmul = new matmul_pack_1.WebGLMatMulPacked();
        _this.outputReshape = new reshape_packed_1.WebGLReshapePacked();
        return _this;
    }
    WebGLConvPacked.prototype.run = function (inferenceHandler, inputs) {
        var programManager = inferenceHandler.session.programManager;
        var xshape = inputs[0].dims.slice();
        var kshape = inputs[1].dims.slice();
        // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims
        if (this.kernelShape.length === 0) {
            for (var i = 2; i < kshape.length; ++i) {
                this.kernelShape.push(kshape[i]);
            }
        }
        util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims, this.strides, this.dilations, this.kernelShape, this.pads, this.autoPad);
        instrument_1.Logger.verbose('Conv', "autpPad:" + this.autoPad + ", dilations:" + this.dilations + ", group:" + this.group + ", kernelShape:" + this.kernelShape + ", pads:" + this.pads + ", strides:" + this.strides);
        if (!this.outputShape) {
            this.outputShape = conv_2.WebGLConv.calcOutputShape(xshape, kshape, this.dilations, this.pads, this.strides);
        }
        if (this.im2col === undefined) {
            this.im2col = new im2col_pack_1.WebGLIm2ColPacked(this.outputShape, kshape, this.dilations, this.pads, this.strides);
        }
        if (this.activation) {
            var attributes = new attribute_1.Attribute(undefined);
            attributes.set('__internal_activation', 'string', (this.activation));
            this.matmul.initialize(attributes);
        }
        // shape for kernel reshape
        var shape = new tensor_1.Tensor([2], 'int32', undefined, undefined, new Int32Array([kshape[0], kshape[1] * kshape[2] * kshape[3]]));
        if (!this.artifacts) {
            this.artifacts = [];
            this.programInfo = [];
            this.programInfo[0] = this.im2col.createProgramInfo(inferenceHandler, [inputs[0], inputs[1]]);
            this.artifacts[0] = programManager.build(this.programInfo[0]);
            this.programInfo[1] = this.kernelReshape.createProgramInfo(inferenceHandler, [inputs[1], shape]);
            this.artifacts[1] = programManager.build(this.programInfo[1]);
        }
        // run im2col
        var runDataIm2col = this.im2col.createRunData(inferenceHandler, this.programInfo[0], [inputs[0], inputs[1]]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[0], runDataIm2col);
        programManager.run(this.artifacts[0], runDataIm2col);
        var im2colOutput = runDataIm2col.outputTextureData.tensor;
        // reshape kernel
        var runDataKernelReshape = this.kernelReshape.createRunData(inferenceHandler, this.programInfo[1], [inputs[1], shape]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[1], runDataKernelReshape);
        programManager.run(this.artifacts[1], runDataKernelReshape);
        var kernelReshaped = runDataKernelReshape.outputTextureData.tensor;
        // run matmul
        var hasBias = (inputs.length === 3);
        util_1.assert(this.artifacts.length > 1, function () { return 'expect at least 2 artifacts created'; });
        if (this.artifacts.length === 2) {
            this.programInfo[2] = this.matmul.createProgramInfo(inferenceHandler, hasBias ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput]);
            this.artifacts[2] = programManager.build(this.programInfo[2]);
        }
        var runDataMatmul = this.matmul.createRunData(inferenceHandler, this.programInfo[2], hasBias ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[2], runDataMatmul);
        programManager.run(this.artifacts[2], runDataMatmul);
        var matmulOutput = runDataMatmul.outputTextureData.tensor;
        // reshape output
        var outputShapeTensor = new tensor_1.Tensor([this.outputShape.length], 'int32', undefined, undefined, new Int32Array([this.outputShape[0], this.outputShape[1], this.outputShape[2], this.outputShape[3]]));
        util_1.assert(this.artifacts.length > 2, function () { return 'expect at least 3 artifacts created'; });
        if (this.artifacts.length === 3) {
            this.programInfo[3] = this.outputReshape.createProgramInfo(inferenceHandler, [matmulOutput, outputShapeTensor]);
            this.artifacts[3] = programManager.build(this.programInfo[3]);
        }
        var runDataOutputReshape = this.outputReshape.createRunData(inferenceHandler, this.programInfo[3], [matmulOutput, outputShapeTensor]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[3], runDataOutputReshape);
        programManager.run(this.artifacts[3], runDataOutputReshape);
        return [runDataOutputReshape.outputTextureData.tensor];
    };
    return WebGLConvPacked;
}(conv_1.Conv));
exports.WebGLConvPacked = WebGLConvPacked;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/conv.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/conv.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnpackedConv = exports.WebGLUnpackedGroupedConv = exports.WebGLConv = void 0;
var instrument_1 = __webpack_require__(/*! ../../../instrument */ "./lib/onnxjs/instrument.ts");
var conv_1 = __webpack_require__(/*! ../../../ops/conv */ "./lib/onnxjs/ops/conv.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var conv_pack_1 = __webpack_require__(/*! ./conv-pack */ "./lib/onnxjs/backends/webgl/ops/conv-pack.ts");
var fuse_utils_1 = __webpack_require__(/*! ./fuse-utils */ "./lib/onnxjs/backends/webgl/ops/fuse-utils.ts");
var WebGLConv = /** @class */ (function (_super) {
    __extends(WebGLConv, _super);
    function WebGLConv() {
        var _this = _super.call(this) || this;
        _this.unpackedGroupedConvImpl = new WebGLUnpackedGroupedConv();
        _this.unpackedConvImpl = new WebGLUnpackedConv();
        _this.packedConvImpl = new conv_pack_1.WebGLConvPacked();
        return _this;
    }
    WebGLConv.prototype.initialize = function (attributes) {
        _super.prototype.initialize.call(this, attributes);
        this.unpackedGroupedConvImpl.initialize(attributes);
        this.unpackedConvImpl.initialize(attributes);
        this.packedConvImpl.initialize(attributes);
    };
    WebGLConv.prototype.run = function (inferenceHandler, inputs) {
        var packMode = inferenceHandler.session.pack;
        if (this.group > 1) {
            return this.unpackedGroupedConvImpl.run(inferenceHandler, inputs);
        }
        else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1) {
            return this.packedConvImpl.run(inferenceHandler, inputs);
        }
        else {
            return this.unpackedConvImpl.run(inferenceHandler, inputs);
        }
    };
    WebGLConv.calcOutputShape = function (inputShape, kernelShape, dilations, adjustPads, strides) {
        var _a;
        var batchSize = inputShape[0];
        var inputSpatialShape = inputShape.slice(2);
        var spatialRank = inputSpatialShape.length;
        var outChannels = kernelShape[0];
        var kernelSpatialShape = kernelShape.slice(2);
        var dilatedKernelShape = kernelSpatialShape.map(function (v, i) { return v + (v - 1) * (dilations[i] - 1); });
        var inputSpatialShapeWithPad = inputSpatialShape.map(function (v, i) { return v + adjustPads[i] + adjustPads[i + spatialRank]; });
        var outputSpatialShape = inputSpatialShapeWithPad.map(function (v, i) { return Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]); });
        var outputShape = (_a = [batchSize, outChannels]).concat.apply(_a, __spreadArray([], __read(outputSpatialShape)));
        return outputShape;
    };
    return WebGLConv;
}(conv_1.Conv));
exports.WebGLConv = WebGLConv;
var WebGLUnpackedGroupedConv = /** @class */ (function (_super) {
    __extends(WebGLUnpackedGroupedConv, _super);
    function WebGLUnpackedGroupedConv() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLUnpackedGroupedConv.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLUnpackedGroupedConv.prototype.createProgramInfo = function (handler, inputs) {
        var hasBias = inputs.length > 2;
        var processBias = hasBias ? 'value += getBias(output_channel);' : '';
        var xShape = inputs[0].dims.slice();
        var wShape = inputs[1].dims.slice();
        var outputChannelsPerGroup = wShape[0] / this.group;
        // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims
        if (this.kernelShape.length === 0) {
            for (var i = 2; i < wShape.length; ++i) {
                this.kernelShape.push(wShape[i]);
            }
        }
        util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims, this.strides, this.dilations, this.kernelShape, this.pads, this.autoPad);
        instrument_1.Logger.verbose('Conv', "autpPad:" + this.autoPad + ", dilations:" + this.dilations + ", group:" + this.group + ", kernelShape:" + this.kernelShape + ", pads:" + this.pads + ", strides:" + this.strides);
        var outputShape = WebGLConv.calcOutputShape(xShape, wShape, this.dilations, this.pads, this.strides);
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var _a = fuse_utils_1.getActicationSnippet(this.activation), activationFunction = _a.activationFunction, applyActivation = _a.applyActivation;
        var shaderSource = "\n    const ivec2 strides = ivec2(" + this.strides[0] + ", " + this.strides[1] + ");\n    const ivec2 pads = ivec2(" + this.pads[0] + ", " + this.pads[1] + ");\n    " + activationFunction + "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int batch = coords.x;\n      int output_channel = coords.y;\n      ivec2 xRCCorner = coords.zw * strides - pads;\n      int group_id = output_channel / " + outputChannelsPerGroup + ";\n\n      float value = 0.0;\n      for (int wInChannel = 0; wInChannel < " + wShape[1] + "; wInChannel++) {\n        int input_channel = group_id * " + wShape[1] + " + wInChannel;\n        for (int wHeight = 0; wHeight < " + wShape[2] + "; wHeight++) {\n          int xHeight = xRCCorner.x + wHeight * " + this.dilations[0] + ";\n\n          if (xHeight < 0 || xHeight >= " + xShape[2] + ") {\n            continue;\n          }\n\n          for (int wWidth = 0; wWidth < " + wShape[3] + "; wWidth++) {\n            int xWidth = xRCCorner.y + wWidth * " + this.dilations[1] + ";\n            if (xWidth < 0 || xWidth >= " + xShape[3] + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, input_channel, xWidth, xHeight);\n            float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n            value += xVal*wVal;\n          }\n        }\n      }\n      " + processBias + "\n      " + applyActivation + "\n      " + glsl.output + " = vec4(value, .0, .0, .0);\n    }\n";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: hasBias ? ['X', 'W', 'Bias'] : ['X', 'W'],
            shaderSource: shaderSource,
            hasMain: true,
        };
    };
    WebGLUnpackedGroupedConv.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLUnpackedGroupedConv;
}(conv_1.Conv));
exports.WebGLUnpackedGroupedConv = WebGLUnpackedGroupedConv;
var WebGLUnpackedConv = /** @class */ (function (_super) {
    __extends(WebGLUnpackedConv, _super);
    function WebGLUnpackedConv() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.readSize = 8;
        _this.blockSize = 64;
        return _this;
    }
    WebGLUnpackedConv.prototype.run = function (inferenceHandler, inputs) {
        var programManager = inferenceHandler.session.programManager;
        if (!this.artifacts) {
            this.artifacts = [];
            var programInfos = this.createProgramInfoArray(inferenceHandler, inputs);
            for (var i = 0; i < programInfos.length; ++i) {
                var artifact = inferenceHandler.session.programManager.build(programInfos[i]);
                this.artifacts.push(artifact);
            }
        }
        var runDataArray = this.createRunDataArray(inferenceHandler, this.artifacts.map(function (a) { return a.programInfo; }), inputs);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[0], runDataArray[0]);
        programManager.run(this.artifacts[0], runDataArray[0]);
        programManager.run(this.artifacts[1], runDataArray[1]);
        return [runDataArray[1].outputTextureData.tensor];
    };
    WebGLUnpackedConv.prototype.createProgramInfoArray = function (inferenceHandler, inputs) {
        var xshape = inputs[0].dims.slice();
        var kshape = inputs[1].dims.slice();
        // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims
        if (this.kernelShape.length === 0) {
            var wDims = inputs[1].dims;
            for (var i = 2; i < wDims.length; ++i) {
                this.kernelShape.push(wDims[i]);
            }
        }
        util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims, this.strides, this.dilations, this.kernelShape, this.pads, this.autoPad);
        instrument_1.Logger.verbose('Conv', "autpPad:" + this.autoPad + ", dilations:" + this.dilations + ", group:" + this.group + ", kernelShape:" + this.kernelShape + ", pads:" + this.pads + ", strides:" + this.strides);
        var outputShape = WebGLConv.calcOutputShape(xshape, kshape, this.dilations, this.pads, this.strides);
        var im2colProgramInfo = this.createIm2ColProgramInfo(inferenceHandler, inputs, outputShape);
        var dotProductProgramInfo = this.createDotProductProgramInfo(inferenceHandler, im2colProgramInfo.outputLayout, inputs, outputShape);
        return [im2colProgramInfo, dotProductProgramInfo];
    };
    WebGLUnpackedConv.prototype.createRunDataArray = function (inferenceHandler, programInfos, inputs) {
        var k = inputs[1];
        var b = inputs.length >= 3 ? inputs[2] : undefined;
        var kTD = inferenceHandler.getTextureData(k.dataId);
        if (!kTD) {
            instrument_1.Logger.verbose('Conv', 'Did not find the adjustedKernel texture in the cache. Creating rew.');
            var newKernelData = WebGLUnpackedConv.prepKernelForDotProduct(k.dims.slice(), this.group, 4, k.floatData);
            // hack: should use graph transformer to rewrite initializer K
            kTD = inferenceHandler.createTextureDataFromLayoutBindTensor(programInfos[1].inputLayouts[1], k.type, newKernelData, k);
        }
        var runtDataIm2Col = {
            inputTextureDatas: [inferenceHandler.getOrCreateTextureData(inputs[0])],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[0].outputLayout, inputs[0].type),
            uniformData: {}
        };
        var inputTDs = [runtDataIm2Col.outputTextureData, kTD];
        if (b) {
            inputTDs.push(inferenceHandler.getOrCreateTextureData(b));
        }
        var outputTD = inferenceHandler.createTextureDataFromLayout(programInfos[1].outputLayout, inputs[0].type);
        var runDataDotProduct = {
            inputTextureDatas: inputTDs,
            outputTextureData: outputTD,
            uniformData: {},
            draw: function (glContext, artifact) {
                var gl = glContext.gl;
                var sharedDim = artifact.programInfo.params.sharedDim;
                var sharedDimReadSize = artifact.programInfo.params.sharedDimReadSize;
                var sharedDimOffsetLocation = artifact.uniformLocations.find(function (l) { return l.name === 'sharedDimOffset'; }).location;
                var blend = false;
                for (var k_1 = 0; k_1 < sharedDim; k_1 += sharedDimReadSize) {
                    instrument_1.Logger.verbose('MatMul2D', "k = " + k_1 + ", sharedDim: " + sharedDim + ", readSize = " + sharedDimReadSize);
                    if (k_1 === sharedDimReadSize) {
                        blend = true;
                        gl.enable(gl.BLEND);
                        glContext.checkError();
                        gl.blendEquation(gl.FUNC_ADD);
                        glContext.checkError();
                        gl.blendFunc(gl.ONE, gl.ONE);
                        glContext.checkError();
                    }
                    gl.uniform1i(sharedDimOffsetLocation, k_1);
                    glContext.checkError();
                    glContext.draw();
                }
                if (blend) {
                    gl.disable(gl.BLEND);
                    glContext.checkError();
                }
            }
        };
        return [runtDataIm2Col, runDataDotProduct];
    };
    WebGLUnpackedConv.prototype.createIm2ColProgramInfo = function (inferenceHandler, inputs, outputShape) {
        var xshape = inputs[0].dims.slice();
        var kshape = inputs[1].dims.slice();
        var rank = outputShape.length;
        var im2colDims = WebGLUnpackedConv.calcIm2ColDims(xshape, kshape, outputShape, 4);
        var outputLayout = inferenceHandler.createTextureLayoutFromShape(im2colDims, 4, [im2colDims[0], im2colDims[1], im2colDims[2], im2colDims[3] * 4], { breakAxis: 3 });
        var shaderSource = "\n      const int XC = " + xshape[1] + ";\n      const int XH = " + xshape[2] + ";\n      const int XW = " + xshape[3] + ";\n      const int KH = " + this.kernelShape[0] + ";\n      const int KW = " + this.kernelShape[1] + ";\n      const int dilationH = " + this.dilations[0] + ";\n      const int dilationW = " + this.dilations[1] + ";\n      const int strideH = " + this.strides[0] + ";\n      const int strideW = " + this.strides[1] + ";\n      const int padH = " + this.pads[0] + ";\n      const int padW = " + this.pads[1] + ";\n      const int KHKW = KH*KW;\n      const int XCKHKW = XC * KHKW;\n      const int outputChannels = 4;\n      vec4 process(int indices[" + rank + "]) {\n        int b  = indices[0]; // batch size\n        int oh = indices[1] * strideH - padH; //output height\n        int ow = indices[2] * strideW - padW; //output width\n        int p = indices[3] * outputChannels; //patch\n        vec4 value = vec4(0.0);\n        for(int i=0; i < outputChannels; ++i) {\n          if(p < XCKHKW) {\n            int patchC = p / KHKW;\n            int patchH = (p - patchC*KHKW) / KW;\n            int patchW = (p - patchC*KHKW) - patchH * KW;\n            int xh2 = oh + patchH * dilationH;\n            int xw2 = ow + patchW * dilationW;\n            int x[" + xshape.length + "];\n            x[0] = b;\n            x[1] = patchC;\n            x[2] = xh2;\n            x[3] = xw2;\n            if(xh2 >= 0 &&\n                xh2 < XH &&\n                xw2 >= 0 &&\n                xw2 < XW) {\n              value[i] = _X(x);\n            }\n          }\n          ++p;\n        }\n        return value;\n      }\n      ";
        return {
            name: 'Im2Col',
            inputLayouts: [inferenceHandler.createTextureLayoutFromShape(xshape)],
            outputLayout: outputLayout,
            samplers: ['X'],
            shaderSource: shaderSource,
        };
    };
    WebGLUnpackedConv.prototype.createDotProductProgramInfo = function (inferenceHandler, im2colLayout, inputs, outputShape) {
        var xshape = inputs[0].dims.slice();
        var kshape = inputs[1].dims.slice();
        var adjustedKernelShape = [kshape[0], Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4)];
        var kLayout = inferenceHandler.createTextureLayoutFromShape(adjustedKernelShape, 4, [adjustedKernelShape[0], adjustedKernelShape[1] * 4], { breakAxis: 1 });
        var bLayout;
        var rank = outputShape.length;
        var inputLayouts = [im2colLayout, kLayout];
        if (inputs.length === 3) {
            bLayout = inferenceHandler.createTextureLayoutFromShape(inputs[2].dims.slice());
            inputLayouts.push(bLayout);
        }
        var outputLayout = inferenceHandler.createTextureLayoutFromShape(outputShape);
        var initValue = (inputs.length < 3) ? '0.0' : '_B(b)';
        var sharedDim = im2colLayout.shape[3];
        var blendEnabled = inferenceHandler.session.backend.glContext.isBlendSupported && !this.activation;
        var sharedDimReadSize = blendEnabled && inferenceHandler.session.backend.matmulMaxBatchSize ?
            this.calcSharedDimReadSize(inferenceHandler.session.backend.matmulMaxBatchSize, sharedDim) :
            sharedDim;
        var samplers = ['Im2Col', 'K'];
        if (inputs.length === 3) {
            samplers.push('B');
        }
        var _a = fuse_utils_1.getActicationSnippet(this.activation), activationFunction = _a.activationFunction, applyActivation = _a.applyActivation;
        var glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        var shaderSource = "\n    " + activationFunction + "\n    float process(int indices[" + rank + "]) {\n      int b[1];\n      b[0] = indices[1];\n      int im2col[" + im2colLayout.shape.length + "];\n      im2col[0] = indices[0];\n      im2col[1] = indices[2];\n      im2col[2] = indices[3];\n      int im2colOffset = im2col[0] * " + im2colLayout.strides[0] + " + im2col[1] * " + im2colLayout.strides[1] + " + im2col[2] * " + im2colLayout.strides[2] + " + sharedDimOffset;\n      int kernelOffset = indices[1] * " + kLayout.strides[0] + " + sharedDimOffset;\n      float value = sharedDimOffset == 0 ? " + initValue + " : 0.0;\n      for (int i = 0; i < " + sharedDimReadSize + "; ++i) {\n        vec2 im2colCoords = offsetToCoords(im2colOffset, " + im2colLayout.width + ", " + im2colLayout.height + ");\n        vec2 kernelCoords = offsetToCoords(kernelOffset, " + kLayout.width + ", " + kLayout.height + ");\n        value += dot(" + glsl.texture2D + "(Im2Col, im2colCoords), " + glsl.texture2D + "(K, kernelCoords));\n        ++im2colOffset;\n        ++kernelOffset;\n      }\n      " + applyActivation + "\n      return value;\n    }";
        return {
            name: 'dotProduct',
            inputLayouts: inputs.length === 3 ? [im2colLayout, kLayout, bLayout] : [im2colLayout, kLayout],
            outputLayout: outputLayout,
            shaderSource: shaderSource,
            samplers: samplers,
            variables: [{ name: 'sharedDimOffset', type: 'int' }],
            params: { sharedDim: sharedDim, sharedDimReadSize: sharedDimReadSize }
        };
    };
    WebGLUnpackedConv.prepKernelForDotProduct = function (shape, group, channels, kernel) {
        if (group === 1 && (channels === 1 || (shape[2] * shape[3]) % channels === 0)) {
            return kernel;
        }
        var numFeatureMaps = shape[0];
        var oldRowSize = shape[1] * shape[2] * shape[3];
        var newRowSize = Math.ceil(oldRowSize * group / channels) * channels;
        var newSize = numFeatureMaps * newRowSize;
        var buffer = new Float32Array(newSize);
        for (var f = 0; f < numFeatureMaps; ++f) {
            var oldOffset = f * oldRowSize;
            var newOffset = f * newRowSize + f % group * oldRowSize;
            buffer.set(kernel.subarray(oldOffset, oldOffset + oldRowSize), newOffset);
        }
        return buffer;
    };
    WebGLUnpackedConv.calcIm2ColDims = function (inputShape, kernelShape, outputShape, channels) {
        if (channels === void 0) { channels = 1; }
        return [
            outputShape[0], outputShape[2], outputShape[3],
            Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)
        ];
    };
    WebGLUnpackedConv.prototype.calcSharedDimReadSize = function (preferredBatchSize, sharedDim) {
        if (preferredBatchSize <= 0 || sharedDim < preferredBatchSize || sharedDim % preferredBatchSize !== 0) {
            return sharedDim;
        }
        return preferredBatchSize;
    };
    WebGLUnpackedConv.prototype.calcBlockSize = function (outputLayout) {
        var preferredRowCount = 64;
        var preferredColCount = 64;
        if (outputLayout.height < preferredRowCount) {
            return undefined;
        }
        return [preferredColCount, preferredRowCount];
    };
    return WebGLUnpackedConv;
}(conv_1.Conv));
exports.WebGLUnpackedConv = WebGLUnpackedConv;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/depth-to-space.ts":
/*!*********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/depth-to-space.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLDepthToSpace = void 0;
var attribute_1 = __webpack_require__(/*! ../../../attribute */ "./lib/onnxjs/attribute.ts");
var depth_to_space_1 = __webpack_require__(/*! ../../../ops/depth-to-space */ "./lib/onnxjs/ops/depth-to-space.ts");
var reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
var transpose_1 = __webpack_require__(/*! ./transpose */ "./lib/onnxjs/backends/webgl/ops/transpose.ts");
var WebGLDepthToSpace = /** @class */ (function (_super) {
    __extends(WebGLDepthToSpace, _super);
    function WebGLDepthToSpace() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLDepthToSpace.prototype.run = function (inferenceHandler, inputs) {
        var programManager = inferenceHandler.session.programManager;
        var transposePerm = this.mode === 'DCR' ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        var firstReshapeShape = this.mode === 'DCR' ?
            [
                inputs[0].dims[0], this.blocksize, this.blocksize, inputs[0].dims[1] / this.blocksizeSqr, inputs[0].dims[2],
                inputs[0].dims[3]
            ] :
            [
                inputs[0].dims[0], inputs[0].dims[1] / this.blocksizeSqr, this.blocksize, this.blocksize, inputs[0].dims[2],
                inputs[0].dims[3]
            ];
        var transpose = new transpose_1.WebGLTranspose();
        var attributes = new attribute_1.Attribute(undefined);
        attributes.set('perm', 'ints', transposePerm);
        transpose.initialize(attributes);
        // First reshape
        var firstReshapedTensor = reshape_1.reshape(inferenceHandler, inputs[0], firstReshapeShape);
        // transpose
        if (!this.transposeProgramInfo) {
            this.transposeProgramInfo = transpose.createProgramInfo(inferenceHandler, [firstReshapedTensor]);
            this.transposeArtifact = programManager.build(this.transposeProgramInfo);
        }
        var runDataTranspose = transpose.createRunData(inferenceHandler, this.transposeProgramInfo, [firstReshapedTensor]);
        inferenceHandler.checkAndUpdateTextureForm(this.transposeArtifact, runDataTranspose);
        programManager.run(this.transposeArtifact, runDataTranspose);
        var transposeOutput = runDataTranspose.outputTextureData.tensor;
        // Second reshape
        var result = reshape_1.reshape(inferenceHandler, transposeOutput, [
            inputs[0].dims[0], inputs[0].dims[1] / this.blocksizeSqr, inputs[0].dims[2] * this.blocksize,
            inputs[0].dims[3] * this.blocksize
        ]);
        return [result];
    };
    WebGLDepthToSpace.prototype.getOutShape = function (input) {
        var batchSize = input.dims[0];
        var inputDepth = input.dims[1];
        var inputHeight = input.dims[2];
        var inputWidth = input.dims[3];
        if (inputDepth % (this.blocksizeSqr) !== 0) {
            throw new Error('Input depth must be divisible by squared blocksize.');
        }
        var outputDepth = inputDepth / this.blocksizeSqr;
        var outputHeight = inputHeight * this.blocksize;
        var outputWidth = inputWidth * this.blocksize;
        return [batchSize, outputDepth, outputHeight, outputWidth];
    };
    WebGLDepthToSpace.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLDepthToSpace;
}(depth_to_space_1.DepthToSpace));
exports.WebGLDepthToSpace = WebGLDepthToSpace;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/dropout.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/dropout.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLDropout = void 0;
var dropout_1 = __webpack_require__(/*! ../../../ops/dropout */ "./lib/onnxjs/ops/dropout.ts");
var WebGLDropout = /** @class */ (function (_super) {
    __extends(WebGLDropout, _super);
    function WebGLDropout() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLDropout.prototype.run = function (inferenceHandler, inputs) {
        if (this.testMode) {
            return [inputs[0]];
        }
        throw new Error('Non test mode Dropout is not implemented yet');
    };
    WebGLDropout.prototype.createProgramInfo = function (_handler, _inputs) {
        throw new Error('Non test mode Dropout is not implemented yet');
    };
    WebGLDropout.prototype.createRunData = function (_handler, _programInfo, _inputs) {
        throw new Error('Non test mode Dropout is not implemented yet');
    };
    return WebGLDropout;
}(dropout_1.Dropout));
exports.WebGLDropout = WebGLDropout;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/elu.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/elu.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLElu = void 0;
var elu_1 = __webpack_require__(/*! ../../../ops/elu */ "./lib/onnxjs/ops/elu.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLElu = /** @class */ (function (_super) {
    __extends(WebGLElu, _super);
    function WebGLElu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLElu.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLElu.prototype.createProgramInfo = function (handler, inputs) {
        var outputShape = inputs[0].dims.slice();
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n      void main() {\n        float v = " + glsl.texture2D + "(A, TexCoords).r;\n        " + glsl.output + " = vec4(v >= 0.0 ? v: (exp(v) - 1.0) * " + this.alpha.toExponential() + "); /* float number format */\n      }\n      ";
        return {
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
            hasMain: true,
        };
    };
    WebGLElu.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLElu;
}(elu_1.Elu));
exports.WebGLElu = WebGLElu;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/flatten.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/flatten.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLFlatten = void 0;
var flatten_1 = __webpack_require__(/*! ../../../ops/flatten */ "./lib/onnxjs/ops/flatten.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
var WebGLFlatten = /** @class */ (function (_super) {
    __extends(WebGLFlatten, _super);
    function WebGLFlatten() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLFlatten.prototype.run = function (inferenceHandler, inputs) {
        var outputDims = util_1.ShapeUtil.flattenShape(inputs[0].dims, this.axis);
        return [reshape_1.reshape(inferenceHandler, inputs[0], outputDims)];
    };
    return WebGLFlatten;
}(flatten_1.Flatten));
exports.WebGLFlatten = WebGLFlatten;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/fuse-utils.ts":
/*!*****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/fuse-utils.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActicationSnippet = void 0;
var unary_op_1 = __webpack_require__(/*! ./unary-op */ "./lib/onnxjs/backends/webgl/ops/unary-op.ts");
function getActicationSnippet(activation) {
    var activationFunction = '';
    var activationName = '';
    switch (activation) {
        case 'Relu':
            activationName = unary_op_1.glslRelu().name;
            activationFunction = unary_op_1.glslRelu().body;
            break;
        case 'Sigmoid':
            activationName = unary_op_1.glslSigmoid().name;
            activationFunction = unary_op_1.glslSigmoid().body;
            break;
        default:
            // TODO: adding other activations that can be fused.
            activationName = '';
            activationFunction = '';
    }
    var applyActivation = activation ? "\n  value = " + activationName + "(value);" :
        '';
    return { activationFunction: activationFunction, applyActivation: applyActivation };
}
exports.getActicationSnippet = getActicationSnippet;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/gather.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/gather.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLGather = void 0;
var gather_1 = __webpack_require__(/*! ../../../ops/gather */ "./lib/onnxjs/ops/gather.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var WebGLGather = /** @class */ (function (_super) {
    __extends(WebGLGather, _super);
    function WebGLGather() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLGather.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLGather.prototype.createProgramInfo = function (handler, inputs) {
        var inputShape = inputs[0].dims.slice();
        var indexDataShape = inputs[1].dims.slice();
        var outputShape = new Array(inputShape.length + indexDataShape.length - 1);
        var axis = util_1.ShapeUtil.normalizeAxis(this.axis, inputShape.length);
        var indexCopyOps = [];
        for (var i = 0; i < outputShape.length; i++) {
            // outputShape is divided into three parts: A, B, C
            // |0        axis|  axis + indexDataShape.length |          end|
            // |     A       |             B                 |      C      |
            //
            // inputIdx: [A, inputs[1][B], C]
            if (i < axis) { // A
                outputShape[i] = inputShape[i];
                indexCopyOps.push("inputIdx[" + i + "] = outputIdx[" + i + "];");
            }
            else {
                if (i < axis + indexDataShape.length) { // B
                    outputShape[i] = indexDataShape[i - axis];
                    indexCopyOps.push("indexDataIdx[" + (i - axis) + "] = outputIdx[" + i + "];");
                }
                else { // C
                    outputShape[i] = inputShape[i - indexDataShape.length + 1]; // skip 1 for axis
                    indexCopyOps.push("inputIdx[" + (i - indexDataShape.length + 1) + "] = outputIdx[" + i + "];");
                }
            }
        }
        var orank = outputShape.length || 1;
        var irank = inputShape.length;
        var iDrank = indexDataShape.length || 1;
        var shaderSource = "\n      float process(int outputIdx[" + orank + "]) {\n        int inputIdx[" + irank + "];\n        int indexDataIdx[" + iDrank + "];\n        indexDataIdx[0] = 0;\n        " + indexCopyOps.join('\n        ') + "\n        int idx = int(_B(indexDataIdx));\n        inputIdx[" + axis + "] = idx < 0 ? idx + " + inputShape[axis] + " : idx;\n        return _A(inputIdx);\n      }";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'B'],
            shaderSource: shaderSource,
        };
    };
    WebGLGather.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLGather;
}(gather_1.Gather));
exports.WebGLGather = WebGLGather;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/gemm.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/gemm.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLGemm = void 0;
var gemm_1 = __webpack_require__(/*! ../../../ops/gemm */ "./lib/onnxjs/ops/gemm.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var WebGLGemm = /** @class */ (function (_super) {
    __extends(WebGLGemm, _super);
    function WebGLGemm() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLGemm.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLGemm.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        var aShape = inputs[0].dims.slice();
        var bShape = inputs[1].dims.slice();
        var _a = __read(util_1.GemmUtil.getShapeOfGemmResult(aShape, this.transA, bShape, this.transB, inputs.length === 3 ? inputs[2].dims : undefined), 2), M = _a[0], N = _a[1];
        var oShape = [M, N];
        if (!oShape) {
            throw new Error('Can\'t use gemm on the given tensors');
        }
        var sharedDim = aShape[aShape.length - 1];
        var line = '';
        if (this.transA) {
            sharedDim = aShape[0];
        }
        if (this.transA && this.transB) {
            line = 'value += _A_T(a) * _B_T(b);';
        }
        else if (this.transA && !this.transB) {
            line = 'value += _A_T(a) * _B(b);';
        }
        else if (!this.transA && this.transB) {
            line = 'value += _A(a) * _B_T(b);';
        }
        else if (!this.transA && !this.transB) {
            line = 'value += _A(a) * _B(b);';
        }
        var rank = oShape.length;
        var declareC = inputs.length === 3 ? "int c[" + inputs[2].dims.length + "];" : '';
        var broadcastC = inputs.length === 3 ? 'bcastIndices_C(indices, c);' : '';
        var calculateC = inputs.length === 3 ? 'value += beta * _C(c);' : '';
        var shaderSource = "\n      float process(int indices[" + rank + "]) {\n          int a[" + rank + "];\n          int b[" + rank + "];\n          " + declareC + "\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          " + broadcastC + "\n\n          float value = 0.0;\n          for (int k=0; k<" + sharedDim + "; ++k) {\n              a[" + (rank - 1) + "] = k;\n              b[" + (rank - 2) + "] = k;\n              " + line + "\n          }\n\n          value = value * alpha;\n          " + calculateC + "\n          return value;\n      }";
        var inputLayouts = inputs.map(function (t) { return inferenceHandler.getOrCreateTextureLayout(t); });
        return {
            inputLayouts: inputLayouts,
            outputLayout: inferenceHandler.createTextureLayoutFromShape(oShape),
            samplers: inputs.length === 3 ? ['A', 'B', 'C'] : ['A', 'B'],
            variables: [{ name: 'alpha', type: 'float' }, { name: 'beta', type: 'float' }],
            shaderSource: shaderSource,
        };
    };
    WebGLGemm.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return inferenceHandler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: { 'alpha': this.alpha, 'beta': this.beta }
        };
    };
    return WebGLGemm;
}(gemm_1.Gemm));
exports.WebGLGemm = WebGLGemm;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/im2col-pack.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/im2col-pack.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLIm2ColPacked = void 0;
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
var WebGLIm2ColPacked = /** @class */ (function () {
    function WebGLIm2ColPacked(convOutputShape, kernelShape, dilations, pads, strides) {
        this.convOutputShape = convOutputShape;
        this.kernelShape = kernelShape;
        this.dilations = dilations;
        this.pads = pads;
        this.strides = strides;
    }
    WebGLIm2ColPacked.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLIm2ColPacked.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        if (inputs.length !== 2) {
            throw new Error('Im2Col kernel should have two input tensors');
        }
        var xshape = inputs[0].dims.slice();
        var wshape = inputs[1].dims.slice();
        var rowDim = 2;
        var colDim = 3;
        var rank = this.convOutputShape.length;
        var im2colShape = [wshape[1] * wshape[2] * wshape[3], this.convOutputShape[2] * this.convOutputShape[3]];
        var kernelSize = wshape[2] * wshape[3];
        var unpackChannel = packing_utils_1.unpackFromChannel();
        var glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        var unrolled = '';
        for (var row = 0; row <= 1; row++) {
            for (var col = 0; col <= 1; col++) {
                unrolled += "\n          blockIndex = rc.x + " + col + ";\n          pos = rc.y + " + row + ";\n\n          if(blockIndex < " + im2colShape[1] + " && pos < " + im2colShape[0] + ") {\n            offsetY = int(blockIndex / (" + this.convOutputShape[rank - 1] + ")) * " + this.strides[0] + " - " + this.pads[0] + ";\n            d0 = offsetY + " + this.dilations[0] + " * (imod(pos, " + kernelSize + ") / " + wshape[2] + ");\n\n            if(d0 < " + xshape[rowDim] + " && d0 >= 0) {\n              offsetX = imod(blockIndex, " + this.convOutputShape[rank - 1] + ") * " + this.strides[1] + " - " + this.pads[1] + ";\n              d1 = offsetX + " + this.dilations[1] + " * imod(imod(pos, " + kernelSize + "), " + wshape[2] + ");\n\n              if(d1 < " + xshape[colDim] + " && d1 >= 0) {\n\n                ch = int(float(pos)/ " + kernelSize + ".);\n                  innerDims = vec2(d0, d1);\n                  result[" + (row * 2 + col) + "] = getChannel(\n                    getA(0, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n              }\n            }\n          }\n\n        ";
            }
        }
        var shaderSource = "\n    " + unpackChannel + "\n\n    void main() {\n      ivec2 rc = getOutputCoords();\n        vec4 result = vec4(0.0);\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n        " + unrolled + "\n        " + glsl.output + " = result;\n    }\n          ";
        return {
            name: 'WebGLIm2ColPacked',
            inputLayouts: [inferenceHandler.getOrCreateTextureLayout(inputs[0], 4, true, xshape, true)],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(im2colShape, 4, im2colShape, { isPacked: true, reverseWH: true }),
            samplers: ['A'],
            shaderSource: shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true,
        };
    };
    WebGLIm2ColPacked.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t) { return handler.getOrCreateTextureData(t, handler.getOrCreateTextureLayout(t, 1, false, [], true)); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLIm2ColPacked;
}());
exports.WebGLIm2ColPacked = WebGLIm2ColPacked;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/image-scaler.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/image-scaler.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLImageScaler = void 0;
var image_scaler_1 = __webpack_require__(/*! ../../../ops/image-scaler */ "./lib/onnxjs/ops/image-scaler.ts");
var WebGLImageScaler = /** @class */ (function (_super) {
    __extends(WebGLImageScaler, _super);
    function WebGLImageScaler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLImageScaler.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLImageScaler.prototype.createProgramInfo = function (handler, inputs) {
        var outputShape = inputs[0].dims.slice();
        var rank = outputShape.length;
        var getBiasMethod = this.createGetBiasMethod(this.bias.length);
        var shaderSource = "\n      " + getBiasMethod + "\n      float process(int indices[" + rank + "]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }";
        return {
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['X'],
            variables: [{ name: 'bias', type: 'float', arrayLength: this.bias.length }, { name: 'scale', type: 'float' }],
            shaderSource: shaderSource,
        };
    };
    WebGLImageScaler.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: { 'bias': this.bias, 'scale': this.scale }
        };
    };
    WebGLImageScaler.prototype.createGetBiasMethod = function (numChannels) {
        var codeLines = ["float getBias(float bias[" + numChannels + "], int channel) {"];
        for (var i = 0; i < numChannels; ++i) {
            if (i === 0) {
                codeLines.push('\t' +
                    ("if (channel == " + i + ") { return bias[" + i + "]; }"));
            }
            else if (i === numChannels - 1) {
                codeLines.push('\t' +
                    ("else { return bias[" + i + "]; }"));
            }
            else {
                codeLines.push('\t' +
                    ("else if (channel == " + i + ") { return bias[" + i + "]; }"));
            }
        }
        codeLines.push('\t' +
            '}');
        return codeLines.join('\n');
    };
    return WebGLImageScaler;
}(image_scaler_1.ImageScaler));
exports.WebGLImageScaler = WebGLImageScaler;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/instance-normalization.ts":
/*!*****************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/instance-normalization.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLInstanceNormalization = void 0;
var instance_normalization_1 = __webpack_require__(/*! ../../../ops/instance-normalization */ "./lib/onnxjs/ops/instance-normalization.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLInstanceNormalization = /** @class */ (function (_super) {
    __extends(WebGLInstanceNormalization, _super);
    function WebGLInstanceNormalization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLInstanceNormalization.prototype.run = function (inferenceHandler, inputs) {
        var _this = this;
        if (!this.artifacts) {
            this.artifacts = [];
            var programInfos = this.createProgramInfos(inferenceHandler, inputs);
            programInfos.forEach(function (programInfo) {
                var artifact = inferenceHandler.session.programManager.build(programInfo);
                _this.artifacts.push(artifact);
            });
        }
        var runDatas = this.createRunDatas(inferenceHandler, this.artifacts.map(function (a) { return a.programInfo; }), inputs);
        runDatas.forEach(function (v, i) { return inferenceHandler.session.programManager.run(_this.artifacts[i], v); });
        return [runDatas[1].outputTextureData.tensor];
    };
    WebGLInstanceNormalization.prototype.checkInputTypes = function (inputs) {
        if (!_super.prototype.checkInputTypes.call(this, inputs)) {
            return false;
        }
        if (inputs[0].dims.length !== 4) {
            // currently webgl implementation only support 4-D input.
            return false;
        }
        return true;
    };
    WebGLInstanceNormalization.prototype.createMeanAndVarianceProgramInfo = function (inferenceHandler, xLayout) {
        var xDims = xLayout.shape;
        var channel = xDims[1];
        var channelSize = xDims[2] * xDims[3];
        var outputShape = [xDims[0], channel];
        var outputUnpackedShape = [xDims[0], channel * 4];
        var shaderSource = "\n    vec4 process(int[2] indices) {\n      vec4 v = vec4(0.0);\n      int a[4];\n      a[0] = indices[0];\n      a[1] = indices[1];\n      float temp = 0.0;\n      for(int a2=0; a2<" + xDims[2] + "; a2++) {\n        a[2] = a2;\n        for(int a3=0; a3<" + xDims[3] + "; a3++) {\n          a[3] = a3;\n          float x = _X(a);\n          temp += x;\n        }\n      }\n      float mean = temp / float(" + channelSize + ");\n      temp = 0.0;\n      for(int a2=0; a2<" + xDims[2] + "; a2++) {\n        a[2] = a2;\n        for(int a3=0; a3<" + xDims[3] + "; a3++) {\n          a[3] = a3;\n          float x = _X(a);\n          temp += (x - mean) * (x - mean);\n        }\n      }\n      v.r = mean;\n      v.g = temp / float(" + channelSize + ");\n\n      return v;\n    }";
        return {
            inputLayouts: [xLayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape, 4, outputUnpackedShape),
            samplers: ['X'],
            shaderSource: shaderSource,
            name: 'MeanAndVariance',
        };
    };
    WebGLInstanceNormalization.prototype.createComputOutputProgramInfo = function (inferenceHandler, xLayout, scaleLayout, bLayout, meanAndVarianceLayout) {
        var glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        var shaderSource = "\n    vec4 get_MeanAndVariance(int[2] mv) {\n      int offset = indicesToOffset_MeanAndVariance(mv);\n      vec2 coords = offsetToCoords(offset, " + meanAndVarianceLayout.width + ", " + meanAndVarianceLayout.height + ");\n      return " + glsl.texture2D + "(MeanAndVariance, coords);\n    }\n\n    float process(int[4] indices) {\n\n          int mv[2];\n          mv[0] = indices[0];\n          mv[1] = indices[1];\n          vec4 mean_and_variance = get_MeanAndVariance(mv);\n          float mean = mean_and_variance.r;\n          float variance = mean_and_variance.g;\n\n          int sb[1];\n          sb[0] = indices[1];\n          float scale = _Scale(sb);\n          float b = _B(sb);\n\n          return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n        }";
        return {
            inputLayouts: [xLayout, meanAndVarianceLayout, scaleLayout, bLayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(xLayout.shape),
            samplers: ['X', 'MeanAndVariance', 'Scale', 'B'],
            variables: [{ name: 'epsilon', type: 'float' }],
            shaderSource: shaderSource,
            name: 'ComputOutput',
        };
    };
    WebGLInstanceNormalization.prototype.createProgramInfos = function (inferenceHandler, inputs) {
        var xLayout = inferenceHandler.getOrCreateTextureLayout(inputs[0]);
        var scaleLayout = inferenceHandler.getOrCreateTextureLayout(inputs[1]);
        var bLayout = inferenceHandler.getOrCreateTextureLayout(inputs[2]);
        var meanAndVarianceProgramInfo = this.createMeanAndVarianceProgramInfo(inferenceHandler, xLayout);
        var computeOutputProgramInfo = this.createComputOutputProgramInfo(inferenceHandler, xLayout, scaleLayout, bLayout, meanAndVarianceProgramInfo.outputLayout);
        var programInfos = [meanAndVarianceProgramInfo, computeOutputProgramInfo];
        return programInfos;
    };
    WebGLInstanceNormalization.prototype.createRunDatas = function (inferenceHandler, programInfos, inputs) {
        var dataType = inputs[0].type;
        var inputTD = inferenceHandler.getOrCreateTextureData(inputs[0], programInfos[0].inputLayouts[0]);
        var scaleTD = inferenceHandler.getOrCreateTextureData(inputs[1], programInfos[1].inputLayouts[2]);
        var bTD = inferenceHandler.getOrCreateTextureData(inputs[2], programInfos[1].inputLayouts[3]);
        var runDatas = [];
        runDatas.push({
            inputTextureDatas: [inputTD],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[0].outputLayout, dataType),
            uniformData: {}
        });
        runDatas.push({
            inputTextureDatas: [inputTD, runDatas[0].outputTextureData, scaleTD, bTD],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[1].outputLayout, dataType),
            uniformData: { 'epsilon': this.epsilon }
        });
        return runDatas;
    };
    return WebGLInstanceNormalization;
}(instance_normalization_1.InstanceNormalization));
exports.WebGLInstanceNormalization = WebGLInstanceNormalization;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/leaky-relu.ts":
/*!*****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/leaky-relu.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLLeakyRelu = void 0;
var leaky_relu_1 = __webpack_require__(/*! ../../../ops/leaky-relu */ "./lib/onnxjs/ops/leaky-relu.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLLeakyRelu = /** @class */ (function (_super) {
    __extends(WebGLLeakyRelu, _super);
    function WebGLLeakyRelu() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLLeakyRelu.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLLeakyRelu.prototype.createProgramInfo = function (handler, inputs) {
        var outputShape = inputs[0].dims.slice();
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n      void main() {\n        float v = " + glsl.texture2D + "(A, TexCoords).r;\n        " + glsl.output + " = vec4(v < 0.0 ? v * float(" + this.alpha + ") : v);\n      }\n      ";
        return {
            hasMain: true,
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
        };
    };
    WebGLLeakyRelu.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLLeakyRelu;
}(leaky_relu_1.LeakyRelu));
exports.WebGLLeakyRelu = WebGLLeakyRelu;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/matmul-pack.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/matmul-pack.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLMatMulPacked = void 0;
var matmul_1 = __webpack_require__(/*! ../../../ops/matmul */ "./lib/onnxjs/ops/matmul.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var fuse_utils_1 = __webpack_require__(/*! ./fuse-utils */ "./lib/onnxjs/backends/webgl/ops/fuse-utils.ts");
var WebGLMatMulPacked = /** @class */ (function (_super) {
    __extends(WebGLMatMulPacked, _super);
    function WebGLMatMulPacked() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLMatMulPacked.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLMatMulPacked.prototype.createProgramInfo = function (handler, inputs) {
        var hasBias = inputs.length > 2;
        var processBias = hasBias ? 'result += getBiasAtOutCoords();' : '';
        var aShape = inputs[0].dims;
        var bShape = inputs[1].dims;
        var outputShape = util_1.BroadcastUtil.calcShape(aShape, bShape, true);
        if (!outputShape) {
            throw new Error('Can\'t use matmul on the given tensors');
        }
        var sharedDim = aShape[aShape.length - 1];
        var sharedDimIndex = Math.ceil(sharedDim / 2);
        var aRank = aShape.length;
        var bRank = bShape.length;
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var coordsDataType = utils_1.getCoordsDataType(outputShape.length);
        var outRank = outputShape.length;
        var allGlChannels = ['x', 'y', 'z', 'w', 'u', 'v'];
        var _a = fuse_utils_1.getActicationSnippet(this.activation), activationFunction = _a.activationFunction, applyActivation = _a.applyActivation;
        var shaderSource = "\n      " + activationFunction + "\n      void main() {\n        " + coordsDataType + " rc = getOutputCoords();\n        int lastDim = rc." + allGlChannels[outRank - 1] + ";\n        rc." + allGlChannels[outRank - 1] + " = rc." + allGlChannels[outRank - 2] + ";\n        rc." + allGlChannels[outRank - 2] + " = lastDim;\n\n        vec4 result = vec4(0);\n        for (int i = 0; i < " + sharedDimIndex + "; i++) {\n          vec4 a = getA(" + getA(allGlChannels, aRank) + ");\n          vec4 b = getB(" + getB(allGlChannels, bRank) + ");\n          result += (a.rrbb * b.rgrg);\n          result += (a.ggaa * b.baba);\n        }\n        " + processBias + "\n        " + applyActivation + "\n        " + glsl.output + " = result;\n      }";
        return {
            name: 'WebGLMatMulPacked',
            inputLayouts: inputs.map(function (t, i) { return handler.getOrCreateTextureLayout(t, 4, true, inputs[i].dims, true); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }),
            samplers: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],
            shaderSource: shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true,
        };
    };
    WebGLMatMulPacked.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t) { return handler.getOrCreateTextureData(t, handler.getOrCreateTextureLayout(t, 1, false, [], true)); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLMatMulPacked;
}(matmul_1.MatMul));
exports.WebGLMatMulPacked = WebGLMatMulPacked;
function getA(allGlChannels, rank) {
    var res = '';
    for (var i = 0; i < rank - 2; i++) {
        res += "rc." + allGlChannels[i] + ", ";
    }
    res += "rc." + allGlChannels[rank - 2] + ", " +
        'i*2';
    return res;
}
function getB(allGlChannels, rank) {
    var res = '';
    for (var i = 0; i < rank - 2; i++) {
        res += "rc." + allGlChannels[i] + ", ";
    }
    res += 'i*2, ' +
        ("rc." + allGlChannels[rank - 1]);
    return res;
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/matmul.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/matmul.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnpackedMatMul = exports.WebGLMatMul = void 0;
var matmul_1 = __webpack_require__(/*! ../../../ops/matmul */ "./lib/onnxjs/ops/matmul.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var matmul_pack_1 = __webpack_require__(/*! ./matmul-pack */ "./lib/onnxjs/backends/webgl/ops/matmul-pack.ts");
var WebGLMatMul = /** @class */ (function (_super) {
    __extends(WebGLMatMul, _super);
    function WebGLMatMul() {
        var _this = _super.call(this) || this;
        _this.packedImpl = new matmul_pack_1.WebGLMatMulPacked();
        _this.unpackedImpl = new WebGLUnpackedMatMul();
        return _this;
    }
    WebGLMatMul.prototype.run = function (inferenceHandler, inputs) {
        if (this.usePackedTexture === undefined) {
            var isBroadcast = !util_1.ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
            this.usePackedTexture = !isBroadcast && inferenceHandler.session.pack;
        }
        if (this.usePackedTexture) {
            return inferenceHandler.run(this.packedImpl, inputs);
        }
        else {
            return inferenceHandler.run(this.unpackedImpl, inputs);
        }
    };
    WebGLMatMul.prototype.createProgramInfo = function (handler, inputs) {
        if (this.usePackedTexture === undefined) {
            var isBroadcast = !util_1.ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
            this.usePackedTexture = !isBroadcast && handler.session.pack;
        }
        if (this.usePackedTexture && inputs[0].dims.length > 1) {
            return this.packedImpl.createProgramInfo(handler, inputs);
        }
        else {
            return this.unpackedImpl.createProgramInfo(handler, inputs);
        }
    };
    WebGLMatMul.prototype.createRunData = function (handler, programInfo, inputs) {
        if (this.usePackedTexture && inputs[0].dims.length > 1) {
            return this.packedImpl.createRunData(handler, programInfo, inputs);
        }
        else {
            return this.unpackedImpl.createRunData(handler, programInfo, inputs);
        }
    };
    return WebGLMatMul;
}(matmul_1.MatMul));
exports.WebGLMatMul = WebGLMatMul;
var WebGLUnpackedMatMul = /** @class */ (function (_super) {
    __extends(WebGLUnpackedMatMul, _super);
    function WebGLUnpackedMatMul() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLUnpackedMatMul.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLUnpackedMatMul.prototype.createProgramInfo = function (handler, inputs) {
        var aShape = inputs[0].dims;
        var bShape = inputs[1].dims;
        var outputShape = util_1.BroadcastUtil.calcShape(aShape, bShape, true);
        if (!outputShape) {
            throw new Error('Can\'t use matmul on the given tensors');
        }
        var rank = outputShape.length;
        var arank = aShape.length;
        var brank = bShape.length;
        var sharedDim = aShape[aShape.length - 1];
        var shaderSource = "\n      float process(int indices[" + rank + "]) {\n          int a[" + arank + "];\n          int b[" + brank + "];\n          bcastMatmulIndices_A(indices, a);\n          bcastMatmulIndices_B(indices, b);\n\n          float value;\n          for (int k=0; k<" + sharedDim + "; ++k) {\n              a[" + (arank - 1) + "] = k;\n              b[" + (brank - 2) + "] = k;\n              value += _A(a) * _B(b);\n          }\n          return value;\n      }";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'B'],
            shaderSource: shaderSource,
        };
    };
    WebGLUnpackedMatMul.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLUnpackedMatMul;
}(matmul_1.MatMul));
exports.WebGLUnpackedMatMul = WebGLUnpackedMatMul;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/pack.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/pack.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLPack = void 0;
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
var WebGLPack = /** @class */ (function () {
    function WebGLPack() {
    }
    WebGLPack.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLPack.prototype.createProgramInfo = function (handler, inputs) {
        if (inputs.length !== 1) {
            throw new Error('Pack kernel should have input tensor count to 1.');
        }
        var inputShape = inputs[0].dims;
        var outputLayout = handler.createTextureLayoutFromShape(inputShape, 4, inputShape, { isPacked: true, reverseWH: true });
        var outputShape = outputLayout.shape;
        var inputRank = inputShape.length;
        var outputRank = outputShape.length;
        var coordsDataType = utils_1.getCoordsDataType(outputRank);
        var channels = packing_utils_1.getChannels('rc', outputRank);
        var setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);
        var reversedInputWH;
        if (inputRank === 0) {
            reversedInputWH = [1, 1];
        }
        else if (inputRank === 1) {
            reversedInputWH = [inputShape[0], 1];
        }
        else {
            reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];
        }
        var outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);
        var output = getOutput(inputShape, channels);
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n        void main() {\n          " + coordsDataType + " rc = getOutputCoords();\n\n          if(" + outOfBoundsCondition + ") {\n            " + glsl.output + " = vec4(0);\n          } else {\n            " + setup + "\n\n            " + glsl.output + " = vec4(" + output + ");\n          }\n        }\n      ";
        return {
            name: 'WebGLPack',
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0], 1, false, [], true)],
            outputLayout: outputLayout,
            samplers: ['A'],
            shaderSource: shaderSource,
            hasMain: true,
            expectPackedInputs: false,
            expectPackedOutputs: true,
        };
    };
    WebGLPack.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLPack;
}());
exports.WebGLPack = WebGLPack;
/**
 * check output coordinate location and return false if it is outside input's width/height boundary
 */
function getOutOfBoundsCondition(rank, shape, dims) {
    if (rank === 1) {
        return "rc > " + shape[0];
    }
    var cond = '';
    for (var i = rank - 2; i < rank; i++) {
        cond += dims[i] + " >= " + shape[i - rank + 2];
        if (i < rank - 1) {
            cond += '||';
        }
    }
    return cond;
}
/**
 * code snippet to sample input texture with output coordiantes
 */
function getOutput(shape, dims) {
    var rank = shape.length;
    if (rank === 0) {
        return 'getA(), 0, 0, 0';
    }
    if (rank === 1) {
        return "getA(rc),\n            rc + 1 >= " + shape[0] + " ? 0. : getA(rc + 1),\n            0, 0";
    }
    var coord00 = 'r, c';
    var coord01 = 'r, cp1';
    var coord10 = 'rp1, c';
    var coord11 = 'rp1, cp1';
    var D = '';
    if (rank > 2) {
        for (var i = 0; i < rank - 2; ++i) {
            D = D + (dims[i] + ",");
        }
    }
    return "getA(" + D + coord00 + "),\n          rEdge ? 0. : getA(" + D + coord10 + "),\n          cEdge ? 0. : getA(" + D + coord01 + "),\n          rEdge || cEdge ? 0. : getA(" + D + coord11 + ")";
}
/**
 * code snippet to setup 4 coordinates and edge conditions
 */
function getSetup(rank, dims, rows, cols) {
    if (rank === 0 || rank === 1) {
        return '';
    }
    // rank >= 2 for width+height pack.
    else {
        var setup_1 = "\n    int r = " + dims[rank - 2] + ";\n    int c = " + dims[rank - 1] + ";\n    int rp1 = " + dims[rank - 2] + " + 1;\n    int cp1 = " + dims[rank - 1] + " + 1;\n    bool rEdge = rp1 >= " + cols + ";\n    bool cEdge = cp1 >= " + rows + ";\n    ";
        return setup_1;
    }
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/packing-utils.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unpackFromChannel = exports.getChannels = exports.getVecChannels = void 0;
function getVecChannels(name, rank) {
    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(function (d) { return name + "." + d; });
}
exports.getVecChannels = getVecChannels;
function getChannels(name, rank) {
    if (rank === 1) {
        return [name];
    }
    return getVecChannels(name, rank);
}
exports.getChannels = getChannels;
function unpackFromChannel() {
    return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
}
exports.unpackFromChannel = unpackFromChannel;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/pad.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/pad.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPadFunction = exports.WebGLPad = void 0;
var pad_1 = __webpack_require__(/*! ../../../ops/pad */ "./lib/onnxjs/ops/pad.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLPad = /** @class */ (function (_super) {
    __extends(WebGLPad, _super);
    function WebGLPad() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLPad.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLPad.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        var outputShape = util_1.ShapeUtil.padShape(inputs[0].dims.slice(), this.pads);
        var rank = outputShape.length;
        var alayout = inferenceHandler.getOrCreateTextureLayout(inputs[0]);
        var padFunction = getPadFunction(glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version), 'A', alayout, this.mode, this.pads, this.value);
        var shaderSource = "\n      " + padFunction + "\n      float process(int[" + rank + "] indices) {\n          return padA(indices);\n      }";
        return {
            inputLayouts: [alayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
        };
    };
    WebGLPad.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLPad;
}(pad_1.Pad));
exports.WebGLPad = WebGLPad;
function getPadFunction(glsl, name, inputLayout, mode, pads, value) {
    switch (mode) {
        case 'constant':
            return getPadConstant(glsl, name, inputLayout.shape, inputLayout.strides, inputLayout.width, inputLayout.height, pads, value);
        case 'reflect':
            return getPadReflect(glsl, name, inputLayout.shape, inputLayout.strides, inputLayout.width, inputLayout.height, pads);
        case 'edge':
            return getPadEdge(glsl, name, inputLayout.shape, inputLayout.strides, inputLayout.width, inputLayout.height, pads);
        default:
            throw new Error('Invalid mode');
    }
}
exports.getPadFunction = getPadFunction;
function getPadConstant(glsl, name, shape, strides, width, height, pads, value) {
    var rank = shape.length;
    var block = '';
    for (var i = rank - 1; i >= 0; --i) {
        block += "\n          k = m[" + i + "] - " + pads[i] + ";\n          if (k < 0)  return constant;\n          if (k >= " + shape[i] + ") return constant;\n          offset += k * " + strides[i] + ";\n          ";
    }
    return "\n        float pad" + name + "(int m[" + rank + "]) {\n          const float constant = float(" + value + ");\n          int offset = 0;\n          int k = 0;\n          " + block + "\n          vec2 coords = offsetToCoords(offset, " + width + ", " + height + ");\n          float value = getColorAsFloat(" + glsl.texture2D + "(" + name + ", coords));\n          return value;\n        }\n        ";
}
function getPadReflect(glsl, name, shape, strides, width, height, pads) {
    var rank = shape.length;
    var block = '';
    for (var i = rank - 1; i >= 0; --i) {
        block += "\n        k = m[" + i + "] - " + pads[i] + ";\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = " + 2 * (shape[i] - 1) + ";\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= " + shape[i] + ") { k = _2n_1 - k; }\n        }\n        offset += k * " + strides[i] + ";\n        ";
    }
    return "\n      float pad" + name + "(int m[" + rank + "]) {\n        int offset = 0;\n        int k = 0;\n        " + block + "\n        vec2 coords = offsetToCoords(offset, " + width + ", " + height + ");\n        float value = getColorAsFloat(" + glsl.texture2D + "(" + name + ", coords));\n        return value;\n      }\n      ";
}
function getPadEdge(glsl, name, shape, strides, width, height, pads) {
    var rank = shape.length;
    var block = '';
    for (var i = rank - 1; i >= 0; --i) {
        block += "\n      k = m[" + i + "] - " + pads[i] + ";\n      if (k < 0)  k = 0;\n      if (k >= " + shape[i] + ") k = " + (shape[i] - 1) + ";\n      offset += k * " + strides[i] + ";\n      ";
    }
    return "\n    float pad" + name + "(int m[" + rank + "]) {\n      int offset = 0;\n      int k = 0;\n      " + block + "\n      vec2 coords = offsetToCoords(offset, " + width + ", " + height + ");\n      float value = getColorAsFloat(" + glsl.texture2D + "(" + name + ", coords));\n      return value;\n    }\n    ";
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/pool.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/pool.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.offsetToIndices = exports.copyArray = exports.generatePoolingCode = exports.WebGLMaxPool = exports.WebGLGlobalMaxPool = exports.WebGLAveragePool = exports.WebGLGlobalAveragePool = void 0;
var pool_1 = __webpack_require__(/*! ../../../ops/pool */ "./lib/onnxjs/ops/pool.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var WebGLGlobalAveragePool = /** @class */ (function (_super) {
    __extends(WebGLGlobalAveragePool, _super);
    function WebGLGlobalAveragePool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLGlobalAveragePool.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLGlobalAveragePool.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        return createAveragePoolProgramInfo(inferenceHandler, inputs, true, this.kernelShape, this.autoPad, this.strides, this.pads, this.countIncludePad);
    };
    WebGLGlobalAveragePool.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLGlobalAveragePool;
}(pool_1.GlobalAveragePool));
exports.WebGLGlobalAveragePool = WebGLGlobalAveragePool;
var WebGLAveragePool = /** @class */ (function (_super) {
    __extends(WebGLAveragePool, _super);
    function WebGLAveragePool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLAveragePool.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLAveragePool.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        return createAveragePoolProgramInfo(inferenceHandler, inputs, false, this.kernelShape, this.autoPad, this.strides, this.pads, this.countIncludePad);
    };
    WebGLAveragePool.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLAveragePool;
}(pool_1.AveragePool));
exports.WebGLAveragePool = WebGLAveragePool;
function createAveragePoolProgramInfo(inferenceHandler, inputs, isGlobalOperator, kernelShape, autoPad, strides, pads, countIncludePad) {
    if (kernelShape === void 0) { kernelShape = []; }
    if (autoPad === void 0) { autoPad = ''; }
    if (strides === void 0) { strides = []; }
    if (pads === void 0) { pads = []; }
    var inputShape = inputs[0].dims.slice();
    util_1.PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, pads);
    var outputShape = util_1.PoolConvUtil.computePoolOutputShape(isGlobalOperator, inputShape, strides, kernelShape, pads, autoPad);
    var kernelSize = util_1.ShapeUtil.size(kernelShape);
    var op1 = 'value += _X(x);';
    var op2 = '';
    if (countIncludePad) {
        op2 += "value /= float(" + kernelSize + ");";
    }
    else {
        op2 += "value /= float(" + kernelSize + " - pad);";
    }
    var inputLayout = inferenceHandler.getOrCreateTextureLayout(inputs[0]);
    var poolingCode = generatePoolingCode(inputLayout, kernelShape, pads, strides, op1, op2, '0.0');
    var shaderSource = "\n      " + poolingCode + "\n    ";
    return {
        inputLayouts: [inputLayout],
        outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
        samplers: ['X'],
        shaderSource: shaderSource,
    };
}
var WebGLGlobalMaxPool = /** @class */ (function (_super) {
    __extends(WebGLGlobalMaxPool, _super);
    function WebGLGlobalMaxPool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLGlobalMaxPool.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLGlobalMaxPool.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        return createMaxPoolProgramInfo(inferenceHandler, inputs, true, this.kernelShape, this.autoPad, this.strides, this.pads);
    };
    WebGLGlobalMaxPool.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLGlobalMaxPool;
}(pool_1.GlobalMaxPool));
exports.WebGLGlobalMaxPool = WebGLGlobalMaxPool;
var WebGLMaxPool = /** @class */ (function (_super) {
    __extends(WebGLMaxPool, _super);
    function WebGLMaxPool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLMaxPool.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLMaxPool.prototype.createProgramInfo = function (inferenceHandler, inputs) {
        return createMaxPoolProgramInfo(inferenceHandler, inputs, false, this.kernelShape, this.autoPad, this.strides, this.pads);
    };
    WebGLMaxPool.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLMaxPool;
}(pool_1.MaxPool));
exports.WebGLMaxPool = WebGLMaxPool;
function createMaxPoolProgramInfo(inferenceHandler, inputs, isGlobalOperator, kernelShape, autoPad, strides, pads) {
    if (kernelShape === void 0) { kernelShape = []; }
    if (autoPad === void 0) { autoPad = ''; }
    if (strides === void 0) { strides = []; }
    if (pads === void 0) { pads = []; }
    var inputShape = inputs[0].dims.slice();
    util_1.PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, pads);
    var outputShape = util_1.PoolConvUtil.computePoolOutputShape(isGlobalOperator, inputShape, strides, kernelShape, pads, autoPad);
    var op1 = "\n              value = max(_X(x), value);\n      ";
    var op2 = '';
    var inputLayout = inferenceHandler.createTextureLayoutFromShape(inputShape);
    var poolingCode = generatePoolingCode(inputLayout, kernelShape, pads, strides, op1, op2, '-1e5');
    var shaderSource = "\n    " + poolingCode + "\n  ";
    return {
        inputLayouts: [inputLayout],
        outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
        samplers: ['X'],
        shaderSource: shaderSource,
    };
}
function generatePoolingCode(x, kernelShape, pads, strides, op1, op2, startVal) {
    var inputDims = x.shape;
    var rank = x.shape.length;
    if (kernelShape.length <= 2) {
        var kw = kernelShape[kernelShape.length - 1];
        var sw = strides[strides.length - 1];
        var pwStart = pads[pads.length / 2 - 1];
        var pwEnd = pads[pads.length - 1];
        var dimW = inputDims[rank - 1];
        var codeW = '';
        var codeH = '';
        var codeHEnd = '';
        if (pwStart + pwEnd !== 0) {
            codeW = "\n                for (int i = 0; i < " + kw + "; i++) {\n                  x[" + rank + " - 1] = indices[" + rank + " - 1] * " + sw + " - " + pwStart + " + i;\n                  if (x[" + rank + " - 1] < 0 || x[" + rank + " - 1] >= " + dimW + ") {\n                    pad++;\n                    continue;\n                  }\n                  " + op1 + "\n                }";
        }
        else {
            codeW = "\n                for (int i = 0; i < " + kw + "; i++) {\n                  x[" + rank + " - 1] = indices[" + rank + " - 1] * " + sw + " - " + pwStart + " + i;\n                  " + op1 + "\n                }";
        }
        if (kernelShape.length === 2) {
            var kh = kernelShape[kernelShape.length - 2];
            var sh = strides[strides.length - 2];
            var phStart = pads[pads.length / 2 - 2];
            var phEnd = pads[pads.length - 2];
            var dimH = inputDims[rank - 2];
            if (phStart + phEnd !== 0) {
                codeH = "\n              for (int j = 0; j < " + kh + "; j++) {\n                x[" + rank + " - 2] = indices[" + rank + " - 2] * " + sh + " - " + phStart + " + j;\n                if (x[" + rank + " - 2] < 0 || x[" + rank + " - 2] >= " + dimH + ") {\n                  pad+= " + kw + ";\n                  continue;\n                }\n            ";
            }
            else {
                codeH = "\n                for (int j = 0; j < " + kh + "; j++) {\n                  x[" + rank + " - 2] = indices[" + rank + " - 2] * " + sh + " - " + phStart + " + j;\n                ";
            }
            codeHEnd = "\n              }\n            ";
        }
        var poolingCode = "\n            float process(int indices[" + rank + "]) {\n              int x[" + rank + "];\n              copyVec(indices, x);\n\n              float value = " + startVal + ";\n              int pad = 0;\n              " + codeH + "\n              " + codeW + "\n              " + codeHEnd + "\n              " + op2 + "\n              return value;\n            }\n          ";
        return poolingCode;
    }
    else {
        var kernelSize = util_1.ShapeUtil.size(kernelShape);
        var kernelStrides = util_1.ShapeUtil.computeStrides(kernelShape);
        var stridesRank = kernelStrides.length;
        var padsRank = pads.length;
        var offsetToIndicesFunction = offsetToIndices(stridesRank);
        var copyInputDims = copyArray(inputDims, 'inputDims');
        var copyPads = copyArray(pads, 'pads');
        var copyKernelStrides = copyArray(kernelStrides, 'kernelStrides');
        var copyStrides = copyArray(strides, 'strides');
        var hasPads = pads.reduce(function (sum, cur) { return sum + cur; });
        var padCode = '';
        if (hasPads) {
            padCode = "\n                if (x[j] >= inputDims[j] || x[j] < 0) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                " + op1 + "\n              }";
        }
        else {
            padCode = "\n                  }\n                  " + op1;
        }
        var poolingCode = "\n            " + offsetToIndicesFunction + "\n            float process(int indices[" + rank + "]) {\n                int x[" + rank + "];\n                copyVec(indices, x);\n                int offset[" + stridesRank + "];\n                int pads[" + padsRank + "];\n                int inputDims[" + rank + "];\n                int kernelStrides[" + stridesRank + "];\n                int strides[" + stridesRank + "];\n                " + copyPads + "\n                " + copyInputDims + "\n                " + copyStrides + "\n                " + copyKernelStrides + "\n\n                float value = " + startVal + ";\n                int pad = 0;\n                bool isPad = false;\n                for (int i = 0; i < " + kernelSize + "; i++) {\n                    offsetToIndices(i, kernelStrides, offset);\n                    isPad = false;\n                    for (int j = " + rank + " - " + stridesRank + "; j < " + rank + "; j++) {\n                      x[j] = indices[j] * strides[j - " + rank + " + " + stridesRank + "]\n                        + offset[j - " + rank + " + " + stridesRank + "] - pads[j - 2];\n                      " + padCode + "\n                }\n                " + op2 + "\n\n                return value;\n            }";
        return poolingCode;
    }
}
exports.generatePoolingCode = generatePoolingCode;
function copyArray(array, arrayName) {
    var block = '';
    for (var i = 0; i < array.length; i++) {
        block += "\n      " + arrayName + "[" + i + "] = " + array[i] + ";\n    ";
    }
    return block;
}
exports.copyArray = copyArray;
function offsetToIndices(rank) {
    return "\n    void offsetToIndices(int offset, int[" + rank + "] strides, out int[" + rank + "] indices) {\n      if (" + rank + " == 0) {\n        return;\n      }\n      for (int i = 0; i < " + rank + " - 1; ++i) {\n        indices[i] = offset / strides[i];\n        offset -= indices[i] * strides[i];\n      }\n      indices[" + rank + " - 1] = offset;\n    }";
}
exports.offsetToIndices = offsetToIndices;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/reduce.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/reduce.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLReduceSumSquare = exports.WebGLReduceLogSum = exports.WebGLReduceProd = exports.WebGLReduceMin = exports.WebGLReduceMax = exports.WebGLReduceMean = exports.WebGLReduceSum = void 0;
var reduce_op_1 = __webpack_require__(/*! ../../../ops/reduce-op */ "./lib/onnxjs/ops/reduce-op.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var WebGLGenericReduce = /** @class */ (function (_super) {
    __extends(WebGLGenericReduce, _super);
    function WebGLGenericReduce() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLGenericReduce.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLGenericReduce.prototype.createProgramInfo = function (handler, inputs) {
        var outputShape = [];
        var iRank = inputs[0].dims.length || 1;
        var idxCopy = []; // copy output indexes to input indexes
        var axes = util_1.ShapeUtil.normalizeAxes(this.axes, inputs[0].dims.length);
        var ops = this.getOps(inputs, axes); // [init ops, reduce ops, final ops]
        var reduceOps = ops[1];
        for (var k = 0; k < inputs[0].dims.length; k++) {
            // if this axis is reduced
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                if (this.keepDims) {
                    outputShape.push(1);
                } // else { remove the axis from outputShape; }
                // loop over the d-th axis
                reduceOps = "\n        for(int j" + k + " = 0; j" + k + " < " + inputs[0].dims[k] + "; j" + k + "++) {\n          inputIdx[" + k + "] = j" + k + ";\n          " + reduceOps + "\n        }\n        ";
            }
            else {
                idxCopy.push("inputIdx[" + k + "] = outputIdx[" + outputShape.length + "];");
                outputShape.push(inputs[0].dims[k]);
            }
        }
        var oRank = outputShape.length || 1;
        var shaderSource = "\n      float process(int outputIdx[" + oRank + "]) {\n        float value;                 // final result\n        int inputIdx[" + iRank + "];      // addressing input data\n        " + idxCopy.join('\n') + "\n        " + ops[0] + "       // init ops for reduce max/min\n        " + reduceOps + "\n        " + ops[2] + "       // final computation for reduce mean\n        return value;\n      }";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
        };
    };
    WebGLGenericReduce.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLGenericReduce;
}(reduce_op_1.ReduceBase));
var WebGLReduceSum = /** @class */ (function (_super) {
    __extends(WebGLReduceSum, _super);
    function WebGLReduceSum() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceSum.prototype.getOps = function (_inputs) {
        return ['value = 0.0;', 'value += _A(inputIdx);', ''];
    };
    return WebGLReduceSum;
}(WebGLGenericReduce));
exports.WebGLReduceSum = WebGLReduceSum;
var WebGLReduceMean = /** @class */ (function (_super) {
    __extends(WebGLReduceMean, _super);
    function WebGLReduceMean() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceMean.prototype.getOps = function (inputs, axes) {
        var size = 1.0;
        for (var k = 0; k < inputs[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                size *= inputs[0].dims[k];
            }
        }
        return ['value = 0.0;', 'value += _A(inputIdx);', "value /= " + size + ".;"]; // ensure real number with `.`
    };
    return WebGLReduceMean;
}(WebGLGenericReduce));
exports.WebGLReduceMean = WebGLReduceMean;
var WebGLReduceMax = /** @class */ (function (_super) {
    __extends(WebGLReduceMax, _super);
    function WebGLReduceMax() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceMax.prototype.getOps = function (inputs, axes) {
        var idxZero = [];
        for (var k = 0; k < inputs[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                idxZero.push("inputIdx[" + k + "] = 0;"); // first element
            }
        }
        return [idxZero.join('\n') + "\nvalue = _A(inputIdx);", 'value = max(value, _A(inputIdx));', ''];
    };
    return WebGLReduceMax;
}(WebGLGenericReduce));
exports.WebGLReduceMax = WebGLReduceMax;
var WebGLReduceMin = /** @class */ (function (_super) {
    __extends(WebGLReduceMin, _super);
    function WebGLReduceMin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceMin.prototype.getOps = function (inputs, axes) {
        var idxZero = [];
        for (var k = 0; k < inputs[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                idxZero.push("inputIdx[" + k + "] = 0;"); // first element
            }
        }
        return [idxZero.join('\n') + "\nvalue = _A(inputIdx);", 'value = min(value, _A(inputIdx));', ''];
    };
    return WebGLReduceMin;
}(WebGLGenericReduce));
exports.WebGLReduceMin = WebGLReduceMin;
var WebGLReduceProd = /** @class */ (function (_super) {
    __extends(WebGLReduceProd, _super);
    function WebGLReduceProd() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceProd.prototype.getOps = function (_inputs) {
        return ['value = 1.0;', 'value *= _A(inputIdx);', ''];
    };
    return WebGLReduceProd;
}(WebGLGenericReduce));
exports.WebGLReduceProd = WebGLReduceProd;
var WebGLReduceLogSum = /** @class */ (function (_super) {
    __extends(WebGLReduceLogSum, _super);
    function WebGLReduceLogSum() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceLogSum.prototype.getOps = function (_inputs) {
        return ['value = 0.0;', 'value += _A(inputIdx);', 'value = log(value);'];
    };
    return WebGLReduceLogSum;
}(WebGLGenericReduce));
exports.WebGLReduceLogSum = WebGLReduceLogSum;
var WebGLReduceSumSquare = /** @class */ (function (_super) {
    __extends(WebGLReduceSumSquare, _super);
    function WebGLReduceSumSquare() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLReduceSumSquare.prototype.getOps = function (_inputs) {
        return ['float t; value = 0.0;', 't = _A(inputIdx); value += t * t;', ''];
    };
    return WebGLReduceSumSquare;
}(WebGLGenericReduce));
exports.WebGLReduceSumSquare = WebGLReduceSumSquare;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/reshape-packed.ts":
/*!*********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/reshape-packed.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLReshapePacked = void 0;
var reshape_1 = __webpack_require__(/*! ../../../ops/reshape */ "./lib/onnxjs/ops/reshape.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
var WebGLReshapePacked = /** @class */ (function (_super) {
    __extends(WebGLReshapePacked, _super);
    function WebGLReshapePacked() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.needSqueezeInputData = false;
        return _this;
    }
    WebGLReshapePacked.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLReshapePacked.prototype.createProgramInfo = function (handler, inputs) {
        if (inputs.length !== 2) {
            throw new Error('resize kernel should have input tensor count to 2.');
        }
        // For packed reshape, we need to re-arrange texel data for output shape.
        // Our pack is designed to pack a 2x2 tile in last h and w dimension, so
        // for the reshaped new tensor, we just need to re-arrange the last h and
        // w dimension. For any shape that is not in 3D, i.e. [batch, W, H], we
        // first convert it to 3D by collapsing other dimension to batch dim, then
        // process with the last two dimensions.
        // Note: we only need the shape tensor to calculate output shape, so the
        // content in shape tensor is never uploaded to GPU. It is always kept in CPU.
        // TODO: optimize the algorithm -- in some cases, if the last two dims are
        // the same between input shape and output shape, the packed reshape can be
        // treated as no-op.
        // TODO: the implementation is a bit complicated due to the fact tensor shape is
        // immutable once the tensor is created, plus the tensor shape has a 1-to-1
        // mapping with texture layout. In the future, we may consider relaxing this
        // assumption.
        var originInputShape = inputs[0].dims;
        this.inputShape3D = processDims3D(inputs[0].dims);
        var inputLayout;
        inputLayout = handler.getOrCreateTextureLayout(inputs[0], 4, true, originInputShape, true);
        if (originInputShape.length !== 3) {
            var originalInputLayout = inputLayout;
            // if originShape is not a 3D shape, create texture layout from the processed shape.
            inputLayout = handler.createTextureLayoutFromShape(this.inputShape3D, 4, this.inputShape3D, { isPacked: true, reverseWH: true });
            // if the processed input shape produces texture layout differnt from the original
            // one, the run data has to use the processed (3D) input shape later.
            this.needSqueezeInputData =
                (inputLayout.height !== originalInputLayout.height) || (inputLayout.width !== originalInputLayout.width);
        }
        this.outputShape = util_1.ShapeUtil.calculateReshapedDims(originInputShape, inputs[1].integerData);
        var squeezedOutputShape = processDims3D(this.outputShape);
        this.outputLayout = handler.createTextureLayoutFromShape(squeezedOutputShape, 4, squeezedOutputShape, { isPacked: true, reverseWH: true });
        var mainLoop = '';
        for (var i = 0; i < 4; i++) {
            var outputCoords = '';
            switch (i) {
                case 0:
                    outputCoords = 'outputCoords = rc;';
                    break;
                case 1:
                    outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z);';
                    break;
                case 2:
                    outputCoords = 'outputCoords = ivec3(rc.x, rc.y, rc.z+1);';
                    break;
                case 3:
                    outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);';
                    break;
                default:
                    throw new Error();
            }
            mainLoop += "\n        " + outputCoords + "\n        " + (i > 0 ? 'if(outputCoords.y < rows && outputCoords.z < cols){' : '') + "\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + i + "] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        " + (i > 0 ? '}' : '') + "\n      ";
        }
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n      " + getReshapedInputCoords(this.inputShape3D) + "\n      " + getFlattenedIndexFrom3D(squeezedOutputShape) + "\n      " + packing_utils_1.unpackFromChannel() + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = " + squeezedOutputShape[2] + ";\n        int cols = " + squeezedOutputShape[1] + ";\n\n        " + mainLoop + "\n        " + glsl.output + " = result;\n      }\n    ";
        return {
            name: 'WebGLReshapePacked',
            inputLayouts: [inputLayout],
            outputLayout: this.outputLayout,
            samplers: ['A'],
            shaderSource: shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true,
        };
    };
    WebGLReshapePacked.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs;
        var originalInputLayout = handler.getOrCreateTextureLayout(inputs[0], 1, false, [], false);
        var originalInputTD = handler.getOrCreateTextureData(inputs[0], originalInputLayout, false);
        if (this.needSqueezeInputData) {
            var squeezedInputLayout = {
                channels: 1,
                height: originalInputLayout.height,
                width: originalInputLayout.width,
                shape: this.inputShape3D,
                strides: util_1.ShapeUtil.computeStrides(this.inputShape3D),
                unpackedShape: this.inputShape3D,
            };
            var squeezedInputTD = handler.createSharedTextureData(squeezedInputLayout, inputs[0].type, originalInputTD.texture);
            inputTDs = [squeezedInputTD];
        }
        else {
            inputTDs = [originalInputTD];
        }
        var outputLayout = this.outputLayout;
        // Use original output shape for runData output layout.
        outputLayout.shape = this.outputShape;
        outputLayout.unpackedShape = this.outputShape;
        if (outputLayout === undefined) {
            outputLayout = handler.createTextureLayoutFromShape(this.outputShape, 4, this.outputShape, { isPacked: true, reverseWH: true });
        }
        // return run data for reshape. Here, we use the original calculate outputLayout to create the real output layout.
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLReshapePacked;
}(reshape_1.Reshape));
exports.WebGLReshapePacked = WebGLReshapePacked;
function processDims3D(shape) {
    if (shape.length === 0) {
        return [1, 1, 1];
    }
    // TODO: squeeze other shapes to 2D case
    var batchDims = shape.length >= 3 ? shape.slice(0, shape.length - 2) : [1];
    var batch = 1;
    for (var i = 0; i < batchDims.length; ++i) {
        batch *= batchDims[i];
    }
    return [batch, shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];
}
function getReshapedInputCoords(shape) {
    var strides = util_1.ShapeUtil.computeStrides(shape);
    var coords = ['b', 'r', 'c'];
    var index = 'index';
    var coordsFromIndexSnippet = strides
        .map(function (stride, i) {
        var line1 = "int " + coords[i] + " = " + index + " / " + stride;
        var line2 = i === strides.length - 1 ?
            "int " + coords[i + 1] + " = " + index + " - " + coords[i] + " * " + stride :
            "index -= " + coords[i] + " * " + stride;
        return line1 + "; " + line2 + ";";
    })
        .join('');
    return "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + coordsFromIndexSnippet + "\n      return ivec3(b, r, c);\n    }\n  ";
}
function getFlattenedIndexFrom3D(shape) {
    var strides = util_1.ShapeUtil.computeStrides(shape);
    return "\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * " + strides[0] + " + coords.z * " + strides[1] + " + coords.y;\n  }\n";
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/reshape.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/reshape.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reshape = exports.WebGLReshape = void 0;
var reshape_1 = __webpack_require__(/*! ../../../ops/reshape */ "./lib/onnxjs/ops/reshape.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var reshape_packed_1 = __webpack_require__(/*! ./reshape-packed */ "./lib/onnxjs/backends/webgl/ops/reshape-packed.ts");
var WebGLReshape = /** @class */ (function (_super) {
    __extends(WebGLReshape, _super);
    function WebGLReshape() {
        var _this = _super.call(this) || this;
        _this.packedImpl = new reshape_packed_1.WebGLReshapePacked();
        return _this;
    }
    WebGLReshape.prototype.run = function (inferenceHandler, inputs) {
        if (inferenceHandler.session.pack) {
            return inferenceHandler.run(this.packedImpl, inputs);
        }
        else {
            var reshapedDims = util_1.ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);
            var reshapedTensor = reshape(inferenceHandler, inputs[0], reshapedDims);
            return [reshapedTensor];
        }
    };
    return WebGLReshape;
}(reshape_1.Reshape));
exports.WebGLReshape = WebGLReshape;
function reshape(inferenceHandler, input, reshapedDims) {
    var inputTD = inferenceHandler.getOrCreateTextureData(input);
    var packedShape = reshapedDims;
    if (inputTD.channels === 4) {
        packedShape = utils_1.getPackedShape(reshapedDims);
    }
    var newTextureLayout = {
        channels: inputTD.channels,
        height: inputTD.height,
        width: inputTD.width,
        // handle reshaping into scalar Tensors
        shape: packedShape.length !== 0 ? packedShape : [1],
        strides: util_1.ShapeUtil.computeStrides(packedShape),
        unpackedShape: reshapedDims,
    };
    var newTextureData = inferenceHandler.createSharedTextureData(newTextureLayout, input.type, inputTD.texture);
    return newTextureData.tensor;
}
exports.reshape = reshape;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/resize-packed.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/resize-packed.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLResizePacked = void 0;
var upsample_1 = __webpack_require__(/*! ../../../ops/upsample */ "./lib/onnxjs/ops/upsample.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
var WebGLResizePacked = /** @class */ (function (_super) {
    __extends(WebGLResizePacked, _super);
    function WebGLResizePacked() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLResizePacked.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLResizePacked.prototype.createProgramInfo = function (handler, inputs) {
        var inputLayout = handler.getOrCreateTextureLayout(inputs[0], 4, true, inputs[0].dims, true);
        var _a = __read(this.prepareInputs(inputs), 3), roi = _a[0], scales = _a[1], outputShape = _a[2];
        var outputLayout = handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true });
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        return createResizeProgramInfo(glsl, this.mode, inputLayout, outputLayout, scales, roi, this.useExtrapolation, this.extrapolationValue, this.cubicCoefficientA, this.excludeOutside, this.coordinateTransformMode);
    };
    WebGLResizePacked.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTD = handler.getOrCreateTextureData(inputs[0], handler.getOrCreateTextureLayout(inputs[0], 1, false, [], true));
        var outputTD = handler.createTextureDataFromLayout(programInfo.outputLayout, inputTD.tensor.type);
        return { inputTextureDatas: [inputTD], outputTextureData: outputTD, uniformData: {} };
    };
    return WebGLResizePacked;
}(upsample_1.Upsample));
exports.WebGLResizePacked = WebGLResizePacked;
function createResizeProgramInfo(glsl, mode, inputLayout, outputLayout, scales, roi, extrapolationEnabled, extrapolationValue, cubicCoefficientA, excludeOutside, coordinateTransformMode) {
    var isSame = scales.every(function (s) { return s === 1; }) && coordinateTransformMode !== 'tf_crop_and_resize';
    if (isSame) {
        return {
            inputLayouts: [inputLayout],
            outputLayout: outputLayout,
            samplers: ['X'],
            hasMain: true,
            shaderSource: "void main() {\n      vec4 v = " + glsl.texture2D + "(X, TexCoords);\n      " + glsl.output + " = v;\n    }"
        };
    }
    var outputShape = outputLayout.unpackedShape;
    var dim = outputShape.length;
    if (dim < 2) {
        throw new Error("output dimension should be at least 2, but got " + dim);
    }
    var outputHeight = outputShape[dim - 2];
    var outputWidth = outputShape[dim - 1];
    var inputShape = inputLayout.unpackedShape;
    if (dim !== inputShape.length) {
        throw new Error("output dimension should match input " + inputShape.length + ", but got " + dim);
    }
    var inputHeight = inputShape[dim - 2];
    var inputWidth = inputShape[dim - 1];
    var scalesHeight = scales[dim - 2];
    var scalesWidth = scales[dim - 1];
    var getSourceFracIndex = '';
    if (mode !== 'linear') {
        // TODO: support other modes
        throw new Error("resize (packed) does not support mode: '" + mode + "'");
    }
    switch (coordinateTransformMode) {
        case 'asymmetric':
            getSourceFracIndex = "\n        vec4 getSourceFracIndex(ivec4 coords){\n          return vec4(coords) / scaleWHWH;\n        }\n    ";
            break;
        case 'half_pixel':
            getSourceFracIndex = "\n        vec4 getSourceFracIndex(ivec4 coords){\n          return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n        }\n    ";
            break;
        case 'align_corners':
            getSourceFracIndex = "\n        vec4 getSourceFracIndex(ivec4 coords){\n          vec4 resized = vec4(" + outputWidth + ".0 - 1.0, " + outputHeight + ".0 - 1.0, " + outputWidth + ".0 - 1.0, " + outputHeight + ".0 - 1.0);\n          vec4 original = vec4(" + inputWidth + ".0 - 1.0, " + inputHeight + ".0 - 1.0, " + inputWidth + ".0 - 1.0, " + inputHeight + ".0 - 1.0);\n          vec4 new_scale = original / resized;\n          return vec4(coords) * new_scale;\n        }\n      ";
            break;
        default:
            // TODO:supporting other coordinateTransformModes
            throw new Error("resize (packed) does not support coordinateTransformMode: '" + coordinateTransformMode + "'");
    }
    var coordsDataType = utils_1.getCoordsDataType(dim);
    var unpackChannel = packing_utils_1.unpackFromChannel();
    var shader = "\n        const vec2 inputWH = vec2(" + inputHeight + ".0, " + inputWidth + ".0);\n        const vec4 scaleWHWH = vec4(" + scalesHeight + ".0, " + scalesWidth + ".0, " + scalesHeight + ".0, " + scalesWidth + ".0);\n        " + unpackChannel + "\n        " + getSourceFracIndex + "\n        float getAValue(int x10, int r, int c, int d) {\n          return getChannel(getA(x10, r, c, d), vec2(c, d));\n        }\n        void main() {\n          " + coordsDataType + " rc = getOutputCoords();\n\n          int batch = rc[0];\n          int depth = rc[1];\n\n          // retrieve the 4 coordinates that is used in the 4 packed output values.\n          ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n          // calculate the source index in fraction\n          vec4 sourceFrac = getSourceFracIndex(coords);\n\n          // get the lower and upper bound of the 4 values that will be packed into one texel.\n          ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n          ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n          ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n          ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n          bool hasNextRow = rc.w < " + (outputHeight - 1) + ";\n          bool hasNextCol = rc.z < " + (outputWidth - 1) + ";\n\n          // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n          vec4 topLeft = vec4(\n            getAValue(batch, depth, x00.x, x00.y),\n            hasNextCol ? getAValue(batch, depth, x01.x, x01.y)\n                      : 0.0,\n            hasNextRow ? getAValue(batch, depth, x10.x, x10.y)\n                      : 0.0,\n            (hasNextRow && hasNextCol) ?\n              getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n          // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n          vec4 topRight = vec4(\n            getAValue(batch, depth, x00.x, x00.w),\n            hasNextCol ? getAValue(batch, depth, x01.x, x01.w)\n                      : 0.0,\n            hasNextRow ? getAValue(batch, depth, x10.x, x10.w)\n                      : 0.0,\n            (hasNextRow && hasNextCol) ?\n              getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n          // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n          vec4 bottomLeft = vec4(\n            getAValue(batch, depth, x00.z, x00.y),\n            hasNextCol ? getAValue(batch, depth, x01.z, x01.y)\n                      : 0.0,\n            hasNextRow ? getAValue(batch, depth, x10.z, x10.y)\n                      : 0.0,\n            (hasNextRow && hasNextCol) ?\n              getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n          // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n          vec4 bottomRight = vec4(\n            getAValue(batch, depth, x00.z, x00.w),\n            hasNextCol ? getAValue(batch, depth, x01.z, x01.w)\n                      : 0.0,\n            hasNextRow ? getAValue(batch, depth, x10.z, x10.w)\n                      : 0.0,\n            (hasNextRow && hasNextCol) ?\n              getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n          // calculate the interpolation fraction on u and v direction\n          vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n          vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n          vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n          vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n          vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n          " + glsl.output + " = vec4(newValue);\n        }\n      ";
    return {
        inputLayouts: [inputLayout],
        outputLayout: outputLayout,
        samplers: ['A'],
        shaderSource: shader,
        hasMain: true,
        expectPackedInputs: true,
        expectPackedOutputs: true,
    };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/shape.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/shape.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLShape = void 0;
var shape_1 = __webpack_require__(/*! ../../../ops/shape */ "./lib/onnxjs/ops/shape.ts");
var tensor_1 = __webpack_require__(/*! ../../../tensor */ "./lib/onnxjs/tensor.ts");
var WebGLShape = /** @class */ (function (_super) {
    __extends(WebGLShape, _super);
    function WebGLShape() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLShape.prototype.run = function (inferenceHandler, inputs) {
        return [new tensor_1.Tensor([inputs[0].dims.length], 'int32', undefined, undefined, new Int32Array(inputs[0].dims))];
    };
    return WebGLShape;
}(shape_1.Shape));
exports.WebGLShape = WebGLShape;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/slice.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/slice.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSliceV10 = exports.WebGLSlice = void 0;
var slice_1 = __webpack_require__(/*! ../../../ops/slice */ "./lib/onnxjs/ops/slice.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var WebGLSlice = /** @class */ (function (_super) {
    __extends(WebGLSlice, _super);
    function WebGLSlice() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLSlice.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLSlice.prototype.createProgramInfo = function (handler, inputs) {
        return createProgramInfo(handler, inputs[0], this.starts, this.ends, this.axes);
    };
    WebGLSlice.prototype.createRunData = function (handler, programInfo, inputs) {
        return createRunData(handler, programInfo, inputs);
    };
    return WebGLSlice;
}(slice_1.Slice));
exports.WebGLSlice = WebGLSlice;
var WebGLSliceV10 = /** @class */ (function (_super) {
    __extends(WebGLSliceV10, _super);
    function WebGLSliceV10() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLSliceV10.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLSliceV10.prototype.createProgramInfo = function (handler, inputs) {
        if (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId) ||
            (inputs.length >= 4 && !handler.session.isInitializer(inputs[3].dataId)) ||
            (inputs.length >= 5 && !handler.session.isInitializer(inputs[4].dataId))) {
            throw new Error('dynamic slice attributes are not allowed');
        }
        if (inputs.length >= 5 && inputs[4].integerData.some(function (i) { return i !== 1; })) {
            throw new Error('currently non-1 steps is not supported for Slice');
        }
        var starts = Array.from(inputs[1].integerData);
        var ends = Array.from(inputs[2].integerData);
        var axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];
        return createProgramInfo(handler, inputs[0], starts, ends, axes);
    };
    WebGLSliceV10.prototype.createRunData = function (handler, programInfo, inputs) {
        return createRunData(handler, programInfo, inputs);
    };
    return WebGLSliceV10;
}(slice_1.SliceV10));
exports.WebGLSliceV10 = WebGLSliceV10;
function createProgramInfo(handler, x, starts, ends, axes) {
    if (axes.length === 0) {
        axes = x.dims.slice(0).map(function (val, ind) { return ind; });
    }
    axes = util_1.ShapeUtil.normalizeAxes(axes, x.dims.length);
    starts = starts.map(function (start, ind) {
        if (start > x.dims[axes[ind]] - 1) {
            return x.dims[axes[ind]];
        }
        return util_1.ShapeUtil.normalizeAxis(start, x.dims[axes[ind]]);
    });
    ends = ends.map(function (end, ind) {
        if (end > x.dims[axes[ind]] - 1) {
            return x.dims[axes[ind]];
        }
        return util_1.ShapeUtil.normalizeAxis(end, x.dims[axes[ind]]);
    });
    var outputShape = x.dims.slice();
    var sliceOps = [];
    for (var i = 0; i < axes.length; i++) {
        outputShape[axes[i]] = ends[i] - starts[i];
        if (starts[i] > 0) {
            sliceOps.push("outputIdx[" + axes[i] + "] += " + starts[i] + ";");
        } // else { sliceOps.push(`outputIdx[${axes[i]}] += 0;`); }
    }
    var rank = outputShape.length;
    var shaderSource = "\n      float process(int outputIdx[" + rank + "]) {\n        " + sliceOps.join('\n      ') + "\n        return _A(outputIdx);\n      }";
    return {
        inputLayouts: [handler.getOrCreateTextureLayout(x)],
        outputLayout: handler.createTextureLayoutFromShape(outputShape),
        samplers: ['A'],
        shaderSource: shaderSource,
    };
}
function createRunData(handler, programInfo, inputs) {
    var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
    return {
        inputTextureDatas: inputTDs,
        outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
        uniformData: {}
    };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/softmax.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/softmax.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSoftmax = void 0;
var softmax_1 = __webpack_require__(/*! ../../../ops/softmax */ "./lib/onnxjs/ops/softmax.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLSoftmax = /** @class */ (function (_super) {
    __extends(WebGLSoftmax, _super);
    function WebGLSoftmax() {
        return _super.call(this) || this;
    }
    WebGLSoftmax.prototype.run = function (inferenceHandler, inputs) {
        var _this = this;
        if (!this.artifacts) {
            this.artifacts = [];
            var programInfos = this.createProgramInfos(inferenceHandler, inputs);
            programInfos.forEach(function (pi) {
                var artifact = inferenceHandler.session.programManager.build(pi);
                _this.artifacts.push(artifact);
            });
        }
        var runDatas = this.createRunDatas(inferenceHandler, this.artifacts.map(function (a) { return a.programInfo; }), inputs);
        runDatas.forEach(function (v, i) { return inferenceHandler.session.programManager.run(_this.artifacts[i], v); });
        // return only the last output
        return [runDatas[runDatas.length - 1].outputTextureData.tensor];
    };
    WebGLSoftmax.prototype.createSoftMaxProgramInfo = function (
    // eslint-disable-next-line @typescript-eslint/naming-convention
    inferenceHandler, input, N, D, maxElementPerLogicalRow, normalizationPerLogicalRow) {
        var inputShape = input.dims.slice();
        var inputLayout = inferenceHandler.createTextureLayoutFromShape(inputShape);
        var outputShape = inputShape;
        var rank = outputShape.length;
        var textureWidth = inputLayout.width;
        var textureHeight = inputLayout.height;
        if (N < 1 || D < 1) {
            throw new Error('Logical row count N and feature count D must be greater than or equal to 1');
        }
        if (maxElementPerLogicalRow.shape.length !== 1 || normalizationPerLogicalRow.shape.length !== 1) {
            throw new Error('Dimensionality of the intermediate results should be 1');
        }
        if (maxElementPerLogicalRow.shape[0] !== N || normalizationPerLogicalRow.shape[0] !== N) {
            throw new Error('Shape of the intermediate results should be equal to logical row count');
        }
        var shaderSource = "\n    float process(int[" + rank + "] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, " + textureWidth + ", " + textureHeight + ");\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / " + D + ";\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }";
        return {
            inputLayouts: [inputLayout, maxElementPerLogicalRow, normalizationPerLogicalRow],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'Max', 'Norm'],
            shaderSource: shaderSource,
            name: 'SoftMax',
        };
    };
    /**
     * Create a texture that contains the normalization factor for each of the 'N' rows
     */
    WebGLSoftmax.prototype.createComputScaleProgramInfo = function (
    // eslint-disable-next-line @typescript-eslint/naming-convention
    inferenceHandler, x, N, D, maxElementPerLogicalRow, outputShape) {
        var xlayout = inferenceHandler.createTextureLayoutFromShape(x.dims.slice());
        var rank = outputShape.length;
        var textureWidth = xlayout.width;
        var textureHeight = xlayout.height;
        if (N < 1 || D < 1) {
            throw new Error('Logical row count N and feature count D must be greater than or equal to 1');
        }
        if (outputShape.length !== 1) {
            throw new Error('Dimensionality of the output should be 1');
        }
        if (outputShape[0] !== N) {
            throw new Error('Shape of the output should be equal to logical row count');
        }
        if (maxElementPerLogicalRow.shape.length !== 1) {
            throw new Error('Dimensionality of the intermediate results should be 1');
        }
        if (maxElementPerLogicalRow.shape[0] !== N) {
            throw new Error('Shape of the intermediate results should be equal to logical row count');
        }
        var glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        var shaderSource = "\n    float process(int[" + rank + "] indices) {\n\n      int logical_row_start_offset = indices[0] * " + D + ";\n\n      float norm_factor = 0.0;\n      float max = _Max(indices);\n      for(int i=0; i<" + D + "; ++i)\n      {\n        norm_factor += exp(getColorAsFloat(" + glsl.texture2D + "(A, offsetToCoords(logical_row_start_offset + i, " + textureWidth + ", " + textureHeight + "))) - max);\n      }\n\n      return norm_factor;\n    }";
        return {
            inputLayouts: [xlayout, maxElementPerLogicalRow],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'Max'],
            shaderSource: shaderSource,
            name: 'ComputScale',
        };
    };
    /**
     * Create a texture that contains the maximum value of each of the 'N' rows
     */
    WebGLSoftmax.prototype.createComputeMaxProgramInfo = function (
    // eslint-disable-next-line @typescript-eslint/naming-convention
    inferenceHandler, x, N, D, outputShape) {
        var xlayout = inferenceHandler.createTextureLayoutFromShape(x.dims.slice());
        var rank = outputShape.length;
        var textureWidth = xlayout.width;
        var textureHeight = xlayout.height;
        if (N < 1 || D < 1) {
            throw new Error('Logical row count N and feature count D must be greater than or equal to 1');
        }
        if (outputShape.length !== 1) {
            throw new Error('Dimensionality of the output should be 1');
        }
        if (outputShape[0] !== N) {
            throw new Error('Shape of the output should be equal to logical row count');
        }
        var glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        var shaderSource = "\n        float process(int[" + rank + "] indices) {\n\n          int logical_row_start_offset = indices[0] * " + D + ";\n\n          float max = getColorAsFloat(" + glsl.texture2D + "(A, offsetToCoords(logical_row_start_offset, " + textureWidth + ", " + textureHeight + " )));\n          for(int i=1; i<" + D + "; ++i)\n          {\n            float current = getColorAsFloat(" + glsl.texture2D + "(A, offsetToCoords(logical_row_start_offset + i, " + textureWidth + ", " + textureHeight + ")));\n            if(current > max)\n              max = current;\n          }\n\n          return max;\n        }";
        return {
            inputLayouts: [xlayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
            name: 'ComputeMax',
        };
    };
    WebGLSoftmax.prototype.createProgramInfos = function (inferenceHandler, inputs) {
        var inputShape = inputs[0].dims.slice();
        var axis = util_1.ShapeUtil.normalizeAxis(this.axis, inputShape.length);
        var N = util_1.ShapeUtil.sizeToDimension(inputShape, axis);
        var D = util_1.ShapeUtil.sizeFromDimension(inputShape, axis);
        var computeMaxProgramInfo = this.createComputeMaxProgramInfo(inferenceHandler, inputs[0], N, D, [N]);
        var computeScaleProgramInfo = this.createComputScaleProgramInfo(inferenceHandler, inputs[0], N, D, computeMaxProgramInfo.outputLayout, [N]);
        var softMaxProgramInfo = this.createSoftMaxProgramInfo(inferenceHandler, inputs[0], N, D, computeMaxProgramInfo.outputLayout, computeScaleProgramInfo.outputLayout);
        var programInfos = [computeMaxProgramInfo, computeScaleProgramInfo, softMaxProgramInfo];
        return programInfos;
    };
    WebGLSoftmax.prototype.createRunDatas = function (inferenceHandler, programInfos, inputs) {
        var dataType = inputs[0].type;
        var inputTD = inferenceHandler.getOrCreateTextureData(inputs[0], programInfos[0].inputLayouts[0]);
        var runDatas = [];
        runDatas.push({
            inputTextureDatas: [inputTD],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[0].outputLayout, dataType),
            uniformData: {}
        });
        for (var i = 1; i < programInfos.length; ++i) {
            runDatas.push({
                inputTextureDatas: __spreadArray(__spreadArray([], __read(runDatas[i - 1].inputTextureDatas)), [runDatas[i - 1].outputTextureData]),
                outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[i].outputLayout, dataType),
                uniformData: {}
            });
        }
        return runDatas;
    };
    return WebGLSoftmax;
}(softmax_1.Softmax));
exports.WebGLSoftmax = WebGLSoftmax;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/split.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/split.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSplit = void 0;
var split_1 = __webpack_require__(/*! ../../../ops/split */ "./lib/onnxjs/ops/split.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var WebGLSplit = /** @class */ (function (_super) {
    __extends(WebGLSplit, _super);
    function WebGLSplit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLSplit.prototype.run = function (inferenceHandler, inputs) {
        var _this = this;
        if (!this.artifacts) {
            this.artifacts = [];
            var axis = util_1.ShapeUtil.normalizeAxis(this.axis, inputs[0].dims.length);
            var count = this.getProgramCount(inferenceHandler, inputs, axis);
            for (var i = 0; i < count; ++i) {
                var programInfo = this.createProgramInfo(inferenceHandler, inputs[0], axis, i);
                var artifact = inferenceHandler.session.programManager.build(programInfo);
                this.artifacts.push(artifact);
            }
        }
        var results = [];
        this.artifacts.forEach(function (artifact) {
            var rundata = _this.createRunData(inferenceHandler, artifact.programInfo, inputs);
            inferenceHandler.session.programManager.run(artifact, rundata);
            results.push(rundata.outputTextureData.tensor);
        });
        return results;
    };
    WebGLSplit.prototype.getProgramCount = function (inferenceHandler, inputs, axis) {
        var _a = __read(util_1.SplitUtil.splitShape(inputs[0].dims, axis, this.split, this.numOutputs), 2), offsets = _a[1];
        return offsets.length;
    };
    WebGLSplit.prototype.createProgramInfo = function (inferenceHandler, input, axis, index) {
        var _a = __read(util_1.SplitUtil.splitShape(input.dims, axis, this.split, this.numOutputs), 2), shapes = _a[0], offsets = _a[1];
        var offset = offsets[index];
        var outputShape = shapes[index];
        var rank = outputShape.length;
        var shaderSource = "\n      float process(int indices[" + rank + "]) {\n        indices[" + axis + "] += " + offset + ";\n        return _A(indices);\n      }";
        return {
            name: 'WebGLSplit',
            inputLayouts: [inferenceHandler.getOrCreateTextureLayout(input)],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
        };
    };
    WebGLSplit.prototype.createRunData = function (inferenceHandler, programInfo, inputs) {
        var inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLSplit;
}(split_1.Split));
exports.WebGLSplit = WebGLSplit;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/squeeze.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/squeeze.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSqueeze = void 0;
var squeeze_1 = __webpack_require__(/*! ../../../ops/squeeze */ "./lib/onnxjs/ops/squeeze.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
var WebGLSqueeze = /** @class */ (function (_super) {
    __extends(WebGLSqueeze, _super);
    function WebGLSqueeze() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLSqueeze.prototype.run = function (inferenceHandler, inputs) {
        var outputDims = util_1.ShapeUtil.squeezeShape(inputs[0].dims, this.axes);
        return [reshape_1.reshape(inferenceHandler, inputs[0], outputDims)];
    };
    return WebGLSqueeze;
}(squeeze_1.Squeeze));
exports.WebGLSqueeze = WebGLSqueeze;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/sum.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/sum.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSum = void 0;
var sum_1 = __webpack_require__(/*! ../../../ops/sum */ "./lib/onnxjs/ops/sum.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLSum = /** @class */ (function (_super) {
    __extends(WebGLSum, _super);
    function WebGLSum() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLSum.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLSum.prototype.createProgramInfo = function (handler, inputs) {
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var outputShape = inputs[0].dims.slice();
        var sumLine = inputs.map(function (v, i) { return glsl.texture2D + "(X" + i + ",TexCoords)"; }).join(' + ');
        var samplers = inputs.map(function (v, i) { return "X" + i; });
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: samplers,
            shaderSource: "\n      void main() {\n        vec4 result = " + sumLine + ";\n        " + glsl.output + " = result;\n      }",
            hasMain: true
        };
    };
    WebGLSum.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLSum;
}(sum_1.Sum));
exports.WebGLSum = WebGLSum;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/tile.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/tile.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLTile = void 0;
var tile_1 = __webpack_require__(/*! ../../../ops/tile */ "./lib/onnxjs/ops/tile.ts");
var WebGLTile = /** @class */ (function (_super) {
    __extends(WebGLTile, _super);
    function WebGLTile() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLTile.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLTile.prototype.createProgramInfo = function (handler, inputs) {
        var inputShape = inputs[0].dims.slice();
        var outputShape = new Array(inputShape.length); // inputs[0].dims.slice();
        var tileOps = [];
        for (var i = 0; i < inputShape.length; i++) {
            outputShape[i] = inputShape[i] * inputs[1].numberData[i];
            tileOps.push("inputIdx[" + i + "] = int(mod(float(outputIdx[" + i + "]), " + inputShape[i] + ".));");
        }
        var rank = outputShape.length;
        var shaderSource = "\n    float process(int outputIdx[" + rank + "]) {\n      int inputIdx[" + rank + "];\n      " + tileOps.join('\n') + "\n      return _A(inputIdx);\n    }";
        return {
            inputLayouts: inputs.map(function (t) { return handler.getOrCreateTextureLayout(t); }),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource: shaderSource,
        };
    };
    WebGLTile.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLTile;
}(tile_1.Tile));
exports.WebGLTile = WebGLTile;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/transpose.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/transpose.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLTranspose = void 0;
var transpose_1 = __webpack_require__(/*! ../../../ops/transpose */ "./lib/onnxjs/ops/transpose.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_definitions_1 = __webpack_require__(/*! ../glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
var WebGLTranspose = /** @class */ (function (_super) {
    __extends(WebGLTranspose, _super);
    function WebGLTranspose() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLTranspose.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLTranspose.prototype.getOutputShape = function (inputShapes) {
        var perm = this.getAdjustedPerm(inputShapes[0]);
        return util_1.ShapeUtil.sortBasedOnPerm(inputShapes[0], perm);
    };
    WebGLTranspose.prototype.createProgramInfo = function (handler, inputs) {
        var inputShapes = inputs.map(function (t) { return t.dims.slice(); });
        var perm = this.getAdjustedPerm(inputShapes[0]);
        var unpackedOutputShape = this.getOutputShape(inputShapes);
        var rank = inputs[0].dims.length;
        // A dims=[${inputs[0].dims.toString()}]
        // out Dims=[${unpackedOutputShape.toString()}]
        // based on perm=[${perm.toString()}]
        var shaderSource = "\n      " + this.getPermFunctionBody('perm', perm, rank) + "\n      float process(int indices[" + rank + "]) {\n        int a[" + rank + "];\n        perm(a, indices);\n        return _A(a);\n      }";
        var outputLayout = handler.createTextureLayoutFromShape(unpackedOutputShape, 1, unpackedOutputShape);
        return { inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])], outputLayout: outputLayout, samplers: ['A'], shaderSource: shaderSource };
    };
    WebGLTranspose.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    WebGLTranspose.prototype.getPositionalFunction = function (handler, inputShape, name) {
        var outputShape = this.getOutputShape([inputShape]);
        if (!name) {
            name = 'perm';
        }
        return {
            name: name,
            body: this.getPermFunctionBody(name, this.getAdjustedPerm(inputShape), outputShape.length),
            type: glsl_definitions_1.FunctionType.Positional,
            inputShape: inputShape,
            outputShape: outputShape
        };
    };
    WebGLTranspose.prototype.getAdjustedPerm = function (inputShape) {
        var perm = this.perm;
        if (perm && perm.length !== inputShape.length) {
            perm = __spreadArray([], __read((inputShape.keys()))).reverse();
        }
        return perm;
    };
    WebGLTranspose.prototype.getPermFunctionBody = function (name, perm, rank) {
        var reverseFunc = [];
        reverseFunc.push("void " + name + "(out int a[" + rank + "], int src[" + rank + "]) {");
        for (var i = 0; i < rank; ++i) {
            reverseFunc.push("\ta[" + perm[i] + "]=src[" + i + "];");
        }
        reverseFunc.push('\t}');
        return reverseFunc.join('\n');
    };
    return WebGLTranspose;
}(transpose_1.Transpose));
exports.WebGLTranspose = WebGLTranspose;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/uint8-encode.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/uint8-encode.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUint8Encode = void 0;
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLUint8Encode = /** @class */ (function () {
    function WebGLUint8Encode() {
    }
    WebGLUint8Encode.prototype.runInternal = function (inferenceHandler, input) {
        var outputShape = input.shape;
        var _a = __read(inferenceHandler.session.layoutStrategy.computeTextureWH(input.shape), 2), width = _a[0], height = _a[1];
        var outputLayout = {
            width: width,
            height: height,
            channels: 4,
            shape: outputShape,
            strides: util_1.ShapeUtil.computeStrides(outputShape),
            unpackedShape: outputShape
        };
        var glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        // TODO: remove this special script. Use graph transformer instead.
        /**
         * https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/webgl/encode_float_gpu.ts
         */
        var shaderSource = "\n      const float FLOAT_MAX = 1.70141184e38;\n      const float FLOAT_MIN = 1.17549435e-38;\n\n      bool isNaN(float val) {\n        return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n      }\n\n      highp vec4 encodeAsUint8(highp float v) {\n        if (isNaN(v)) {\n          return vec4(255, 255, 255, 255);\n        }\n\n        highp float av = abs(v);\n\n        if(av < FLOAT_MIN) {\n          return vec4(0.0, 0.0, 0.0, 0.0);\n        } else if(v > FLOAT_MAX) {\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n        } else if(v < -FLOAT_MAX) {\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n        }\n\n        highp vec4 c = vec4(0,0,0,0);\n\n        highp float e = floor(log2(av));\n        highp float m = exp2(fract(log2(av))) - 1.0;\n\n        c[2] = floor(128.0 * m);\n        m -= c[2] / 128.0;\n        c[1] = floor(32768.0 * m);\n        m -= c[1] / 32768.0;\n        c[0] = floor(8388608.0 * m);\n\n        highp float ebias = e + 127.0;\n        c[3] = floor(ebias / 2.0);\n        ebias -= c[3] * 2.0;\n        c[2] += floor(ebias) * 128.0;\n\n        c[3] += 128.0 * step(0.0, -v);\n\n        return c / 255.0;\n      }\n\n      void main() {\n        float value = " + glsl.texture2D + "(X,TexCoords).r;\n        " + glsl.output + " = encodeAsUint8(value);\n      }";
        var programInfo = { name: 'Uint8Encode', inputLayouts: [input], outputLayout: outputLayout, samplers: ['X'], shaderSource: shaderSource, hasMain: true };
        var artifact = inferenceHandler.session.programManager.build(programInfo);
        var encoder = inferenceHandler.session.backend.glContext.getEncoder('byte', 4);
        var texture = inferenceHandler.session.backend.glContext.allocateTexture(outputLayout.width, outputLayout.height, encoder);
        var outputTextureData = inferenceHandler.createSharedTextureData(outputLayout, 'uint8', texture);
        var runData = { inputTextureDatas: [input], outputTextureData: outputTextureData, uniformData: {} };
        inferenceHandler.session.programManager.run(artifact, runData);
        return runData.outputTextureData;
    };
    return WebGLUint8Encode;
}());
exports.WebGLUint8Encode = WebGLUint8Encode;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/unary-op.ts":
/*!***************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/unary-op.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.glslTanh = exports.glslTan = exports.glslSqrt = exports.glslSigmoid = exports.glslRelu = exports.glslSin = exports.glslNot = exports.glslNeg = exports.glslLog = exports.glslIdentity = exports.glslFloor = exports.glslExp = exports.glslCos = exports.glslCeil = exports.glslAtan = exports.glslAsin = exports.glslAcos = exports.glslAbs = exports.WebGLUnaryOp = void 0;
var unary_op_1 = __webpack_require__(/*! ../../../ops/unary-op */ "./lib/onnxjs/ops/unary-op.ts");
var glsl_definitions_1 = __webpack_require__(/*! ../glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLUnaryOp = /** @class */ (function (_super) {
    __extends(WebGLUnaryOp, _super);
    function WebGLUnaryOp(typeConstraint, glslFunc) {
        var _this = _super.call(this, typeConstraint) || this;
        _this.typeConstraint = typeConstraint;
        _this.glslFunc = glslFunc;
        return _this;
    }
    WebGLUnaryOp.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLUnaryOp.prototype.createProgramInfo = function (handler, inputs) {
        var outputShape = inputs[0].dims.slice();
        var inputLayout = handler.session.pack ?
            handler.getOrCreateTextureLayout(inputs[0], 4, true, inputs[0].dims, true) :
            handler.getOrCreateTextureLayout(inputs[0]);
        var outputLayout = handler.session.pack ?
            handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }) :
            handler.createTextureLayoutFromShape(outputShape);
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n      " + this.glslFunc.body + "\n      void main() {\n        vec4 v = " + glsl.texture2D + "(A, TexCoords);\n        v = " + this.glslFunc.name + "(v);\n        " + glsl.output + " = v;\n      }\n      ";
        if (handler.session.pack) {
            return {
                inputLayouts: [inputLayout],
                outputLayout: outputLayout,
                samplers: ['A'],
                shaderSource: shaderSource,
                hasMain: true,
                expectPackedInputs: true,
                expectPackedOutputs: true
            };
        }
        else {
            return { inputLayouts: [inputLayout], outputLayout: outputLayout, samplers: ['A'], shaderSource: shaderSource, hasMain: true };
        }
    };
    WebGLUnaryOp.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTD = handler.session.pack ?
            handler.getOrCreateTextureData(inputs[0], handler.getOrCreateTextureLayout(inputs[0], 1, false, [], true)) :
            handler.getOrCreateTextureData(inputs[0]);
        return {
            inputTextureDatas: [inputTD],
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTD.tensor.type),
            uniformData: {}
        };
    };
    return WebGLUnaryOp;
}(unary_op_1.UnaryOp));
exports.WebGLUnaryOp = WebGLUnaryOp;
function glslAbs() {
    return glslBuiltinUnary('abs');
}
exports.glslAbs = glslAbs;
function glslAcos() {
    return glslBuiltinUnary('acos');
}
exports.glslAcos = glslAcos;
function glslAsin() {
    return glslBuiltinUnary('asin');
}
exports.glslAsin = glslAsin;
function glslAtan() {
    return glslBuiltinUnary('atan');
}
exports.glslAtan = glslAtan;
function glslCeil() {
    return glslBuiltinUnary('ceil');
}
exports.glslCeil = glslCeil;
function glslCos() {
    return glslBuiltinUnary('cos');
}
exports.glslCos = glslCos;
function glslExp() {
    return glslBuiltinUnary('exp');
}
exports.glslExp = glslExp;
function glslFloor() {
    return glslBuiltinUnary('floor');
}
exports.glslFloor = glslFloor;
function glslIdentity() {
    var name = 'indentity_';
    var body = "\n  float " + name + "(float a) {\n    return a;\n  }\n  vec4 " + name + "(vec4 v) {\n    return v;\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslIdentity = glslIdentity;
function glslLog() {
    return glslBuiltinUnary('log');
}
exports.glslLog = glslLog;
function glslNeg() {
    var name = 'neg_';
    var body = "\n  float " + name + "(float a) {\n    return -a;\n  }\n  vec4 " + name + "(vec4 v) {\n    return -v;\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslNeg = glslNeg;
function glslNot() {
    var name = 'not_';
    var body = "\n  float " + name + "(float a) {\n    return float( ! bool(a) );\n  }\n  bool " + name + "(bool a) {\n    return !a;\n  }\n  vec4 " + name + "(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 " + name + "(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslNot = glslNot;
function glslSin() {
    return glslBuiltinUnary('sin');
}
exports.glslSin = glslSin;
function glslRelu() {
    var name = 'relu_';
    var body = "\n  float " + name + "(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 " + name + "(vec4 v) {\n    return max( v, 0.0 );\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslRelu = glslRelu;
function glslSigmoid() {
    var name = 'sigmoid_';
    var body = "\n  float " + name + "(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 " + name + "(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslSigmoid = glslSigmoid;
function glslSqrt() {
    return glslBuiltinUnary('sqrt');
}
exports.glslSqrt = glslSqrt;
function glslTan() {
    return glslBuiltinUnary('tan');
}
exports.glslTan = glslTan;
function glslTanh() {
    var name = 'tanh_';
    var body = "\n  float " + name + "(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 " + name + "(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslTanh = glslTanh;
function glslBuiltinUnary(fname) {
    var name = fname + "_";
    var body = "\n  float " + name + "(float a) {\n    return " + fname + "(a);\n  }\n  vec4 " + name + "(vec4 v) {\n    return " + fname + "(v);\n  }\n  ";
    return { body: body, name: name, type: glsl_definitions_1.FunctionType.ValueBased };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/unpack.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/unpack.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSourceCoords = exports.WebGLUnpack = void 0;
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
var packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
var WebGLUnpack = /** @class */ (function () {
    function WebGLUnpack() {
    }
    WebGLUnpack.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLUnpack.prototype.createProgramInfo = function (handler, inputs) {
        if (inputs.length !== 1) {
            throw new Error('Pack kernel should have input tensor count to 1.');
        }
        var inputTexture = handler.getTextureData(inputs[0].dataId, true);
        if (!inputTexture) {
            throw new Error('packed input texture must exist');
        }
        var inputLayout = handler.getOrCreateTextureLayout(inputs[0], 4, true);
        var isScalar = (inputLayout.unpackedShape.length === 0);
        var outputLayout = handler.createTextureLayoutFromShape(inputTexture.unpackedShape);
        var outputShape = outputLayout.shape;
        var rank = outputShape.length;
        var channels = packing_utils_1.getChannels('rc', rank);
        var innerDims = channels.slice(-2);
        var coordsDataType = utils_1.getCoordsDataType(rank);
        var unpackChannel = packing_utils_1.unpackFromChannel();
        var sourceCoords = isScalar ? '' : getSourceCoords(rank, channels);
        var coords = rank <= 1 ? 'rc' : "vec2(" + innerDims.join(',') + ")";
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var shaderSource = "\n    " + unpackChannel + "\n    void main() {\n      " + coordsDataType + " rc = getOutputCoords();\n\n      // Sample the texture with the coords to get the rgba channel value.\n      vec4 packedInput = getA(" + sourceCoords + ");\n\n      " + glsl.output + " = vec4(getChannel(packedInput, " + coords + "), 0, 0, 0);\n    }\n  ";
        return {
            name: 'WebGLUnpack',
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0], 4, true, inputs[0].dims, true)],
            outputLayout: outputLayout,
            samplers: ['A'],
            shaderSource: shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: false,
        };
    };
    WebGLUnpack.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0], true)];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    };
    return WebGLUnpack;
}());
exports.WebGLUnpack = WebGLUnpack;
function getSourceCoords(rank, dims) {
    if (rank === 1) {
        return 'rc';
    }
    var coords = '';
    for (var i = 0; i < rank; i++) {
        coords += dims[i];
        if (i < rank - 1) {
            coords += ',';
        }
    }
    return coords;
}
exports.getSourceCoords = getSourceCoords;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/unsqueeze.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/unsqueeze.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnsqueeze = void 0;
var unsqueeze_1 = __webpack_require__(/*! ../../../ops/unsqueeze */ "./lib/onnxjs/ops/unsqueeze.ts");
var util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
var reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
var WebGLUnsqueeze = /** @class */ (function (_super) {
    __extends(WebGLUnsqueeze, _super);
    function WebGLUnsqueeze() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLUnsqueeze.prototype.run = function (inferenceHandler, inputs) {
        var outputDims = util_1.ShapeUtil.unsqueezeShape(inputs[0].dims, this.axes);
        return [reshape_1.reshape(inferenceHandler, inputs[0], outputDims)];
    };
    return WebGLUnsqueeze;
}(unsqueeze_1.Unsqueeze));
exports.WebGLUnsqueeze = WebGLUnsqueeze;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/upsample.ts":
/*!***************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/upsample.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUpsample = void 0;
var upsample_1 = __webpack_require__(/*! ../../../ops/upsample */ "./lib/onnxjs/ops/upsample.ts");
var glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
var WebGLUpsample = /** @class */ (function (_super) {
    __extends(WebGLUpsample, _super);
    function WebGLUpsample() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGLUpsample.prototype.run = function (inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    };
    WebGLUpsample.prototype.createProgramInfo = function (handler, inputs) {
        var _this = this;
        var inputLayout = handler.getOrCreateTextureLayout(inputs[0]);
        var outputShape = inputs[0].dims.map(function (dim, i) { return Math.floor(dim * _this.scales[i]); });
        var outputLayout = handler.createTextureLayoutFromShape(outputShape);
        var dim = outputShape.length;
        var glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        var outputPitches = new Array(dim);
        var inputPitches = new Array(dim);
        var precalculatedPitches = "\n      int output_pitches[" + dim + "];\n      int input_pitches[" + dim + "];\n      ";
        for (var d = dim - 1; d >= 0; d--) {
            outputPitches[d] = (d === dim - 1) ? 1 : outputPitches[d + 1] * outputShape[d + 1];
            inputPitches[d] = (d === dim - 1) ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];
            precalculatedPitches += "\n      output_pitches[" + d + "] = " + outputPitches[d] + ";\n      input_pitches[" + d + "] = " + inputPitches[d] + ";\n      ";
        }
        var getInputFloatFunction = "\n    float getInputFloat(int index) {\n      vec2 coords = offsetToCoords(index, " + inputLayout.width + ", " + inputLayout.height + ");\n      float value = getColorAsFloat(" + glsl.texture2D + "(X, coords));\n      return value;\n    }\n    ";
        var shaderSource = this.mode === 'nearest' ?
            // nearest
            "\n      " + getInputFloatFunction + "\n      float process(int indices[" + dim + "]) {\n        int input_index = 0;\n        int output_index = coordsToOffset(TexCoords, " + outputLayout.width + ", " + outputLayout.height + ");\n\n        " + precalculatedPitches + "\n\n        int d, m;\n        for (int dim = 0; dim < " + dim + "; ++dim) {\n          d = output_index / output_pitches[dim];\n          m = output_index - d * output_pitches[dim];\n          output_index = m;\n\n          if (scales[dim] != 1 && d > 0) {\n            int d2 = d / scales[dim];\n            m = d - d2 * scales[dim];\n            d = d2;\n          }\n          input_index += input_pitches[dim] * d;\n        }\n\n        return getInputFloat(input_index);\n      }" :
            dim === 4 ?
                // bilinear 4D
                "\n      " + getInputFloatFunction + "\n      float process(int indices[4]) {\n        int input_index = 0;\n        int output_index = coordsToOffset(TexCoords, " + outputLayout.width + ", " + outputLayout.height + ");\n\n        " + precalculatedPitches + "\n\n        int m;\n        int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n        index_of_dim0 = output_index / output_pitches[0];\n        m = output_index - index_of_dim0 * output_pitches[0];\n        index_of_dim1 = m / output_pitches[1];\n        m = m - index_of_dim1 * output_pitches[1];\n        index_of_dim2 = m / output_pitches[2];\n        m = m - index_of_dim2 * output_pitches[2];\n        index_of_dim3 = m;\n\n        int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n        index_of_input_dim2 = index_of_dim2 / scales[2];\n        y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n        index_of_input_dim3 = index_of_dim3 / scales[3];\n        x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n        input_index = index_of_dim0 * input_pitches[0] +\n                      index_of_dim1 * input_pitches[1] +\n                      index_of_input_dim2 * input_pitches[2] +\n                      index_of_input_dim3;\n\n        float x00 = getInputFloat(input_index);\n        float x10, x01, x11;\n\n        bool end_of_dim2 = false;\n        if (index_of_input_dim2 == (" + inputs[0].dims[2] + " - 1)) {\n          // It's the end in dimension 2\n          x01 = x00;\n          end_of_dim2 = true;\n        } else {\n          x01 = getInputFloat(input_index + input_pitches[2]);\n        }\n\n        if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n          // It's the end in dimension 3\n          x10 = x00;\n          x11 = x01;\n        }\n        else {\n          x10 = getInputFloat(input_index + 1);\n          x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n        }\n\n        float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n        float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n        return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n      }" :
                // bilinear 2D
                "\n      " + getInputFloatFunction + "\n      float process(int indices[2]) {\n        int input_index = 0;\n        int output_index = coordsToOffset(TexCoords, " + outputLayout.width + ", " + outputLayout.height + ");\n\n        " + precalculatedPitches + "\n\n        int m;\n        int index_of_dim0, index_of_dim1;\n        index_of_dim0 = output_index / output_pitches[0];\n        m = output_index - index_of_dim0 * output_pitches[0];\n        index_of_dim1 = m;\n\n        int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n        index_of_input_dim0 = index_of_dim0 / scales[0];\n        y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n        index_of_input_dim1 = index_of_dim1 / scales[1];\n        x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n        input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n        float x00 = getInputFloat(input_index);\n        float x10, x01, x11;\n\n        bool end_of_dim0 = false;\n        if (index_of_input_dim0 == (" + inputs[0].dims[0] + " - 1)) {\n          // It's the end in dimension 0\n          x01 = x00;\n          end_of_dim0 = true;\n        } else {\n          x01 = getInputFloat(input_index + input_pitches[0]);\n        }\n\n        if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n          // It's the end in dimension 1\n          x10 = x00;\n          x11 = x01;\n        }\n        else {\n          x10 = getInputFloat(input_index + 1);\n          x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n        }\n\n        float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n        float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n        return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n      }";
        return {
            inputLayouts: [inputLayout],
            outputLayout: outputLayout,
            samplers: ['X'],
            shaderSource: shaderSource,
            variables: [{ name: 'scales', type: 'int', arrayLength: this.scales.length }]
        };
    };
    WebGLUpsample.prototype.createRunData = function (handler, programInfo, inputs) {
        var inputTDs = inputs.map(function (t, i) { return handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]); });
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: { scales: this.scales.map(function (x) { return Math.ceil(x); }) }
        };
    };
    return WebGLUpsample;
}(upsample_1.Upsample));
exports.WebGLUpsample = WebGLUpsample;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/program-manager.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/program-manager.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgramManager = void 0;
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
var glsl_preprocessor_1 = __webpack_require__(/*! ./glsl-preprocessor */ "./lib/onnxjs/backends/webgl/glsl-preprocessor.ts");
var glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
/**
 * ProgramManager is the main class behind running computations
 * It builds ProgramInfo's into Artifacts
 * It compiles given ProgramInfo's into WebGL Prorams (cached as Artifacts)
 * Uses the artifact to run the computation by calling Draw on
 * the WebGL drawing buffer
 * ProgramManager automatically maps (binds) input variables to their
 * corresponding Location's in the binary program
 */
var ProgramManager = /** @class */ (function () {
    function ProgramManager(profiler, glContext, textureLayoutStrategy) {
        this.profiler = profiler;
        this.glContext = glContext;
        this.textureLayoutStrategy = textureLayoutStrategy;
        this.repo = new Map();
        this.attributesBound = false;
    }
    ProgramManager.prototype.getArtifact = function (key) {
        return this.repo.get(key);
    };
    ProgramManager.prototype.setArtifact = function (key, artifact) {
        this.repo.set(key, artifact);
    };
    ProgramManager.prototype.run = function (buildArtifact, runData) {
        var _this = this;
        var _a;
        this.profiler.event('op', "ProgramManager.run " + ((_a = buildArtifact.programInfo.name) !== null && _a !== void 0 ? _a : 'unknown kernel'), function () {
            var gl = _this.glContext.gl;
            var program = buildArtifact.program;
            gl.useProgram(program);
            try {
                _this.bindOutput(runData.outputTextureData);
                if (!_this.attributesBound) {
                    _this.bindAttributes(buildArtifact.attribLocations);
                }
                _this.bindUniforms(buildArtifact.uniformLocations, runData.uniformData, runData.inputTextureDatas);
            }
            catch (err) {
                instrument_1.Logger.error('ProgramManager', buildArtifact.programInfo.shaderSource);
                throw err;
            }
            _this.profiler.event('backend', 'GlContext.draw()', function () {
                _this.doDraw(buildArtifact, runData);
            });
        }, this.glContext);
    };
    ProgramManager.prototype.dispose = function () {
        var _this = this;
        if (this.vertexShader) {
            this.glContext.deleteShader(this.vertexShader);
        }
        this.repo.forEach(function (a) { return _this.glContext.deleteProgram(a.program); });
    };
    ProgramManager.prototype.build = function (programInfo) {
        var _this = this;
        return this.profiler.event('backend', 'ProgramManager.build', function () {
            var preprocessor = new glsl_preprocessor_1.GlslPreprocessor(_this.glContext, programInfo);
            var fragScript = preprocessor.preprocess();
            var program = _this.compile(fragScript);
            var artifact = {
                programInfo: programInfo,
                program: program,
                uniformLocations: _this.getUniformLocations(program, preprocessor.context.programInfo.samplers, preprocessor.context.programInfo.variables),
                attribLocations: _this.getAttribLocations(program)
            };
            return artifact;
        });
    };
    ProgramManager.prototype.doDraw = function (artifact, runData) {
        if (runData.draw) {
            instrument_1.Logger.verbose('ProgramManager', 'Custom draw function');
            runData.draw(this.glContext, artifact);
        }
        else {
            this.glContext.draw();
        }
    };
    ProgramManager.prototype.compile = function (fragShaderScript) {
        if (!this.vertexShader) {
            instrument_1.Logger.verbose('ProrgramManager', 'Compiling and caching Vertex shader for the first time');
            var vertexShaderScript = glsl_source_1.getVertexShaderSource(this.glContext.version);
            this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);
        }
        if (onnxruntime_common_1.env.debug) {
            instrument_1.Logger.verbose('ProrgramManager', "FragShader:\n" + fragShaderScript + "\n");
        }
        var fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);
        var program = this.glContext.createProgram(this.vertexShader, fragShader);
        this.glContext.deleteShader(fragShader);
        return program;
    };
    ProgramManager.prototype.bindOutput = function (td) {
        var width = td.width;
        var height = td.height;
        instrument_1.Logger.verbose('ProrgramManager', "Binding output texture to Framebuffer: w/h=" + width + "/" + height + ", shape=" + td.shape + ", type=" + td.tensor.type);
        this.glContext.attachFramebuffer(td.texture, width, height);
    };
    ProgramManager.prototype.bindAttributes = function (attribLocations) {
        var positionHandle = attribLocations.position;
        var textureCoordHandle = attribLocations.textureCoord;
        this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);
        this.attributesBound = true;
    };
    ProgramManager.prototype.bindUniforms = function (uniformLocations, uniformData, textures) {
        var e_1, _a;
        var gl = this.glContext.gl;
        var texturePosition = 0;
        try {
            for (var uniformLocations_1 = __values(uniformLocations), uniformLocations_1_1 = uniformLocations_1.next(); !uniformLocations_1_1.done; uniformLocations_1_1 = uniformLocations_1.next()) {
                var _b = uniformLocations_1_1.value, name_1 = _b.name, type = _b.type, location_1 = _b.location, arrayLength = _b.arrayLength;
                switch (type) {
                    case 'sampler2D':
                        this.bindTexture(textures[texturePosition], location_1, texturePosition);
                        texturePosition++;
                        break;
                    case 'float':
                        if (arrayLength) {
                            gl.uniform1fv(location_1, uniformData[name_1]);
                        }
                        else {
                            gl.uniform1f(location_1, uniformData[name_1]);
                        }
                        break;
                    case 'int':
                        if (arrayLength) {
                            gl.uniform1iv(location_1, uniformData[name_1]);
                        }
                        else {
                            gl.uniform1i(location_1, uniformData[name_1]);
                        }
                        break;
                    default:
                        throw new Error("Uniform not implemented: " + type);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (uniformLocations_1_1 && !uniformLocations_1_1.done && (_a = uniformLocations_1.return)) _a.call(uniformLocations_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    ProgramManager.prototype.bindTexture = function (td, uniformHandle, position) {
        this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);
    };
    ProgramManager.prototype.getAttribLocations = function (program) {
        return {
            position: this.getAttribLocation(program, 'position'),
            textureCoord: this.getAttribLocation(program, 'textureCoord')
        };
    };
    ProgramManager.prototype.getUniformLocations = function (program, samplers, variables) {
        var e_2, _a, e_3, _b;
        var uniformLocations = [];
        if (samplers) {
            try {
                for (var samplers_1 = __values(samplers), samplers_1_1 = samplers_1.next(); !samplers_1_1.done; samplers_1_1 = samplers_1.next()) {
                    var sampler = samplers_1_1.value;
                    uniformLocations.push({ name: sampler, type: 'sampler2D', location: this.getUniformLocation(program, sampler) });
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (samplers_1_1 && !samplers_1_1.done && (_a = samplers_1.return)) _a.call(samplers_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (variables) {
            try {
                for (var variables_1 = __values(variables), variables_1_1 = variables_1.next(); !variables_1_1.done; variables_1_1 = variables_1.next()) {
                    var variable = variables_1_1.value;
                    uniformLocations.push(__assign(__assign({}, variable), { location: this.getUniformLocation(program, variable.name) }));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (variables_1_1 && !variables_1_1.done && (_b = variables_1.return)) _b.call(variables_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        return uniformLocations;
    };
    ProgramManager.prototype.getUniformLocation = function (program, name) {
        var gl = this.glContext.gl;
        var reference = gl.getUniformLocation(program, name);
        if (reference === null) {
            throw new Error("Uniform " + name + " not found.");
        }
        return reference;
    };
    ProgramManager.prototype.getAttribLocation = function (program, name) {
        var gl = this.glContext.gl;
        var attributeLocation = gl.getAttribLocation(program, name);
        return attributeLocation;
    };
    return ProgramManager;
}());
exports.ProgramManager = ProgramManager;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/session-handler.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/session-handler.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSessionHandler = void 0;
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
var opset_1 = __webpack_require__(/*! ../../opset */ "./lib/onnxjs/opset.ts");
var inference_handler_1 = __webpack_require__(/*! ./inference-handler */ "./lib/onnxjs/backends/webgl/inference-handler.ts");
var op_resolve_rules_1 = __webpack_require__(/*! ./op-resolve-rules */ "./lib/onnxjs/backends/webgl/op-resolve-rules.ts");
var program_manager_1 = __webpack_require__(/*! ./program-manager */ "./lib/onnxjs/backends/webgl/program-manager.ts");
var texture_layout_strategy_1 = __webpack_require__(/*! ./texture-layout-strategy */ "./lib/onnxjs/backends/webgl/texture-layout-strategy.ts");
var texture_manager_1 = __webpack_require__(/*! ./texture-manager */ "./lib/onnxjs/backends/webgl/texture-manager.ts");
var WebGLSessionHandler = /** @class */ (function () {
    function WebGLSessionHandler(backend, context) {
        this.backend = backend;
        this.context = context;
        this.layoutStrategy = new texture_layout_strategy_1.PreferLogicalStrategy(backend.glContext.maxTextureSize);
        this.programManager = new program_manager_1.ProgramManager(this.context.profiler, backend.glContext, this.layoutStrategy);
        this.textureManager = new texture_manager_1.TextureManager(backend.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: backend.textureCacheMode === 'full' });
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache = new Map();
        this.packOpCache = new Map();
        this.unpackOpCache = new Map();
        this.pack = backend.pack;
        this.pack2unpackMap = new Map();
        this.unpack2packMap = new Map();
    }
    WebGLSessionHandler.prototype.createInferenceHandler = function () {
        return new inference_handler_1.WebGLInferenceHandler(this);
    };
    WebGLSessionHandler.prototype.onGraphInitialized = function (graph) {
        var initializers = graph.getValues().filter(function (v) { return v.from === -1 && v.tensor; }).map(function (v) { return v.tensor.dataId; });
        this.initializers = new Set(initializers);
    };
    WebGLSessionHandler.prototype.isInitializer = function (tensorId) {
        return this.initializers ? this.initializers.has(tensorId) : false;
    };
    WebGLSessionHandler.prototype.addInitializer = function (tensorId) {
        this.initializers.add(tensorId);
    };
    WebGLSessionHandler.prototype.getTextureData = function (tensorId, isPacked) {
        if (isPacked) {
            return this.packedTextureDataCache.get(tensorId);
        }
        else {
            return this.unpackedTextureDataCache.get(tensorId);
        }
    };
    WebGLSessionHandler.prototype.setTextureData = function (tensorId, textureData, isPacked) {
        if (isPacked === void 0) { isPacked = false; }
        instrument_1.Logger.verbose('WebGLSessionHandler', 'Storing Texture data in cache');
        if (isPacked) {
            this.packedTextureDataCache.set(tensorId, textureData);
        }
        else {
            this.unpackedTextureDataCache.set(tensorId, textureData);
        }
    };
    WebGLSessionHandler.prototype.dispose = function () {
        var _this = this;
        this.programManager.dispose();
        this.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach(function (td) { return _this.textureManager.releaseTexture(td, true); });
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache.forEach(function (td) { return _this.textureManager.releaseTexture(td, true); });
        this.unpackedTextureDataCache = new Map();
    };
    WebGLSessionHandler.prototype.resolve = function (node, opsets, graph) {
        var op = opset_1.resolveOperator(node, opsets, op_resolve_rules_1.WEBGL_OP_RESOLVE_RULES);
        op.initialize(node.attributes, node, graph);
        return op;
    };
    return WebGLSessionHandler;
}());
exports.WebGLSessionHandler = WebGLSessionHandler;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/texture-data-encoder.ts":
/*!***********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/texture-data-encoder.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint8DataEncoder = exports.RGBAFloatDataEncoder = exports.RedFloat32DataEncoder = void 0;
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
/**
 * WebGL2 data encoder
 * Uses R32F as the format for texlet
 */
var RedFloat32DataEncoder = /** @class */ (function () {
    function RedFloat32DataEncoder(gl, channels) {
        if (channels === void 0) { channels = 1; }
        if (channels === 1) {
            this.internalFormat = gl.R32F;
            this.format = gl.RED;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
        }
        else if (channels === 4) {
            this.internalFormat = gl.RGBA32F;
            this.format = gl.RGBA;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
        }
        else {
            throw new Error("Invalid number of channels: " + channels);
        }
    }
    RedFloat32DataEncoder.prototype.encode = function (src, textureSize) {
        var result;
        var source;
        if (src.constructor !== Float32Array) {
            instrument_1.Logger.warning('Encoder', 'data was not of type Float32; creating new Float32Array');
            source = new Float32Array(src);
        }
        if (textureSize * this.channelSize > src.length) {
            instrument_1.Logger.warning('Encoder', 'Source data too small. Allocating larger array');
            source = src;
            result = this.allocate(textureSize * this.channelSize);
            source.forEach(function (v, i) { return result[i] = v; });
        }
        else {
            source = src;
            result = source;
        }
        return result;
    };
    RedFloat32DataEncoder.prototype.allocate = function (size) {
        return new Float32Array(size * 4);
    };
    RedFloat32DataEncoder.prototype.decode = function (buffer, dataSize) {
        if (this.channelSize === 1) {
            var filteredData = buffer.filter(function (value, index) { return index % 4 === 0; }).subarray(0, dataSize);
            return filteredData;
        }
        return buffer.subarray(0, dataSize);
    };
    return RedFloat32DataEncoder;
}());
exports.RedFloat32DataEncoder = RedFloat32DataEncoder;
/**
 * Data encoder for WebGL 1 with support for floating point texture
 */
var RGBAFloatDataEncoder = /** @class */ (function () {
    function RGBAFloatDataEncoder(gl, channels, textureType) {
        if (channels === void 0) { channels = 1; }
        if (channels !== 1 && channels !== 4) {
            throw new Error("Invalid number of channels: " + channels);
        }
        this.internalFormat = gl.RGBA;
        this.format = gl.RGBA;
        this.channelSize = channels;
        this.textureType = textureType || gl.FLOAT;
    }
    RGBAFloatDataEncoder.prototype.encode = function (src, textureSize) {
        var dest = src;
        if (this.channelSize === 1) {
            instrument_1.Logger.verbose('Encoder', 'Exploding into a larger array');
            dest = this.allocate(textureSize);
            src.forEach(function (v, i) { return dest[i * 4] = v; });
        }
        return dest;
    };
    RGBAFloatDataEncoder.prototype.allocate = function (size) {
        return new Float32Array(size * 4);
    };
    RGBAFloatDataEncoder.prototype.decode = function (buffer, dataSize) {
        if (this.channelSize === 1) {
            var filteredData = buffer.filter(function (value, index) { return index % 4 === 0; }).subarray(0, dataSize);
            return filteredData;
        }
        return buffer.subarray(0, dataSize);
    };
    return RGBAFloatDataEncoder;
}());
exports.RGBAFloatDataEncoder = RGBAFloatDataEncoder;
var Uint8DataEncoder = /** @class */ (function () {
    function Uint8DataEncoder(gl, channels) {
        if (channels === void 0) { channels = 1; }
        this.channelSize = 4;
        if (channels === 1) {
            this.internalFormat = gl.ALPHA;
            this.format = gl.ALPHA; // not tested
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
        }
        else if (channels === 4) {
            this.internalFormat = gl.RGBA;
            this.format = gl.RGBA;
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
        }
        else {
            throw new Error("Invalid number of channels: " + channels);
        }
    }
    Uint8DataEncoder.prototype.encode = function (src, _textureSize) {
        return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);
    };
    Uint8DataEncoder.prototype.allocate = function (size) {
        return new Uint8Array(size * this.channelSize);
    };
    Uint8DataEncoder.prototype.decode = function (buffer, dataSize) {
        if (buffer instanceof Uint8Array) {
            return buffer.subarray(0, dataSize);
        }
        throw new Error("Invalid array type: " + buffer.constructor);
    };
    return Uint8DataEncoder;
}());
exports.Uint8DataEncoder = Uint8DataEncoder;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/texture-layout-strategy.ts":
/*!**************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/texture-layout-strategy.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBatchDim = exports.sizeToSquarishShape = exports.getRowsCols = exports.sizeFromShape = exports.isInt = exports.parseAxisParam = exports.squeezeShape = exports.PreferLogicalStrategy = exports.AlwaysKeepOriginalSizeStrategy = void 0;
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
var util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
/**
 * This strategy try to find the minimal max(W,H) that fulfills (W * H == totalSize)
 */
var AlwaysKeepOriginalSizeStrategy = /** @class */ (function () {
    function AlwaysKeepOriginalSizeStrategy(maxTextureSize) {
        this.maxTextureSize = maxTextureSize;
    }
    AlwaysKeepOriginalSizeStrategy.prototype.computeTextureWH = function (shape, prefs) {
        // scalar tensor
        if (shape.length === 0) {
            return [1, 1];
        }
        var maxTextureSize = this.maxTextureSize;
        if (prefs && prefs.breakAxis !== undefined) {
            // check to see if dims fit
            var wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce(function (a, b) { return a * b; });
            var hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce(function (a, b) { return a * b; });
            if (wsize > maxTextureSize || hsize > maxTextureSize) {
                // ignore preferences
                // continue with default layout
                instrument_1.Logger.verbose('TextureLayout', "Given width/height preferences were unattainable: shape:" + shape + ", breakAxis:" + prefs.breakAxis);
            }
            else {
                return [wsize, hsize];
            }
        }
        var totalSize = shape.reduce(function (a, b) { return a * b; });
        var width = Math.floor(Math.sqrt(totalSize));
        for (; width < maxTextureSize && width < totalSize; width++) {
            if (totalSize % width === 0) {
                break;
            }
        }
        if (width >= maxTextureSize || totalSize % width !== 0) {
            throw new Error("The given dimensions are outside this GPU's boundaries: " + shape);
        }
        return [width, totalSize / width];
    };
    return AlwaysKeepOriginalSizeStrategy;
}());
exports.AlwaysKeepOriginalSizeStrategy = AlwaysKeepOriginalSizeStrategy;
var PreferLogicalStrategy = /** @class */ (function () {
    function PreferLogicalStrategy(maxTextureSize) {
        this.maxTextureSize = maxTextureSize;
    }
    PreferLogicalStrategy.prototype.computeTextureWH = function (shape, prefs) {
        var wh = this.computeTexture(shape, prefs);
        if (prefs && prefs.isPacked) {
            wh[0] /= 2;
            wh[1] /= 2;
        }
        return wh;
    };
    PreferLogicalStrategy.prototype.computeTexture = function (shape, prefs) {
        var isPacked = prefs && prefs.isPacked;
        // scalar tensor
        if (shape.length === 0) {
            return isPacked ? [2, 2] : [1, 1];
        }
        var maxTextureSize = this.maxTextureSize;
        if (prefs && prefs.breakAxis !== undefined) {
            // check to see if dims fit
            var wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce(function (a, b) { return a * b; });
            var hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce(function (a, b) { return a * b; });
            if (wsize > maxTextureSize || hsize > maxTextureSize) {
                // ignore preferences
                // continue with default layout
                instrument_1.Logger.verbose('TextureLayout', "Given width/height preferences were unattainable: shape:" + shape + ", breakAxis:" + prefs.breakAxis);
            }
            else {
                return [wsize, hsize];
            }
        }
        var logShape = shape.slice(0);
        if (isPacked) {
            maxTextureSize = maxTextureSize * 2;
            // This logic ensures we accurately count the number of packed texels needed
            // to accommodate the tensor. We can only pack values in the same texel if
            // they are from adjacent pairs of rows/cols within the same batch. So if a
            // tensor has 3 rows, we pretend it has 4 rows in order to account for the
            // fact that the texels containing the third row are half empty.
            logShape = logShape.map(function (d, i) { return i >= logShape.length - 2 ? (logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1) : logShape[i]; });
            // Packed texture height is at least 2 (the channel height of a single
            // texel).
            if (logShape.length === 1) {
                logShape = [2, logShape[0]];
            }
        }
        // If logical shape is 2, we don't squeeze, since we want to match physical.
        if (logShape.length !== 2) {
            var squeezeResult = squeezeShape(logShape);
            logShape = squeezeResult.newShape;
        }
        var size = sizeFromShape(logShape);
        if (logShape.length <= 1 && size <= maxTextureSize) {
            return [1, size];
        }
        else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {
            return logShape;
        }
        else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {
            return [logShape[0] * logShape[1], logShape[2]];
        }
        else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2]];
        }
        else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize &&
            logShape[3] <= maxTextureSize) {
            return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
        }
        else if (logShape.length === 4 && logShape[0] <= maxTextureSize &&
            logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
        }
        else {
            if (isPacked) {
                // For packed textures size equals the number of channels required to
                // accommodate the texture data. However in order to squarify such that
                // inner dimensions stay even, we rewrite size to equal the number of
                // texels. Then in the return statement we rehydrate the squarified
                // dimensions to channel units.
                return sizeToSquarishShape(size / 4).map(function (d) { return d * 2; });
            }
            return sizeToSquarishShape(size);
        }
    };
    return PreferLogicalStrategy;
}());
exports.PreferLogicalStrategy = PreferLogicalStrategy;
function squeezeShape(shape, axis) {
    var newShape = [];
    var keptDims = [];
    var isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    var axes = (axis == null || isEmptyArray) ? null : parseAxisParam(axis, shape).sort();
    var j = 0;
    for (var i = 0; i < shape.length; ++i) {
        if (axes != null) {
            if (axes[j] === i && shape[i] !== 1) {
                throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
            }
            if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axes[j] <= i) {
                j++;
            }
        }
        if (shape[i] !== 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
function parseAxisParam(axis, shape) {
    var rank = shape.length;
    // Normalize input
    axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
    // Check for valid range
    util_1.assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), function () { return "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
        ("got axis " + axis); });
    // Check for only integers
    util_1.assert(axis.every(isInt), function () { return 'All values in axis param must be integers but ' +
        ("got axis " + axis); });
    // Handle negative axis.
    return axis.map(function (a) { return a < 0 ? rank + a : a; });
}
exports.parseAxisParam = parseAxisParam;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        // Scalar.
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function getRowsCols(shape) {
    if (shape.length === 0) {
        throw Error('Cannot get rows and columns of an empty shape array.');
    }
    return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];
}
exports.getRowsCols = getRowsCols;
function sizeToSquarishShape(size) {
    var width = Math.ceil(Math.sqrt(size));
    return [width, Math.ceil(size / width)];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function getBatchDim(shape, dimsToSkip) {
    if (dimsToSkip === void 0) { dimsToSkip = 2; }
    return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
}
exports.getBatchDim = getBatchDim;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/texture-manager.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/texture-manager.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextureManager = void 0;
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
/**
 * TextureManager is the mainly responsible for caching Textures
 * Textures are cached in 2 levels:
 *   1. the texures which are associated with a dataId (from Tensor)
 *    Caching these is crucial to performance. These are In-use Textures
 *   2. textures which are not in use by any current ProgramInfo/Tensor
 *     These are called Free Textures
 * TextureManager is also used to help creating textures. For this it
 * uses WebGLContext and TextureLayoutStrategy
 */
var TextureManager = /** @class */ (function () {
    function TextureManager(glContext, layoutStrategy, profiler, config) {
        this.glContext = glContext;
        this.layoutStrategy = layoutStrategy;
        this.profiler = profiler;
        this.config = config;
        if (config.reuseTextures) {
            this.inUseTextures = new Map();
            this.idleTextures = new Map();
            this.textureLookup = new Map();
        }
    }
    TextureManager.prototype.createTextureFromLayout = function (dataType, layout, data, usage) {
        var textureDataType = this.toEncoderType(dataType);
        var encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);
        if (layout.isPacked && usage === 1 /* UploadOnly */) {
            throw new Error('not implemented');
        }
        var width = layout.width;
        var height = layout.height;
        var key;
        var inUseTextures;
        if (this.config.reuseTextures) {
            key = width + "x" + height + "_" + encoder.format + "_" + encoder.internalFormat + "_" + encoder.textureType;
            inUseTextures = this.inUseTextures.get(key);
            if (!inUseTextures) {
                inUseTextures = [];
                this.inUseTextures.set(key, inUseTextures);
            }
            var idleTextures = this.idleTextures.get(key);
            if (idleTextures && idleTextures.length > 0) {
                var texture_1 = idleTextures.pop();
                inUseTextures.push(texture_1);
                if (usage === 1 /* UploadOnly */) {
                    this.glContext.updateTexture(texture_1, width, height, encoder, this.toTextureData(dataType, data));
                }
                return texture_1;
            }
        }
        instrument_1.Logger.verbose('TextureManager', "Creating new texture of size " + layout.width + "x" + layout.height);
        var texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));
        if (this.config.reuseTextures) {
            inUseTextures.push(texture);
            this.textureLookup.set(texture, key);
        }
        return texture;
    };
    TextureManager.prototype.readTexture = function (td, dataType, channels) {
        var _this = this;
        if (!channels) {
            channels = 1;
        }
        return this.profiler.event('backend', 'TextureManager.readTexture', function () {
            var dataSize = td.shape.reduce(function (a, b) { return a * b; }) * channels;
            var data = _this.glContext.readTexture(td.texture, td.width, td.height, dataSize, _this.toEncoderType(dataType), channels);
            return _this.toTensorData(dataType, data);
        });
    };
    TextureManager.prototype.readUint8TextureAsFloat = function (td) {
        var _this = this;
        return this.profiler.event('backend', 'TextureManager.readUint8TextureAsFloat', function () {
            var dataSize = td.shape.reduce(function (a, b) { return a * b; });
            var data = _this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, 'byte', 4);
            return new Float32Array(data.buffer, data.byteOffset, dataSize);
        });
    };
    TextureManager.prototype.releaseTexture = function (textureData, deleteTexture) {
        var key;
        if (this.config.reuseTextures) {
            key = this.textureLookup.get(textureData.texture);
            if (key) {
                if (deleteTexture) {
                    this.textureLookup.delete(key);
                }
                var inUseTextures = this.inUseTextures.get(key);
                if (inUseTextures) {
                    var index = inUseTextures.indexOf(textureData.texture);
                    if (index !== -1) {
                        inUseTextures.splice(index, 1);
                        var idleTextures = this.idleTextures.get(key);
                        if (!idleTextures) {
                            idleTextures = [];
                            this.idleTextures.set(key, idleTextures);
                        }
                        idleTextures.push(textureData.texture);
                    }
                }
            }
        }
        if (!key || deleteTexture) {
            instrument_1.Logger.verbose('TextureManager', "Deleting texture of size " + textureData.width + "x" + textureData.height);
            this.glContext.deleteTexture(textureData.texture);
        }
    };
    TextureManager.prototype.toTensorData = function (dataType, data) {
        switch (dataType) {
            case 'int16':
                return data instanceof Int16Array ? data : Int16Array.from(data);
            case 'int32':
                return data instanceof Int32Array ? data : Int32Array.from(data);
            case 'int8':
                return data instanceof Int8Array ? data : Int8Array.from(data);
            case 'uint16':
                return data instanceof Uint16Array ? data : Uint16Array.from(data);
            case 'uint32':
                return data instanceof Uint32Array ? data : Uint32Array.from(data);
            case 'uint8':
            case 'bool':
                return data instanceof Uint8Array ? data : Uint8Array.from(data);
            case 'float32':
                return data instanceof Float32Array ? data : Float32Array.from(data);
            case 'float64':
                return data instanceof Float64Array ? data : Float64Array.from(data);
            default:
                throw new Error("TensorData type " + dataType + " is not supported");
        }
    };
    TextureManager.prototype.toTextureData = function (dataType, data) {
        if (!data) {
            return undefined;
        }
        return (data instanceof Float32Array) ? data : new Float32Array(data);
        /*
        switch (dataType) {
          case 'int16':
          case 'int32':
          case 'uint16':
          case 'uint32':
            return (data.constructor === Uint32Array) ? data as Uint32Array : new Uint32Array(data);
          case 'int8':
          case 'uint8':
          case 'bool':
            return (data.constructor === Uint8Array) ? data as Uint8Array : new Uint8Array(data);
          case 'float32':
          case 'float64':
            return (data.constructor === Float32Array) ? data as Float32Array : new Float32Array(data);
          default:
            throw new Error(`TensorData type ${dataType} is not supported`);
        }
        */
    };
    TextureManager.prototype.toEncoderType = function (_dataType) {
        return 'float';
        // switch (dataType) {
        //   case 'int16':
        //   case 'int32':
        //   case 'uint16':
        //   case 'uint32':
        //     return 'int';
        //   case 'uint8':
        //   case 'bool':
        //     return 'byte';
        //   case 'float32':
        //   case 'float64':
        //     return 'float';
        //   default:
        //     throw new Error(`TensorData type ${dataType} is not supported`);
        // }
    };
    TextureManager.prototype.clearActiveTextures = function () {
        this.glContext.clearActiveTextures();
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/utils.ts":
/*!********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/utils.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCoordsDataType = exports.getSqueezedParams = exports.squeezeInputShape = exports.generateShaderFuncNameFromInputSamplerNameAtOutCoords = exports.generateShaderFuncNameFromInputSamplerName = exports.repeatedTry = exports.getPackedShape = void 0;
var util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
/**
 * Given a non RGBA shape calculate the R version
 * It is assumed that the dimensions are multiples of given channels
 * NOTE: it is always the last dim that gets packed.
 * @param unpackedShape original shape to create a packed version from
 */
function getPackedShape(unpackedShape) {
    var len = unpackedShape.length;
    return unpackedShape.slice(0, len - 1).concat(unpackedShape[len - 1] / 4);
}
exports.getPackedShape = getPackedShape;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (_counter) { return 0; }; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var tryCount = 0;
                    var tryFn = function () {
                        if (checkFn()) {
                            resolve();
                            return;
                        }
                        tryCount++;
                        var nextBackoff = delayFn(tryCount);
                        if (maxCounter != null && tryCount >= maxCounter) {
                            reject();
                            return;
                        }
                        setTimeout(tryFn, nextBackoff);
                    };
                    tryFn();
                })];
        });
    });
}
exports.repeatedTry = repeatedTry;
/**
 * Generates the function name from an input sampler name.
 * @param samplerName Name of the sampler.
 */
function generateShaderFuncNameFromInputSamplerName(samplerName) {
    util_1.assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, function () { return 'empty string found for sampler name'; });
    return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);
}
exports.generateShaderFuncNameFromInputSamplerName = generateShaderFuncNameFromInputSamplerName;
/**
 * Generates the function name from an input sampler name at output coordinates.
 * @param samplerName Name of the sampler.
 */
function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName) {
    util_1.assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, function () { return 'empty string found for sampler name'; });
    return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + 'AtOutCoords';
}
exports.generateShaderFuncNameFromInputSamplerNameAtOutCoords = generateShaderFuncNameFromInputSamplerNameAtOutCoords;
/** Returns a new input shape (a copy) that has a squeezed logical shape. */
function squeezeInputShape(inputShape, squeezedShape) {
    // Deep copy.
    var newInputShape = JSON.parse(JSON.stringify(inputShape));
    newInputShape = squeezedShape;
    return newInputShape;
}
exports.squeezeInputShape = squeezeInputShape;
/** Returns a list of squeezed parameters for shader functions */
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}
exports.getSqueezedParams = getSqueezedParams;
/** Returns the data type for different ranks. */
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else if (rank === 5) {
        return 'ivec5';
    }
    else if (rank === 6) {
        return 'ivec6';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/webgl-context-factory.ts":
/*!************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/webgl-context-factory.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNewWebGLContext = exports.createWebGLContext = void 0;
var instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
var webgl_context_1 = __webpack_require__(/*! ./webgl-context */ "./lib/onnxjs/backends/webgl/webgl-context.ts");
var cache = {};
/**
 * This factory function creates proper WebGLRenderingContext based on
 * the current browsers capabilities
 * The order is from higher/most recent versions to most basic
 */
function createWebGLContext(contextId) {
    var context;
    if ((!contextId || contextId === 'webgl2') && 'webgl2' in cache) {
        context = cache.webgl2;
    }
    else if ((!contextId || contextId === 'webgl') && 'webgl' in cache) {
        context = cache.webgl;
    }
    context = context || createNewWebGLContext(contextId);
    contextId = contextId || context.version === 1 ? 'webgl' : 'webgl2';
    var gl = context.gl;
    cache[contextId] = context;
    if (gl.isContextLost()) {
        delete cache[contextId];
        return createWebGLContext(contextId);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return context;
}
exports.createWebGLContext = createWebGLContext;
function createNewWebGLContext(contextId) {
    var canvas = createCanvas();
    var contextAttributes = {
        alpha: false,
        depth: false,
        antialias: false,
        stencil: false,
        preserveDrawingBuffer: false,
        premultipliedAlpha: false,
        failIfMajorPerformanceCaveat: false
    };
    var gl;
    var ca = contextAttributes;
    if (!contextId || contextId === 'webgl2') {
        gl = canvas.getContext('webgl2', ca);
        if (gl) {
            try {
                return new webgl_context_1.WebGLContext(gl, 2);
            }
            catch (err) {
                instrument_1.Logger.warning('GlContextFactory', "failed to create WebGLContext using contextId 'webgl2'. Error: " + err);
            }
        }
    }
    if (!contextId || contextId === 'webgl') {
        gl = canvas.getContext('webgl', ca) || canvas.getContext('experimental-webgl', ca);
        if (gl) {
            try {
                return new webgl_context_1.WebGLContext(gl, 1);
            }
            catch (err) {
                instrument_1.Logger.warning('GlContextFactory', "failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: " + err);
            }
        }
    }
    throw new Error('WebGL is not supported');
}
exports.createNewWebGLContext = createNewWebGLContext;
function createCanvas() {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas;
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/webgl-context.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/webgl-context.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLContext = void 0;
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var DataEncoders = __importStar(__webpack_require__(/*! ./texture-data-encoder */ "./lib/onnxjs/backends/webgl/texture-data-encoder.ts"));
var utils_1 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
/**
 * Abstraction and wrapper around WebGLRenderingContext and its operations
 */
var WebGLContext = /** @class */ (function () {
    function WebGLContext(gl, version) {
        this.frameBufferBound = false;
        this.gl = gl;
        this.version = version;
        this.getExtensions();
        this.vertexbuffer = this.createVertexbuffer();
        this.framebuffer = this.createFramebuffer();
        this.queryVitalParameters();
    }
    WebGLContext.prototype.allocateTexture = function (width, height, encoder, data) {
        var gl = this.gl;
        // create the texture
        var texture = gl.createTexture();
        // bind the texture so the following methods effect this texture.
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        var buffer = data ? encoder.encode(data, width * height) : null;
        gl.texImage2D(gl.TEXTURE_2D, 0, // Level of detail.
        encoder.internalFormat, width, height, 0, // Always 0 in OpenGL ES.
        encoder.format, encoder.textureType, buffer);
        this.checkError();
        return texture;
    };
    WebGLContext.prototype.updateTexture = function (texture, width, height, encoder, data) {
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        var buffer = encoder.encode(data, width * height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, // level
        0, // xoffset
        0, // yoffset
        width, height, encoder.format, encoder.textureType, buffer);
        this.checkError();
    };
    WebGLContext.prototype.attachFramebuffer = function (texture, width, height) {
        var gl = this.gl;
        // Make it the target for framebuffer operations - including rendering.
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs
        this.checkError();
        gl.viewport(0, 0, width, height);
        gl.scissor(0, 0, width, height);
    };
    WebGLContext.prototype.readTexture = function (texture, width, height, dataSize, dataType, channels) {
        var gl = this.gl;
        if (!channels) {
            channels = 1;
        }
        if (!this.frameBufferBound) {
            this.attachFramebuffer(texture, width, height);
        }
        var encoder = this.getEncoder(dataType, channels);
        var buffer = encoder.allocate(width * height);
        // bind texture to framebuffer
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs
        // TODO: Check if framebuffer is ready
        gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);
        this.checkError();
        // unbind FB
        return encoder.decode(buffer, dataSize);
    };
    WebGLContext.prototype.isFramebufferReady = function () {
        // TODO: Implement logic to check if the framebuffer is ready
        return true;
    };
    WebGLContext.prototype.getActiveTexture = function () {
        var gl = this.gl;
        var n = gl.getParameter(this.gl.ACTIVE_TEXTURE);
        return "TEXTURE" + (n - gl.TEXTURE0);
    };
    WebGLContext.prototype.getTextureBinding = function () {
        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
    };
    WebGLContext.prototype.getFramebufferBinding = function () {
        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
    };
    WebGLContext.prototype.setVertexAttributes = function (positionHandle, textureCoordHandle) {
        var gl = this.gl;
        gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(positionHandle);
        if (textureCoordHandle !== -1) {
            gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);
            gl.enableVertexAttribArray(textureCoordHandle);
        }
        this.checkError();
    };
    WebGLContext.prototype.createProgram = function (vertexShader, fragShader) {
        var gl = this.gl;
        var program = gl.createProgram();
        // the program consists of our shaders
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        return program;
    };
    WebGLContext.prototype.compileShader = function (shaderSource, shaderType) {
        var gl = this.gl;
        var shader = gl.createShader(shaderType);
        if (!shader) {
            throw new Error("createShader() returned null with type " + shaderType);
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            throw new Error("Failed to compile shader: " + gl.getShaderInfoLog(shader) + "\nShader source:\n" + shaderSource);
        }
        return shader;
    };
    WebGLContext.prototype.deleteShader = function (shader) {
        this.gl.deleteShader(shader);
    };
    WebGLContext.prototype.bindTextureToUniform = function (texture, position, uniformHandle) {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + position);
        this.checkError();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.checkError();
        gl.uniform1i(uniformHandle, position);
        this.checkError();
    };
    WebGLContext.prototype.draw = function () {
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        this.checkError();
    };
    WebGLContext.prototype.checkError = function () {
        if (onnxruntime_common_1.env.debug) {
            var gl = this.gl;
            var error = gl.getError();
            var label = '';
            switch (error) {
                case (gl.NO_ERROR):
                    return;
                case (gl.INVALID_ENUM):
                    label = 'INVALID_ENUM';
                    break;
                case (gl.INVALID_VALUE):
                    label = 'INVALID_VALUE';
                    break;
                case (gl.INVALID_OPERATION):
                    label = 'INVALID_OPERATION';
                    break;
                case (gl.INVALID_FRAMEBUFFER_OPERATION):
                    label = 'INVALID_FRAMEBUFFER_OPERATION';
                    break;
                case (gl.OUT_OF_MEMORY):
                    label = 'OUT_OF_MEMORY';
                    break;
                case (gl.CONTEXT_LOST_WEBGL):
                    label = 'CONTEXT_LOST_WEBGL';
                    break;
                default:
                    label = "Unknown WebGL Error: " + error.toString(16);
            }
            throw new Error(label);
        }
    };
    WebGLContext.prototype.deleteTexture = function (texture) {
        this.gl.deleteTexture(texture);
    };
    WebGLContext.prototype.deleteProgram = function (program) {
        this.gl.deleteProgram(program);
    };
    WebGLContext.prototype.getEncoder = function (dataType, channels, usage) {
        if (usage === void 0) { usage = 0 /* Default */; }
        if (this.version === 2) {
            return new DataEncoders.RedFloat32DataEncoder(this.gl, channels);
        }
        switch (dataType) {
            case 'float':
                if (usage === 1 /* UploadOnly */ || this.isRenderFloat32Supported) {
                    return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels);
                }
                else {
                    return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                }
            case 'int':
                throw new Error('not implemented');
            case 'byte':
                return new DataEncoders.Uint8DataEncoder(this.gl, channels);
            default:
                throw new Error("Invalid dataType: " + dataType);
        }
    };
    WebGLContext.prototype.clearActiveTextures = function () {
        var gl = this.gl;
        for (var unit = 0; unit < this.maxTextureImageUnits; ++unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    };
    WebGLContext.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        var gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(this.framebuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.deleteBuffer(this.vertexbuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.finish();
        this.disposed = true;
    };
    WebGLContext.prototype.createDefaultGeometry = function () {
        // Sets of x,y,z(=0),s,t coordinates.
        return new Float32Array([
            -1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, -1.0, 0.0, 0.0, 0.0,
            1.0, 1.0, 0.0, 1.0, 1.0,
            1.0, -1.0, 0.0, 1.0, 0.0 // lower right
        ]);
    };
    WebGLContext.prototype.createVertexbuffer = function () {
        var gl = this.gl;
        var buffer = gl.createBuffer();
        if (!buffer) {
            throw new Error('createBuffer() returned null');
        }
        var geometry = this.createDefaultGeometry();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);
        this.checkError();
        return buffer;
    };
    WebGLContext.prototype.createFramebuffer = function () {
        var fb = this.gl.createFramebuffer();
        if (!fb) {
            throw new Error('createFramebuffer returned null');
        }
        return fb;
    };
    WebGLContext.prototype.queryVitalParameters = function () {
        var gl = this.gl;
        this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();
        this.isRenderFloat32Supported = this.checkRenderFloat32();
        this.isFloat32DownloadSupported = this.checkFloat32Download();
        if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {
            throw new Error('both float32 and float16 TextureType are not supported');
        }
        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();
        // this.maxCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        // this.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        // this.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        // this.webglVendor = gl.getParameter(gl.VENDOR);
        // this.webglVersion = gl.getParameter(gl.VERSION);
        if (this.version === 2) {
            // this.max3DTextureSize = gl.getParameter(WebGL2RenderingContext.MAX_3D_TEXTURE_SIZE);
            // this.maxArrayTextureLayers = gl.getParameter(WebGL2RenderingContext.MAX_ARRAY_TEXTURE_LAYERS);
            // this.maxColorAttachments = gl.getParameter(WebGL2RenderingContext.MAX_COLOR_ATTACHMENTS);
            // this.maxDrawBuffers = gl.getParameter(WebGL2RenderingContext.MAX_DRAW_BUFFERS);
        }
    };
    WebGLContext.prototype.getExtensions = function () {
        if (this.version === 2) {
            this.colorBufferFloatExtension = this.gl.getExtension('EXT_color_buffer_float');
            this.disjointTimerQueryWebgl2Extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');
        }
        else {
            this.textureFloatExtension = this.gl.getExtension('OES_texture_float');
            this.textureHalfFloatExtension = this.gl.getExtension('OES_texture_half_float');
        }
    };
    WebGLContext.prototype.checkFloatTextureAttachableToFrameBuffer = function () {
        // test whether Float32 texture is supported:
        // STEP.1 create a float texture
        var gl = this.gl;
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        var internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
        // STEP.2 bind a frame buffer
        var frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        // STEP.3 attach texture to framebuffer
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        // STEP.4 test whether framebuffer is complete
        var isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(frameBuffer);
        return isComplete;
    };
    WebGLContext.prototype.checkRenderFloat32 = function () {
        if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
                return false;
            }
        }
        else {
            if (!this.textureFloatExtension) {
                return false;
            }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
    };
    WebGLContext.prototype.checkFloat32Download = function () {
        if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
                return false;
            }
        }
        else {
            if (!this.textureFloatExtension) {
                return false;
            }
            if (!this.gl.getExtension('WEBGL_color_buffer_float')) {
                return false;
            }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
    };
    /**
     * Check whether GL_BLEND is supported
     */
    WebGLContext.prototype.checkFloat32Blend = function () {
        // it looks like currently (2019-05-08) there is no easy way to detect whether BLEND is supported
        // https://github.com/microsoft/onnxjs/issues/145
        var gl = this.gl;
        var texture;
        var frameBuffer;
        var vertexShader;
        var fragmentShader;
        var program;
        try {
            texture = gl.createTexture();
            frameBuffer = gl.createFramebuffer();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // eslint-disable-next-line @typescript-eslint/naming-convention
            var internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.enable(gl.BLEND);
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            if (!vertexShader) {
                return false;
            }
            gl.shaderSource(vertexShader, 'void main(){}');
            gl.compileShader(vertexShader);
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            if (!fragmentShader) {
                return false;
            }
            gl.shaderSource(fragmentShader, 'precision highp float;void main(){gl_FragColor=vec4(0.5);}');
            gl.compileShader(fragmentShader);
            program = gl.createProgram();
            if (!program) {
                return false;
            }
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            gl.drawArrays(gl.POINTS, 0, 1);
            return gl.getError() === gl.NO_ERROR;
        }
        finally {
            gl.disable(gl.BLEND);
            if (program) {
                gl.deleteProgram(program);
            }
            if (vertexShader) {
                gl.deleteShader(vertexShader);
            }
            if (fragmentShader) {
                gl.deleteShader(fragmentShader);
            }
            if (frameBuffer) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.deleteFramebuffer(frameBuffer);
            }
            if (texture) {
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        }
    };
    WebGLContext.prototype.beginTimer = function () {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            var gl2 = this.gl;
            var ext = this.disjointTimerQueryWebgl2Extension;
            var query = gl2.createQuery();
            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
            return query;
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported.');
        }
    };
    WebGLContext.prototype.endTimer = function () {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            var gl2 = this.gl;
            var ext = this.disjointTimerQueryWebgl2Extension;
            gl2.endQuery(ext.TIME_ELAPSED_EXT);
            return;
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported');
        }
    };
    WebGLContext.prototype.isTimerResultAvailable = function (query) {
        var available = false, disjoint = false;
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            var gl2 = this.gl;
            var ext = this.disjointTimerQueryWebgl2Extension;
            available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported');
        }
        return available && !disjoint;
    };
    WebGLContext.prototype.getTimerResult = function (query) {
        var timeElapsed = 0;
        if (this.version === 2) {
            var gl2 = this.gl;
            timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            gl2.deleteQuery(query);
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported');
        }
        // return miliseconds
        return timeElapsed / 1000000;
    };
    WebGLContext.prototype.waitForQueryAndGetTime = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, utils_1.repeatedTry(function () { return _this.isTimerResultAvailable(query); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.getTimerResult(query)];
                }
            });
        });
    };
    return WebGLContext;
}());
exports.WebGLContext = WebGLContext;


/***/ }),

/***/ "./lib/onnxjs/execution-plan.ts":
/*!**************************************!*\
  !*** ./lib/onnxjs/execution-plan.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecutionPlan = void 0;
var instrument_1 = __webpack_require__(/*! ./instrument */ "./lib/onnxjs/instrument.ts");
var KernelOp = /** @class */ (function () {
    function KernelOp(op, node) {
        this.op = op;
        this.node = node;
    }
    return KernelOp;
}());
var ExecutionPlan = /** @class */ (function () {
    function ExecutionPlan(graph, ops, profiler) {
        this.graph = graph;
        this.profiler = profiler;
        this.initialize(ops);
    }
    ExecutionPlan.prototype.initialize = function (ops) {
        var _this = this;
        this.profiler.event('session', 'ExecutionPlan.initialize', function () {
            var graphNodes = _this.graph.getNodes();
            if (graphNodes.length !== ops.length) {
                throw new Error('The size of nodes and OPs do not match.');
            }
            _this._ops = ops.map(function (op, i) { return new KernelOp(op, graphNodes[i]); });
            _this.reset();
            // look for starter node(s)
            _this._starter = [];
            _this._ops.forEach(function (op, i) {
                var e_1, _a;
                var resolved = true;
                try {
                    for (var _b = __values(op.node.inputs), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var input = _c.value;
                        if (!_this._values[input] // not an initialized input
                            && _this.graph.getInputIndices().indexOf(input) === -1 // not model input
                        ) {
                            resolved = false;
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (resolved) {
                    _this._starter.push(i);
                }
            });
        });
    };
    ExecutionPlan.prototype.reset = function () {
        this._values = this.graph.getValues().map(function (i) { return i.tensor; });
    };
    ExecutionPlan.prototype.execute = function (sessionHandler, modelInputs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.profiler.event('session', 'ExecutionPlan.execute', function () { return __awaiter(_this, void 0, void 0, function () {
                        var inferenceHandler, graphInputs, sequence, graphValues, graphNodes, rear, _loop_1, this_1, output;
                        var _this = this;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    // reset mediem result
                                    this.reset();
                                    inferenceHandler = sessionHandler.createInferenceHandler();
                                    graphInputs = this.graph.getInputIndices();
                                    if (modelInputs.length !== graphInputs.length) {
                                        throw new Error("number of input tensors don't match the number of inputs to the model: actual: " + modelInputs.length + " expected: " + graphInputs.length);
                                    }
                                    modelInputs.forEach(function (input, i) {
                                        var index = graphInputs[i];
                                        _this._values[index] = input;
                                    });
                                    sequence = this._starter.slice(0);
                                    graphValues = this.graph.getValues();
                                    graphNodes = this.graph.getNodes();
                                    rear = 0;
                                    _loop_1 = function () {
                                        var thisOpIndex, thisOp, inputList, inputTensors, execNodeFn, outputList, downstreamNodes;
                                        return __generator(this, function (_b) {
                                            switch (_b.label) {
                                                case 0:
                                                    thisOpIndex = sequence[rear++];
                                                    thisOp = this_1._ops[thisOpIndex];
                                                    inputList = thisOp.node.inputs.map(function (i) { return _this._values[i]; });
                                                    if (inputList.indexOf(undefined) !== -1) {
                                                        throw new Error("unresolved input detected: op: " + thisOp.node);
                                                    }
                                                    inputTensors = inputList;
                                                    instrument_1.Logger.verbose('ExecPlan', "Runing op:" + thisOp.node.name + " (" + inputTensors.map(function (t, i) { return "'" + thisOp.node.inputs[i] + "': " + t.type + "[" + t.dims.join(',') + "]"; }).join(', ') + ")");
                                                    execNodeFn = function () { return __awaiter(_this, void 0, void 0, function () {
                                                        var op, result;
                                                        return __generator(this, function (_a) {
                                                            op = thisOp.op;
                                                            if (!op.checkInputs(inputTensors)) {
                                                                throw new Error("invalid inputs detected; op: " + thisOp.node.name);
                                                            }
                                                            result = op.run(inferenceHandler, inputTensors);
                                                            return [2 /*return*/, result];
                                                        });
                                                    }); };
                                                    return [4 /*yield*/, this_1.profiler.event('node', thisOp.node.name, execNodeFn)];
                                                case 1:
                                                    outputList = _b.sent();
                                                    // check output
                                                    if (outputList.length !== thisOp.node.outputs.length) {
                                                        throw new Error('the size of output does not match model definition.');
                                                    }
                                                    // fill value
                                                    outputList.forEach(function (output, i) {
                                                        var j = thisOp.node.outputs[i];
                                                        if (_this._values[j]) {
                                                            throw new Error("output [" + j + "] already has value: op:" + thisOp.node.name);
                                                        }
                                                        _this._values[j] = output;
                                                    });
                                                    downstreamNodes = new Set();
                                                    outputList.forEach(function (output, i) {
                                                        var e_2, _a, e_3, _b;
                                                        var j = thisOp.node.outputs[i];
                                                        try {
                                                            for (var _c = (e_2 = void 0, __values(graphValues[j].to)), _d = _c.next(); !_d.done; _d = _c.next()) {
                                                                var currentDownstreamNodeIndex = _d.value;
                                                                var currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];
                                                                var resolved = true;
                                                                try {
                                                                    for (var _e = (e_3 = void 0, __values(currentDownstreamNode.inputs)), _f = _e.next(); !_f.done; _f = _e.next()) {
                                                                        var k = _f.value;
                                                                        if (!_this._values[k]) {
                                                                            resolved = false;
                                                                            break;
                                                                        }
                                                                    }
                                                                }
                                                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                                                finally {
                                                                    try {
                                                                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                                                                    }
                                                                    finally { if (e_3) throw e_3.error; }
                                                                }
                                                                if (resolved) {
                                                                    downstreamNodes.add(currentDownstreamNodeIndex);
                                                                }
                                                            }
                                                        }
                                                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                                        finally {
                                                            try {
                                                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                                                            }
                                                            finally { if (e_2) throw e_2.error; }
                                                        }
                                                    });
                                                    sequence.push.apply(sequence, __spreadArray([], __read(downstreamNodes)));
                                                    return [2 /*return*/];
                                            }
                                        });
                                    };
                                    this_1 = this;
                                    _a.label = 1;
                                case 1:
                                    if (!(rear < sequence.length)) return [3 /*break*/, 3];
                                    return [5 /*yield**/, _loop_1()];
                                case 2:
                                    _a.sent();
                                    return [3 /*break*/, 1];
                                case 3:
                                    output = [];
                                    this.graph.getOutputIndices().forEach(function (outputIndex) {
                                        var thisValue = _this._values[outputIndex];
                                        if (thisValue === undefined) {
                                            throw new Error("required output [" + outputIndex + "] does not have value");
                                        }
                                        // eslint-disable-next-line no-unused-expressions
                                        thisValue.data;
                                        output.push(thisValue);
                                    });
                                    instrument_1.Logger.verbose('ExecPlan', 'disposing of inferenceHandler');
                                    inferenceHandler.dispose();
                                    return [2 /*return*/, output];
                            }
                        });
                    }); })];
            });
        });
    };
    return ExecutionPlan;
}());
exports.ExecutionPlan = ExecutionPlan;


/***/ }),

/***/ "./lib/onnxjs/graph.ts":
/*!*****************************!*\
  !*** ./lib/onnxjs/graph.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Graph = void 0;
var onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
var attribute_1 = __webpack_require__(/*! ./attribute */ "./lib/onnxjs/attribute.ts");
var ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
var tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
var util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-redeclare
exports.Graph = {
    /**
     * construct a graph from a graph protobuf type
     */
    from: function (graphProto, initializer) {
        return new GraphImpl(graphProto, initializer);
    },
};
var Value = /** @class */ (function () {
    function Value(valueInfo) {
        this._from = undefined;
        this._to = [];
        this.tensor = undefined;
        this.type = undefined;
        if (valueInfo) {
            this.type = util_1.ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType);
        }
    }
    Object.defineProperty(Value.prototype, "from", {
        get: function () {
            return this._from;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Value.prototype, "to", {
        get: function () {
            return this._to;
        },
        enumerable: false,
        configurable: true
    });
    return Value;
}());
var Node = /** @class */ (function () {
    function Node(_nodeProto, name) {
        if (_nodeProto instanceof onnx_proto_1.onnx.NodeProto) {
            this.name = _nodeProto.name;
            this.opType = _nodeProto.opType;
            this.attributes = new attribute_1.Attribute(_nodeProto.attribute);
        }
        else if (_nodeProto instanceof ortFbs.Node) {
            this.name = name !== null && name !== void 0 ? name : _nodeProto.name();
            this.opType = _nodeProto.opType();
            this.attributes = new attribute_1.Attribute(util_1.ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));
        }
        this.inputs = [];
        this.outputs = [];
        this.executeNode = true;
    }
    return Node;
}());
var GraphImpl = /** @class */ (function () {
    function GraphImpl(graph, graphInitializer) {
        if (!graph) {
            throw new TypeError('graph is empty');
        }
        // build the graph - will throw exceptions if something fatal is detected
        this.buildGraph(graph);
        // execute any transformation logic for the graph (if applicable)
        this.transformGraph(graphInitializer);
        // check for cycles and other inconsistencies - will throw exceptions if something fatal is detected
        this.checkIsAcyclic();
    }
    GraphImpl.prototype.getInputIndices = function () {
        return this._allInputIndices;
    };
    GraphImpl.prototype.getInputNames = function () {
        return this._allInputNames;
    };
    GraphImpl.prototype.getOutputIndices = function () {
        return this._allOutputIndices;
    };
    GraphImpl.prototype.getOutputNames = function () {
        return this._allOutputNames;
    };
    GraphImpl.prototype.getValues = function () {
        return this._allData;
    };
    GraphImpl.prototype.getNodes = function () {
        return this._nodes;
    };
    GraphImpl.prototype.buildGraph = function (graph) {
        // build the graph - will throw exceptions if something fatal is detected
        if (graph instanceof onnx_proto_1.onnx.GraphProto) {
            this.buildGraphFromOnnxFormat(graph);
        }
        else if (graph instanceof ortFbs.Graph) {
            this.buildGraphFromOrtFormat(graph);
        }
        else {
            throw new TypeError('Graph type is not supported.');
        }
    };
    GraphImpl.prototype.buildGraphFromOnnxFormat = function (graph) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f;
        var dataIndices = new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        var nodesIndices = new Map();
        // scan all inputs
        if (!graph.input) {
            throw new Error('missing information in graph: input');
        }
        var inputValueNames = [];
        try {
            for (var _g = __values(graph.input), _h = _g.next(); !_h.done; _h = _g.next()) {
                var i = _h.value;
                if (dataIndices.has(i.name)) {
                    throw new Error("duplicated input name: " + i.name);
                }
                var currentIndex = this._allData.push(new Value(i)) - 1;
                dataIndices.set(i.name, currentIndex);
                inputValueNames.push(i.name);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // scan all initializers
        if (!graph.initializer) {
            throw new Error('missing information in graph: initializer');
        }
        try {
            for (var _j = __values(graph.initializer), _k = _j.next(); !_k.done; _k = _j.next()) {
                var i = _k.value;
                var index = dataIndices.get(i.name);
                if (index === undefined) {
                    var value = new Value();
                    value.type = {
                        shape: { dims: util_1.ProtoUtil.tensorDimsFromProto(i.dims) },
                        tensorType: util_1.ProtoUtil.tensorDataTypeFromProto(i.dataType)
                    };
                    index = this._allData.push(value) - 1;
                    dataIndices.set(i.name, index);
                }
                this._allData[index]._from = -1;
                this._allData[index].tensor = tensor_1.Tensor.fromProto(i);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // filter out input indices
        for (var i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
                this._allInputIndices.push(i);
                this._allInputNames.push(inputValueNames[i]);
            }
        }
        // scan all outputs
        if (!graph.output) {
            throw new Error('missing information in graph: output');
        }
        try {
            for (var _l = __values(graph.output), _m = _l.next(); !_m.done; _m = _l.next()) {
                var i = _m.value;
                if (dataIndices.has(i.name)) {
                    throw new Error("duplicated output name: " + i.name);
                }
                var currentIndex = this._allData.push(new Value(i)) - 1;
                dataIndices.set(i.name, currentIndex);
                this._allOutputIndices.push(currentIndex);
                this._allOutputNames.push(i.name);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_c = _l.return)) _c.call(_l);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // scan all nodes
        if (!graph.node) {
            throw new Error('missing information in graph: node');
        }
        try {
            for (var _o = __values(graph.node), _p = _o.next(); !_p.done; _p = _o.next()) {
                var nodeProto = _p.value;
                if (!nodeProto.name) {
                    // assign a name to the node if it doesn't have one
                    for (var pick = 0;; pick++) {
                        var name_1 = "unnamed_" + nodeProto.opType + "_" + pick;
                        if (!nodesIndices.has(name_1)) {
                            nodeProto.name = name_1;
                            break;
                        }
                    }
                }
                if (nodesIndices.has(nodeProto.name)) {
                    throw new Error("duplicated node name: " + nodeProto.name);
                }
                var currentIndex = this._nodes.push(new Node(nodeProto)) - 1;
                nodesIndices.set(nodeProto.name, currentIndex);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_p && !_p.done && (_d = _o.return)) _d.call(_o);
            }
            finally { if (e_4) throw e_4.error; }
        }
        // scan node's outputs
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var nodeProto = graph.node[i];
            if (!nodeProto.output) {
                throw new Error("missing output for node: " + nodeProto.name);
            }
            try {
                for (var _q = (e_5 = void 0, __values(nodeProto.output)), _r = _q.next(); !_r.done; _r = _q.next()) {
                    var output = _r.value;
                    var dataIndex = dataIndices.get(output);
                    if (typeof dataIndex === 'undefined') {
                        dataIndex = this._allData.push(new Value()) - 1;
                        dataIndices.set(output, dataIndex);
                    }
                    node.outputs.push(dataIndex);
                    if (this._allData[dataIndex]._from !== undefined) {
                        throw new Error("multiple nodes output to one data value: " + dataIndex);
                    }
                    this._allData[dataIndex]._from = i;
                    // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the
                    // operator and ignore the node from the graph
                    if (nodeProto.opType === 'Constant') {
                        if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {
                            throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');
                        }
                        if (!nodeProto.output || nodeProto.output.length !== 1) {
                            throw new Error('missing output or incorrect number of outputs for this Constant operator');
                        }
                        node.outputs.pop();
                        node.executeNode = false;
                        this._allData[dataIndex]._from = -1;
                        this._allData[dataIndex].tensor = tensor_1.Tensor.fromProto(nodeProto.attribute[0].t);
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_r && !_r.done && (_e = _q.return)) _e.call(_q);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        // scan node's inputs
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var nodeProto = graph.node[i];
            if (!nodeProto.input) {
                throw new Error("missing input for node: " + nodeProto.name);
            }
            try {
                for (var _s = (e_6 = void 0, __values(nodeProto.input)), _t = _s.next(); !_t.done; _t = _s.next()) {
                    var input = _t.value;
                    var dataIndex = dataIndices.get(input);
                    if (typeof dataIndex === 'undefined') {
                        throw new Error("unrecognized input '" + input + "' for node: " + nodeProto.name);
                    }
                    node.inputs.push(dataIndex);
                    this._allData[dataIndex]._to.push(i);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_t && !_t.done && (_f = _s.return)) _f.call(_s);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        return true;
    };
    GraphImpl.prototype.buildGraphFromOrtFormat = function (graph) {
        var _a, _b, _c;
        var dataIndices = new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        var nodesIndices = new Map();
        // scan all inputs
        var inputValueNames = [];
        for (var i = 0; i < graph.inputsLength(); i++) {
            var inputName = graph.inputs(i);
            if (dataIndices.has(inputName)) {
                throw new Error("duplicated input name: " + inputName);
            }
            // Find the input typeInfo from nodeargs
            for (var j = 0; j < graph.nodeArgsLength(); j++) {
                if (((_a = graph.nodeArgs(j)) === null || _a === void 0 ? void 0 : _a.name()) === inputName) {
                    var value = new Value();
                    var valueType = (_c = (_b = graph.nodeArgs(j)) === null || _b === void 0 ? void 0 : _b.type()) === null || _c === void 0 ? void 0 : _c.valueType();
                    if (valueType !== ortFbs.TypeInfoValue.tensor_type) {
                        throw new Error('Unexpected value type for the nodeArg.');
                    }
                    var valueInfo = graph.nodeArgs(j).type().value(new ortFbs.TensorTypeAndShape());
                    var type = util_1.ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());
                    var shape = valueInfo.shape();
                    var dims = [];
                    for (var k = 0; k < shape.dimLength(); k++) {
                        dims.push(util_1.LongUtil.longToNumber(shape.dim(k).value().dimValue()));
                    }
                    value.type = { shape: { dims: dims }, tensorType: type };
                    var currentIndex = this._allData.push(value) - 1;
                    dataIndices.set(inputName, currentIndex);
                    inputValueNames.push(inputName);
                }
            }
        }
        // check initializers
        for (var i = 0; i < graph.initializersLength(); i++) {
            var initializer = graph.initializers(i);
            var index = dataIndices.get(initializer.name());
            if (index === undefined) {
                var value = new Value();
                var dims = util_1.ProtoUtil.tensorDimsFromORTFormat(initializer);
                var type = util_1.ProtoUtil.tensorDataTypeFromProto(initializer.dataType());
                value.type = { shape: { dims: dims }, tensorType: type };
                index = this._allData.push(value) - 1;
                dataIndices.set(initializer.name(), index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = tensor_1.Tensor.fromOrtTensor(initializer);
        }
        // filter out input indices
        for (var i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
                this._allInputIndices.push(i);
                this._allInputNames.push(inputValueNames[i]);
            }
        }
        // scan all outputs
        for (var i = 0; i < graph.outputsLength(); i++) {
            var outputName = graph.outputs(i);
            if (dataIndices.has(outputName)) {
                throw new Error("duplicated output name: " + outputName);
            }
            var currentIndex = this._allData.push(new Value()) - 1;
            dataIndices.set(outputName, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(outputName);
        }
        // scan all nodes
        if (!graph.nodes) {
            throw new Error('missing information in graph: node');
        }
        for (var i = 0; i < graph.nodesLength(); i++) {
            var nodeProto = graph.nodes(i);
            var name_2 = nodeProto.name();
            if (!name_2) {
                // assign a name to the node if it doesn't have one
                for (var pick = 0;; pick++) {
                    name_2 = "unnamed_" + nodeProto.opType() + "_" + pick;
                    if (!nodesIndices.has(name_2)) {
                        // an unique name is found. break.
                        break;
                    }
                }
            }
            if (nodesIndices.has(name_2)) {
                throw new Error("duplicated node name: " + name_2);
            }
            var currentIndex = this._nodes.push(new Node(nodeProto, name_2)) - 1;
            nodesIndices.set(name_2, currentIndex);
        }
        // scan node's outputs
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var nodeProto = graph.nodes(i);
            if (nodeProto == null) {
                throw new Error("No node exists at index " + i);
            }
            if ((nodeProto === null || nodeProto === void 0 ? void 0 : nodeProto.outputsLength()) === 0) {
                throw new Error("missing output for node: " + nodeProto.name);
            }
            for (var j = 0; j < (nodeProto === null || nodeProto === void 0 ? void 0 : nodeProto.outputsLength()); j++) {
                var output = nodeProto === null || nodeProto === void 0 ? void 0 : nodeProto.outputs(j);
                var dataIndex = dataIndices.get(output);
                if (typeof dataIndex === 'undefined') {
                    dataIndex = this._allData.push(new Value()) - 1;
                    dataIndices.set(output, dataIndex);
                }
                node.outputs.push(dataIndex);
                if (this._allData[dataIndex]._from !== undefined) {
                    throw new Error("multiple nodes output to one data value: " + dataIndex);
                }
                this._allData[dataIndex]._from = i;
                // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the
                // operator and ignore the node from the graph
                if (nodeProto.opType() === 'Constant') {
                    if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0).t()) {
                        throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');
                    }
                    if (nodeProto.outputsLength() !== 1) {
                        throw new Error('missing output or incorrect number of outputs for this Constant operator');
                    }
                    node.outputs.pop();
                    node.executeNode = false;
                    this._allData[dataIndex]._from = -1;
                    this._allData[dataIndex].tensor = tensor_1.Tensor.fromOrtTensor(nodeProto.attributes(0).t());
                }
            }
        }
        // scan node's inputs
        for (var i = 0; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            var nodeProto = graph.nodes(i);
            if (nodeProto.inputsLength() === 0) {
                throw new Error("missing input for node: " + nodeProto.name);
            }
            for (var j = 0; j < nodeProto.inputsLength(); j++) {
                var input = nodeProto.inputs(j);
                var dataIndex = dataIndices.get(input);
                if (typeof dataIndex === 'undefined') {
                    throw new Error("unrecognized input '" + input + "' for node: " + nodeProto.name());
                }
                node.inputs.push(dataIndex);
                this._allData[dataIndex]._to.push(i);
            }
        }
    };
    GraphImpl.prototype.checkIsAcyclic = function () {
        var _this = this;
        // go through the graph and check for cycles or other fatal inconsistencies
        var starters = new Set();
        this._allInputIndices.forEach(function (i) {
            var data = _this._allData[i];
            data._to.forEach(function (j) {
                starters.add(j);
            });
        });
        // Iterative DFS to check for cycles
        var nodesStack = Array.from(starters);
        var nodesState = new Array(this._nodes.length).fill('white');
        var _loop_1 = function () {
            var nodeIndex = nodesStack.pop();
            // this node has now been processed completely. Mark this node 'black' to denote this.
            if (nodesState[nodeIndex] === 'gray') {
                nodesState[nodeIndex] = 'black';
            }
            else {
                // this node is under processing stage. mark this node 'gray' to denote this.
                nodesStack.push(nodeIndex);
                nodesState[nodeIndex] = 'gray';
                this_1._nodes[nodeIndex].outputs.forEach(function (outgoingEdgeIndex) {
                    var data = _this._allData[outgoingEdgeIndex];
                    if (typeof data.tensor !== 'undefined') {
                        throw new Error('node outputs should not be initialized');
                    }
                    if (data._from !== nodeIndex) {
                        throw new Error('from property of the Value object doesn\'t match index of Node being processed');
                    }
                    data._to.forEach(function (downstreamNodeIndex) {
                        // back edge found - cyclic
                        if (nodesState[downstreamNodeIndex] === 'gray') {
                            throw new Error('model graph is cyclic');
                        }
                        // tree edge found - continue processing by adding it to stack
                        else if (nodesState[downstreamNodeIndex] === 'white') {
                            nodesStack.push(downstreamNodeIndex);
                        }
                    });
                });
            }
        };
        var this_1 = this;
        while (nodesStack.length > 0) {
            _loop_1();
        }
    };
    GraphImpl.prototype.transformGraph = function (graphInitializer) {
        // apply common transform
        this.removeAllIdentityNodes();
        this.removeAllDropoutNodes();
        // apply initializer specific transform
        if (graphInitializer) {
            graphInitializer.transformGraph(this);
        }
        // finalize graph
        this.finalizeGraph();
    };
    /**
     * finalize the graph.
     *
     * this function should be called after all the transformation completed.
     * this function removes all unnecessary nodes and values from the graph
     */
    GraphImpl.prototype.finalizeGraph = function () {
        var _this = this;
        var offset = 0;
        var _loop_2 = function (i) {
            if (!this_2._nodes[i].executeNode) {
                // delete this node and shift all subsequent nodes up
                offset++;
                // delete all output values
                this_2._nodes[i].outputs.forEach(function (ind) {
                    _this._allData[ind]._from = -2;
                });
                this_2._nodes.splice(i, 1);
                i--;
                return out_i_1 = i, "continue";
            }
            if (offset > 0) {
                // update the value table
                this_2._nodes[i].inputs.forEach(function (value) {
                    var ind = _this._allData[value]._to.indexOf(i + offset);
                    if (ind !== -1) {
                        _this._allData[value]._to[ind] = i;
                    }
                });
                this_2._nodes[i].outputs.forEach(function (value) {
                    if (_this._allData[value]._from && _this._allData[value]._from === i + offset) {
                        _this._allData[value]._from = i;
                    }
                });
            }
            out_i_1 = i;
        };
        var this_2 = this, out_i_1;
        // delete all nodes that are not being executed
        for (var i = 0; i < this._nodes.length; i++) {
            _loop_2(i);
            i = out_i_1;
        }
        offset = 0;
        var _loop_3 = function (i) {
            // if current value is neither linked to next node, nor an output value, remove it.
            if (this_3._allData[i].from === -2 && this_3._allOutputIndices.indexOf(i + offset) === -1) {
                offset++;
                this_3._allData.splice(i, 1);
                i--;
                return out_i_2 = i, "continue";
            }
            if (offset > 0) {
                var ind_1 = -1;
                // if current value is neither an input value nor an initializer, find the node it's
                // coming from and update the corresponding node output
                if (this_3._allData[i].from !== undefined && this_3._allData[i].from !== -1) {
                    ind_1 = this_3._nodes[this_3._allData[i].from].outputs.indexOf(i + offset);
                    if (ind_1 !== -1) {
                        this_3._nodes[this_3._allData[i].from].outputs[ind_1] = i;
                    }
                }
                else {
                    // if current value is an input value, update its reference in inputIndices
                    ind_1 = this_3._allInputIndices.indexOf(i + offset);
                    if (ind_1 !== -1) {
                        this_3._allInputIndices[ind_1] = i;
                    }
                }
                // find the node that the current value is linking to and update its input reference
                this_3._allData[i].to.forEach(function (node) {
                    ind_1 = _this._nodes[node].inputs.indexOf(i + offset);
                    if (ind_1 !== -1) {
                        _this._nodes[node].inputs[ind_1] = i;
                    }
                });
                if (this_3._allData[i].to.length === 0) {
                    // if current value is a graph output, update its reference in outputIndices
                    ind_1 = this_3._allOutputIndices.indexOf(i + offset);
                    if (ind_1 !== -1) {
                        this_3._allOutputIndices[ind_1] = i;
                    }
                }
            }
            out_i_2 = i;
        };
        var this_3 = this, out_i_2;
        // delete all values that are not being referenced
        for (var i = 0; i < this._allData.length; i++) {
            _loop_3(i);
            i = out_i_2;
        }
    };
    /**
     * Delete the specifed node. Assume the node has only one input and the first output connected to other nodes
     * @param nodeIndex The index of node to be deleted
     */
    GraphImpl.prototype.deleteNode = function (nodeIndex) {
        var e_7, _a;
        var node = this._nodes[nodeIndex];
        if (node.inputs.length > 1) {
            throw new Error('Node deletion with multiple inputs is not supported. ');
        }
        if (node.outputs.length > 1) {
            for (var i = 1; i < node.outputs.length; i++) {
                if (this._allData[node.outputs[i]].to.length > 0) {
                    throw new Error('Node deletion with more than one output connected to other nodes is not supported. ');
                }
            }
        }
        // this node wil not be executed
        node.executeNode = false;
        var inputValueIndex = node.inputs[0];
        var outputValueIndex = node.outputs[0];
        var nodesConsumingOutput = this._allData[outputValueIndex].to;
        // remove this node from the to property of the input Value
        var delIndex = this._allData[inputValueIndex].to.indexOf(nodeIndex);
        // should not happen
        if (delIndex === -1) {
            throw new Error('The Value object doesn\'t have the current Node in it\'s \'to\' property ');
        }
        this._allData[inputValueIndex].to.splice(delIndex, 1);
        // clear node indices consuming this output Value
        this._allData[outputValueIndex]._to = [];
        // if the output of this node is a graph output, adjust the index appropriately
        var index = this._allOutputIndices.indexOf(outputValueIndex);
        if (index !== -1) {
            this._allOutputIndices[index] = inputValueIndex;
        }
        // override the inputs for nodes consuming this node's output with the input to this node
        if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {
            try {
                for (var nodesConsumingOutput_1 = __values(nodesConsumingOutput), nodesConsumingOutput_1_1 = nodesConsumingOutput_1.next(); !nodesConsumingOutput_1_1.done; nodesConsumingOutput_1_1 = nodesConsumingOutput_1.next()) {
                    var nodeIndex_1 = nodesConsumingOutput_1_1.value;
                    var replaceIndex = this._nodes[nodeIndex_1].inputs.indexOf(outputValueIndex);
                    // should not happen
                    if (replaceIndex === -1) {
                        throw new Error('The Node object doesn\'t have the output Value in it\'s \'inputs\' property ');
                    }
                    this._nodes[nodeIndex_1].inputs[replaceIndex] = inputValueIndex;
                    this._allData[inputValueIndex].to.push(nodeIndex_1);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (nodesConsumingOutput_1_1 && !nodesConsumingOutput_1_1.done && (_a = nodesConsumingOutput_1.return)) _a.call(nodesConsumingOutput_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
    };
    GraphImpl.prototype.removeAllDropoutNodes = function () {
        var e_8, _a;
        var nodeIndex = 0;
        try {
            for (var _b = __values(this._nodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                // weed out 'Dropout' nodes so that no time is wasted in execution
                if (node.opType === 'Dropout') {
                    // the node should have exactly 1 input and 1 or 2 outputs
                    if (node.inputs.length !== 1) {
                        throw new Error('Dropout nodes should only contain one input. ');
                    }
                    if (node.outputs.length !== 1 && node.outputs.length !== 2) {
                        throw new Error('Dropout nodes should contain either 1 or 2 output(s)');
                    }
                    // the second output should not be referenced by any other node
                    if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {
                        throw new Error('Dropout nodes\'s second output should not be referenced by other nodes');
                    }
                    this.deleteNode(nodeIndex);
                }
                nodeIndex++;
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
    };
    GraphImpl.prototype.removeAllIdentityNodes = function () {
        var e_9, _a;
        var nodeIndex = 0;
        try {
            for (var _b = __values(this._nodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                // weed out 'Identity' nodes so that no time is wasted in execution
                if (node.opType === 'Identity') {
                    this.deleteNode(nodeIndex);
                }
                nodeIndex++;
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
    };
    GraphImpl.prototype.isActivation = function (n) {
        switch (n.opType) {
            // TODO: add other activation methods
            case 'Relu':
            case 'Sigmoid':
                return true;
            default:
                return false;
        }
    };
    GraphImpl.prototype.fuseConvActivationNodes = function () {
        var e_10, _a;
        try {
            for (var _b = __values(this._nodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (node.opType === 'Conv') {
                    var next = this._allData[node.outputs[0]]._to;
                    if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {
                        node.attributes.set('__internal_activation', 'string', (this._nodes[next[0]].opType));
                        this.deleteNode(next[0]);
                    }
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
    };
    return GraphImpl;
}());


/***/ }),

/***/ "./lib/onnxjs/instrument.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/instrument.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.now = exports.Profiler = exports.Logger = void 0;
var NoOpLoggerProvider = /** @class */ (function () {
    function NoOpLoggerProvider() {
    }
    NoOpLoggerProvider.prototype.log = function (_severity, _content, _category) {
        // do nothing
    };
    return NoOpLoggerProvider;
}());
var ConsoleLoggerProvider = /** @class */ (function () {
    function ConsoleLoggerProvider() {
    }
    ConsoleLoggerProvider.prototype.log = function (severity, content, category) {
        // eslint-disable-next-line no-console
        console.log(this.color(severity) + " " + (category ? '\x1b[35m' + category + '\x1b[0m ' : '') + content);
    };
    ConsoleLoggerProvider.prototype.color = function (severity) {
        switch (severity) {
            case 'verbose':
                return '\x1b[34;40mv\x1b[0m';
            case 'info':
                return '\x1b[32mi\x1b[0m';
            case 'warning':
                return '\x1b[30;43mw\x1b[0m';
            case 'error':
                return '\x1b[31;40me\x1b[0m';
            case 'fatal':
                return '\x1b[101mf\x1b[0m';
            default:
                throw new Error("unsupported severity: " + severity);
        }
    };
    return ConsoleLoggerProvider;
}());
var SEVERITY_VALUE = {
    verbose: 1000,
    info: 2000,
    warning: 4000,
    error: 5000,
    fatal: 6000
};
var LOGGER_PROVIDER_MAP = (_a = {},
    _a['none'] = new NoOpLoggerProvider(),
    _a['console'] = new ConsoleLoggerProvider(),
    _a);
var LOGGER_DEFAULT_CONFIG = {
    provider: 'console',
    minimalSeverity: 'warning',
    logDateTime: true,
    logSourceLocation: false
};
var LOGGER_CONFIG_MAP = (_b = {}, _b[''] = LOGGER_DEFAULT_CONFIG, _b);
function log(arg0, arg1, arg2, arg3) {
    if (arg1 === undefined) {
        // log(category: string): Logger.CategorizedLogger;
        return createCategorizedLogger(arg0);
    }
    else if (arg2 === undefined) {
        // log(severity, content);
        logInternal(arg0, arg1, 1);
    }
    else if (typeof arg2 === 'number' && arg3 === undefined) {
        // log(severity, content, stack)
        logInternal(arg0, arg1, arg2);
    }
    else if (typeof arg2 === 'string' && arg3 === undefined) {
        // log(severity, category, content)
        logInternal(arg0, arg2, 1, arg1);
    }
    else if (typeof arg2 === 'string' && typeof arg3 === 'number') {
        // log(severity, category, content, stack)
        logInternal(arg0, arg2, arg3, arg1);
    }
    else {
        throw new TypeError('input is valid');
    }
}
function createCategorizedLogger(category) {
    return {
        verbose: log.verbose.bind(null, category),
        info: log.info.bind(null, category),
        warning: log.warning.bind(null, category),
        error: log.error.bind(null, category),
        fatal: log.fatal.bind(null, category)
    };
}
// NOTE: argument 'category' is put the last parameter beacause typescript
// doesn't allow optional argument put in front of required argument. This
// order is different from a usual logging API.
function logInternal(severity, content, stack, category) {
    var config = LOGGER_CONFIG_MAP[category || ''] || LOGGER_CONFIG_MAP[''];
    if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {
        return;
    }
    if (config.logDateTime) {
        content = new Date().toISOString() + "|" + content;
    }
    if (config.logSourceLocation) {
        // TODO: calculate source location from 'stack'
    }
    LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);
}
// eslint-disable-next-line @typescript-eslint/no-namespace
(function (log) {
    function verbose(arg0, arg1) {
        log('verbose', arg0, arg1);
    }
    log.verbose = verbose;
    function info(arg0, arg1) {
        log('info', arg0, arg1);
    }
    log.info = info;
    function warning(arg0, arg1) {
        log('warning', arg0, arg1);
    }
    log.warning = warning;
    function error(arg0, arg1) {
        log('error', arg0, arg1);
    }
    log.error = error;
    function fatal(arg0, arg1) {
        log('fatal', arg0, arg1);
    }
    log.fatal = fatal;
    function reset(config) {
        LOGGER_CONFIG_MAP = {};
        set('', config || {});
    }
    log.reset = reset;
    function set(category, config) {
        if (category === '*') {
            reset(config);
        }
        else {
            var previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;
            LOGGER_CONFIG_MAP[category] = {
                provider: config.provider || previousConfig.provider,
                minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,
                logDateTime: (config.logDateTime === undefined) ? previousConfig.logDateTime : config.logDateTime,
                logSourceLocation: (config.logSourceLocation === undefined) ? previousConfig.logSourceLocation :
                    config.logSourceLocation
            };
        }
        // TODO: we want to support wildcard or regex?
    }
    log.set = set;
    function setWithEnv(env) {
        var config = {};
        if (env.logLevel) {
            config.minimalSeverity = env.logLevel;
        }
        set('', config);
    }
    log.setWithEnv = setWithEnv;
})(log || (log = {}));
// eslint-disable-next-line @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention
exports.Logger = log;
// TODO
// class WebGLEvent implements Profiler.Event {}
var Event = /** @class */ (function () {
    function Event(category, name, startTime, endCallback, timer, ctx) {
        this.category = category;
        this.name = name;
        this.startTime = startTime;
        this.endCallback = endCallback;
        this.timer = timer;
        this.ctx = ctx;
    }
    Event.prototype.end = function () {
        return this.endCallback(this);
    };
    Event.prototype.checkTimer = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.ctx === undefined || this.timer === undefined) {
                    throw new Error('No webgl timer found');
                }
                else {
                    this.ctx.endTimer();
                    return [2 /*return*/, this.ctx.waitForQueryAndGetTime(this.timer)];
                }
                return [2 /*return*/];
            });
        });
    };
    return Event;
}());
var EventRecord = /** @class */ (function () {
    function EventRecord(category, name, startTime, endTime) {
        this.category = category;
        this.name = name;
        this.startTime = startTime;
        this.endTime = endTime;
    }
    return EventRecord;
}());
var Profiler = /** @class */ (function () {
    function Profiler(maxNumberEvents, flushBatchSize, flushIntervalInMilliseconds) {
        this._started = false;
        this._flushPointer = 0;
        this._started = false;
        this._maxNumberEvents = maxNumberEvents === undefined ? 10000 : maxNumberEvents;
        this._flushBatchSize = flushBatchSize === undefined ? 10 : flushBatchSize;
        this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === undefined ? 5000 : flushIntervalInMilliseconds;
    }
    Profiler.create = function (config) {
        if (config === undefined) {
            return new this();
        }
        return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);
    };
    // start profiling
    Profiler.prototype.start = function () {
        this._started = true;
        this._timingEvents = [];
        this._flushTime = exports.now();
        this._flushPointer = 0;
    };
    // stop profiling
    Profiler.prototype.stop = function () {
        this._started = false;
        for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {
            this.logOneEvent(this._timingEvents[this._flushPointer]);
        }
    };
    Profiler.prototype.event = function (category, name, func, ctx) {
        var _this = this;
        var event = this._started ? this.begin(category, name, ctx) : undefined;
        var isPromise = false;
        var res = func();
        // we consider a then-able object is a promise
        if (res && typeof res.then === 'function') {
            isPromise = true;
            return new Promise(function (resolve, reject) {
                res
                    .then(function (value) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!event) return [3 /*break*/, 2];
                                return [4 /*yield*/, event.end()];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2:
                                resolve(value);
                                return [2 /*return*/];
                        }
                    });
                }); }, function (reason) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!event) return [3 /*break*/, 2];
                                return [4 /*yield*/, event.end()];
                            case 1:
                                _a.sent();
                                _a.label = 2;
                            case 2:
                                reject(reason);
                                return [2 /*return*/];
                        }
                    });
                }); });
            });
        }
        if (!isPromise && event) {
            var eventRes_1 = event.end();
            if (eventRes_1 && typeof eventRes_1.then === 'function') {
                return new Promise(function (resolve, reject) {
                    (eventRes_1).then(function () {
                        resolve(res);
                    }, function (reason) {
                        reject(reason);
                    });
                });
            }
        }
        return res;
    };
    // begin an event
    Profiler.prototype.begin = function (category, name, ctx) {
        var _this = this;
        if (!this._started) {
            throw new Error('profiler is not started yet');
        }
        if (ctx === undefined) {
            var startTime = exports.now();
            this.flush(startTime);
            return new Event(category, name, startTime, function (e) { return _this.endSync(e); });
        }
        else {
            var timer = ctx.beginTimer();
            return new Event(category, name, 0, function (e) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, this.end(e)];
            }); }); }, timer, ctx);
        }
    };
    // end the specific event
    Profiler.prototype.end = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var endTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, event.checkTimer()];
                    case 1:
                        endTime = _a.sent();
                        if (this._timingEvents.length < this._maxNumberEvents) {
                            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
                            this.flush(endTime);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Profiler.prototype.endSync = function (event) {
        var endTime = exports.now();
        if (this._timingEvents.length < this._maxNumberEvents) {
            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
            this.flush(endTime);
        }
    };
    Profiler.prototype.logOneEvent = function (event) {
        exports.Logger.verbose("Profiler." + event.category, (event.endTime - event.startTime).toFixed(2) + "ms on event '" + event.name + "' at " + event.endTime.toFixed(2));
    };
    Profiler.prototype.flush = function (currentTime) {
        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize ||
            currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {
            // should flush when either batch size accumlated or interval elepsed
            for (var previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize &&
                this._flushPointer < this._timingEvents.length; this._flushPointer++) {
                this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            this._flushTime = exports.now();
        }
    };
    Object.defineProperty(Profiler.prototype, "started", {
        get: function () {
            return this._started;
        },
        enumerable: false,
        configurable: true
    });
    return Profiler;
}());
exports.Profiler = Profiler;
/**
 * returns a number to represent the current timestamp in a resolution as high as possible.
 */
exports.now = (typeof performance !== 'undefined' && performance.now) ? function () { return performance.now(); } : Date.now;


/***/ }),

/***/ "./lib/onnxjs/model.ts":
/*!*****************************!*\
  !*** ./lib/onnxjs/model.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Model = void 0;
var flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/js/flatbuffers.mjs");
var onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
var graph_1 = __webpack_require__(/*! ./graph */ "./lib/onnxjs/graph.ts");
var ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
var util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
var Model = /** @class */ (function () {
    // empty model
    function Model() {
    }
    Model.prototype.load = function (buf, graphInitializer, isOrtFormat) {
        if (!isOrtFormat) {
            // isOrtFormat === false || isOrtFormat === undefined
            try {
                this.loadFromOnnxFormat(buf, graphInitializer);
                return;
            }
            catch (e) {
                if (isOrtFormat !== undefined) {
                    throw e;
                }
            }
        }
        this.loadFromOrtFormat(buf, graphInitializer);
    };
    Model.prototype.loadFromOnnxFormat = function (buf, graphInitializer) {
        var modelProto = onnx_proto_1.onnx.ModelProto.decode(buf);
        var irVersion = util_1.LongUtil.longToNumber(modelProto.irVersion);
        if (irVersion < 3) {
            throw new Error('only support ONNX model with IR_VERSION>=3');
        }
        this._opsets =
            modelProto.opsetImport.map(function (i) { return ({ domain: i.domain, version: util_1.LongUtil.longToNumber(i.version) }); });
        this._graph = graph_1.Graph.from(modelProto.graph, graphInitializer);
    };
    Model.prototype.loadFromOrtFormat = function (buf, graphInitializer) {
        var fb = new flatbuffers_1.flatbuffers.ByteBuffer(buf);
        var ortModel = ortFbs.InferenceSession.getRootAsInferenceSession(fb).model();
        var irVersion = util_1.LongUtil.longToNumber(ortModel.irVersion());
        if (irVersion < 3) {
            throw new Error('only support ONNX model with IR_VERSION>=3');
        }
        this._opsets = [];
        for (var i = 0; i < ortModel.opsetImportLength(); i++) {
            var opsetId = ortModel.opsetImport(i);
            this._opsets.push({ domain: opsetId === null || opsetId === void 0 ? void 0 : opsetId.domain(), version: util_1.LongUtil.longToNumber(opsetId.version()) });
        }
        this._graph = graph_1.Graph.from(ortModel.graph(), graphInitializer);
    };
    Object.defineProperty(Model.prototype, "graph", {
        get: function () {
            return this._graph;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Model.prototype, "opsets", {
        get: function () {
            return this._opsets;
        },
        enumerable: false,
        configurable: true
    });
    return Model;
}());
exports.Model = Model;


/***/ }),

/***/ "./lib/onnxjs/operators.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/operators.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FLOAT_TYPES = exports.INT_TYPES = exports.NUMBER_TYPES = void 0;
exports.NUMBER_TYPES = ['float32', 'float64', 'int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];
exports.INT_TYPES = ['int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];
exports.FLOAT_TYPES = ['float32', 'float64'];


/***/ }),

/***/ "./lib/onnxjs/ops/batch-normalization.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/ops/batch-normalization.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchNormalization = void 0;
// currently this operator supports ONLY 'test' mode
// inputs/outputs and parameters will reflect that
// the operator implementation only supports test mode
var BatchNormalization = /** @class */ (function () {
    function BatchNormalization() {
    }
    BatchNormalization.prototype.initialize = function (attributes) {
        this.epsilon = attributes.getFloat('epsilon', 1e-5);
        this.momentum = attributes.getFloat('momentum', 0.9);
        this.spatial = attributes.getInt('spatial', 1);
    };
    BatchNormalization.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 5) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    BatchNormalization.prototype.checkInputTypes = function (inputs) {
        var X = inputs[0];
        var scale = inputs[1];
        var B = inputs[2];
        var mean = inputs[3];
        var var_ = inputs[4];
        // input should atleast have three dimensions - N,C,dim1,...,dimn
        // other inputs can have only one dimensions
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 ||
            var_.dims.length !== 1) {
            return false;
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] ||
            var_.dims[0] !== X.dims[1]) {
            return false;
        }
        if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||
            (B.type !== 'float32' && B.type !== 'float64') || (mean.type !== 'float32' && mean.type !== 'float64') ||
            (var_.type !== 'float32' && var_.type !== 'float64')) {
            return false;
        }
        return true;
    };
    return BatchNormalization;
}());
exports.BatchNormalization = BatchNormalization;


/***/ }),

/***/ "./lib/onnxjs/ops/binary-op.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/binary-op.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinaryOp = void 0;
var BinaryOp = /** @class */ (function () {
    function BinaryOp(typeConstraint, opType, resultType) {
        this.typeConstraint = typeConstraint;
        this.opType = opType;
        this.resultType = resultType;
    }
    BinaryOp.prototype.initialize = function (_attributes) { };
    BinaryOp.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    BinaryOp.prototype.checkInputTypes = function (inputs) {
        if (this.typeConstraint.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[0].type !== inputs[1].type) {
            return false;
        }
        return true;
    };
    return BinaryOp;
}());
exports.BinaryOp = BinaryOp;


/***/ }),

/***/ "./lib/onnxjs/ops/clip.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/clip.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Clip = void 0;
var Clip = /** @class */ (function () {
    function Clip() {
    }
    Clip.prototype.initialize = function (attributes) {
        this.min = attributes.getFloat('min', -3.4028234663852886e+38);
        this.max = attributes.getFloat('max', 3.4028234663852886e+38);
    };
    Clip.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Clip.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return Clip;
}());
exports.Clip = Clip;


/***/ }),

/***/ "./lib/onnxjs/ops/concat.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/ops/concat.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Concat = void 0;
var Concat = /** @class */ (function () {
    function Concat() {
    }
    Concat.prototype.initialize = function (attributes) {
        this.axis = attributes.getInt('axis');
    };
    Concat.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length < 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Concat.prototype.checkInputTypes = function (inputs) {
        var e_1, _a;
        var inputType = inputs[0].type;
        var inputDimensionality = inputs[0].dims.length;
        // TODO: Support string concat
        if (inputType === 'string') {
            return false;
        }
        try {
            for (var inputs_1 = __values(inputs), inputs_1_1 = inputs_1.next(); !inputs_1_1.done; inputs_1_1 = inputs_1.next()) {
                var input = inputs_1_1.value;
                // make sure types of all inputs match
                if (input.type !== inputType) {
                    return false;
                }
                // make sure the dimensionality of all inputs are the same
                if (input.dims.length !== inputDimensionality) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (inputs_1_1 && !inputs_1_1.done && (_a = inputs_1.return)) _a.call(inputs_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    return Concat;
}());
exports.Concat = Concat;


/***/ }),

/***/ "./lib/onnxjs/ops/conv.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/conv.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Conv = void 0;
var Conv = /** @class */ (function () {
    function Conv() {
    }
    Conv.prototype.initialize = function (attributes) {
        // TODO : Make this generic enough to compute default attributes for multi-dimensional conv
        this.autoPad = attributes.getString('auto_pad', 'NOTSET');
        this.dilations = attributes.getInts('dilations', [1, 1]);
        this.group = attributes.getInt('group', 1);
        this.kernelShape = attributes.getInts('kernel_shape', []);
        this.pads = attributes.getInts('pads', [0, 0, 0, 0]);
        this.strides = attributes.getInts('strides', [1, 1]);
        this.activation = attributes.getString('__internal_activation', '');
    };
    Conv.prototype.checkInputs = function (inputs) {
        // Refer to the below link for all input checks
        // https://github.com/onnx/onnx/blob/master/docs/Operators.md#Conv
        if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {
            return false;
        }
        // TODO : Need to add support for multi-dimensional conv
        // currently only support 2-dimensional conv
        if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
            return false;
        }
        // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL
        var dataChannel = inputs[0].dims[1];
        var filterInChannel = inputs[1].dims[1] * this.group;
        if (dataChannel !== filterInChannel) {
            return false;
        }
        // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
            return false;
        }
        var spatialRank = inputs[0].dims.length - 2;
        // wrong dilations dimension
        if (this.dilations.length !== spatialRank) {
            return false;
        }
        // Wrong strides dimension
        if (this.strides.length !== spatialRank) {
            return false;
        }
        // Wrong pads dimension
        if (this.pads.length !== spatialRank * 2) {
            return false;
        }
        // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor
        // (the first 2 dims are batch_size and channels)
        if (this.kernelShape.length !== 0 && this.kernelShape.length !== inputs[1].dims.length - 2) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Conv.prototype.checkInputTypes = function (inputs) {
        // TODO : Need to add support for float64
        if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {
            return false;
        }
        if (inputs.length === 3 && inputs[2].type !== 'float32') {
            return false;
        }
        return true;
    };
    return Conv;
}());
exports.Conv = Conv;


/***/ }),

/***/ "./lib/onnxjs/ops/depth-to-space.ts":
/*!******************************************!*\
  !*** ./lib/onnxjs/ops/depth-to-space.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepthToSpace = void 0;
var DepthToSpace = /** @class */ (function () {
    function DepthToSpace() {
    }
    DepthToSpace.prototype.initialize = function (attributes) {
        // processing node attributes
        this.blocksize = attributes.getInt('blocksize');
        if (this.blocksize < 1) {
            throw new Error("blocksize must be >= 1, but got : " + this.blocksize + " for DepthToSpace");
        }
        this.blocksizeSqr = this.blocksize * this.blocksize;
        this.mode = attributes.getString('mode', 'DCR');
        if (DepthToSpace.supportedModes.indexOf(this.mode) < 0) {
            throw new Error("unrecognized mode: " + this.mode + " for DepthToSpace");
        }
    };
    DepthToSpace.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    DepthToSpace.prototype.checkInputTypes = function (inputs) {
        var inputType = inputs[0].type;
        var inputDimensionality = inputs[0].dims.length;
        // Input has to be a 4-D tensor
        // TODO: Support string depth-to-space.
        if (inputType === 'string' || inputDimensionality !== 4) {
            return false;
        }
        return true;
    };
    DepthToSpace.supportedModes = ['DCR', 'CRD'];
    return DepthToSpace;
}());
exports.DepthToSpace = DepthToSpace;


/***/ }),

/***/ "./lib/onnxjs/ops/dropout.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/dropout.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dropout = void 0;
var Dropout = /** @class */ (function () {
    function Dropout() {
    }
    Dropout.prototype.initialize = function (attributes) {
        this.ratio = attributes.getFloat('ratio', 0.5);
        this.testMode = true; // this is a hack to reflect that test mode is hardcoded
    };
    Dropout.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Dropout.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return Dropout;
}());
exports.Dropout = Dropout;


/***/ }),

/***/ "./lib/onnxjs/ops/elu.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/ops/elu.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Elu = void 0;
var Elu = /** @class */ (function () {
    function Elu() {
    }
    Elu.prototype.initialize = function (attributes) {
        this.alpha = attributes.getFloat('alpha', 1.0);
    };
    Elu.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Elu.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return Elu;
}());
exports.Elu = Elu;


/***/ }),

/***/ "./lib/onnxjs/ops/flatten.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/flatten.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Flatten = void 0;
var Flatten = /** @class */ (function () {
    function Flatten() {
    }
    Flatten.prototype.initialize = function (attributes) {
        this.axis = attributes.getInt('axis', 1); // default axis is 1
    };
    Flatten.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        var r = inputs[0].dims.length;
        if (r === 0) {
            return false; // scalar tensor is not supported
        }
        if (this.axis < -r || this.axis > r) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Flatten.prototype.checkInputTypes = function (inputs) {
        // TODO: Support string type
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    };
    return Flatten;
}());
exports.Flatten = Flatten;


/***/ }),

/***/ "./lib/onnxjs/ops/gather.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/ops/gather.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gather = void 0;
var operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
var Gather = /** @class */ (function () {
    function Gather() {
    }
    Gather.prototype.initialize = function (attributes) {
        this.axis = attributes.getInt('axis', 0);
    };
    Gather.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        var tensorRank = inputs[0].dims.length;
        if (tensorRank < 1) {
            return false;
        }
        if (this.axis < -tensorRank || this.axis > tensorRank - 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Gather.prototype.checkInputTypes = function (inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {
            return false;
        }
        return true;
    };
    return Gather;
}());
exports.Gather = Gather;


/***/ }),

/***/ "./lib/onnxjs/ops/gemm.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/gemm.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gemm = void 0;
var Gemm = /** @class */ (function () {
    function Gemm(isOptionalC) {
        this.isOptionalC = isOptionalC;
    }
    Gemm.prototype.initialize = function (attributes) {
        this.transA = attributes.getInt('transA', 0) !== 0;
        this.transB = attributes.getInt('transB', 0) !== 0;
        this.alpha = attributes.getFloat('alpha', 1);
        this.beta = attributes.getFloat('beta', 1);
    };
    Gemm.prototype.checkInputs = function (inputs) {
        if (!inputs) {
            return false;
        }
        if (this.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {
            return false;
        }
        if (!this.isOptionalC && inputs.length !== 3) {
            return false;
        }
        // 'C' can be of dimensionality 1 or 2 only
        if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Gemm.prototype.checkInputTypes = function (inputs) {
        if ((inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||
            (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') ||
            (inputs.length === 3 && inputs[2].type !== 'float32' && inputs[2].type !== 'float64')) {
            return false;
        }
        if ((inputs[0].type !== inputs[1].type) || (inputs.length === 3 && inputs[0].type !== inputs[2].type)) {
            return false;
        }
        return true;
    };
    return Gemm;
}());
exports.Gemm = Gemm;


/***/ }),

/***/ "./lib/onnxjs/ops/image-scaler.ts":
/*!****************************************!*\
  !*** ./lib/onnxjs/ops/image-scaler.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageScaler = void 0;
var ImageScaler = /** @class */ (function () {
    function ImageScaler() {
    }
    ImageScaler.prototype.initialize = function (attributes) {
        this.scale = attributes.getFloat('scale');
        this.bias = attributes.getFloats('bias');
    };
    ImageScaler.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        if (inputs[0].dims.length !== 4) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    ImageScaler.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return ImageScaler;
}());
exports.ImageScaler = ImageScaler;


/***/ }),

/***/ "./lib/onnxjs/ops/instance-normalization.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/ops/instance-normalization.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstanceNormalization = void 0;
var InstanceNormalization = /** @class */ (function () {
    function InstanceNormalization() {
    }
    InstanceNormalization.prototype.initialize = function (attributes) {
        this.epsilon = attributes.getFloat('epsilon', 1e-5);
    };
    InstanceNormalization.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 3) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    InstanceNormalization.prototype.checkInputTypes = function (inputs) {
        var X = inputs[0];
        var scale = inputs[1];
        var B = inputs[2];
        // input should atleast have three dimensions - N,C,dim1,...,dimn
        // other inputs can have only one dimensions
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {
            return false;
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {
            return false;
        }
        if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||
            (B.type !== 'float32' && B.type !== 'float64')) {
            return false;
        }
        return true;
    };
    return InstanceNormalization;
}());
exports.InstanceNormalization = InstanceNormalization;


/***/ }),

/***/ "./lib/onnxjs/ops/leaky-relu.ts":
/*!**************************************!*\
  !*** ./lib/onnxjs/ops/leaky-relu.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LeakyRelu = void 0;
var LeakyRelu = /** @class */ (function () {
    function LeakyRelu() {
    }
    LeakyRelu.prototype.initialize = function (attributes) {
        this.alpha = attributes.getFloat('alpha', 0.01);
    };
    LeakyRelu.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    LeakyRelu.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return LeakyRelu;
}());
exports.LeakyRelu = LeakyRelu;


/***/ }),

/***/ "./lib/onnxjs/ops/matmul.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/ops/matmul.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatMul = void 0;
var MatMul = /** @class */ (function () {
    function MatMul() {
    }
    MatMul.prototype.initialize = function (attributes) {
        this.activation = attributes.getString('__internal_activation', '');
    };
    MatMul.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    MatMul.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        if (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') {
            return false;
        }
        if (inputs[0].type !== inputs[1].type) {
            return false;
        }
        return true;
    };
    return MatMul;
}());
exports.MatMul = MatMul;


/***/ }),

/***/ "./lib/onnxjs/ops/pad.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/ops/pad.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pad = void 0;
var Pad = /** @class */ (function () {
    function Pad() {
    }
    Pad.prototype.initialize = function (attributes) {
        this.mode = attributes.getString('mode', 'constant');
        this.value = attributes.getFloat('value', 0.0);
        this.pads = attributes.getInts('pads');
    };
    Pad.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Pad.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return Pad;
}());
exports.Pad = Pad;


/***/ }),

/***/ "./lib/onnxjs/ops/pool.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/pool.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalMaxPool = exports.MaxPool = exports.GlobalAveragePool = exports.AveragePool = void 0;
var PoolBase = /** @class */ (function () {
    function PoolBase() {
    }
    PoolBase.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    PoolBase.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return PoolBase;
}());
var AveragePool = /** @class */ (function (_super) {
    __extends(AveragePool, _super);
    function AveragePool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AveragePool.prototype.initialize = function (attributes) {
        this.autoPad = attributes.getString('auto_pad', 'NOTSET');
        this.kernelShape = attributes.getInts('kernel_shape');
        this.strides = attributes.getInts('strides', []);
        this.pads = attributes.getInts('pads', []);
        this.countIncludePad = (attributes.getInt('count_include_pad', 0) === 0 ? false : true);
        this.ceilMode = attributes.getInt('ceil_mode', 0);
        // TODO: support attribute 'ceil_mode'
        if (this.ceilMode !== 0) {
            throw new Error('using ceil() in shape computation is not yet supported for AveragePool');
        }
    };
    return AveragePool;
}(PoolBase));
exports.AveragePool = AveragePool;
var GlobalAveragePool = /** @class */ (function (_super) {
    __extends(GlobalAveragePool, _super);
    function GlobalAveragePool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalAveragePool.prototype.initialize = function (attributes) {
        this.countIncludePad = (attributes.getInt('count_include_pad', 0) === 0 ? false : true);
    };
    return GlobalAveragePool;
}(PoolBase));
exports.GlobalAveragePool = GlobalAveragePool;
var MaxPool = /** @class */ (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MaxPool.prototype.initialize = function (attributes) {
        this.autoPad = attributes.getString('auto_pad', 'NOTSET');
        this.kernelShape = attributes.getInts('kernel_shape');
        this.strides = attributes.getInts('strides', []);
        this.pads = attributes.getInts('pads', []);
        this.ceilMode = attributes.getInt('ceil_mode', 0);
        this.storageOrder = attributes.getInt('storage_order', 0);
        // TODO: support attribute 'ceil_mode' and 'storage_order'
        if (this.storageOrder !== 0) {
            throw new Error('column major storage order is not yet supported for MaxPool');
        }
        if (this.ceilMode !== 0) {
            throw new Error('using ceil() in shape computation is not yet supported for MaxPool');
        }
    };
    return MaxPool;
}(PoolBase));
exports.MaxPool = MaxPool;
var GlobalMaxPool = /** @class */ (function (_super) {
    __extends(GlobalMaxPool, _super);
    function GlobalMaxPool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalMaxPool.prototype.initialize = function (_attributes) { };
    return GlobalMaxPool;
}(PoolBase));
exports.GlobalMaxPool = GlobalMaxPool;


/***/ }),

/***/ "./lib/onnxjs/ops/reduce-op.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/reduce-op.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceBase = void 0;
var operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
var ReduceBase = /** @class */ (function () {
    function ReduceBase() {
    }
    ReduceBase.prototype.initialize = function (attributes) {
        this.axes = attributes.getInts('axes', []);
        this.keepDims = attributes.getInt('keepdims', 1) === 1;
    };
    ReduceBase.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    ReduceBase.prototype.checkInputTypes = function (inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        return true;
    };
    return ReduceBase;
}());
exports.ReduceBase = ReduceBase;


/***/ }),

/***/ "./lib/onnxjs/ops/reshape.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/reshape.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reshape = void 0;
var operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
var Reshape = /** @class */ (function () {
    function Reshape() {
    }
    Reshape.prototype.initialize = function (_attributes) { };
    Reshape.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 2 || inputs[1].dims.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Reshape.prototype.checkInputTypes = function (inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[1].type !== 'int32') {
            return false;
        }
        return true;
    };
    return Reshape;
}());
exports.Reshape = Reshape;


/***/ }),

/***/ "./lib/onnxjs/ops/shape.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/ops/shape.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shape = void 0;
var Shape = /** @class */ (function () {
    function Shape() {
    }
    Shape.prototype.initialize = function (_attributes) { };
    Shape.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return true;
    };
    return Shape;
}());
exports.Shape = Shape;


/***/ }),

/***/ "./lib/onnxjs/ops/slice.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/ops/slice.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SliceV10 = exports.Slice = void 0;
var operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
var Slice = /** @class */ (function () {
    function Slice() {
    }
    Slice.prototype.initialize = function (attributes) {
        this.starts = attributes.getInts('starts');
        this.ends = attributes.getInts('ends');
        this.axes = attributes.getInts('axes', []);
    };
    Slice.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Slice.prototype.checkInputTypes = function (inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        return true;
    };
    return Slice;
}());
exports.Slice = Slice;
var SliceV10 = /** @class */ (function () {
    function SliceV10() {
    }
    SliceV10.prototype.initialize = function (_attributes) { };
    SliceV10.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length < 3 || inputs.length > 5) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    SliceV10.prototype.checkInputTypes = function (inputs) {
        if (inputs[1].type !== 'int32' || inputs[1].dims.length !== 1) {
            return false;
        }
        if (inputs[2].type !== 'int32' || inputs[2].dims.length !== 1) {
            return false;
        }
        if (inputs.length >= 4 && (inputs[3].type !== 'int32' || inputs[3].dims.length !== 1)) {
            return false;
        }
        if (inputs.length >= 5 && (inputs[4].type !== 'int32' || inputs[4].dims.length !== 1)) {
            return false;
        }
        return true;
    };
    return SliceV10;
}());
exports.SliceV10 = SliceV10;


/***/ }),

/***/ "./lib/onnxjs/ops/softmax.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/softmax.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Softmax = void 0;
var Softmax = /** @class */ (function () {
    function Softmax() {
    }
    Softmax.prototype.initialize = function (attributes) {
        this.axis = attributes.getInt('axis', 1);
    };
    Softmax.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Softmax.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return Softmax;
}());
exports.Softmax = Softmax;


/***/ }),

/***/ "./lib/onnxjs/ops/split.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/ops/split.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Split = void 0;
var Split = /** @class */ (function () {
    function Split(numOutputs) {
        this.numOutputs = numOutputs;
    }
    Split.prototype.initialize = function (attributes) {
        this.axis = attributes.getInt('axis', 0);
        this.split = attributes.getInts('split', []);
    };
    Split.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Split.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'int8' && inputs[0].type !== 'uint8' && inputs[0].type !== 'int16' &&
            inputs[0].type !== 'uint16' && inputs[0].type !== 'int32' && inputs[0].type !== 'uint32' &&
            inputs[0].type !== 'float32' && inputs[0].type !== 'float64' && inputs[0].type !== 'bool') {
            return false;
        }
        return true;
    };
    return Split;
}());
exports.Split = Split;


/***/ }),

/***/ "./lib/onnxjs/ops/squeeze.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/squeeze.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Squeeze = void 0;
var Squeeze = /** @class */ (function () {
    function Squeeze() {
    }
    Squeeze.prototype.initialize = function (attributes) {
        this.axes = attributes.getInts('axes');
    };
    Squeeze.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Squeeze.prototype.checkInputTypes = function (inputs) {
        // TODO: Support string type
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    };
    return Squeeze;
}());
exports.Squeeze = Squeeze;


/***/ }),

/***/ "./lib/onnxjs/ops/sum.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/ops/sum.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sum = void 0;
var Sum = /** @class */ (function () {
    function Sum() {
    }
    Sum.prototype.initialize = function (_attributes) { };
    Sum.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length === 0) {
            return false;
        }
        var length = inputs[0].dims.length;
        for (var i = 1; i < inputs.length; i++) {
            if (length !== inputs[i].dims.length) {
                return false;
            }
            for (var j = 0; j < length; j++) {
                if (inputs[0].dims[j] !== inputs[i].dims[j]) {
                    return false;
                }
            }
        }
        return this.checkInputTypes(inputs);
    };
    Sum.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        for (var i = 1; i < inputs.length; i++) {
            if (inputs[0].type !== inputs[i].type) {
                return false;
            }
        }
        return true;
    };
    return Sum;
}());
exports.Sum = Sum;


/***/ }),

/***/ "./lib/onnxjs/ops/tile.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/tile.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tile = void 0;
var operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
var Tile = /** @class */ (function () {
    function Tile() {
    }
    Tile.prototype.initialize = function (_attributes) { };
    Tile.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        if (inputs[1].dims.length !== 1) {
            return false;
        }
        if (inputs[1].dims[0] !== inputs[0].dims.length) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Tile.prototype.checkInputTypes = function (inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {
            return false;
        }
        return true;
    };
    return Tile;
}());
exports.Tile = Tile;


/***/ }),

/***/ "./lib/onnxjs/ops/transpose.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/transpose.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transpose = void 0;
var Transpose = /** @class */ (function () {
    function Transpose() {
    }
    Transpose.prototype.initialize = function (attributes) {
        this.perm = attributes.getInts('perm', []);
    };
    Transpose.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Transpose.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    };
    return Transpose;
}());
exports.Transpose = Transpose;


/***/ }),

/***/ "./lib/onnxjs/ops/unary-op.ts":
/*!************************************!*\
  !*** ./lib/onnxjs/ops/unary-op.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnaryOp = void 0;
var UnaryOp = /** @class */ (function () {
    function UnaryOp(typeConstraint, resultType) {
        this.typeConstraint = typeConstraint;
        this.resultType = resultType;
    }
    UnaryOp.prototype.initialize = function (_attributes) { };
    UnaryOp.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    UnaryOp.prototype.checkInputTypes = function (inputs) {
        if (this.typeConstraint.indexOf(inputs[0].type) === -1) {
            return false;
        }
        return true;
    };
    return UnaryOp;
}());
exports.UnaryOp = UnaryOp;


/***/ }),

/***/ "./lib/onnxjs/ops/unsqueeze.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/unsqueeze.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unsqueeze = void 0;
var Unsqueeze = /** @class */ (function () {
    function Unsqueeze() {
    }
    Unsqueeze.prototype.initialize = function (attributes) {
        this.axes = attributes.getInts('axes');
    };
    Unsqueeze.prototype.checkInputs = function (inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Unsqueeze.prototype.checkInputTypes = function (inputs) {
        // TODO: Support string type
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    };
    return Unsqueeze;
}());
exports.Unsqueeze = Unsqueeze;


/***/ }),

/***/ "./lib/onnxjs/ops/upsample.ts":
/*!************************************!*\
  !*** ./lib/onnxjs/ops/upsample.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeOutputShape = exports.parseScalesDataFromOutputSize = exports.parseScalesData = exports.parseRoiData = exports.Upsample = void 0;
var Upsample = /** @class */ (function () {
    function Upsample(opset) {
        this.opset = opset;
    }
    Upsample.prototype.initialize = function (attributes, _node, _graph) {
        this.isResize = (this.opset >= 10);
        // processing node attributes
        this.mode = attributes.getString('mode', 'nearest');
        if (this.mode !== 'nearest' && this.mode !== 'linear' && (this.opset < 11 || this.mode !== 'cubic')) {
            throw new Error("unrecognized mode: " + this.mode);
        }
        if (this.opset < 9) {
            this.scales = attributes.getFloats('scales');
            scalesValidataion(this.scales, this.mode, this.isResize);
        }
        this.extrapolationValue = attributes.getFloat('extrapolation_value', 0.0);
        this.coordinateTransformMode =
            this.opset > 10 ? attributes.getString('coordinate_transformation_mode', 'half_pixel') : 'asymmetric';
        if ([
            'asymmetric', 'pytorch_half_pixel', 'tf_half_pixel_for_nn', 'align_corners', 'tf_crop_and_resize',
            'half_pixel'
        ].indexOf(this.coordinateTransformMode) === -1) {
            throw new Error("coordinate_transform_mode '" + this.coordinateTransformMode + "' is not supported");
        }
        this.useExtrapolation = this.needRoiInput = (this.coordinateTransformMode === 'tf_crop_and_resize');
        this.nearestMode =
            (this.mode === 'nearest' && this.opset >= 11) ? attributes.getString('nearest_mode', 'round_prefer_floor') : '';
        if (['round_prefer_floor', 'round_prefer_ceil', 'floor', 'ceil', ''].indexOf(this.nearestMode) === -1) {
            throw new Error("nearest_mode '" + this.nearestMode + "' is not supported");
        }
        this.cubicCoefficientA = attributes.getFloat('cubic_coeff_a', -0.75);
        this.excludeOutside = attributes.getInt('exclude_outside', 0) !== 0;
        if (this.excludeOutside && this.mode !== 'cubic') {
            throw new Error('exclude_outside can be set to 1 only when mode is CUBIC.');
        }
        this.useNearest2xOptimization = (this.opset < 11) ?
            true :
            (this.mode === 'nearest' && this.coordinateTransformMode === 'asymmetric' && this.nearestMode === 'floor');
        if (this.opset > 10) {
            this.roiInputIdx = 1;
            this.scalesInputIdx = 2;
            this.sizesInputIdx = 3;
        }
        else if (this.opset === 9) {
            this.scalesInputIdx = 1;
        }
    };
    Upsample.prototype.checkInputs = function (inputs) {
        if (!inputs || (this.opset < 9 && inputs.length !== 1) ||
            (this.opset >= 9 && this.opset < 11 && inputs.length !== 2) ||
            (this.opset >= 11 && inputs.length !== 3 && inputs.length !== 4)) {
            return false;
        }
        if (this.scales && inputs[0].dims.length !== this.scales.length) {
            return false;
        }
        return this.checkInputTypes(inputs);
    };
    Upsample.prototype.checkInputTypes = function (inputs) {
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    };
    Upsample.prototype.prepareInputs = function (inputs) {
        var x = inputs[0];
        var xDims = x.dims;
        // get roi data
        var roi = this.roi;
        if (!roi) {
            if (this.needRoiInput) {
                if (this.roiInputIdx <= 0) {
                    throw new Error('Invalid roi input index.');
                }
                roi = parseRoiData(inputs[this.roiInputIdx]);
            }
            else {
                roi = new Array(xDims.length * 2).fill(0);
            }
        }
        var scales = this.scales;
        var outputSizes;
        if (!scales) {
            var scalesTensor = inputs[this.scalesInputIdx];
            if (scalesTensor && scalesTensor.size !== 0) {
                if (inputs[this.sizesInputIdx]) {
                    throw new Error('Only one of scales or sizes must be provided as input.');
                }
                scales = parseScalesData(scalesTensor, this.mode, this.isResize);
            }
            else {
                var sizesTensor = inputs[this.sizesInputIdx];
                if (!sizesTensor || sizesTensor.size === 0) {
                    throw new Error('Either scales or sizes MUST be provided as input.');
                }
                outputSizes = Array.from(sizesTensor.integerData);
                scales = parseScalesDataFromOutputSize(outputSizes, xDims, this.mode, this.isResize);
            }
        }
        else {
            if (inputs[this.sizesInputIdx]) {
                throw new Error('Only one of scales or sizes must be provided as input.');
            }
        }
        var yDims = outputSizes || computeOutputShape(scales, xDims);
        return [roi, scales, yDims];
    };
    return Upsample;
}());
exports.Upsample = Upsample;
function scalesValidataion(scales, mode, isResize) {
    var e_1, _a, e_2, _b;
    if (!isResize) {
        try {
            for (var scales_1 = __values(scales), scales_1_1 = scales_1.next(); !scales_1_1.done; scales_1_1 = scales_1.next()) {
                var scale = scales_1_1.value;
                if (scale < 1) {
                    throw new Error('Scale value should be greater than or equal to 1.');
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (scales_1_1 && !scales_1_1.done && (_a = scales_1.return)) _a.call(scales_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        try {
            for (var scales_2 = __values(scales), scales_2_1 = scales_2.next(); !scales_2_1.done; scales_2_1 = scales_2.next()) {
                var scale = scales_2_1.value;
                if (scale <= 0) {
                    throw new Error('Scale value should be greater than 0.');
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (scales_2_1 && !scales_2_1.done && (_b = scales_2.return)) _b.call(scales_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    if (mode === 'linear' || mode === 'cubic') {
        if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {
            throw new Error("'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic') or 4-D inputswith the corresponding outermost 2 scale values being 1 in the " + (isResize ? 'Resize' : 'Upsample') + " opeartor.");
        }
    }
}
function parseRoiData(roi) {
    return roi.size > 0 ? Array.from(roi.floatData) : [];
}
exports.parseRoiData = parseRoiData;
function parseScalesData(scale, mode, isResize) {
    var scales = Array.from(scale.floatData);
    scalesValidataion(scales, mode, isResize);
    return scales;
}
exports.parseScalesData = parseScalesData;
function parseScalesDataFromOutputSize(yDims, xDims, mode, isResize) {
    var length = xDims.length;
    var scales = new Array(length);
    for (var i = 0, end = length; i < end; i++) {
        if (xDims[i] === 0) {
            if (yDims[i] !== 0) {
                throw new Error('Input dim is zero but required output dim is non-zero.');
            }
            scales[i] = 1;
        }
        else {
            scales[i] = yDims[i] / xDims[i];
        }
    }
    scalesValidataion(scales, mode, isResize);
    return scales;
}
exports.parseScalesDataFromOutputSize = parseScalesDataFromOutputSize;
function computeOutputShape(scales, inputDims) {
    return inputDims.map(function (dim, i) { return Math.floor(dim * scales[i]); });
}
exports.computeOutputShape = computeOutputShape;


/***/ }),

/***/ "./lib/onnxjs/opset.ts":
/*!*****************************!*\
  !*** ./lib/onnxjs/opset.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveOperator = void 0;
function resolveOperator(node, opsets, rules) {
    var e_1, _a, e_2, _b;
    try {
        for (var rules_1 = __values(rules), rules_1_1 = rules_1.next(); !rules_1_1.done; rules_1_1 = rules_1.next()) {
            var rule = rules_1_1.value;
            var opType = rule[0];
            var domain = rule[1];
            var versionSelector = rule[2];
            var opConstructor = rule[3];
            if (node.opType === opType) { // operator type matches
                try {
                    for (var opsets_1 = (e_2 = void 0, __values(opsets)), opsets_1_1 = opsets_1.next(); !opsets_1_1.done; opsets_1_1 = opsets_1.next()) {
                        var opset = opsets_1_1.value;
                        // opset '' and 'ai.onnx' are considered the same.
                        if (opset.domain === domain || (opset.domain === 'ai.onnx' && domain === '')) { // opset domain found
                            if (matchSelector(opset.version, versionSelector)) {
                                return opConstructor(node);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (opsets_1_1 && !opsets_1_1.done && (_b = opsets_1.return)) _b.call(opsets_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (rules_1_1 && !rules_1_1.done && (_a = rules_1.return)) _a.call(rules_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    throw new TypeError("cannot resolve operator '" + node.opType + "' with opsets: " + opsets.map(function (set) { return (set.domain || 'ai.onnx') + " v" + set.version; }).join(', '));
}
exports.resolveOperator = resolveOperator;
function matchSelector(version, selector) {
    if (selector.endsWith('+')) {
        // minimum version match ('7+' expects version>=7)
        var rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);
        return !isNaN(rangeStart) && rangeStart <= version;
    }
    else if (selector.split('-').length === 2) {
        // range match ('6-8' expects 6<=version<=8)
        var pair = selector.split('-');
        var rangeStart = Number.parseInt(pair[0], 10);
        var rangeEnd = Number.parseInt(pair[1], 10);
        return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version && version <= rangeEnd;
    }
    else {
        // exact match ('7' expects version===7)
        return Number.parseInt(selector, 10) === version;
    }
}


/***/ }),

/***/ "./lib/onnxjs/ort-schema/ort-generated.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/ort-schema/ort-generated.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onnxruntime = void 0;
var flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/js/flatbuffers.mjs");
/**
 * @enum {number}
 */
var onnxruntime;
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var AttributeType;
            (function (AttributeType) {
                AttributeType[AttributeType["UNDEFINED"] = 0] = "UNDEFINED";
                AttributeType[AttributeType["FLOAT"] = 1] = "FLOAT";
                AttributeType[AttributeType["INT"] = 2] = "INT";
                AttributeType[AttributeType["STRING"] = 3] = "STRING";
                AttributeType[AttributeType["TENSOR"] = 4] = "TENSOR";
                AttributeType[AttributeType["GRAPH"] = 5] = "GRAPH";
                AttributeType[AttributeType["FLOATS"] = 6] = "FLOATS";
                AttributeType[AttributeType["INTS"] = 7] = "INTS";
                AttributeType[AttributeType["STRINGS"] = 8] = "STRINGS";
                AttributeType[AttributeType["TENSORS"] = 9] = "TENSORS";
                AttributeType[AttributeType["GRAPHS"] = 10] = "GRAPHS";
                AttributeType[AttributeType["SPARSE_TENSOR"] = 11] = "SPARSE_TENSOR";
                AttributeType[AttributeType["SPARSE_TENSORS"] = 12] = "SPARSE_TENSORS";
            })(AttributeType = fbs.AttributeType || (fbs.AttributeType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var DimensionValueType;
            (function (DimensionValueType) {
                DimensionValueType[DimensionValueType["UNKNOWN"] = 0] = "UNKNOWN";
                DimensionValueType[DimensionValueType["VALUE"] = 1] = "VALUE";
                DimensionValueType[DimensionValueType["PARAM"] = 2] = "PARAM";
            })(DimensionValueType = fbs.DimensionValueType || (fbs.DimensionValueType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var TensorDataType;
            (function (TensorDataType) {
                TensorDataType[TensorDataType["UNDEFINED"] = 0] = "UNDEFINED";
                TensorDataType[TensorDataType["FLOAT"] = 1] = "FLOAT";
                TensorDataType[TensorDataType["UINT8"] = 2] = "UINT8";
                TensorDataType[TensorDataType["INT8"] = 3] = "INT8";
                TensorDataType[TensorDataType["UINT16"] = 4] = "UINT16";
                TensorDataType[TensorDataType["INT16"] = 5] = "INT16";
                TensorDataType[TensorDataType["INT32"] = 6] = "INT32";
                TensorDataType[TensorDataType["INT64"] = 7] = "INT64";
                TensorDataType[TensorDataType["STRING"] = 8] = "STRING";
                TensorDataType[TensorDataType["BOOL"] = 9] = "BOOL";
                TensorDataType[TensorDataType["FLOAT16"] = 10] = "FLOAT16";
                TensorDataType[TensorDataType["DOUBLE"] = 11] = "DOUBLE";
                TensorDataType[TensorDataType["UINT32"] = 12] = "UINT32";
                TensorDataType[TensorDataType["UINT64"] = 13] = "UINT64";
                TensorDataType[TensorDataType["COMPLEX64"] = 14] = "COMPLEX64";
                TensorDataType[TensorDataType["COMPLEX128"] = 15] = "COMPLEX128";
                TensorDataType[TensorDataType["BFLOAT16"] = 16] = "BFLOAT16";
            })(TensorDataType = fbs.TensorDataType || (fbs.TensorDataType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var NodeType;
            (function (NodeType) {
                NodeType[NodeType["Primitive"] = 0] = "Primitive";
                NodeType[NodeType["Fused"] = 1] = "Fused";
            })(NodeType = fbs.NodeType || (fbs.NodeType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var TypeInfoValue;
            (function (TypeInfoValue) {
                TypeInfoValue[TypeInfoValue["NONE"] = 0] = "NONE";
                TypeInfoValue[TypeInfoValue["tensor_type"] = 1] = "tensor_type";
                TypeInfoValue[TypeInfoValue["sequence_type"] = 2] = "sequence_type";
                TypeInfoValue[TypeInfoValue["map_type"] = 3] = "map_type";
            })(TypeInfoValue = fbs.TypeInfoValue || (fbs.TypeInfoValue = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Shape = /** @class */ (function () {
                function Shape() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Shape
                 */
                Shape.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Shape= obj
                 * @returns Shape
                 */
                Shape.getRootAsShape = function (bb, obj) {
                    return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Shape= obj
                 * @returns Shape
                 */
                Shape.getSizePrefixedRootAsShape = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Dimension= obj
                 * @returns onnxruntime.experimental.fbs.Dimension
                 */
                Shape.prototype.dim = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Dimension())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Shape.prototype.dimLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Shape.startShape = function (builder) {
                    builder.startObject(1);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimOffset
                 */
                Shape.addDim = function (builder, dimOffset) {
                    builder.addFieldOffset(0, dimOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Shape.createDimVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Shape.startDimVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Shape.endShape = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Shape.createShape = function (builder, dimOffset) {
                    Shape.startShape(builder);
                    Shape.addDim(builder, dimOffset);
                    return Shape.endShape(builder);
                };
                return Shape;
            }());
            fbs.Shape = Shape;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Dimension = /** @class */ (function () {
                function Dimension() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Dimension
                 */
                Dimension.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Dimension= obj
                 * @returns Dimension
                 */
                Dimension.getRootAsDimension = function (bb, obj) {
                    return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Dimension= obj
                 * @returns Dimension
                 */
                Dimension.getSizePrefixedRootAsDimension = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param onnxruntime.experimental.fbs.DimensionValue= obj
                 * @returns onnxruntime.experimental.fbs.DimensionValue|null
                 */
                Dimension.prototype.value = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.DimensionValue())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                Dimension.prototype.denotation = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Dimension.startDimension = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valueOffset
                 */
                Dimension.addValue = function (builder, valueOffset) {
                    builder.addFieldOffset(0, valueOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset denotationOffset
                 */
                Dimension.addDenotation = function (builder, denotationOffset) {
                    builder.addFieldOffset(1, denotationOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Dimension.endDimension = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Dimension.createDimension = function (builder, valueOffset, denotationOffset) {
                    Dimension.startDimension(builder);
                    Dimension.addValue(builder, valueOffset);
                    Dimension.addDenotation(builder, denotationOffset);
                    return Dimension.endDimension(builder);
                };
                return Dimension;
            }());
            fbs.Dimension = Dimension;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var DimensionValue = /** @class */ (function () {
                function DimensionValue() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns DimensionValue
                 */
                DimensionValue.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param DimensionValue= obj
                 * @returns DimensionValue
                 */
                DimensionValue.getRootAsDimensionValue = function (bb, obj) {
                    return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param DimensionValue= obj
                 * @returns DimensionValue
                 */
                DimensionValue.getSizePrefixedRootAsDimensionValue = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @returns onnxruntime.experimental.fbs.DimensionValueType
                 */
                DimensionValue.prototype.dimType = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? /**  */ (this.bb.readInt8(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN;
                };
                /**
                 * @returns flatbuffers.Long
                 */
                DimensionValue.prototype.dimValue = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                };
                DimensionValue.prototype.dimParam = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                DimensionValue.startDimensionValue = function (builder) {
                    builder.startObject(3);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.DimensionValueType dimType
                 */
                DimensionValue.addDimType = function (builder, dimType) {
                    builder.addFieldInt8(0, dimType, onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long dimValue
                 */
                DimensionValue.addDimValue = function (builder, dimValue) {
                    builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimParamOffset
                 */
                DimensionValue.addDimParam = function (builder, dimParamOffset) {
                    builder.addFieldOffset(2, dimParamOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                DimensionValue.endDimensionValue = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                DimensionValue.createDimensionValue = function (builder, dimType, dimValue, dimParamOffset) {
                    DimensionValue.startDimensionValue(builder);
                    DimensionValue.addDimType(builder, dimType);
                    DimensionValue.addDimValue(builder, dimValue);
                    DimensionValue.addDimParam(builder, dimParamOffset);
                    return DimensionValue.endDimensionValue(builder);
                };
                return DimensionValue;
            }());
            fbs.DimensionValue = DimensionValue;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var TensorTypeAndShape = /** @class */ (function () {
                function TensorTypeAndShape() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns TensorTypeAndShape
                 */
                TensorTypeAndShape.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TensorTypeAndShape= obj
                 * @returns TensorTypeAndShape
                 */
                TensorTypeAndShape.getRootAsTensorTypeAndShape = function (bb, obj) {
                    return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TensorTypeAndShape= obj
                 * @returns TensorTypeAndShape
                 */
                TensorTypeAndShape.getSizePrefixedRootAsTensorTypeAndShape = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @returns onnxruntime.experimental.fbs.TensorDataType
                 */
                TensorTypeAndShape.prototype.elemType = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;
                };
                /**
                 * @param onnxruntime.experimental.fbs.Shape= obj
                 * @returns onnxruntime.experimental.fbs.Shape|null
                 */
                TensorTypeAndShape.prototype.shape = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Shape())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                TensorTypeAndShape.startTensorTypeAndShape = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TensorDataType elemType
                 */
                TensorTypeAndShape.addElemType = function (builder, elemType) {
                    builder.addFieldInt32(0, elemType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset shapeOffset
                 */
                TensorTypeAndShape.addShape = function (builder, shapeOffset) {
                    builder.addFieldOffset(1, shapeOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                TensorTypeAndShape.endTensorTypeAndShape = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                TensorTypeAndShape.createTensorTypeAndShape = function (builder, elemType, shapeOffset) {
                    TensorTypeAndShape.startTensorTypeAndShape(builder);
                    TensorTypeAndShape.addElemType(builder, elemType);
                    TensorTypeAndShape.addShape(builder, shapeOffset);
                    return TensorTypeAndShape.endTensorTypeAndShape(builder);
                };
                return TensorTypeAndShape;
            }());
            fbs.TensorTypeAndShape = TensorTypeAndShape;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var MapType = /** @class */ (function () {
                function MapType() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns MapType
                 */
                MapType.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param MapType= obj
                 * @returns MapType
                 */
                MapType.getRootAsMapType = function (bb, obj) {
                    return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param MapType= obj
                 * @returns MapType
                 */
                MapType.getSizePrefixedRootAsMapType = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @returns onnxruntime.experimental.fbs.TensorDataType
                 */
                MapType.prototype.keyType = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;
                };
                /**
                 * @param onnxruntime.experimental.fbs.TypeInfo= obj
                 * @returns onnxruntime.experimental.fbs.TypeInfo|null
                 */
                MapType.prototype.valueType = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                MapType.startMapType = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TensorDataType keyType
                 */
                MapType.addKeyType = function (builder, keyType) {
                    builder.addFieldInt32(0, keyType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valueTypeOffset
                 */
                MapType.addValueType = function (builder, valueTypeOffset) {
                    builder.addFieldOffset(1, valueTypeOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                MapType.endMapType = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                MapType.createMapType = function (builder, keyType, valueTypeOffset) {
                    MapType.startMapType(builder);
                    MapType.addKeyType(builder, keyType);
                    MapType.addValueType(builder, valueTypeOffset);
                    return MapType.endMapType(builder);
                };
                return MapType;
            }());
            fbs.MapType = MapType;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var SequenceType = /** @class */ (function () {
                function SequenceType() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SequenceType
                 */
                SequenceType.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SequenceType= obj
                 * @returns SequenceType
                 */
                SequenceType.getRootAsSequenceType = function (bb, obj) {
                    return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SequenceType= obj
                 * @returns SequenceType
                 */
                SequenceType.getSizePrefixedRootAsSequenceType = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param onnxruntime.experimental.fbs.TypeInfo= obj
                 * @returns onnxruntime.experimental.fbs.TypeInfo|null
                 */
                SequenceType.prototype.elemType = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                SequenceType.startSequenceType = function (builder) {
                    builder.startObject(1);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset elemTypeOffset
                 */
                SequenceType.addElemType = function (builder, elemTypeOffset) {
                    builder.addFieldOffset(0, elemTypeOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                SequenceType.endSequenceType = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                SequenceType.createSequenceType = function (builder, elemTypeOffset) {
                    SequenceType.startSequenceType(builder);
                    SequenceType.addElemType(builder, elemTypeOffset);
                    return SequenceType.endSequenceType(builder);
                };
                return SequenceType;
            }());
            fbs.SequenceType = SequenceType;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var EdgeEnd = /** @class */ (function () {
                function EdgeEnd() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns EdgeEnd
                 */
                EdgeEnd.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @returns number
                 */
                EdgeEnd.prototype.nodeIndex = function () {
                    return this.bb.readUint32(this.bb_pos);
                };
                /**
                 * @returns number
                 */
                EdgeEnd.prototype.srcArgIndex = function () {
                    return this.bb.readInt32(this.bb_pos + 4);
                };
                /**
                 * @returns number
                 */
                EdgeEnd.prototype.dstArgIndex = function () {
                    return this.bb.readInt32(this.bb_pos + 8);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number node_index
                 * @param number src_arg_index
                 * @param number dst_arg_index
                 * @returns flatbuffers.Offset
                 */
                EdgeEnd.createEdgeEnd = function (builder, node_index, src_arg_index, dst_arg_index) {
                    builder.prep(4, 12);
                    builder.writeInt32(dst_arg_index);
                    builder.writeInt32(src_arg_index);
                    builder.writeInt32(node_index);
                    return builder.offset();
                };
                return EdgeEnd;
            }());
            fbs.EdgeEnd = EdgeEnd;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var NodeEdge = /** @class */ (function () {
                function NodeEdge() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns NodeEdge
                 */
                NodeEdge.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param NodeEdge= obj
                 * @returns NodeEdge
                 */
                NodeEdge.getRootAsNodeEdge = function (bb, obj) {
                    return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param NodeEdge= obj
                 * @returns NodeEdge
                 */
                NodeEdge.getSizePrefixedRootAsNodeEdge = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @returns number
                 */
                NodeEdge.prototype.nodeIndex = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.EdgeEnd= obj
                 * @returns onnxruntime.experimental.fbs.EdgeEnd
                 */
                NodeEdge.prototype.inputEdges = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())
                        .__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                NodeEdge.prototype.inputEdgesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.EdgeEnd= obj
                 * @returns onnxruntime.experimental.fbs.EdgeEnd
                 */
                NodeEdge.prototype.outputEdges = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())
                        .__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                NodeEdge.prototype.outputEdgesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                NodeEdge.startNodeEdge = function (builder) {
                    builder.startObject(3);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number nodeIndex
                 */
                NodeEdge.addNodeIndex = function (builder, nodeIndex) {
                    builder.addFieldInt32(0, nodeIndex, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputEdgesOffset
                 */
                NodeEdge.addInputEdges = function (builder, inputEdgesOffset) {
                    builder.addFieldOffset(1, inputEdgesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                NodeEdge.startInputEdgesVector = function (builder, numElems) {
                    builder.startVector(12, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset outputEdgesOffset
                 */
                NodeEdge.addOutputEdges = function (builder, outputEdgesOffset) {
                    builder.addFieldOffset(2, outputEdgesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                NodeEdge.startOutputEdgesVector = function (builder, numElems) {
                    builder.startVector(12, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                NodeEdge.endNodeEdge = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                NodeEdge.createNodeEdge = function (builder, nodeIndex, inputEdgesOffset, outputEdgesOffset) {
                    NodeEdge.startNodeEdge(builder);
                    NodeEdge.addNodeIndex(builder, nodeIndex);
                    NodeEdge.addInputEdges(builder, inputEdgesOffset);
                    NodeEdge.addOutputEdges(builder, outputEdgesOffset);
                    return NodeEdge.endNodeEdge(builder);
                };
                return NodeEdge;
            }());
            fbs.NodeEdge = NodeEdge;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Node = /** @class */ (function () {
                function Node() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Node
                 */
                Node.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Node= obj
                 * @returns Node
                 */
                Node.getRootAsNode = function (bb, obj) {
                    return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Node= obj
                 * @returns Node
                 */
                Node.getSizePrefixedRootAsNode = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                Node.prototype.name = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Node.prototype.docString = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Node.prototype.domain = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Node.prototype.sinceVersion = function () {
                    var offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns number
                 */
                Node.prototype.index = function () {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
                };
                Node.prototype.opType = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @returns onnxruntime.experimental.fbs.NodeType
                 */
                Node.prototype.type = function () {
                    var offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.NodeType.Primitive;
                };
                Node.prototype.executionProviderType = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Node.prototype.inputs = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Node.prototype.inputsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                Node.prototype.outputs = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Node.prototype.outputsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Attribute= obj
                 * @returns onnxruntime.experimental.fbs.Attribute
                 */
                Node.prototype.attributes = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Attribute())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Node.prototype.attributesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @returns number
                 */
                Node.prototype.inputArgCounts = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
                };
                /**
                 * @returns number
                 */
                Node.prototype.inputArgCountsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns Int32Array
                 */
                Node.prototype.inputArgCountsArray = function () {
                    var offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ?
                        new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                };
                Node.prototype.implicitInputs = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Node.prototype.implicitInputsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Node.startNode = function (builder) {
                    builder.startObject(13);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                Node.addName = function (builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                Node.addDocString = function (builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset domainOffset
                 */
                Node.addDomain = function (builder, domainOffset) {
                    builder.addFieldOffset(2, domainOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number sinceVersion
                 */
                Node.addSinceVersion = function (builder, sinceVersion) {
                    builder.addFieldInt32(3, sinceVersion, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number index
                 */
                Node.addIndex = function (builder, index) {
                    builder.addFieldInt32(4, index, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset opTypeOffset
                 */
                Node.addOpType = function (builder, opTypeOffset) {
                    builder.addFieldOffset(5, opTypeOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.NodeType type
                 */
                Node.addType = function (builder, type) {
                    builder.addFieldInt32(6, type, onnxruntime.experimental.fbs.NodeType.Primitive);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset executionProviderTypeOffset
                 */
                Node.addExecutionProviderType = function (builder, executionProviderTypeOffset) {
                    builder.addFieldOffset(7, executionProviderTypeOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputsOffset
                 */
                Node.addInputs = function (builder, inputsOffset) {
                    builder.addFieldOffset(8, inputsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Node.createInputsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Node.startInputsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset outputsOffset
                 */
                Node.addOutputs = function (builder, outputsOffset) {
                    builder.addFieldOffset(9, outputsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Node.createOutputsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Node.startOutputsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset attributesOffset
                 */
                Node.addAttributes = function (builder, attributesOffset) {
                    builder.addFieldOffset(10, attributesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Node.createAttributesVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Node.startAttributesVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputArgCountsOffset
                 */
                Node.addInputArgCounts = function (builder, inputArgCountsOffset) {
                    builder.addFieldOffset(11, inputArgCountsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                Node.createInputArgCountsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt32(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Node.startInputArgCountsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset implicitInputsOffset
                 */
                Node.addImplicitInputs = function (builder, implicitInputsOffset) {
                    builder.addFieldOffset(12, implicitInputsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Node.createImplicitInputsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Node.startImplicitInputsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Node.endNode = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Node.createNode = function (builder, nameOffset, docStringOffset, domainOffset, sinceVersion, index, opTypeOffset, type, executionProviderTypeOffset, inputsOffset, outputsOffset, attributesOffset, inputArgCountsOffset, implicitInputsOffset) {
                    Node.startNode(builder);
                    Node.addName(builder, nameOffset);
                    Node.addDocString(builder, docStringOffset);
                    Node.addDomain(builder, domainOffset);
                    Node.addSinceVersion(builder, sinceVersion);
                    Node.addIndex(builder, index);
                    Node.addOpType(builder, opTypeOffset);
                    Node.addType(builder, type);
                    Node.addExecutionProviderType(builder, executionProviderTypeOffset);
                    Node.addInputs(builder, inputsOffset);
                    Node.addOutputs(builder, outputsOffset);
                    Node.addAttributes(builder, attributesOffset);
                    Node.addInputArgCounts(builder, inputArgCountsOffset);
                    Node.addImplicitInputs(builder, implicitInputsOffset);
                    return Node.endNode(builder);
                };
                return Node;
            }());
            fbs.Node = Node;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var ValueInfo = /** @class */ (function () {
                function ValueInfo() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns ValueInfo
                 */
                ValueInfo.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param ValueInfo= obj
                 * @returns ValueInfo
                 */
                ValueInfo.getRootAsValueInfo = function (bb, obj) {
                    return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param ValueInfo= obj
                 * @returns ValueInfo
                 */
                ValueInfo.getSizePrefixedRootAsValueInfo = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                ValueInfo.prototype.name = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                ValueInfo.prototype.docString = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.TypeInfo= obj
                 * @returns onnxruntime.experimental.fbs.TypeInfo|null
                 */
                ValueInfo.prototype.type = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                ValueInfo.startValueInfo = function (builder) {
                    builder.startObject(3);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                ValueInfo.addName = function (builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                ValueInfo.addDocString = function (builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset typeOffset
                 */
                ValueInfo.addType = function (builder, typeOffset) {
                    builder.addFieldOffset(2, typeOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                ValueInfo.endValueInfo = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                ValueInfo.createValueInfo = function (builder, nameOffset, docStringOffset, typeOffset) {
                    ValueInfo.startValueInfo(builder);
                    ValueInfo.addName(builder, nameOffset);
                    ValueInfo.addDocString(builder, docStringOffset);
                    ValueInfo.addType(builder, typeOffset);
                    return ValueInfo.endValueInfo(builder);
                };
                return ValueInfo;
            }());
            fbs.ValueInfo = ValueInfo;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var TypeInfo = /** @class */ (function () {
                function TypeInfo() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns TypeInfo
                 */
                TypeInfo.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TypeInfo= obj
                 * @returns TypeInfo
                 */
                TypeInfo.getRootAsTypeInfo = function (bb, obj) {
                    return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TypeInfo= obj
                 * @returns TypeInfo
                 */
                TypeInfo.getSizePrefixedRootAsTypeInfo = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                TypeInfo.prototype.denotation = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @returns onnxruntime.experimental.fbs.TypeInfoValue
                 */
                TypeInfo.prototype.valueType = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? /**  */ (this.bb.readUint8(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TypeInfoValue.NONE;
                };
                /**
                 * @param flatbuffers.Table obj
                 * @returns ?flatbuffers.Table
                 */
                TypeInfo.prototype.value = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                TypeInfo.startTypeInfo = function (builder) {
                    builder.startObject(3);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset denotationOffset
                 */
                TypeInfo.addDenotation = function (builder, denotationOffset) {
                    builder.addFieldOffset(0, denotationOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TypeInfoValue valueType
                 */
                TypeInfo.addValueType = function (builder, valueType) {
                    builder.addFieldInt8(1, valueType, onnxruntime.experimental.fbs.TypeInfoValue.NONE);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valueOffset
                 */
                TypeInfo.addValue = function (builder, valueOffset) {
                    builder.addFieldOffset(2, valueOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                TypeInfo.endTypeInfo = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                TypeInfo.createTypeInfo = function (builder, denotationOffset, valueType, valueOffset) {
                    TypeInfo.startTypeInfo(builder);
                    TypeInfo.addDenotation(builder, denotationOffset);
                    TypeInfo.addValueType(builder, valueType);
                    TypeInfo.addValue(builder, valueOffset);
                    return TypeInfo.endTypeInfo(builder);
                };
                return TypeInfo;
            }());
            fbs.TypeInfo = TypeInfo;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var OperatorSetId = /** @class */ (function () {
                function OperatorSetId() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns OperatorSetId
                 */
                OperatorSetId.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param OperatorSetId= obj
                 * @returns OperatorSetId
                 */
                OperatorSetId.getRootAsOperatorSetId = function (bb, obj) {
                    return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param OperatorSetId= obj
                 * @returns OperatorSetId
                 */
                OperatorSetId.getSizePrefixedRootAsOperatorSetId = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                OperatorSetId.prototype.domain = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @returns flatbuffers.Long
                 */
                OperatorSetId.prototype.version = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                OperatorSetId.startOperatorSetId = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset domainOffset
                 */
                OperatorSetId.addDomain = function (builder, domainOffset) {
                    builder.addFieldOffset(0, domainOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long version
                 */
                OperatorSetId.addVersion = function (builder, version) {
                    builder.addFieldInt64(1, version, builder.createLong(0, 0));
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                OperatorSetId.endOperatorSetId = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                OperatorSetId.createOperatorSetId = function (builder, domainOffset, version) {
                    OperatorSetId.startOperatorSetId(builder);
                    OperatorSetId.addDomain(builder, domainOffset);
                    OperatorSetId.addVersion(builder, version);
                    return OperatorSetId.endOperatorSetId(builder);
                };
                return OperatorSetId;
            }());
            fbs.OperatorSetId = OperatorSetId;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Tensor = /** @class */ (function () {
                function Tensor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Tensor
                 */
                Tensor.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Tensor= obj
                 * @returns Tensor
                 */
                Tensor.getRootAsTensor = function (bb, obj) {
                    return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Tensor= obj
                 * @returns Tensor
                 */
                Tensor.getSizePrefixedRootAsTensor = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                Tensor.prototype.name = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Tensor.prototype.docString = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                Tensor.prototype.dims = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                };
                /**
                 * @returns number
                 */
                Tensor.prototype.dimsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns onnxruntime.experimental.fbs.TensorDataType
                 */
                Tensor.prototype.dataType = function () {
                    var offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;
                };
                /**
                 * @param number index
                 * @returns number
                 */
                Tensor.prototype.rawData = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
                };
                /**
                 * @returns number
                 */
                Tensor.prototype.rawDataLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns Uint8Array
                 */
                Tensor.prototype.rawDataArray = function () {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ?
                        new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                };
                Tensor.prototype.stringData = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Tensor.prototype.stringDataLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Tensor.startTensor = function (builder) {
                    builder.startObject(6);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                Tensor.addName = function (builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                Tensor.addDocString = function (builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimsOffset
                 */
                Tensor.addDims = function (builder, dimsOffset) {
                    builder.addFieldOffset(2, dimsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                Tensor.createDimsVector = function (builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Tensor.startDimsVector = function (builder, numElems) {
                    builder.startVector(8, numElems, 8);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TensorDataType dataType
                 */
                Tensor.addDataType = function (builder, dataType) {
                    builder.addFieldInt32(3, dataType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset rawDataOffset
                 */
                Tensor.addRawData = function (builder, rawDataOffset) {
                    builder.addFieldOffset(4, rawDataOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                Tensor.createRawDataVector = function (builder, data) {
                    builder.startVector(1, data.length, 1);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt8(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Tensor.startRawDataVector = function (builder, numElems) {
                    builder.startVector(1, numElems, 1);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset stringDataOffset
                 */
                Tensor.addStringData = function (builder, stringDataOffset) {
                    builder.addFieldOffset(5, stringDataOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Tensor.createStringDataVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Tensor.startStringDataVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Tensor.endTensor = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Tensor.createTensor = function (builder, nameOffset, docStringOffset, dimsOffset, dataType, rawDataOffset, stringDataOffset) {
                    Tensor.startTensor(builder);
                    Tensor.addName(builder, nameOffset);
                    Tensor.addDocString(builder, docStringOffset);
                    Tensor.addDims(builder, dimsOffset);
                    Tensor.addDataType(builder, dataType);
                    Tensor.addRawData(builder, rawDataOffset);
                    Tensor.addStringData(builder, stringDataOffset);
                    return Tensor.endTensor(builder);
                };
                return Tensor;
            }());
            fbs.Tensor = Tensor;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var SparseTensor = /** @class */ (function () {
                function SparseTensor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SparseTensor
                 */
                SparseTensor.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SparseTensor= obj
                 * @returns SparseTensor
                 */
                SparseTensor.getRootAsSparseTensor = function (bb, obj) {
                    return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SparseTensor= obj
                 * @returns SparseTensor
                 */
                SparseTensor.getSizePrefixedRootAsSparseTensor = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor|null
                 */
                SparseTensor.prototype.values = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor|null
                 */
                SparseTensor.prototype.indices = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                SparseTensor.prototype.dims = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                };
                /**
                 * @returns number
                 */
                SparseTensor.prototype.dimsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                SparseTensor.startSparseTensor = function (builder) {
                    builder.startObject(3);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valuesOffset
                 */
                SparseTensor.addValues = function (builder, valuesOffset) {
                    builder.addFieldOffset(0, valuesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset indicesOffset
                 */
                SparseTensor.addIndices = function (builder, indicesOffset) {
                    builder.addFieldOffset(1, indicesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimsOffset
                 */
                SparseTensor.addDims = function (builder, dimsOffset) {
                    builder.addFieldOffset(2, dimsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                SparseTensor.createDimsVector = function (builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                SparseTensor.startDimsVector = function (builder, numElems) {
                    builder.startVector(8, numElems, 8);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                SparseTensor.endSparseTensor = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                SparseTensor.createSparseTensor = function (builder, valuesOffset, indicesOffset, dimsOffset) {
                    SparseTensor.startSparseTensor(builder);
                    SparseTensor.addValues(builder, valuesOffset);
                    SparseTensor.addIndices(builder, indicesOffset);
                    SparseTensor.addDims(builder, dimsOffset);
                    return SparseTensor.endSparseTensor(builder);
                };
                return SparseTensor;
            }());
            fbs.SparseTensor = SparseTensor;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Attribute = /** @class */ (function () {
                function Attribute() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Attribute
                 */
                Attribute.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Attribute= obj
                 * @returns Attribute
                 */
                Attribute.getRootAsAttribute = function (bb, obj) {
                    return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Attribute= obj
                 * @returns Attribute
                 */
                Attribute.getSizePrefixedRootAsAttribute = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                Attribute.prototype.name = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Attribute.prototype.docString = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @returns onnxruntime.experimental.fbs.AttributeType
                 */
                Attribute.prototype.type = function () {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.AttributeType.UNDEFINED;
                };
                /**
                 * @returns number
                 */
                Attribute.prototype.f = function () {
                    var offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
                };
                /**
                 * @returns flatbuffers.Long
                 */
                Attribute.prototype.i = function () {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                };
                Attribute.prototype.s = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor|null
                 */
                Attribute.prototype.t = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.Graph= obj
                 * @returns onnxruntime.experimental.fbs.Graph|null
                 */
                Attribute.prototype.g = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Graph())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param number index
                 * @returns number
                 */
                Attribute.prototype.floats = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
                };
                /**
                 * @returns number
                 */
                Attribute.prototype.floatsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns Float32Array
                 */
                Attribute.prototype.floatsArray = function () {
                    var offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ?
                        new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                };
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                Attribute.prototype.ints = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                };
                /**
                 * @returns number
                 */
                Attribute.prototype.intsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                Attribute.prototype.strings = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Attribute.prototype.stringsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor
                 */
                Attribute.prototype.tensors = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Attribute.prototype.tensorsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Graph= obj
                 * @returns onnxruntime.experimental.fbs.Graph
                 */
                Attribute.prototype.graphs = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Graph())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Attribute.prototype.graphsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Attribute.startAttribute = function (builder) {
                    builder.startObject(13);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                Attribute.addName = function (builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                Attribute.addDocString = function (builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.AttributeType type
                 */
                Attribute.addType = function (builder, type) {
                    builder.addFieldInt32(2, type, onnxruntime.experimental.fbs.AttributeType.UNDEFINED);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number f
                 */
                Attribute.addF = function (builder, f) {
                    builder.addFieldFloat32(3, f, 0.0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long i
                 */
                Attribute.addI = function (builder, i) {
                    builder.addFieldInt64(4, i, builder.createLong(0, 0));
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sOffset
                 */
                Attribute.addS = function (builder, sOffset) {
                    builder.addFieldOffset(5, sOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset tOffset
                 */
                Attribute.addT = function (builder, tOffset) {
                    builder.addFieldOffset(6, tOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset gOffset
                 */
                Attribute.addG = function (builder, gOffset) {
                    builder.addFieldOffset(7, gOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset floatsOffset
                 */
                Attribute.addFloats = function (builder, floatsOffset) {
                    builder.addFieldOffset(8, floatsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                Attribute.createFloatsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addFloat32(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Attribute.startFloatsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset intsOffset
                 */
                Attribute.addInts = function (builder, intsOffset) {
                    builder.addFieldOffset(9, intsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                Attribute.createIntsVector = function (builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Attribute.startIntsVector = function (builder, numElems) {
                    builder.startVector(8, numElems, 8);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset stringsOffset
                 */
                Attribute.addStrings = function (builder, stringsOffset) {
                    builder.addFieldOffset(10, stringsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Attribute.createStringsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Attribute.startStringsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset tensorsOffset
                 */
                Attribute.addTensors = function (builder, tensorsOffset) {
                    builder.addFieldOffset(11, tensorsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Attribute.createTensorsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Attribute.startTensorsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphsOffset
                 */
                Attribute.addGraphs = function (builder, graphsOffset) {
                    builder.addFieldOffset(12, graphsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Attribute.createGraphsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Attribute.startGraphsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Attribute.endAttribute = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Attribute.createAttribute = function (builder, nameOffset, docStringOffset, type, f, i, sOffset, tOffset, gOffset, floatsOffset, intsOffset, stringsOffset, tensorsOffset, graphsOffset) {
                    Attribute.startAttribute(builder);
                    Attribute.addName(builder, nameOffset);
                    Attribute.addDocString(builder, docStringOffset);
                    Attribute.addType(builder, type);
                    Attribute.addF(builder, f);
                    Attribute.addI(builder, i);
                    Attribute.addS(builder, sOffset);
                    Attribute.addT(builder, tOffset);
                    Attribute.addG(builder, gOffset);
                    Attribute.addFloats(builder, floatsOffset);
                    Attribute.addInts(builder, intsOffset);
                    Attribute.addStrings(builder, stringsOffset);
                    Attribute.addTensors(builder, tensorsOffset);
                    Attribute.addGraphs(builder, graphsOffset);
                    return Attribute.endAttribute(builder);
                };
                return Attribute;
            }());
            fbs.Attribute = Attribute;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Graph = /** @class */ (function () {
                function Graph() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Graph
                 */
                Graph.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Graph= obj
                 * @returns Graph
                 */
                Graph.getRootAsGraph = function (bb, obj) {
                    return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Graph= obj
                 * @returns Graph
                 */
                Graph.getSizePrefixedRootAsGraph = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor
                 */
                Graph.prototype.initializers = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.initializersLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.ValueInfo= obj
                 * @returns onnxruntime.experimental.fbs.ValueInfo
                 */
                Graph.prototype.nodeArgs = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.ValueInfo())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.nodeArgsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Node= obj
                 * @returns onnxruntime.experimental.fbs.Node
                 */
                Graph.prototype.nodes = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Node())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.nodesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.maxNodeIndex = function () {
                    var offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.NodeEdge= obj
                 * @returns onnxruntime.experimental.fbs.NodeEdge
                 */
                Graph.prototype.nodeEdges = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? (obj || new onnxruntime.experimental.fbs.NodeEdge())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.nodeEdgesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                Graph.prototype.inputs = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.inputsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                Graph.prototype.outputs = function (index, optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.outputsLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.SparseTensor= obj
                 * @returns onnxruntime.experimental.fbs.SparseTensor
                 */
                Graph.prototype.sparseInitializers = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SparseTensor())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Graph.prototype.sparseInitializersLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Graph.startGraph = function (builder) {
                    builder.startObject(8);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset initializersOffset
                 */
                Graph.addInitializers = function (builder, initializersOffset) {
                    builder.addFieldOffset(0, initializersOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createInitializersVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startInitializersVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodeArgsOffset
                 */
                Graph.addNodeArgs = function (builder, nodeArgsOffset) {
                    builder.addFieldOffset(1, nodeArgsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createNodeArgsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startNodeArgsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodesOffset
                 */
                Graph.addNodes = function (builder, nodesOffset) {
                    builder.addFieldOffset(2, nodesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createNodesVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startNodesVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number maxNodeIndex
                 */
                Graph.addMaxNodeIndex = function (builder, maxNodeIndex) {
                    builder.addFieldInt32(3, maxNodeIndex, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodeEdgesOffset
                 */
                Graph.addNodeEdges = function (builder, nodeEdgesOffset) {
                    builder.addFieldOffset(4, nodeEdgesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createNodeEdgesVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startNodeEdgesVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputsOffset
                 */
                Graph.addInputs = function (builder, inputsOffset) {
                    builder.addFieldOffset(5, inputsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createInputsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startInputsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset outputsOffset
                 */
                Graph.addOutputs = function (builder, outputsOffset) {
                    builder.addFieldOffset(6, outputsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createOutputsVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startOutputsVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sparseInitializersOffset
                 */
                Graph.addSparseInitializers = function (builder, sparseInitializersOffset) {
                    builder.addFieldOffset(7, sparseInitializersOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Graph.createSparseInitializersVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Graph.startSparseInitializersVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Graph.endGraph = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Graph.createGraph = function (builder, initializersOffset, nodeArgsOffset, nodesOffset, maxNodeIndex, nodeEdgesOffset, inputsOffset, outputsOffset, sparseInitializersOffset) {
                    Graph.startGraph(builder);
                    Graph.addInitializers(builder, initializersOffset);
                    Graph.addNodeArgs(builder, nodeArgsOffset);
                    Graph.addNodes(builder, nodesOffset);
                    Graph.addMaxNodeIndex(builder, maxNodeIndex);
                    Graph.addNodeEdges(builder, nodeEdgesOffset);
                    Graph.addInputs(builder, inputsOffset);
                    Graph.addOutputs(builder, outputsOffset);
                    Graph.addSparseInitializers(builder, sparseInitializersOffset);
                    return Graph.endGraph(builder);
                };
                return Graph;
            }());
            fbs.Graph = Graph;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var Model = /** @class */ (function () {
                function Model() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Model
                 */
                Model.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Model= obj
                 * @returns Model
                 */
                Model.getRootAsModel = function (bb, obj) {
                    return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Model= obj
                 * @returns Model
                 */
                Model.getSizePrefixedRootAsModel = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @returns flatbuffers.Long
                 */
                Model.prototype.irVersion = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.OperatorSetId= obj
                 * @returns onnxruntime.experimental.fbs.OperatorSetId
                 */
                Model.prototype.opsetImport = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.OperatorSetId())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                Model.prototype.opsetImportLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                Model.prototype.producerName = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Model.prototype.producerVersion = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                Model.prototype.domain = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @returns flatbuffers.Long
                 */
                Model.prototype.modelVersion = function () {
                    var offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                };
                Model.prototype.docString = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.Graph= obj
                 * @returns onnxruntime.experimental.fbs.Graph|null
                 */
                Model.prototype.graph = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Graph())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                Model.prototype.graphDocString = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                Model.startModel = function (builder) {
                    builder.startObject(9);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long irVersion
                 */
                Model.addIrVersion = function (builder, irVersion) {
                    builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset opsetImportOffset
                 */
                Model.addOpsetImport = function (builder, opsetImportOffset) {
                    builder.addFieldOffset(1, opsetImportOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                Model.createOpsetImportVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                Model.startOpsetImportVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset producerNameOffset
                 */
                Model.addProducerName = function (builder, producerNameOffset) {
                    builder.addFieldOffset(2, producerNameOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset producerVersionOffset
                 */
                Model.addProducerVersion = function (builder, producerVersionOffset) {
                    builder.addFieldOffset(3, producerVersionOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset domainOffset
                 */
                Model.addDomain = function (builder, domainOffset) {
                    builder.addFieldOffset(4, domainOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long modelVersion
                 */
                Model.addModelVersion = function (builder, modelVersion) {
                    builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                Model.addDocString = function (builder, docStringOffset) {
                    builder.addFieldOffset(6, docStringOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphOffset
                 */
                Model.addGraph = function (builder, graphOffset) {
                    builder.addFieldOffset(7, graphOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphDocStringOffset
                 */
                Model.addGraphDocString = function (builder, graphDocStringOffset) {
                    builder.addFieldOffset(8, graphDocStringOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                Model.endModel = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                Model.createModel = function (builder, irVersion, opsetImportOffset, producerNameOffset, producerVersionOffset, domainOffset, modelVersion, docStringOffset, graphOffset, graphDocStringOffset) {
                    Model.startModel(builder);
                    Model.addIrVersion(builder, irVersion);
                    Model.addOpsetImport(builder, opsetImportOffset);
                    Model.addProducerName(builder, producerNameOffset);
                    Model.addProducerVersion(builder, producerVersionOffset);
                    Model.addDomain(builder, domainOffset);
                    Model.addModelVersion(builder, modelVersion);
                    Model.addDocString(builder, docStringOffset);
                    Model.addGraph(builder, graphOffset);
                    Model.addGraphDocString(builder, graphDocStringOffset);
                    return Model.endModel(builder);
                };
                return Model;
            }());
            fbs.Model = Model;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var KernelCreateInfos = /** @class */ (function () {
                function KernelCreateInfos() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns KernelCreateInfos
                 */
                KernelCreateInfos.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param KernelCreateInfos= obj
                 * @returns KernelCreateInfos
                 */
                KernelCreateInfos.getRootAsKernelCreateInfos = function (bb, obj) {
                    return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param KernelCreateInfos= obj
                 * @returns KernelCreateInfos
                 */
                KernelCreateInfos.getSizePrefixedRootAsKernelCreateInfos = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param number index
                 * @returns number
                 */
                KernelCreateInfos.prototype.nodeIndices = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
                };
                /**
                 * @returns number
                 */
                KernelCreateInfos.prototype.nodeIndicesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @returns Uint32Array
                 */
                KernelCreateInfos.prototype.nodeIndicesArray = function () {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ?
                        new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                };
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                KernelCreateInfos.prototype.kernelDefHashes = function (index) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                };
                /**
                 * @returns number
                 */
                KernelCreateInfos.prototype.kernelDefHashesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                KernelCreateInfos.startKernelCreateInfos = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodeIndicesOffset
                 */
                KernelCreateInfos.addNodeIndices = function (builder, nodeIndicesOffset) {
                    builder.addFieldOffset(0, nodeIndicesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                KernelCreateInfos.createNodeIndicesVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt32(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                KernelCreateInfos.startNodeIndicesVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset kernelDefHashesOffset
                 */
                KernelCreateInfos.addKernelDefHashes = function (builder, kernelDefHashesOffset) {
                    builder.addFieldOffset(1, kernelDefHashesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                KernelCreateInfos.createKernelDefHashesVector = function (builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                KernelCreateInfos.startKernelDefHashesVector = function (builder, numElems) {
                    builder.startVector(8, numElems, 8);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                KernelCreateInfos.endKernelCreateInfos = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                KernelCreateInfos.createKernelCreateInfos = function (builder, nodeIndicesOffset, kernelDefHashesOffset) {
                    KernelCreateInfos.startKernelCreateInfos(builder);
                    KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);
                    KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);
                    return KernelCreateInfos.endKernelCreateInfos(builder);
                };
                return KernelCreateInfos;
            }());
            fbs.KernelCreateInfos = KernelCreateInfos;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var SubGraphSessionState = /** @class */ (function () {
                function SubGraphSessionState() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SubGraphSessionState
                 */
                SubGraphSessionState.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SubGraphSessionState= obj
                 * @returns SubGraphSessionState
                 */
                SubGraphSessionState.getRootAsSubGraphSessionState = function (bb, obj) {
                    return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SubGraphSessionState= obj
                 * @returns SubGraphSessionState
                 */
                SubGraphSessionState.getSizePrefixedRootAsSubGraphSessionState = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                SubGraphSessionState.prototype.graphId = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.SessionState= obj
                 * @returns onnxruntime.experimental.fbs.SessionState|null
                 */
                SubGraphSessionState.prototype.sessionState = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                SubGraphSessionState.startSubGraphSessionState = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphIdOffset
                 */
                SubGraphSessionState.addGraphId = function (builder, graphIdOffset) {
                    builder.addFieldOffset(0, graphIdOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sessionStateOffset
                 */
                SubGraphSessionState.addSessionState = function (builder, sessionStateOffset) {
                    builder.addFieldOffset(1, sessionStateOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                SubGraphSessionState.endSubGraphSessionState = function (builder) {
                    var offset = builder.endObject();
                    builder.requiredField(offset, 4); // graph_id
                    return offset;
                };
                SubGraphSessionState.createSubGraphSessionState = function (builder, graphIdOffset, sessionStateOffset) {
                    SubGraphSessionState.startSubGraphSessionState(builder);
                    SubGraphSessionState.addGraphId(builder, graphIdOffset);
                    SubGraphSessionState.addSessionState(builder, sessionStateOffset);
                    return SubGraphSessionState.endSubGraphSessionState(builder);
                };
                return SubGraphSessionState;
            }());
            fbs.SubGraphSessionState = SubGraphSessionState;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var SessionState = /** @class */ (function () {
                function SessionState() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SessionState
                 */
                SessionState.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SessionState= obj
                 * @returns SessionState
                 */
                SessionState.getRootAsSessionState = function (bb, obj) {
                    return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SessionState= obj
                 * @returns SessionState
                 */
                SessionState.getSizePrefixedRootAsSessionState = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj
                 * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null
                 */
                SessionState.prototype.kernels = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.KernelCreateInfos())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj
                 * @returns onnxruntime.experimental.fbs.SubGraphSessionState
                 */
                SessionState.prototype.subGraphSessionStates = function (index, obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SubGraphSessionState())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                };
                /**
                 * @returns number
                 */
                SessionState.prototype.subGraphSessionStatesLength = function () {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                SessionState.startSessionState = function (builder) {
                    builder.startObject(2);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset kernelsOffset
                 */
                SessionState.addKernels = function (builder, kernelsOffset) {
                    builder.addFieldOffset(0, kernelsOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset subGraphSessionStatesOffset
                 */
                SessionState.addSubGraphSessionStates = function (builder, subGraphSessionStatesOffset) {
                    builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                SessionState.createSubGraphSessionStatesVector = function (builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (var i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                SessionState.startSubGraphSessionStatesVector = function (builder, numElems) {
                    builder.startVector(4, numElems, 4);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                SessionState.endSessionState = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                SessionState.createSessionState = function (builder, kernelsOffset, subGraphSessionStatesOffset) {
                    SessionState.startSessionState(builder);
                    SessionState.addKernels(builder, kernelsOffset);
                    SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);
                    return SessionState.endSessionState(builder);
                };
                return SessionState;
            }());
            fbs.SessionState = SessionState;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            var InferenceSession = /** @class */ (function () {
                function InferenceSession() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns InferenceSession
                 */
                InferenceSession.prototype.__init = function (i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param InferenceSession= obj
                 * @returns InferenceSession
                 */
                InferenceSession.getRootAsInferenceSession = function (bb, obj) {
                    return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param InferenceSession= obj
                 * @returns InferenceSession
                 */
                InferenceSession.getSizePrefixedRootAsInferenceSession = function (bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                };
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @returns boolean
                 */
                InferenceSession.bufferHasIdentifier = function (bb) {
                    return bb.__has_identifier('ORTM');
                };
                InferenceSession.prototype.ortVersion = function (optionalEncoding) {
                    var offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.Model= obj
                 * @returns onnxruntime.experimental.fbs.Model|null
                 */
                InferenceSession.prototype.model = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Model())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param onnxruntime.experimental.fbs.SessionState= obj
                 * @returns onnxruntime.experimental.fbs.SessionState|null
                 */
                InferenceSession.prototype.sessionState = function (obj) {
                    var offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                };
                /**
                 * @param flatbuffers.Builder builder
                 */
                InferenceSession.startInferenceSession = function (builder) {
                    builder.startObject(3);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset ortVersionOffset
                 */
                InferenceSession.addOrtVersion = function (builder, ortVersionOffset) {
                    builder.addFieldOffset(0, ortVersionOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset modelOffset
                 */
                InferenceSession.addModel = function (builder, modelOffset) {
                    builder.addFieldOffset(1, modelOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sessionStateOffset
                 */
                InferenceSession.addSessionState = function (builder, sessionStateOffset) {
                    builder.addFieldOffset(2, sessionStateOffset, 0);
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                InferenceSession.endInferenceSession = function (builder) {
                    var offset = builder.endObject();
                    return offset;
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset offset
                 */
                InferenceSession.finishInferenceSessionBuffer = function (builder, offset) {
                    builder.finish(offset, 'ORTM');
                };
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset offset
                 */
                InferenceSession.finishSizePrefixedInferenceSessionBuffer = function (builder, offset) {
                    builder.finish(offset, 'ORTM', true);
                };
                InferenceSession.createInferenceSession = function (builder, ortVersionOffset, modelOffset, sessionStateOffset) {
                    InferenceSession.startInferenceSession(builder);
                    InferenceSession.addOrtVersion(builder, ortVersionOffset);
                    InferenceSession.addModel(builder, modelOffset);
                    InferenceSession.addSessionState(builder, sessionStateOffset);
                    return InferenceSession.endInferenceSession(builder);
                };
                return InferenceSession;
            }());
            fbs.InferenceSession = InferenceSession;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));


/***/ }),

/***/ "./lib/onnxjs/session-handler.ts":
/*!***************************************!*\
  !*** ./lib/onnxjs/session-handler.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnnxjsSessionHandler = void 0;
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
var OnnxjsSessionHandler = /** @class */ (function () {
    function OnnxjsSessionHandler(session) {
        this.session = session;
        this.inputNames = this.session.inputNames;
        this.outputNames = this.session.outputNames;
    }
    OnnxjsSessionHandler.prototype.dispose = function () {
        return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/];
        }); });
    };
    OnnxjsSessionHandler.prototype.run = function (feeds, _fetches, _options) {
        return __awaiter(this, void 0, void 0, function () {
            var inputMap, name_1, feed, outputMap, output;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        inputMap = new Map();
                        for (name_1 in feeds) {
                            if (Object.hasOwnProperty.call(feeds, name_1)) {
                                feed = feeds[name_1];
                                inputMap.set(name_1, new tensor_1.Tensor(feed.dims, feed.type, undefined, undefined, feed.data));
                            }
                        }
                        return [4 /*yield*/, this.session.run(inputMap)];
                    case 1:
                        outputMap = _a.sent();
                        output = {};
                        outputMap.forEach(function (tensor, name) {
                            output[name] = new onnxruntime_common_1.Tensor(tensor.type, tensor.data, tensor.dims);
                        });
                        return [2 /*return*/, output];
                }
            });
        });
    };
    OnnxjsSessionHandler.prototype.startProfiling = function () {
        this.session.startProfiling();
    };
    OnnxjsSessionHandler.prototype.endProfiling = function () {
        this.session.endProfiling();
    };
    return OnnxjsSessionHandler;
}());
exports.OnnxjsSessionHandler = OnnxjsSessionHandler;


/***/ }),

/***/ "./lib/onnxjs/session.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/session.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Session = void 0;
var fs_1 = __webpack_require__(/*! fs */ "?6c45");
var util_1 = __webpack_require__(/*! util */ "?b3a2");
var backend_1 = __webpack_require__(/*! ./backend */ "./lib/onnxjs/backend.ts");
var execution_plan_1 = __webpack_require__(/*! ./execution-plan */ "./lib/onnxjs/execution-plan.ts");
var instrument_1 = __webpack_require__(/*! ./instrument */ "./lib/onnxjs/instrument.ts");
var model_1 = __webpack_require__(/*! ./model */ "./lib/onnxjs/model.ts");
var Session = /** @class */ (function () {
    function Session(config) {
        if (config === void 0) { config = {}; }
        this._initialized = false;
        this.backendHint = config.backendHint;
        this.profiler = instrument_1.Profiler.create(config.profiler);
        this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
    }
    Object.defineProperty(Session.prototype, "inputNames", {
        get: function () {
            return this._model.graph.getInputNames();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "outputNames", {
        get: function () {
            return this._model.graph.getOutputNames();
        },
        enumerable: false,
        configurable: true
    });
    Session.prototype.startProfiling = function () {
        this.profiler.start();
    };
    Session.prototype.endProfiling = function () {
        this.profiler.stop();
    };
    Session.prototype.loadModel = function (arg, byteOffset, length) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.profiler.event('session', 'Session.loadModel', function () { return __awaiter(_this, void 0, void 0, function () {
                            var backend, isOrtFormat, buf, response, buf, arr;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, backend_1.resolveBackend(this.backendHint)];
                                    case 1:
                                        backend = _a.sent();
                                        this.sessionHandler = backend.createSessionHandler(this.context);
                                        this._model = new model_1.Model();
                                        if (!(typeof arg === 'string')) return [3 /*break*/, 7];
                                        isOrtFormat = arg.endsWith('.ort');
                                        if (!(typeof fetch === 'undefined')) return [3 /*break*/, 3];
                                        return [4 /*yield*/, util_1.promisify(fs_1.readFile)(arg)];
                                    case 2:
                                        buf = _a.sent();
                                        this.initialize(Buffer.from(buf), isOrtFormat);
                                        return [3 /*break*/, 6];
                                    case 3: return [4 /*yield*/, fetch(arg)];
                                    case 4:
                                        response = _a.sent();
                                        return [4 /*yield*/, response.arrayBuffer()];
                                    case 5:
                                        buf = _a.sent();
                                        this.initialize(new Uint8Array(buf), isOrtFormat);
                                        _a.label = 6;
                                    case 6: return [3 /*break*/, 8];
                                    case 7:
                                        if (!ArrayBuffer.isView(arg)) {
                                            arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
                                            this.initialize(arr);
                                        }
                                        else {
                                            // load model from Uint8array
                                            this.initialize(arg);
                                        }
                                        _a.label = 8;
                                    case 8: return [2 /*return*/];
                                }
                            });
                        }); })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Session.prototype.initialize = function (modelProtoBlob, isOrtFormat) {
        var _this = this;
        if (this._initialized) {
            throw new Error('already initialized');
        }
        this.profiler.event('session', 'Session.initialize', function () {
            // load graph
            var graphInitializer = _this.sessionHandler.transformGraph ? _this.sessionHandler : undefined;
            _this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);
            // graph is completely initialzied at this stage , let the interested handlers know
            if (_this.sessionHandler.onGraphInitialized) {
                _this.sessionHandler.onGraphInitialized(_this._model.graph);
            }
            // initialize each operator in the graph
            _this.initializeOps(_this._model.graph);
            // instantiate an ExecutionPlan object to be used by the Session object
            _this._executionPlan = new execution_plan_1.ExecutionPlan(_this._model.graph, _this._ops, _this.profiler);
        });
        this._initialized = true;
    };
    Session.prototype.run = function (inputs) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!this._initialized) {
                    throw new Error('session not initialized yet');
                }
                return [2 /*return*/, this.profiler.event('session', 'Session.run', function () { return __awaiter(_this, void 0, void 0, function () {
                        var inputTensors, outputTensors;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    inputTensors = this.normalizeAndValidateInputs(inputs);
                                    return [4 /*yield*/, this._executionPlan.execute(this.sessionHandler, inputTensors)];
                                case 1:
                                    outputTensors = _a.sent();
                                    return [2 /*return*/, this.createOutput(outputTensors)];
                            }
                        });
                    }); })];
            });
        });
    };
    Session.prototype.normalizeAndValidateInputs = function (inputs) {
        var modelInputNames = this._model.graph.getInputNames();
        // normalize inputs
        // inputs: Tensor[]
        if (Array.isArray(inputs)) {
            if (inputs.length !== modelInputNames.length) {
                throw new Error("incorrect input array length: expected " + modelInputNames.length + " but got " + inputs.length);
            }
        }
        // convert map to array
        // inputs: Map<string, Tensor>
        else {
            if (inputs.size !== modelInputNames.length) {
                throw new Error("incorrect input map size: expected " + modelInputNames.length + " but got " + inputs.size);
            }
            var sortedInputs = new Array(inputs.size);
            var sortedInputsIndex = 0;
            for (var i = 0; i < modelInputNames.length; ++i) {
                var tensor = inputs.get(modelInputNames[i]);
                if (!tensor) {
                    throw new Error("missing input tensor for: '" + name + "'");
                }
                sortedInputs[sortedInputsIndex++] = tensor;
            }
            inputs = sortedInputs;
        }
        // validate dims requirements
        // First session run - graph input data is not cached for the session
        if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims ||
            this.context.graphInputDims.length === 0) {
            var modelInputIndices = this._model.graph.getInputIndices();
            var modelValues = this._model.graph.getValues();
            var graphInputDims = new Array(modelInputIndices.length);
            for (var i = 0; i < modelInputIndices.length; ++i) {
                var graphInput = modelValues[modelInputIndices[i]];
                graphInputDims[i] = graphInput.type.shape.dims;
                // cached for second and subsequent runs.
                // Some parts of the framework works on the assumption that the graph and types and shapes are static
                this.context.graphInputTypes.push(graphInput.type.tensorType);
                this.context.graphInputDims.push(inputs[i].dims);
            }
            this.validateInputTensorDims(graphInputDims, inputs, true);
        }
        // Second and subsequent session runs - graph input data is cached for the session
        else {
            this.validateInputTensorDims(this.context.graphInputDims, inputs, false);
        }
        // validate types requirement
        this.validateInputTensorTypes(this.context.graphInputTypes, inputs);
        return inputs;
    };
    Session.prototype.validateInputTensorTypes = function (graphInputTypes, givenInputs) {
        for (var i = 0; i < givenInputs.length; i++) {
            var expectedType = graphInputTypes[i];
            var actualType = givenInputs[i].type;
            if (expectedType !== actualType) {
                throw new Error("input tensor[" + i + "] check failed: expected type '" + expectedType + "' but got " + actualType);
            }
        }
    };
    Session.prototype.validateInputTensorDims = function (graphInputDims, givenInputs, noneDimSupported) {
        for (var i = 0; i < givenInputs.length; i++) {
            var expectedDims = graphInputDims[i];
            var actualDims = givenInputs[i].dims;
            if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {
                throw new Error("input tensor[" + i + "] check failed: expected shape '[" + expectedDims.join(',') + "]' but got [" + actualDims.join(',') + "]");
            }
        }
    };
    Session.prototype.compareTensorDims = function (expectedDims, actualDims, noneDimSupported) {
        if (expectedDims.length !== actualDims.length) {
            return false;
        }
        for (var i = 0; i < expectedDims.length; ++i) {
            if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {
                // data shape mis-match AND not a 'None' dimension.
                return false;
            }
        }
        return true;
    };
    Session.prototype.createOutput = function (outputTensors) {
        var modelOutputNames = this._model.graph.getOutputNames();
        if (outputTensors.length !== modelOutputNames.length) {
            throw new Error('expected number of outputs do not match number of generated outputs');
        }
        var output = new Map();
        for (var i = 0; i < modelOutputNames.length; ++i) {
            output.set(modelOutputNames[i], outputTensors[i]);
        }
        return output;
    };
    Session.prototype.initializeOps = function (graph) {
        var nodes = graph.getNodes();
        this._ops = new Array(nodes.length);
        for (var i = 0; i < nodes.length; i++) {
            this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);
        }
    };
    return Session;
}());
exports.Session = Session;


/***/ }),

/***/ "./lib/onnxjs/tensor.ts":
/*!******************************!*\
  !*** ./lib/onnxjs/tensor.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tensor = void 0;
var guid_typescript_1 = __webpack_require__(/*! guid-typescript */ "./node_modules/guid-typescript/dist/guid.js");
var long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
var onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
var ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
var util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
var Tensor = /** @class */ (function () {
    function Tensor(
    /**
     * get the dimensions of the tensor
     */
    dims, 
    /**
     * get the type of the tensor
     */
    type, dataProvider, asyncDataProvider, cache, 
    /**
     * get the data ID that used to map to a tensor data
     */
    dataId) {
        if (dataId === void 0) { dataId = guid_typescript_1.Guid.create(); }
        this.dims = dims;
        this.type = type;
        this.dataProvider = dataProvider;
        this.asyncDataProvider = asyncDataProvider;
        this.cache = cache;
        this.dataId = dataId;
        this.size = util_1.ShapeUtil.validateDimsAndCalcSize(dims);
        var size = this.size;
        var empty = (dataProvider === undefined && asyncDataProvider === undefined && cache === undefined);
        if (cache !== undefined) {
            if (cache.length !== size) {
                throw new RangeError('Input dims doesn\'t match data length.');
            }
        }
        if (type === 'string') {
            if (cache !== undefined && (!Array.isArray(cache) || !cache.every(function (i) { return typeof i === 'string'; }))) {
                throw new TypeError('cache should be a string array');
            }
            if (empty) {
                this.cache = new Array(size);
            }
        }
        else {
            if (cache !== undefined) {
                var constructor = dataviewConstructor(type);
                if (!(cache instanceof constructor)) {
                    throw new TypeError("cache should be type " + constructor.name);
                }
            }
            if (empty) {
                var buf = new ArrayBuffer(size * sizeof(type));
                this.cache = createView(buf, type);
            }
        }
    }
    Object.defineProperty(Tensor.prototype, "data", {
        /**
         * get the underlying tensor data
         */
        get: function () {
            if (this.cache === undefined) {
                var data = this.dataProvider(this.dataId);
                if (data.length !== this.size) {
                    throw new Error('Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.');
                }
                this.cache = data;
            }
            return this.cache;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tensor.prototype, "stringData", {
        /**
         * get the underlying string tensor data. Should only use when type is STRING
         */
        get: function () {
            if (this.type !== 'string') {
                throw new TypeError('data type is not string');
            }
            return this.data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tensor.prototype, "integerData", {
        /**
         * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
         * INT16, INT32, UINT32, BOOL)
         */
        get: function () {
            switch (this.type) {
                case 'uint8':
                case 'int8':
                case 'uint16':
                case 'int16':
                case 'int32':
                case 'uint32':
                case 'bool':
                    return this.data;
                default:
                    throw new TypeError('data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)');
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tensor.prototype, "floatData", {
        /**
         * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)
         */
        get: function () {
            switch (this.type) {
                case 'float32':
                case 'float64':
                    return this.data;
                default:
                    throw new TypeError('data type is not float (float32, float64)');
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Tensor.prototype, "numberData", {
        /**
         * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
         * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)
         */
        get: function () {
            if (this.type !== 'string') {
                return this.data;
            }
            throw new TypeError('type cannot be non-number (string)');
        },
        enumerable: false,
        configurable: true
    });
    /**
     * get value of an element at the given indices
     */
    Tensor.prototype.get = function (indices) {
        return this.data[util_1.ShapeUtil.indicesToOffset(indices, this.strides)];
    };
    /**
     * set value of an element at the given indices
     */
    Tensor.prototype.set = function (indices, value) {
        this.data[util_1.ShapeUtil.indicesToOffset(indices, this.strides)] = value;
    };
    /**
     * get the underlying tensor data asynchronously
     */
    Tensor.prototype.getData = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.cache === undefined)) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, this.asyncDataProvider(this.dataId)];
                    case 1:
                        _a.cache = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, this.cache];
                }
            });
        });
    };
    Object.defineProperty(Tensor.prototype, "strides", {
        /**
         * get the strides for each dimension
         */
        get: function () {
            if (!this._strides) {
                this._strides = util_1.ShapeUtil.computeStrides(this.dims);
            }
            return this._strides;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Construct new Tensor from a ONNX Tensor object
     * @param tensorProto the ONNX Tensor
     */
    Tensor.fromProto = function (tensorProto) {
        if (!tensorProto) {
            throw new Error('cannot construct Value from an empty tensor');
        }
        var type = util_1.ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType);
        var dims = util_1.ProtoUtil.tensorDimsFromProto(tensorProto.dims);
        var value = new Tensor(dims, type);
        if (type === 'string') {
            // When it's STRING type, the value should always be stored in field
            // 'stringData'
            tensorProto.stringData.forEach(function (str, i) {
                var buf = Buffer.from(str.buffer, str.byteOffset, str.byteLength);
                value.data[i] = buf.toString();
            });
        }
        else if (tensorProto.rawData && typeof tensorProto.rawData.byteLength === 'number' &&
            tensorProto.rawData.byteLength > 0) {
            // NOT considering segment for now (IMPORTANT)
            // populate value from rawData
            var dataDest = value.data;
            var dataSource = new DataView(tensorProto.rawData.buffer, tensorProto.rawData.byteOffset, tensorProto.rawData.byteLength);
            var elementSize = sizeofProto(tensorProto.dataType);
            var length_1 = tensorProto.rawData.byteLength / elementSize;
            if (tensorProto.rawData.byteLength % elementSize !== 0) {
                throw new Error('invalid buffer length');
            }
            if (dataDest.length !== length_1) {
                throw new Error('buffer length mismatch');
            }
            for (var i = 0; i < length_1; i++) {
                var n = readProto(dataSource, tensorProto.dataType, i * elementSize);
                dataDest[i] = n;
            }
        }
        else {
            // populate value from array
            var array = void 0;
            switch (tensorProto.dataType) {
                case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
                    array = tensorProto.floatData;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.INT32:
                case onnx_proto_1.onnx.TensorProto.DataType.INT16:
                case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
                case onnx_proto_1.onnx.TensorProto.DataType.INT8:
                case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
                case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
                    array = tensorProto.int32Data;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.INT64:
                    array = tensorProto.int64Data;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
                    array = tensorProto.doubleData;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
                case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
                    array = tensorProto.uint64Data;
                    break;
                default:
                    // should never run here
                    throw new Error('unspecific error');
            }
            if (array === null || array === undefined) {
                throw new Error('failed to populate data from a tensorproto value');
            }
            var data = value.data;
            if (data.length !== array.length) {
                throw new Error('array length mismatch');
            }
            for (var i = 0; i < array.length; i++) {
                var element = array[i];
                if (long_1.default.isLong(element)) {
                    data[i] = longToNumber(element, tensorProto.dataType);
                }
                else {
                    data[i] = element;
                }
            }
        }
        return value;
    };
    /**
     * Construct new Tensor from raw data
     * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array
     * for other types of tensor.
     * @param dims the dimensions of the tensor
     * @param type the type of the tensor
     */
    Tensor.fromData = function (data, dims, type) {
        return new Tensor(dims, type, undefined, undefined, data);
    };
    Tensor.fromOrtTensor = function (ortTensor) {
        if (!ortTensor) {
            throw new Error('cannot construct Value from an empty tensor');
        }
        var dims = util_1.ProtoUtil.tensorDimsFromORTFormat(ortTensor);
        var type = util_1.ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());
        var value = new Tensor(dims, type);
        if (type === 'string') {
            // When it's STRING type, the value should always be stored in field
            // 'stringData'
            for (var i = 0; i < ortTensor.stringDataLength(); i++) {
                value.data[i] = ortTensor.stringData(i);
            }
        }
        else if (ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === 'number' && ortTensor.rawDataLength() > 0) {
            // NOT considering segment for now (IMPORTANT)
            // populate value from rawData
            var dataDest = value.data;
            var dataSource = new DataView(ortTensor.rawDataArray().buffer, ortTensor.rawDataArray().byteOffset, ortTensor.rawDataLength());
            var elementSize = sizeofProto(ortTensor.dataType());
            var length_2 = ortTensor.rawDataLength() / elementSize;
            if (ortTensor.rawDataLength() % elementSize !== 0) {
                throw new Error('invalid buffer length');
            }
            if (dataDest.length !== length_2) {
                throw new Error('buffer length mismatch');
            }
            for (var i = 0; i < length_2; i++) {
                var n = readProto(dataSource, ortTensor.dataType(), i * elementSize);
                dataDest[i] = n;
            }
        }
        return value;
    };
    return Tensor;
}());
exports.Tensor = Tensor;
function sizeof(type) {
    switch (type) {
        case 'bool':
        case 'int8':
        case 'uint8':
            return 1;
        case 'int16':
        case 'uint16':
            return 2;
        case 'int32':
        case 'uint32':
        case 'float32':
            return 4;
        case 'float64':
            return 8;
        default:
            throw new Error("cannot calculate sizeof() on type " + type);
    }
}
function sizeofProto(type) {
    switch (type) {
        case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
        case onnx_proto_1.onnx.TensorProto.DataType.INT8:
        case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
            return 1;
        case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
        case onnx_proto_1.onnx.TensorProto.DataType.INT16:
            return 2;
        case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
        case onnx_proto_1.onnx.TensorProto.DataType.INT32:
        case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
            return 4;
        case onnx_proto_1.onnx.TensorProto.DataType.INT64:
        case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
        case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
            return 8;
        default:
            throw new Error("cannot calculate sizeof() on type " + onnx_proto_1.onnx.TensorProto.DataType[type]);
    }
}
function createView(dataBuffer, type) {
    return new (dataviewConstructor(type))(dataBuffer);
}
function dataviewConstructor(type) {
    switch (type) {
        case 'bool':
        case 'uint8':
            return Uint8Array;
        case 'int8':
            return Int8Array;
        case 'int16':
            return Int16Array;
        case 'uint16':
            return Uint16Array;
        case 'int32':
            return Int32Array;
        case 'uint32':
            return Uint32Array;
        case 'float32':
            return Float32Array;
        case 'float64':
            return Float64Array;
        default:
            // should never run to here
            throw new Error('unspecified error');
    }
}
// convert a long number to a 32-bit integer (cast-down)
function longToNumber(i, type) {
    // INT64, UINT32, UINT64
    if (type === onnx_proto_1.onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {
        if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {
            throw new TypeError('int64 is not supported');
        }
    }
    else if (type === onnx_proto_1.onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 ||
        type === onnx_proto_1.onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {
        if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {
            throw new TypeError('uint64 is not supported');
        }
    }
    else {
        throw new TypeError("not a LONG type: " + onnx_proto_1.onnx.TensorProto.DataType[type]);
    }
    return i.toNumber();
}
// read one value from TensorProto
function readProto(view, type, byteOffset) {
    switch (type) {
        case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
        case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
            return view.getUint8(byteOffset);
        case onnx_proto_1.onnx.TensorProto.DataType.INT8:
            return view.getInt8(byteOffset);
        case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
            return view.getUint16(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.INT16:
            return view.getInt16(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
            return view.getFloat32(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.INT32:
            return view.getInt32(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
            return view.getUint32(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.INT64:
            return longToNumber(long_1.default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false), type);
        case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
            return view.getFloat64(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
            return longToNumber(long_1.default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true), type);
        default:
            throw new Error("cannot read from DataView for type " + onnx_proto_1.onnx.TensorProto.DataType[type]);
    }
}


/***/ }),

/***/ "./lib/onnxjs/util.ts":
/*!****************************!*\
  !*** ./lib/onnxjs/util.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoolConvUtil = exports.ReduceUtil = exports.SplitUtil = exports.MathUtil = exports.ShapeUtil = exports.LongUtil = exports.ProtoUtil = exports.GemmUtil = exports.arrayCopyHelper = exports.BroadcastUtil = exports.MatMulUtil = exports.ArrayUtil = exports.assert = exports.checkInputsShape = void 0;
var flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/js/flatbuffers.mjs");
var long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
var onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
var tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
// check the inputs shape before running an OP.
// return true when the inputs pass the check
// return false when the inputs do not fit the requirement
// throw exception when fatal error or not implemented
function checkInputsShape(inputs) {
    var expectedDimensions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        expectedDimensions[_i - 1] = arguments[_i];
    }
    if (!inputs || inputs.length !== expectedDimensions.length) {
        return false;
    }
    for (var i = 0; i < inputs.length; i++) {
        if (!inputs[i].dims || inputs[i].dims.length !== expectedDimensions[i]) {
            return false;
        }
    }
    return true;
}
exports.checkInputsShape = checkInputsShape;
// Evaluates the given expression and asserts error message if condition is unmet.
function assert(expr, msg) {
    if (!expr) {
        throw new Error(typeof msg === 'string' ? msg : msg());
    }
}
exports.assert = assert;
var ArrayUtil = /** @class */ (function () {
    function ArrayUtil() {
    }
    /**
     * Verifies if 2 input arrays contain the same elements.
     * @param n1 Array 1
     * @param n2 Array 2
     * @returns Whether these 2 are equal
     */
    ArrayUtil.arraysEqual = function (n1, n2) {
        if (n1.length !== n2.length) {
            return false;
        }
        for (var i = 0; i < n1.length; i++) {
            if (n1[i] !== n2[i]) {
                return false;
            }
        }
        return true;
    };
    return ArrayUtil;
}());
exports.ArrayUtil = ArrayUtil;
var MatMulUtil = /** @class */ (function () {
    function MatMulUtil() {
    }
    /**
     * Fix the input shapes for MatMul operation if they need fixing
     * @param dimsA The shape of tensor A. Should be an array of positive integers
     * @param dimsB The shape of tensor B. Should be an array of positive integers
     * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications
     */
    MatMulUtil.preprocessInputShapes = function (dimsA, dimsB) {
        // If the first argument is 1-D, it is promoted to a matrix by prepending
        // a 1 to its dimensions. After matrix multiplication the prepended 1 is
        // removed.
        var a = (dimsA.length === 1) ? [1, dimsA[0]] : dimsA;
        // If the second argument is 1-D, it is promoted to a matrix by appending
        // a 1 to its dimensions. After matrix multiplication the appended 1 is
        // removed.
        var b = (dimsB.length === 1) ? [dimsB[0], 1] : dimsB;
        return [a, b];
    };
    /**
     * Fix the output shape computed for MatMul operation if it needs fixing
     * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.
     * This will be mutated.
     * @param aRank The rank of tensor A.
     * @param bRank The rank of tensor B.
     */
    MatMulUtil.postprocessOutputShape = function (outputShape, aRank, bRank) {
        // Remove prepended dimension if first input is 1d
        if (aRank === 1) {
            // outputShape = outputShape.slice(0, outputShape.length - 2).concat(outputShape.slice(outputShape.length - 1));
            outputShape.splice(outputShape.length - 2, 1);
        }
        // Remove appended dimension if second input is 1d
        if (bRank === 1) {
            outputShape.pop();
        }
    };
    /**
     * Calculate the expected shape when matrix multiplication
     * @param a The shape of tensor A. Should be a tuple of 2 positive integers
     * @param b The shape of tensor B. Should be a tuple of 2 positive integers
     * @returns The expected shape of the result, or undefined if N/A
     */
    MatMulUtil.calcMatMulShape = function (a, b) {
        return (a[1] !== b[0]) ? undefined : [a[0], b[1]];
    };
    return MatMulUtil;
}());
exports.MatMulUtil = MatMulUtil;
var BroadcastUtil = /** @class */ (function () {
    function BroadcastUtil() {
    }
    /**
     * Calculate the expected shape when broadcasting 2 tensors
     * @param a The shape of tensor A. Should be an array of positive integers
     * @param b The shape of tensor B. Should be an array of positive integers
     * @param isMatMul Whether the operation is MatMul
     * @returns The expected shape of the result, or undefined if N/A
     */
    BroadcastUtil.calcShape = function (adims, bdims, isMatMul) {
        var _a;
        if (isMatMul === void 0) { isMatMul = false; }
        var arank = adims.length;
        var brank = bdims.length;
        if (arank === 0) {
            return bdims;
        }
        if (brank === 0) {
            return adims;
        }
        var crank = Math.max(adims.length, bdims.length);
        var cdims = new Array(crank);
        // calculate the last 2 dimension if it is MatMul
        if (isMatMul) {
            if (arank < 2 || brank < 2) {
                return undefined;
            }
            var cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);
            if (cShapeMatMul === undefined) {
                return undefined;
            }
            _a = __read(cShapeMatMul, 2), cdims[crank - 2] = _a[0], cdims[crank - 1] = _a[1];
        }
        for (var i = isMatMul ? 3 : 1; i <= crank; i++) {
            var aLen = arank - i < 0 ? 1 : adims[arank - i];
            var bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
                return undefined;
            }
            cdims[crank - i] = Math.max(aLen, bLen);
        }
        return cdims;
    };
    /**
     * Given the indices of a broadcasted tensor, calculate the original indices
     * @param broadcastedIndices The given indices of the broadcasted tensor.
     * @param originalShape The original shape of the tensor before broadcas
     * @returns The calculated indices that maps to the original tensor.
     */
    BroadcastUtil.index = function (broadcastedIndices, originalShape) {
        // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same
        // length as the broadcasted shape, and for each dimension the index should
        // not be out of range.
        var originalIndices = new Array(originalShape.length);
        BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);
        return originalIndices;
    };
    /**
     * Given the indices of a broadcasted tensor, calculate the original indices
     * @param broadcastedIndices The given indices of the broadcasted tensor.
     * @param originalShape The original shape of the tensor before broadcast
     * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be
     *     mutated).
     */
    BroadcastUtil.fillIndex = function (broadcastedIndices, originalShape, originalIndices) {
        // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same length as the
        // broadcasted shape, and for each dimension the index should not be out of range.
        // NOTE 2: we assume the parameter originalIndices has the same length as the originalShape
        var dimOffset = broadcastedIndices.length - originalShape.length;
        for (var i = 0; i < originalShape.length; i++) {
            originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];
        }
    };
    /**
     * Perform the broadcasting operation on the specific operator
     * @param a The input tensor A
     * @param b The input tensor B
     * @param op The operator lambda function
     * @param inplace Whether to write the result back to A.
     * @returns The result tensor, or undefined if input not broadcastable.
     */
    BroadcastUtil.calc = function (a, b, op, inplace, resultType) {
        var outputShape = BroadcastUtil.calcShape(a.dims, b.dims);
        if (outputShape) {
            if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {
                // B is not broadcastable to A, failed to calculate inplace.
                return undefined;
            }
            var size = ShapeUtil.size(outputShape);
            var c = inplace ? a : new tensor_1.Tensor(outputShape, resultType || a.type);
            // both inputs are scalars
            if (outputShape.length === 0) {
                c.set([], op(a.get([]), b.get([])));
            }
            // atleast one input is a non-scalar
            else {
                var outputIndices = new Array(outputShape.length);
                var originalIndicesA = new Array(a.dims.length);
                var originalIndicesB = new Array(b.dims.length);
                var valA = 0;
                var valB = 0;
                var isAScalar = false;
                var isBScalar = false;
                if (a.dims.length === 0) {
                    valA = a.get([]);
                    isAScalar = true;
                }
                if (b.dims.length === 0) {
                    valB = b.get([]);
                    isBScalar = true;
                }
                var rest = void 0;
                for (var i = 0; i < size; i++) {
                    // traversal indices
                    rest = i;
                    for (var j = outputShape.length - 1; j >= 0; j--) {
                        outputIndices[j] = rest % outputShape[j];
                        rest = Math.floor(rest / outputShape[j]);
                    }
                    if (!isAScalar) {
                        // map outputIndices (which is actually broadcasted) to the originalIndices
                        BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);
                        valA = a.get(originalIndicesA);
                    }
                    if (!isBScalar) {
                        BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);
                        valB = b.get(originalIndicesB);
                    }
                    c.set(outputIndices, op(valA, valB));
                }
            }
            return c;
        }
        return undefined;
    };
    /**
     * Determine if a shape is unidirectional broadcastable to another shape
     * @param shape The input shape
     * @param finalShape The desired shape after broadcasting
     */
    BroadcastUtil.isValidBroadcast = function (shape, finalShape) {
        // align shape to the right
        var inputRank = shape.length;
        var finalRank = finalShape.length;
        if (inputRank > finalRank) {
            return false;
        }
        for (var i = 1; i <= inputRank; i++) {
            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
                return false;
            }
        }
        return true;
    };
    /**
     * Determine the broadcasted dims in input shape based on the given output shape.
     * Note that this function only returns the broadcasted dims.
     * @param inputShape The input shape
     * @param outputShape The output shape
     * @returns The broadcasted dims in input shape.
     */
    BroadcastUtil.getBroadcastDims = function (inputShape, outputShape) {
        var inRank = inputShape.length;
        var dims = [];
        for (var i = 0; i < inRank; i++) {
            var dim = inRank - 1 - i;
            var a = inputShape[dim] || 1;
            var b = outputShape[outputShape.length - 1 - i] || 1;
            if (b > 1 && a === 1) {
                dims.unshift(dim);
            }
        }
        return dims;
    };
    return BroadcastUtil;
}());
exports.BroadcastUtil = BroadcastUtil;
// copy array helper
// mimics memcpy as much as possible
function arrayCopyHelper(target, source, targetIndex, sourceIndex, blockSize) {
    if (sourceIndex < 0 || sourceIndex >= source.length) {
        throw new Error('sourceIndex out of bounds');
    }
    if (targetIndex < 0 || targetIndex >= target.length) {
        throw new Error('targetIndex out of bounds');
    }
    if (sourceIndex + blockSize > source.length) {
        throw new Error('source indices to be copied are outside bounds');
    }
    if (targetIndex + blockSize > target.length) {
        throw new Error('target array is too small to hold result');
    }
    for (var offset = 0; offset < blockSize; offset++) {
        target[targetIndex + offset] = source[sourceIndex + offset];
    }
}
exports.arrayCopyHelper = arrayCopyHelper;
var GemmUtil = /** @class */ (function () {
    function GemmUtil() {
    }
    // will make sure input shapes are compatible for this op
    // and return back the shape of the output in the form of a tuple
    // will throw exception if the input shapes are not compatible
    GemmUtil.getShapeOfGemmResult = function (leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error('shape need to be of size 2');
        }
        var M;
        var K;
        var N;
        if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
        }
        else {
            M = leftShape[0];
            K = leftShape[1];
        }
        var kDim = -1;
        if (transRight) {
            N = rightShape[0];
            kDim = 1;
        }
        else {
            N = rightShape[1];
            kDim = 0;
        }
        if (rightShape[kDim] !== K) {
            throw new Error('dimension mismatch');
        }
        if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error('invalid shape specified');
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error('gemm: invalid bias shape for broadcast');
        }
        return [M, N, K];
    };
    return GemmUtil;
}());
exports.GemmUtil = GemmUtil;
var ProtoUtil = /** @class */ (function () {
    function ProtoUtil() {
    }
    ProtoUtil.tensorDataTypeFromProto = function (typeProto) {
        switch (typeProto) {
            case onnx_proto_1.onnx.TensorProto.DataType.INT8:
                return 'int8';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
                return 'uint8';
            case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
                return 'bool';
            case onnx_proto_1.onnx.TensorProto.DataType.INT16:
                return 'int16';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
                return 'uint16';
            case onnx_proto_1.onnx.TensorProto.DataType.INT32:
                return 'int32';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
                return 'uint32';
            case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
                return 'float32';
            case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
                return 'float64';
            case onnx_proto_1.onnx.TensorProto.DataType.STRING:
                return 'string';
            // For INT64/UINT64, reduce their value to 32-bits.
            // Should throw exception when overflow
            case onnx_proto_1.onnx.TensorProto.DataType.INT64:
                return 'int32';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
                return 'uint32';
            default:
                throw new Error("unsupported data type: " + onnx_proto_1.onnx.TensorProto.DataType[typeProto]);
        }
    };
    ProtoUtil.tensorDataTypeStringToEnum = function (type) {
        switch (type) {
            case 'int8':
                return onnx_proto_1.onnx.TensorProto.DataType.INT8;
            case 'uint8':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT8;
            case 'bool':
                return onnx_proto_1.onnx.TensorProto.DataType.BOOL;
            case 'int16':
                return onnx_proto_1.onnx.TensorProto.DataType.INT16;
            case 'uint16':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT16;
            case 'int32':
                return onnx_proto_1.onnx.TensorProto.DataType.INT32;
            case 'uint32':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT32;
            case 'float32':
                return onnx_proto_1.onnx.TensorProto.DataType.FLOAT;
            case 'float64':
                return onnx_proto_1.onnx.TensorProto.DataType.DOUBLE;
            case 'string':
                return onnx_proto_1.onnx.TensorProto.DataType.STRING;
            case 'int64':
                return onnx_proto_1.onnx.TensorProto.DataType.INT64;
            case 'uint64':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT64;
            default:
                throw new Error("unsupported data type: " + type);
        }
    };
    ProtoUtil.tensorDimsFromProto = function (dims) {
        // get rid of Long type for dims
        return dims.map(function (d) { return long_1.default.isLong(d) ? d.toNumber() : d; });
    };
    ProtoUtil.tensorValueTypeFromProto = function (valueType) {
        return {
            tensorType: ProtoUtil.tensorDataTypeFromProto(valueType.elemType),
            shape: { dims: ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map(function (d) { return d.dimValue; })) }
        };
    };
    ProtoUtil.tensorDimsFromORTFormat = function (tensor) {
        var dims = [];
        for (var i = 0; i < tensor.dimsLength(); i++) {
            dims.push(LongUtil.longToNumber(tensor.dims(i)));
        }
        return dims;
    };
    ProtoUtil.tensorAttributesFromORTFormat = function (node) {
        var attributes = [];
        for (var i = 0; i < node.attributesLength(); i++) {
            attributes.push(node.attributes(i));
        }
        return attributes;
    };
    return ProtoUtil;
}());
exports.ProtoUtil = ProtoUtil;
var LongUtil = /** @class */ (function () {
    function LongUtil() {
    }
    LongUtil.longToNumber = function (n) {
        if (long_1.default.isLong(n)) {
            return n.toNumber();
        }
        else if (n instanceof flatbuffers_1.flatbuffers.Long) {
            return long_1.default.fromValue({ low: n.low, high: n.high, unsigned: true }).toNumber();
        }
        return n;
    };
    LongUtil.isLong = function (n) {
        return long_1.default.isLong(n) || n instanceof flatbuffers_1.flatbuffers.Long;
    };
    return LongUtil;
}());
exports.LongUtil = LongUtil;
var ShapeUtil = /** @class */ (function () {
    function ShapeUtil() {
    }
    ShapeUtil.size = function (dims) {
        return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
    };
    // `axis` inclusive
    ShapeUtil.sizeFromDimension = function (dims, axis) {
        if (axis < 0 || axis > dims.length) {
            throw new Error("invalid dimension of " + axis + " for sizeFromDimension as Tensor has " + dims.length + " dimensions.");
        }
        return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
    };
    // `axis` exclusive
    ShapeUtil.sizeToDimension = function (dims, axis) {
        if (axis < 0 || axis > dims.length) {
            throw new Error("invalid dimension of " + axis + " for sizeToDimension as Tensor has " + dims.length + " dimensions.");
        }
        return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
    };
    ShapeUtil.getSizeFromDimensionRange = function (dims, start, end) {
        var size = 1;
        for (var i = start; i < end; i++) {
            // safety check as this method is called by multiple other methods requiring size.
            // size cannot be 0 or negative.
            if (dims[i] <= 0) {
                throw new Error(
                // eslint-disable-next-line max-len
                'cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.');
            }
            size *= dims[i];
        }
        return size;
    };
    ShapeUtil.computeStrides = function (dims) {
        var rank = dims.length;
        if (rank === 0) {
            return [];
        }
        else if (rank === 1) {
            return [1];
        }
        var strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
    };
    ShapeUtil.transpose = function (dims) {
        var copy = dims.slice();
        return copy.reverse();
    };
    ShapeUtil.indicesToOffset = function (indices, strides, axis) {
        if (axis === undefined) {
            axis = indices.length;
        }
        var offset = 0;
        for (var i = 0; i < axis; ++i) {
            offset += strides[i] * indices[i];
        }
        return offset;
    };
    ShapeUtil.offsetToIndices = function (offset, strides) {
        var rank = strides.length;
        if (rank === 0) {
            return [];
        }
        else if (rank === 1) {
            return [offset * strides[0]];
        }
        var indices = new Array(strides.length);
        for (var i = 0; i < indices.length - 1; ++i) {
            indices[i] = Math.floor(offset / strides[i]);
            offset -= indices[i] * strides[i];
        }
        indices[indices.length - 1] = offset;
        return indices;
    };
    /**
     * normailze axis of range [-r, r) into [0, r).
     */
    ShapeUtil.normalizeAxis = function (axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error('unsupported axis for this operation.');
        }
        return axis < 0 ? axis + tensorRank : axis;
    };
    ShapeUtil.normalizeAxes = function (axes, tensorRank) {
        var _this = this;
        return axes.map(function (x) { return _this.normalizeAxis(x, tensorRank); });
    };
    // Increment an index into a tensor (in lexicographic
    // ordering), wrapping around the specified upper_bound.
    /**
     * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.
     * @param index Given index to increment (Will be mutated)
     * @param dims The dimensions of the tensor for which the given index corresponds to
     * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank
     */
    ShapeUtil.incrementIndex = function (index, dims, axisToIncrementOn) {
        if (dims.length === 0 || index.length === 0) {
            throw new Error('Index incrementing unsupported for scalar Tensor');
        }
        if (axisToIncrementOn === undefined) {
            axisToIncrementOn = dims.length;
        }
        else {
            if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {
                throw new Error('Incorrect axis to increment on');
            }
        }
        for (var k = axisToIncrementOn - 1; k >= 0; --k) {
            index[k]++;
            if (index[k] < dims[k]) {
                break;
            }
            index[k] = 0;
        }
    };
    /**
     * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array
     * Used in Reshape
     * @param originalDims Original Shape array
     * @param shapeHints array containing values to compute the new dimensions
     * For example:
     * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]
     * originalDims = [2,2] and shapeHints = [4] will return [4]
     * originalDims = [2,2] and shapeHints = [5] will throw an exception
     * https://github.com/onnx/onnx/blob/master/docs/Operators.md#Reshape
     */
    ShapeUtil.calculateReshapedDims = function (originalDims, shapeHints) {
        // reshape to a Scalar Tensor
        if (shapeHints.length === 0) {
            if (originalDims.length === 0 || ShapeUtil.size(originalDims) === 1) {
                return [];
            }
            else {
                throw new Error('cannot reshape to a scalar Tensor');
            }
        }
        var nDims = shapeHints.length;
        var reshapedDims = new Array(nDims);
        var unknownDimension = -1;
        var newTensorSize = 1;
        for (var i = 0; i < nDims; i++) {
            if (shapeHints[i] < -1) {
                throw new Error('a dimension in shape hints cannot be less than -1');
            }
            if (shapeHints[i] === -1) {
                if (unknownDimension !== -1) {
                    throw new Error('at most one dimension in shape hints can be -1');
                }
                unknownDimension = i;
            }
            else {
                if (shapeHints[i] === 0) {
                    if (i >= originalDims.length) {
                        throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');
                    }
                    reshapedDims[i] = originalDims[i];
                }
                else {
                    reshapedDims[i] = shapeHints[i];
                }
                newTensorSize *= reshapedDims[i];
            }
        }
        var oldTensorSize = ShapeUtil.size(originalDims);
        if (unknownDimension !== -1) {
            if (oldTensorSize % newTensorSize !== 0) {
                throw new Error("the input tensor cannot be reshaped to the requested shape. Input shape: [" + originalDims + "] Output shape: [" + shapeHints + "]");
            }
            reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;
        }
        // validate sizes from originalDims and reshapedDims match
        else {
            if (newTensorSize !== oldTensorSize) {
                throw new Error('reshapedDims and originalDims don\'t have matching sizes');
            }
        }
        return reshapedDims;
    };
    /**
     * Sorts a given array based on the indices in the Perm array
     * Used in Transpose
     * @param a Array to be sorted such as dims or strides
     * @param perm Perm given; if null a will be reversed
     */
    ShapeUtil.sortBasedOnPerm = function (a, perm) {
        if (perm) {
            return perm.map(function (v) { return a[v]; });
        }
        else {
            return a.slice().reverse();
        }
    };
    /**
     * Pads a given shape according to the padding values
     * @param dims shape of the Tensor to be padded
     * @param pad pad values
     */
    ShapeUtil.padShape = function (dims, pad) {
        var rank = dims.length;
        return dims.map(function (v, i) { return v + pad[i] + pad[i + rank]; });
    };
    /**
     * Determines if the two shapes are identical
     * @param shape1
     * @param shape2
     */
    ShapeUtil.areEqual = function (shape1, shape2) {
        if (shape1.length !== shape2.length) {
            return false;
        }
        return shape1.every(function (v, i) { return v === shape2[i]; });
    };
    /**
     * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size
     * @param dims - input `dims` that needs to be checked
     */
    ShapeUtil.validateDimsAndCalcSize = function (dims) {
        var e_1, _a;
        if (dims.length > 6) {
            throw new TypeError('Only rank 0 to 6 is supported for tensor shape.');
        }
        var size = 1;
        try {
            for (var dims_1 = __values(dims), dims_1_1 = dims_1.next(); !dims_1_1.done; dims_1_1 = dims_1.next()) {
                var n = dims_1_1.value;
                if (!Number.isInteger(n)) {
                    throw new TypeError("Invalid shape: " + n + " is not an integer");
                }
                if (n < 0 || n > 2147483647) {
                    throw new TypeError("Invalid shape: length " + n + " is not allowed");
                }
                size *= n;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (dims_1_1 && !dims_1_1.done && (_a = dims_1.return)) _a.call(dims_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return size;
    };
    /**
     * Determines the shape of output tensor y = flatten(x, axis)
     * @param dims - shape of input tensor
     * @param axis - flatten axis, in the range [-r, r]
     */
    ShapeUtil.flattenShape = function (dims, axis) {
        if (axis < 0) {
            axis += dims.length;
        }
        var total = dims.reduce(function (x, y) { return x * y; }, 1);
        var right = dims.slice(axis).reduce(function (x, y) { return x * y; }, 1);
        var outputDims = [total / right, right];
        return outputDims;
    };
    /**
     * Determines the shape of output tensor y = squeeze(x, axes)
     * @param dims - shape of input tensor
     * @param axes - squeeze axes
     */
    ShapeUtil.squeezeShape = function (dims, axes) {
        var outputDims = new Array();
        // sanity check
        axes = ShapeUtil.normalizeAxes(axes, dims.length);
        for (var i = 0; i < dims.length; i++) {
            var inSqueezeList = axes.indexOf(i) >= 0;
            if (inSqueezeList && dims[i] !== 1) {
                throw new Error('squeeze an axis of size different than 1');
            }
            if ((axes.length === 0 && dims[i] > 1) || (axes.length > 0 && !inSqueezeList)) {
                outputDims.push(dims[i]);
            }
        }
        return outputDims;
    };
    /**
     * Determines the shape of output tensor y = unsqueeze(x, axes)
     * @param dims - shape of input tensor
     * @param axes - unsqueeze axes
     */
    ShapeUtil.unsqueezeShape = function (dims, axes) {
        var outputDims = new Array(dims.length + axes.length);
        // initialize the array elements to 0
        outputDims.fill(0);
        // set all axes indices to 1 in outputDims and check for duplicates
        for (var i = 0; i < axes.length; i++) {
            var axis = ShapeUtil.normalizeAxis(axes[i], dims.length);
            if (axis >= outputDims.length) {
                throw new Error('\'axes\' has an out of range axis');
            }
            if (outputDims[axis] !== 0) {
                throw new Error('\'axes\' has a duplicate axis');
            }
            outputDims[axis] = 1;
        }
        // fill in the zero entries of outputDims with the input tensor's shape
        var inputDimsIterator = 0;
        for (var i = 0; i < outputDims.length; i++) {
            if (outputDims[i] === 0) {
                outputDims[i] = dims[inputDimsIterator++];
            }
        }
        // sanity check assertion. 'inputDimsIterator'
        // should be equal to the length of 'dims'
        if (inputDimsIterator !== dims.length) {
            throw new Error('the unsqueezed dimension could not be established');
        }
        return outputDims;
    };
    return ShapeUtil;
}());
exports.ShapeUtil = ShapeUtil;
// bunch of helper methods that do a variety of math operations
var MathUtil = /** @class */ (function () {
    function MathUtil() {
    }
    // y = (x*x) + y
    MathUtil.sqr = function (target, source, targetIndex, sourceIndex, blockSize) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (var offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] += Math.pow(source[sourceIndex + offset], 2);
        }
    };
    // y = ax + y
    MathUtil.axpy = function (target, source, targetIndex, sourceIndex, blockSize, alpha) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (var offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] += (alpha * source[sourceIndex + offset]);
        }
    };
    // y = pow(x, b)
    MathUtil.powx = function (target, source, targetIndex, sourceIndex, blockSize, b) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (var offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] = Math.pow(source[sourceIndex + offset], b);
        }
    };
    // y = x * y
    MathUtil.mul = function (target, source, targetIndex, sourceIndex, blockSize) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (var offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] = (source[sourceIndex + offset] * target[targetIndex + offset]);
        }
    };
    return MathUtil;
}());
exports.MathUtil = MathUtil;
var SplitUtil = /** @class */ (function () {
    function SplitUtil() {
    }
    /**
     * Calculates new Shapes from existing one and the splits given along the axis provides
     * @param dims Shape of the Tensor to be splitted into two or more Shapes
     * @param axis The dimension along which the Tensor will be split
     * @param splits Offsets for the start of each split
     */
    SplitUtil.splitShape = function (dims, axis, split, numOutputs) {
        if (split.length === 0) {
            if (!numOutputs) {
                throw new Error('need to know number of outputs when the \'split\' attribute is not specified');
            }
            SplitUtil.determineSplit(dims[axis], numOutputs, split);
        }
        var shapes = [];
        var offsets = [0];
        for (var i = 0; i < split.length; ++i) {
            if (i !== 0) {
                offsets.push(offsets[i - 1] + split[i - 1]);
            }
            var shape = dims.slice();
            shape[axis] = split[i];
            shapes.push(shape);
        }
        return [shapes, offsets];
    };
    SplitUtil.determineSplit = function (numElementsAlongAxis, numOutputs, split) {
        // If 'split' is not specified by the user, we need to partition the number of elements equally among the outputs
        if (numElementsAlongAxis % numOutputs !== 0) {
            throw new Error('cannot split tensor to equal sized parts');
        }
        for (var i = 0; i < numOutputs; ++i) {
            split.push(numElementsAlongAxis / numOutputs);
        }
    };
    return SplitUtil;
}());
exports.SplitUtil = SplitUtil;
var ReduceUtil = /** @class */ (function () {
    function ReduceUtil() {
    }
    /**
     * Perform reduce operations on the specific operator
     * @param a Input tensor data
     * @param axes The dimensions along which the Tensor will be reduced
     * @param keepdims If set to true, the axes which are reduced are left in the
     *    result as dimensions with size one.
     * @param op1 The operation to be performed on each element in the tensor
     * @param op2 The operation to be performed between elements in the tensor
     */
    ReduceUtil.calcReduce = function (a, axes, keepdims, op1, op2) {
        var dims = a.dims.slice(0);
        // if axes is not set, perform reduce on all axes
        if (axes.length === 0) {
            dims.forEach(function (d, ind) { return axes.push(ind); });
        }
        // get a temporary broadcastable output shape
        var outputDims = ReduceUtil.calcReduceShape(dims, axes, true);
        // loop through the output and calculate result one by one
        var size = ShapeUtil.size(outputDims);
        var y = new tensor_1.Tensor(outputDims, a.type);
        var strides = ShapeUtil.computeStrides(outputDims);
        var inputStrides = ShapeUtil.computeStrides(dims);
        var indicesY = new Array(dims.length);
        for (var i = 0; i < size; i++) {
            var indices = ShapeUtil.offsetToIndices(i, strides);
            // map index
            BroadcastUtil.fillIndex(indices, dims, indicesY);
            y.set(indices, ReduceUtil.calcReduceByAxis(a.numberData, axes, dims, 0, ShapeUtil.indicesToOffset(indicesY, inputStrides), op1, op2));
        }
        if (keepdims) {
            return y;
        }
        else {
            // keepdims == 0, calculate the expected shape
            return new tensor_1.Tensor(ReduceUtil.calcReduceShape(dims, axes, keepdims), y.type, undefined, undefined, y.data, y.dataId);
        }
    };
    /**
     * Perform reduce operations on the specific operator on specific axes
     * @param a Input tensor data
     * @param axes The dimensions along which the Tensor will be reduced
     * @param dims The input dimension.
     * @param curAxisInd Index in axes specifying the current dimension along
     *      which the tensor will be reduced
     * @param pos The current index of element to perform operation
     * @param op1 The operation to be performed on each element in the tensor
     * @param op2 The operation to be performed between elements in the tensor
     */
    ReduceUtil.calcReduceByAxis = function (input, axes, dims, curAxisInd, pos, op1, op2) {
        var res = 0;
        if (curAxisInd >= axes.length) {
            return op1(input[pos]);
        }
        var axis = axes[curAxisInd];
        var step = axis >= dims.length ? 1 : ShapeUtil.size(dims.slice(axis + 1));
        for (var i = 0; i < dims[axis]; i++) {
            res = i === 0 ? ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2) :
                op2(res, ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2));
            pos += step;
        }
        return res;
    };
    /**
     * Calculate the expected shape of a reduce operation
     * @param dims The input tensor dimension
     * @param axes The dimensions along which the Tensor will be reduced
     * @param keepdims If set to true, the axes which are reduced are left in the
     *    result as dimensions with size one.
     */
    ReduceUtil.calcReduceShape = function (dims, axes, keepDims) {
        var outputDims = dims.slice();
        for (var i = 0; i < axes.length; i++) {
            if (keepDims) {
                outputDims[axes[i]] = 1;
            }
            else {
                outputDims[axes[i]] = 0;
            }
        }
        return outputDims.filter(function (dim) { return dim !== 0; });
    };
    return ReduceUtil;
}());
exports.ReduceUtil = ReduceUtil;
var PoolConvUtil = /** @class */ (function () {
    function PoolConvUtil() {
    }
    /**
     * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
     * @param isGlobalOperator If true, perform global pooling.
     * @param inputDims The input tensor dimension.
     * @param kernelShape The size of the kernel along each axis.
     * @param strides Stride along each axis.
     * @param pads Padding for the beginning and ending along each axis.
     */
    PoolConvUtil.adjustPoolAttributes = function (isGlobalOperator, inputDims, kernelShape, strides, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error('length of specified kernel shapes should be 2 less than length of input dimensions');
        }
        if (isGlobalOperator) {
            // adjust kernel shape to cover the input dims
            for (var dim = 0; dim < inputDims.length - 2; dim++) {
                if (dim >= kernelShape.length) {
                    kernelShape.push(inputDims[dim + 2]);
                }
                else {
                    kernelShape[dim] = inputDims[dim + 2];
                }
            }
        }
        // adjust strides length to match kernel shape length
        for (var dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
                if (strides[dim] < 0) {
                    throw new Error('strides should be greater than or equal to 1');
                }
            }
            else {
                strides.push(1);
            }
        }
        // adjust pads length to match 2 * kernel shape length
        for (var dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
                if (pads[dim] < 0) {
                    throw new Error('pad should be greater than or equal to 1');
                }
            }
            else {
                pads.push(0);
            }
        }
        // sanity checks for values in kernel shapes and pads
        for (var dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
                throw new Error('kernel shapes need to be greater than 0');
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
                throw new Error('pads should be smaller than kernel');
            }
        }
    };
    // adjust pad values based on 'autoPad' attribute
    PoolConvUtil.adjustPadsBasedOnAutoPad = function (inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (!autoPad) {
            return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error('length of pads should be twice the length of data dimensions');
        }
        if (strides.length !== (inputDims.length - 2)) {
            throw new Error('length of strides should be the length of data dimensions');
        }
        if (kernelShape.length !== (inputDims.length - 2)) {
            throw new Error('length of kernel shapes should be the length of data dimensions');
        }
        for (var dim = 0; dim < inputDims.length - 2; dim++) {
            PoolConvUtil.adjustPadAndReturnShape(inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2, autoPad);
        }
    };
    /**
     * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
     * @param isGlobalOperator If true, perform global pooling.
     * @param inputDims The input tensor dimension. (inputs[0].dims)
     * @param strides Stride along each axis.
     * @param kernelShape The size of the kernel along each axis.
     * @param pads Padding for the beginning and ending along each axis.
     * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
     *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
     */
    PoolConvUtil.computePoolOutputShape = function (isGlobalOperator, inputDims, strides, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
            throw new Error('input shape must be of size greater than 0');
        }
        // Add batch size and number of channels of output
        var outputDims = [inputDims[0], inputDims[1]];
        // TODO: support dilations for pool operators
        var dilations = new Array(kernelShape.length).fill(1);
        PoolConvUtil.computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
    };
    /**
     * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
     * @param inputDims The input tensor dimension. (inputs[0].dims)
     * @param filterDims The filter tensor dimension. (inputs[1].dims)
     * @param strides Stride along each axis.
     * @param kernelShape The size of the kernel along each axis.
     * @param pads Padding for the beginning and ending along each axis.
     * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
     *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
     */
    PoolConvUtil.computeConvOutputShape = function (inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error('invalid input tensor dims or invalid filter tensor dims');
        }
        // Add batch size and number of channels of output
        var outputDims = [inputDims[0], filterDims[0]];
        PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
    };
    // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
    // called by computePoolOutputShape() and computeConvOutputShape()
    // adjust pads based on 'autoPad' attribute prior to shape computation
    PoolConvUtil.computeShapeHelper = function (isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
            for (var dim = 0; dim < inputDims.length - 2; dim++) {
                outputDims.push(1);
            }
        }
        else {
            for (var dim = 0; dim < inputDims.length - 2; dim++) {
                outputDims.push(PoolConvUtil.adjustPadAndReturnShape(inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2, autoPad));
            }
        }
    };
    // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
    // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
    PoolConvUtil.adjustPadAndReturnShape = function (inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        var dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== 'NOTSET') {
            switch (autoPad) {
                case 'VALID':
                    pads[padHeadIndex] = 0;
                    pads[padTailIndex] = 0;
                    return Math.floor(((inSize - dkernel) / stride) + 1);
                case 'SAME_LOWER':
                case 'SAME_UPPER':
                    if (dilation !== 1) {
                        throw new Error('Dilation not supported for SAME_UPPER or SAME_LOWER');
                    }
                    else {
                        var legacyTargetSize = (inSize + stride - 1) / stride;
                        var padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                        pads[padHeadIndex] =
                            (autoPad === 'SAME_LOWER') ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                        pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                        return Math.floor(((inSize + padNeeded - kernel) / stride) + 1);
                    }
                default:
                    throw new Error('Unsupported AutoPad type');
            }
        }
        else {
            return Math.floor(((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride) + 1);
        }
    };
    return PoolConvUtil;
}());
exports.PoolConvUtil = PoolConvUtil;


/***/ }),

/***/ "./lib/wasm/options-utils.ts":
/*!***********************************!*\
  !*** ./lib/wasm/options-utils.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iterateExtraOptions = void 0;
var iterateExtraOptions = function (options, prefix, seen, handler) {
    if (typeof options == 'object' && options !== null) {
        if (seen.has(options)) {
            throw new Error('Circular reference in options');
        }
        else {
            seen.add(options);
        }
    }
    Object.entries(options).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        var name = (prefix) ? prefix + key : key;
        if (typeof value === 'object') {
            exports.iterateExtraOptions(value, name + '.', seen, handler);
        }
        else if (typeof value === 'string' || typeof value === 'number') {
            handler(name, value.toString());
        }
        else if (typeof value === 'boolean') {
            handler(name, (value) ? '1' : '0');
        }
        else {
            throw new Error("Can't handle extra config type: " + typeof value);
        }
    });
};
exports.iterateExtraOptions = iterateExtraOptions;


/***/ }),

/***/ "./lib/wasm/run-options.ts":
/*!*********************************!*\
  !*** ./lib/wasm/run-options.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setRunOptions = void 0;
var options_utils_1 = __webpack_require__(/*! ./options-utils */ "./lib/wasm/options-utils.ts");
var string_utils_1 = __webpack_require__(/*! ./string-utils */ "./lib/wasm/string-utils.ts");
var wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
var setRunOptions = function (options) {
    var wasm = wasm_factory_1.getInstance();
    var runOptionsHandle = 0;
    var allocs = [];
    var runOptions = options || {};
    try {
        if ((options === null || options === void 0 ? void 0 : options.logSeverityLevel) === undefined) {
            runOptions.logSeverityLevel = 2; // Default to warning
        }
        else if (typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||
            options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error("log serverity level is not valid: " + options.logSeverityLevel);
        }
        if ((options === null || options === void 0 ? void 0 : options.logVerbosityLevel) === undefined) {
            runOptions.logVerbosityLevel = 0; // Default to 0
        }
        else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error("log verbosity level is not valid: " + options.logVerbosityLevel);
        }
        if ((options === null || options === void 0 ? void 0 : options.terminate) === undefined) {
            runOptions.terminate = false;
        }
        var tagDataOffset = 0;
        if ((options === null || options === void 0 ? void 0 : options.tag) !== undefined) {
            tagDataOffset = string_utils_1.allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm._OrtCreateRunOptions(runOptions.logSeverityLevel, runOptions.logVerbosityLevel, !!runOptions.terminate, tagDataOffset);
        if (runOptionsHandle === 0) {
            throw new Error('Can\'t create run options');
        }
        if ((options === null || options === void 0 ? void 0 : options.extra) !== undefined) {
            options_utils_1.iterateExtraOptions(options.extra, '', new WeakSet(), function (key, value) {
                var keyDataOffset = string_utils_1.allocWasmString(key, allocs);
                var valueDataOffset = string_utils_1.allocWasmString(value, allocs);
                if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    throw new Error("Can't set a run config entry: " + key + " - " + value);
                }
            });
        }
        return [runOptionsHandle, allocs];
    }
    catch (e) {
        if (runOptionsHandle !== 0) {
            wasm._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach(wasm._free);
        throw e;
    }
};
exports.setRunOptions = setRunOptions;


/***/ }),

/***/ "./lib/wasm/session-handler.ts":
/*!*************************************!*\
  !*** ./lib/wasm/session-handler.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnnxruntimeWebAssemblySessionHandler = void 0;
var onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var run_options_1 = __webpack_require__(/*! ./run-options */ "./lib/wasm/run-options.ts");
var session_options_1 = __webpack_require__(/*! ./session-options */ "./lib/wasm/session-options.ts");
var string_utils_1 = __webpack_require__(/*! ./string-utils */ "./lib/wasm/string-utils.ts");
var wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
var ortInit;
var tensorDataTypeStringToEnum = function (type) {
    switch (type) {
        case 'int8':
            return onnx_proto_1.onnx.TensorProto.DataType.INT8;
        case 'uint8':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT8;
        case 'bool':
            return onnx_proto_1.onnx.TensorProto.DataType.BOOL;
        case 'int16':
            return onnx_proto_1.onnx.TensorProto.DataType.INT16;
        case 'uint16':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT16;
        case 'int32':
            return onnx_proto_1.onnx.TensorProto.DataType.INT32;
        case 'uint32':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT32;
        case 'float32':
            return onnx_proto_1.onnx.TensorProto.DataType.FLOAT;
        case 'float64':
            return onnx_proto_1.onnx.TensorProto.DataType.DOUBLE;
        case 'string':
            return onnx_proto_1.onnx.TensorProto.DataType.STRING;
        case 'int64':
            return onnx_proto_1.onnx.TensorProto.DataType.INT64;
        case 'uint64':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT64;
        default:
            throw new Error("unsupported data type: " + type);
    }
};
var tensorDataTypeEnumToString = function (typeProto) {
    switch (typeProto) {
        case onnx_proto_1.onnx.TensorProto.DataType.INT8:
            return 'int8';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
            return 'uint8';
        case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
            return 'bool';
        case onnx_proto_1.onnx.TensorProto.DataType.INT16:
            return 'int16';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
            return 'uint16';
        case onnx_proto_1.onnx.TensorProto.DataType.INT32:
            return 'int32';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
            return 'uint32';
        case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
            return 'float32';
        case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
            return 'float64';
        case onnx_proto_1.onnx.TensorProto.DataType.STRING:
            return 'string';
        case onnx_proto_1.onnx.TensorProto.DataType.INT64:
            return 'int32';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
            return 'uint32';
        default:
            throw new Error("unsupported data type: " + onnx_proto_1.onnx.TensorProto.DataType[typeProto]);
    }
};
var numericTensorTypeToTypedArray = function (type) {
    switch (type) {
        case 'float32':
            return Float32Array;
        case 'uint8':
            return Uint8Array;
        case 'int8':
            return Int8Array;
        case 'uint16':
            return Uint16Array;
        case 'int16':
            return Int16Array;
        case 'int32':
            return Int32Array;
        case 'bool':
            return Uint8Array;
        case 'float64':
            return Float64Array;
        case 'uint32':
            return Uint32Array;
        case 'int64':
            return BigInt64Array;
        case 'uint64':
            return BigUint64Array;
        default:
            throw new Error("unsupported type: " + type);
    }
};
var getLogLevel = function (logLevel) {
    switch (logLevel) {
        case 'verbose':
            return 0;
        case 'info':
            return 1;
        case 'warning':
            return 2;
        case 'error':
            return 3;
        case 'fatal':
            return 4;
        default:
            throw new Error("unsupported logging level: " + logLevel);
    }
};
var OnnxruntimeWebAssemblySessionHandler = /** @class */ (function () {
    function OnnxruntimeWebAssemblySessionHandler() {
    }
    OnnxruntimeWebAssemblySessionHandler.prototype.loadModel = function (model, options) {
        var _a;
        var wasm = wasm_factory_1.getInstance();
        if (!ortInit) {
            var errorCode = wasm._OrtInit(onnxruntime_common_1.env.wasm.numThreads, getLogLevel(onnxruntime_common_1.env.logLevel));
            if (errorCode !== 0) {
                throw new Error("Can't initialize onnxruntime. error code = " + errorCode);
            }
            ortInit = true;
        }
        var modelDataOffset = wasm._malloc(model.byteLength);
        var sessionOptionsHandle = 0;
        var allocs = [];
        try {
            _a = __read(session_options_1.setSessionOptions(options), 2), sessionOptionsHandle = _a[0], allocs = _a[1];
            wasm.HEAPU8.set(model, modelDataOffset);
            this.sessionHandle = wasm._OrtCreateSession(modelDataOffset, model.byteLength, sessionOptionsHandle);
            if (this.sessionHandle === 0) {
                throw new Error('Can\'t create a session');
            }
        }
        finally {
            wasm._free(modelDataOffset);
            wasm._OrtReleaseSessionOptions(sessionOptionsHandle);
            allocs.forEach(wasm._free);
        }
        var inputCount = wasm._OrtGetInputCount(this.sessionHandle);
        var outputCount = wasm._OrtGetOutputCount(this.sessionHandle);
        this.inputNames = [];
        this.inputNamesUTF8Encoded = [];
        this.outputNames = [];
        this.outputNamesUTF8Encoded = [];
        for (var i = 0; i < inputCount; i++) {
            var name_1 = wasm._OrtGetInputName(this.sessionHandle, i);
            if (name_1 === 0) {
                throw new Error('Can\'t get an input name');
            }
            this.inputNamesUTF8Encoded.push(name_1);
            this.inputNames.push(wasm.UTF8ToString(name_1));
        }
        for (var i = 0; i < outputCount; i++) {
            var name_2 = wasm._OrtGetOutputName(this.sessionHandle, i);
            if (name_2 === 0) {
                throw new Error('Can\'t get an output name');
            }
            this.outputNamesUTF8Encoded.push(name_2);
            this.outputNames.push(wasm.UTF8ToString(name_2));
        }
    };
    OnnxruntimeWebAssemblySessionHandler.prototype.dispose = function () {
        return __awaiter(this, void 0, void 0, function () {
            var wasm;
            return __generator(this, function (_a) {
                wasm = wasm_factory_1.getInstance();
                if (this.inputNamesUTF8Encoded) {
                    this.inputNamesUTF8Encoded.forEach(wasm._OrtFree);
                    this.inputNamesUTF8Encoded = [];
                }
                if (this.outputNamesUTF8Encoded) {
                    this.outputNamesUTF8Encoded.forEach(wasm._OrtFree);
                    this.outputNamesUTF8Encoded = [];
                }
                if (this.sessionHandle) {
                    wasm._OrtReleaseSession(this.sessionHandle);
                    this.sessionHandle = 0;
                }
                return [2 /*return*/];
            });
        });
    };
    OnnxruntimeWebAssemblySessionHandler.prototype.run = function (feeds, fetches, options) {
        return __awaiter(this, void 0, void 0, function () {
            var wasm, inputArray, inputIndices, outputIndices, inputCount, outputCount, runOptionsHandle, runOptionsAllocs, inputValues, inputAllocs, _loop_1, i, beforeRunStack, inputValuesOffset, inputNamesOffset, outputValuesOffset, outputNamesOffset, inputValuesIndex, inputNamesIndex, outputValuesIndex, outputNamesIndex, i, i, errorCode, output, i, tensor, beforeGetTensorDataStack, tensorDataOffset, type, dataOffset, tensorDataIndex, dataType, dimsOffset, dimsLength, dims, i_1, size, stringData, dataIndex, i_2, offset, maxBytesToRead, typedArray, t;
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                wasm = wasm_factory_1.getInstance();
                inputArray = [];
                inputIndices = [];
                Object.entries(feeds).forEach(function (kvp) {
                    var name = kvp[0];
                    var tensor = kvp[1];
                    var index = _this.inputNames.indexOf(name);
                    if (index === -1) {
                        throw new Error("invalid input '" + name + "'");
                    }
                    inputArray.push(tensor);
                    inputIndices.push(index);
                });
                outputIndices = [];
                Object.entries(fetches).forEach(function (kvp) {
                    var name = kvp[0];
                    // TODO: support pre-allocated output
                    var index = _this.outputNames.indexOf(name);
                    if (index === -1) {
                        throw new Error("invalid output '" + name + "'");
                    }
                    outputIndices.push(index);
                });
                inputCount = inputIndices.length;
                outputCount = outputIndices.length;
                runOptionsHandle = 0;
                runOptionsAllocs = [];
                inputValues = [];
                inputAllocs = [];
                try {
                    _a = __read(run_options_1.setRunOptions(options), 2), runOptionsHandle = _a[0], runOptionsAllocs = _a[1];
                    _loop_1 = function (i) {
                        var data = inputArray[i].data;
                        var dataOffset = void 0;
                        var dataByteLength = void 0;
                        if (Array.isArray(data)) {
                            // string tensor
                            dataByteLength = 4 * data.length;
                            dataOffset = wasm._malloc(dataByteLength);
                            inputAllocs.push(dataOffset);
                            var dataIndex = dataOffset / 4;
                            for (var i_3 = 0; i_3 < data.length; i_3++) {
                                if (typeof data[i_3] !== 'string') {
                                    throw new TypeError("tensor data at index " + i_3 + " is not a string");
                                }
                                wasm.HEAPU32[dataIndex++] = string_utils_1.allocWasmString(data[i_3], inputAllocs);
                            }
                        }
                        else {
                            dataByteLength = data.byteLength;
                            dataOffset = wasm._malloc(dataByteLength);
                            inputAllocs.push(dataOffset);
                            wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), dataOffset);
                        }
                        var dims = inputArray[i].dims;
                        var stack = wasm.stackSave();
                        var dimsOffset = wasm.stackAlloc(4 * dims.length);
                        try {
                            var dimIndex_1 = dimsOffset / 4;
                            dims.forEach(function (d) { return wasm.HEAP32[dimIndex_1++] = d; });
                            var tensor = wasm._OrtCreateTensor(tensorDataTypeStringToEnum(inputArray[i].type), dataOffset, dataByteLength, dimsOffset, dims.length);
                            if (tensor === 0) {
                                throw new Error('Can\'t create a tensor');
                            }
                            inputValues.push(tensor);
                        }
                        finally {
                            wasm.stackRestore(stack);
                        }
                    };
                    // create input tensors
                    for (i = 0; i < inputCount; i++) {
                        _loop_1(i);
                    }
                    beforeRunStack = wasm.stackSave();
                    inputValuesOffset = wasm.stackAlloc(inputCount * 4);
                    inputNamesOffset = wasm.stackAlloc(inputCount * 4);
                    outputValuesOffset = wasm.stackAlloc(outputCount * 4);
                    outputNamesOffset = wasm.stackAlloc(outputCount * 4);
                    try {
                        inputValuesIndex = inputValuesOffset / 4;
                        inputNamesIndex = inputNamesOffset / 4;
                        outputValuesIndex = outputValuesOffset / 4;
                        outputNamesIndex = outputNamesOffset / 4;
                        for (i = 0; i < inputCount; i++) {
                            wasm.HEAPU32[inputValuesIndex++] = inputValues[i];
                            wasm.HEAPU32[inputNamesIndex++] = this.inputNamesUTF8Encoded[inputIndices[i]];
                        }
                        for (i = 0; i < outputCount; i++) {
                            wasm.HEAPU32[outputValuesIndex++] = 0;
                            wasm.HEAPU32[outputNamesIndex++] = this.outputNamesUTF8Encoded[outputIndices[i]];
                        }
                        errorCode = wasm._OrtRun(this.sessionHandle, inputNamesOffset, inputValuesOffset, inputCount, outputNamesOffset, outputCount, outputValuesOffset, runOptionsHandle);
                        output = {};
                        if (errorCode === 0) {
                            for (i = 0; i < outputCount; i++) {
                                tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];
                                beforeGetTensorDataStack = wasm.stackSave();
                                tensorDataOffset = wasm.stackAlloc(4 * 4);
                                type = void 0, dataOffset = 0;
                                try {
                                    errorCode = wasm._OrtGetTensorData(tensor, tensorDataOffset, tensorDataOffset + 4, tensorDataOffset + 8, tensorDataOffset + 12);
                                    if (errorCode !== 0) {
                                        throw new Error("Can't get a tensor data. error code = " + errorCode);
                                    }
                                    tensorDataIndex = tensorDataOffset / 4;
                                    dataType = wasm.HEAPU32[tensorDataIndex++];
                                    dataOffset = wasm.HEAPU32[tensorDataIndex++];
                                    dimsOffset = wasm.HEAPU32[tensorDataIndex++];
                                    dimsLength = wasm.HEAPU32[tensorDataIndex++];
                                    dims = [];
                                    for (i_1 = 0; i_1 < dimsLength; i_1++) {
                                        dims.push(wasm.HEAPU32[dimsOffset / 4 + i_1]);
                                    }
                                    wasm._OrtFree(dimsOffset);
                                    size = dims.length === 0 ? 1 : dims.reduce(function (a, b) { return a * b; });
                                    type = tensorDataTypeEnumToString(dataType);
                                    if (type === 'string') {
                                        stringData = [];
                                        dataIndex = dataOffset / 4;
                                        for (i_2 = 0; i_2 < size; i_2++) {
                                            offset = wasm.HEAPU32[dataIndex++];
                                            maxBytesToRead = i_2 === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;
                                            stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));
                                        }
                                        output[this.outputNames[outputIndices[i]]] = new onnxruntime_common_1.Tensor('string', stringData, dims);
                                    }
                                    else {
                                        typedArray = numericTensorTypeToTypedArray(type);
                                        t = new onnxruntime_common_1.Tensor(type, new typedArray(size), dims);
                                        new Uint8Array(t.data.buffer, t.data.byteOffset, t.data.byteLength)
                                            .set(wasm.HEAPU8.subarray(dataOffset, dataOffset + t.data.byteLength));
                                        output[this.outputNames[outputIndices[i]]] = t;
                                    }
                                }
                                finally {
                                    wasm.stackRestore(beforeGetTensorDataStack);
                                    if (type === 'string' && dataOffset) {
                                        wasm._free(dataOffset);
                                    }
                                    wasm._OrtReleaseTensor(tensor);
                                }
                            }
                        }
                        if (errorCode === 0) {
                            return [2 /*return*/, output];
                        }
                        else {
                            throw new Error("failed to call OrtRun(). error code = " + errorCode + ".");
                        }
                    }
                    finally {
                        wasm.stackRestore(beforeRunStack);
                    }
                }
                finally {
                    inputValues.forEach(wasm._OrtReleaseTensor);
                    inputAllocs.forEach(wasm._free);
                    wasm._OrtReleaseRunOptions(runOptionsHandle);
                    runOptionsAllocs.forEach(wasm._free);
                }
                return [2 /*return*/];
            });
        });
    };
    OnnxruntimeWebAssemblySessionHandler.prototype.startProfiling = function () {
        // TODO: implement profiling
    };
    OnnxruntimeWebAssemblySessionHandler.prototype.endProfiling = function () {
        // TODO: implement profiling
    };
    return OnnxruntimeWebAssemblySessionHandler;
}());
exports.OnnxruntimeWebAssemblySessionHandler = OnnxruntimeWebAssemblySessionHandler;


/***/ }),

/***/ "./lib/wasm/session-options.ts":
/*!*************************************!*\
  !*** ./lib/wasm/session-options.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSessionOptions = void 0;
var options_utils_1 = __webpack_require__(/*! ./options-utils */ "./lib/wasm/options-utils.ts");
var string_utils_1 = __webpack_require__(/*! ./string-utils */ "./lib/wasm/string-utils.ts");
var wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
var getGraphOptimzationLevel = function (graphOptimizationLevel) {
    switch (graphOptimizationLevel) {
        case 'disabled':
            return 0;
        case 'basic':
            return 1;
        case 'extended':
            return 2;
        case 'all':
            return 99;
        default:
            throw new Error("unsupported graph optimization level: " + graphOptimizationLevel);
    }
};
var getExecutionMode = function (executionMode) {
    switch (executionMode) {
        case 'sequential':
            return 0;
        case 'parallel':
            return 1;
        default:
            throw new Error("unsupported execution mode: " + executionMode);
    }
};
var setSessionOptions = function (options) {
    var wasm = wasm_factory_1.getInstance();
    var sessionOptionsHandle = 0;
    var allocs = [];
    var sessionOptions = options || {};
    try {
        if ((options === null || options === void 0 ? void 0 : options.graphOptimizationLevel) === undefined) {
            sessionOptions.graphOptimizationLevel = 'all';
        }
        var graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel);
        if ((options === null || options === void 0 ? void 0 : options.enableCpuMemArena) === undefined) {
            sessionOptions.enableCpuMemArena = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.enableMemPattern) === undefined) {
            sessionOptions.enableMemPattern = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.executionMode) === undefined) {
            sessionOptions.executionMode = 'sequential';
        }
        var executionMode = getExecutionMode(sessionOptions.executionMode);
        var logIdDataOffset = 0;
        if ((options === null || options === void 0 ? void 0 : options.logId) !== undefined) {
            logIdDataOffset = string_utils_1.allocWasmString(options.logId, allocs);
        }
        if ((options === null || options === void 0 ? void 0 : options.logSeverityLevel) === undefined) {
            sessionOptions.logSeverityLevel = 2; // Default to warning
        }
        else if (typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||
            options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error("log serverity level is not valid: " + options.logSeverityLevel);
        }
        if ((options === null || options === void 0 ? void 0 : options.logVerbosityLevel) === undefined) {
            sessionOptions.logVerbosityLevel = 0; // Default to 0
        }
        else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error("log verbosity level is not valid: " + options.logVerbosityLevel);
        }
        // TODO: Support profiling
        sessionOptions.enableProfiling = false;
        sessionOptionsHandle = wasm._OrtCreateSessionOptions(graphOptimizationLevel, !!sessionOptions.enableCpuMemArena, !!sessionOptions.enableMemPattern, executionMode, sessionOptions.enableProfiling, 0, logIdDataOffset, sessionOptions.logSeverityLevel, sessionOptions.logVerbosityLevel);
        if (sessionOptionsHandle === 0) {
            throw new Error('Can\'t create session options');
        }
        if ((options === null || options === void 0 ? void 0 : options.extra) !== undefined) {
            options_utils_1.iterateExtraOptions(options.extra, '', new WeakSet(), function (key, value) {
                var keyDataOffset = string_utils_1.allocWasmString(key, allocs);
                var valueDataOffset = string_utils_1.allocWasmString(value, allocs);
                if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    throw new Error("Can't set a session config entry: " + key + " - " + value);
                }
            });
        }
        if (options === null || options === void 0 ? void 0 : options.executionProviders) {
            var eps = options.executionProviders;
            var epsNames = eps.map(function (i) { return typeof i === 'string' ? i : i.name; });
            if (epsNames.indexOf('webnn') !== -1) {
                if (wasm._OrtSessionOptionsAppendExecutionProviderWebNN(sessionOptionsHandle, 0) !== 0) {
                    throw new Error("Can't append WebNN execution provider");
                }
            }
        }
        return [sessionOptionsHandle, allocs];
    }
    catch (e) {
        if (sessionOptionsHandle !== 0) {
            wasm._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach(wasm._free);
        throw e;
    }
};
exports.setSessionOptions = setSessionOptions;


/***/ }),

/***/ "./lib/wasm/string-utils.ts":
/*!**********************************!*\
  !*** ./lib/wasm/string-utils.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.allocWasmString = void 0;
var wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
var allocWasmString = function (data, allocs) {
    var wasm = wasm_factory_1.getInstance();
    var dataLength = wasm.lengthBytesUTF8(data) + 1;
    var dataOffset = wasm._malloc(dataLength);
    wasm.stringToUTF8(data, dataOffset, dataLength);
    allocs.push(dataOffset);
    return dataOffset;
};
exports.allocWasmString = allocWasmString;


/***/ }),

/***/ "./lib/wasm/wasm-factory.ts":
/*!**********************************!*\
  !*** ./lib/wasm/wasm-factory.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __dirname = "/";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = exports.getInstance = exports.initializeWebAssembly = void 0;
var onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "../common/dist/lib/index.js");
var path = __importStar(__webpack_require__(/*! path */ "?7aa5"));
var ort_wasm_threaded_js_1 = __importDefault(__webpack_require__(/*! ./binding/ort-wasm-threaded.js */ "./lib/wasm/binding/ort-wasm-threaded.js"));
var ort_wasm_js_1 = __importDefault(__webpack_require__(/*! ./binding/ort-wasm.js */ "./lib/wasm/binding/ort-wasm.js"));
var wasm;
var initialized = false;
var initializing = false;
var aborted = false;
var isMultiThreadSupported = function () {
    try {
        if ((typeof process !== 'undefined') &&
            (typeof process.versions !== 'undefined') &&
            (typeof process.versions.node !== 'undefined')) {
            throw Error('Threads is not supported in Node.js');
        }
        // Test for transferability of SABs (for browsers. needed for Firefox)
        // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ
        if (typeof MessageChannel !== 'undefined') {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        // Test for WebAssembly threads capability (for both browsers and Node.js)
        // This typed array is a WebAssembly program containing threaded instructions.
        return WebAssembly.validate(new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5,
            4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11
        ]));
    }
    catch (e) {
        return false;
    }
};
var isSimdSupported = function () {
    try {
        // Test for WebAssembly SIMD capability (for both browsers and Node.js)
        // This typed array is a WebAssembly program containing SIMD instructions.
        return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]));
    }
    catch (e) {
        return false;
    }
};
var initializeWebAssembly = function () { return __awaiter(void 0, void 0, void 0, function () {
    var timeout, numThreads, simd, useThreads, useSimd, isTimeout, tasks;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (initialized) {
                    return [2 /*return*/, Promise.resolve()];
                }
                if (initializing) {
                    throw new Error('multiple calls to \'initializeWebAssembly()\' detected.');
                }
                if (aborted) {
                    throw new Error('previous call to \'initializeWebAssembly()\' failed.');
                }
                initializing = true;
                timeout = onnxruntime_common_1.env.wasm.initTimeout;
                numThreads = onnxruntime_common_1.env.wasm.numThreads;
                simd = onnxruntime_common_1.env.wasm.simd;
                useThreads = numThreads > 1 && isMultiThreadSupported();
                useSimd = simd && isSimdSupported();
                isTimeout = false;
                tasks = [];
                // promise for timeout
                if (timeout > 0) {
                    tasks.push(new Promise(function (resolve) {
                        setTimeout(function () {
                            isTimeout = true;
                            resolve();
                        }, timeout);
                    }));
                }
                // promise for module initialization
                tasks.push(new Promise(function (resolve, reject) {
                    var factory = useThreads ? ort_wasm_threaded_js_1.default : ort_wasm_js_1.default;
                    var config = {};
                    if (!useThreads) {
                        config.locateFile = function (fileName, scriptDirectory) {
                            if (useSimd && fileName === 'ort-wasm.wasm') {
                                return scriptDirectory + 'ort-wasm-simd.wasm';
                            }
                            return scriptDirectory + fileName;
                        };
                    }
                    else {
                        if (typeof Blob === 'undefined') {
                            config.mainScriptUrlOrBlob = path.join(__dirname, 'ort-wasm-threaded.js');
                        }
                        else {
                            var scriptSourceCode = "var ortWasmThreaded=(function(){var _scriptDir;return " + ort_wasm_threaded_js_1.default.toString() + "})();";
                            config.mainScriptUrlOrBlob = new Blob([scriptSourceCode], { type: 'text/javascript' });
                            config.locateFile = function (fileName, scriptDirectory) {
                                if (fileName.endsWith('.worker.js')) {
                                    return URL.createObjectURL(new Blob([
                                        // This require() function is handled by webpack to load file content of the corresponding .worker.js
                                        // eslint-disable-next-line @typescript-eslint/no-require-imports
                                        __webpack_require__(/*! ./binding/ort-wasm-threaded.worker.js */ "./lib/wasm/binding/ort-wasm-threaded.worker.js")
                                    ], { type: 'text/javascript' }));
                                }
                                if (useSimd && fileName === 'ort-wasm-threaded.wasm') {
                                    return scriptDirectory + 'ort-wasm-simd-threaded.wasm';
                                }
                                return scriptDirectory + fileName;
                            };
                        }
                    }
                    factory(config).then(
                    // wasm module initialized successfully
                    function (module) {
                        initializing = false;
                        initialized = true;
                        wasm = module;
                        resolve();
                    }, 
                    // wasm module failed to initialize
                    function (what) {
                        initializing = false;
                        aborted = true;
                        reject(what);
                    });
                }));
                return [4 /*yield*/, Promise.race(tasks)];
            case 1:
                _a.sent();
                if (isTimeout) {
                    throw new Error("WebAssembly backend initializing failed due to timeout: " + timeout + "ms");
                }
                return [2 /*return*/];
        }
    });
}); };
exports.initializeWebAssembly = initializeWebAssembly;
var getInstance = function () {
    if (initialized) {
        return wasm;
    }
    throw new Error('WebAssembly is not initialized yet.');
};
exports.getInstance = getInstance;
var dispose = function () {
    var _a;
    if (initialized && !initializing && !aborted) {
        initializing = true;
        (_a = wasm.PThread) === null || _a === void 0 ? void 0 : _a.terminateAllThreads();
        initializing = false;
        initialized = false;
        aborted = true;
    }
};
exports.dispose = dispose;


/***/ }),

/***/ "?6c45":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?b3a2":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?63c8":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?aedb":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?75c6":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?674f":
/*!****************************!*\
  !*** perf_hooks (ignored) ***!
  \****************************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?c6f7":
/*!********************************!*\
  !*** worker_threads (ignored) ***!
  \********************************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?7aa5":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?d87b":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?0757":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ "?334c":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function() {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcnQvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL29ydC8uLi9jb21tb24vZGlzdC9saWIvYmFja2VuZC1pbXBsLmpzIiwid2VicGFjazovL29ydC8uLi9jb21tb24vZGlzdC9saWIvYmFja2VuZC5qcyIsIndlYnBhY2s6Ly9vcnQvLi4vY29tbW9uL2Rpc3QvbGliL2Vudi1pbXBsLmpzIiwid2VicGFjazovL29ydC8uLi9jb21tb24vZGlzdC9saWIvZW52LmpzIiwid2VicGFjazovL29ydC8uLi9jb21tb24vZGlzdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb3J0Ly4uL2NvbW1vbi9kaXN0L2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzIiwid2VicGFjazovL29ydC8uLi9jb21tb24vZGlzdC9saWIvaW5mZXJlbmNlLXNlc3Npb24uanMiLCJ3ZWJwYWNrOi8vb3J0Ly4uL2NvbW1vbi9kaXN0L2xpYi9vbm54LXZhbHVlLmpzIiwid2VicGFjazovL29ydC8uLi9jb21tb24vZGlzdC9saWIvdGVuc29yLWltcGwuanMiLCJ3ZWJwYWNrOi8vb3J0Ly4uL2NvbW1vbi9kaXN0L2xpYi90ZW5zb3IuanMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL3dhc20vYmluZGluZy9vcnQtd2FzbS10aHJlYWRlZC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvd2FzbS9iaW5kaW5nL29ydC13YXNtLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvaW5xdWlyZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvdXRmOC9pbmRleC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvanMvZmxhdGJ1ZmZlcnMubWpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9ndWlkLXR5cGVzY3JpcHQvZGlzdC9ndWlkLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9vbm54LXByb3RvL2Rpc3Qvb25ueC5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzIiwid2VicGFjazovL29ydC8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcyIsIndlYnBhY2s6Ly9vcnQvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvYmFja2VuZC1vbm54anMudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL2JhY2tlbmQtd2FzbS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9hdHRyaWJ1dGUudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvYmFja2VuZC13ZWJnbC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtY29vcmRpbmF0ZS1saWIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWRlZmluaXRpb25zLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1lbmNvZGluZy1saWIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWZyYWdjb2xvci1saWIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWZ1bmN0aW9uLWlubGluZXIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXByZXByb2Nlc3Nvci50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtcmVnaXN0ZXJlZC1saWJzLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1zaGFwZS11dGlscy1saWIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXNvdXJjZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtdmVjLWxpYi50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2luZmVyZW5jZS1oYW5kbGVyLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3AtcmVzb2x2ZS1ydWxlcy50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9iYXRjaC1ub3JtYWxpemF0aW9uLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JpbmFyeS1vcC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jbGlwLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbmNhdC1wYWNrZWQudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29uY2F0LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbnYtcGFjay50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb252LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2Ryb3BvdXQudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZWx1LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ZsYXR0ZW4udHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZnVzZS11dGlscy50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9nYXRoZXIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZ2VtbS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9pbTJjb2wtcGFjay50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9pbWFnZS1zY2FsZXIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW5zdGFuY2Utbm9ybWFsaXphdGlvbi50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9sZWFreS1yZWx1LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL21hdG11bC1wYWNrLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL21hdG11bC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wYWNrLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhY2tpbmctdXRpbHMudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcGFkLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Bvb2wudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcmVkdWNlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Jlc2hhcGUtcGFja2VkLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Jlc2hhcGUudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcmVzaXplLXBhY2tlZC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zaGFwZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zbGljZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zb2Z0bWF4LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3NwbGl0LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3NxdWVlemUudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc3VtLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3RpbGUudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdHJhbnNwb3NlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3VpbnQ4LWVuY29kZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91bmFyeS1vcC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91bnBhY2sudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdW5zcXVlZXplLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vwc2FtcGxlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvcHJvZ3JhbS1tYW5hZ2VyLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvc2Vzc2lvbi1oYW5kbGVyLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1kYXRhLWVuY29kZXIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC1zdHJhdGVneS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3RleHR1cmUtbWFuYWdlci50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3V0aWxzLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvd2ViZ2wtY29udGV4dC1mYWN0b3J5LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvd2ViZ2wtY29udGV4dC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL2V4ZWN1dGlvbi1wbGFuLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvZ3JhcGgudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9pbnN0cnVtZW50LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcGVyYXRvcnMudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvYmF0Y2gtbm9ybWFsaXphdGlvbi50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9iaW5hcnktb3AudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvY2xpcC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9jb25jYXQudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvY29udi50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9kZXB0aC10by1zcGFjZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9kcm9wb3V0LnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL2VsdS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9mbGF0dGVuLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL2dhdGhlci50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9nZW1tLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL2ltYWdlLXNjYWxlci50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9pbnN0YW5jZS1ub3JtYWxpemF0aW9uLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL2xlYWt5LXJlbHUudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvbWF0bXVsLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL3BhZC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9wb29sLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL3JlZHVjZS1vcC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9yZXNoYXBlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL3NoYXBlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL3NsaWNlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL3NvZnRtYXgudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvc3BsaXQudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvc3F1ZWV6ZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy9zdW0udHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvdGlsZS50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvb25ueGpzL29wcy90cmFuc3Bvc2UudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvdW5hcnktb3AudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcHMvdW5zcXVlZXplLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzL3Vwc2FtcGxlLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvb3BzZXQudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9vcnQtc2NoZW1hL29ydC1nZW5lcmF0ZWQudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9zZXNzaW9uLWhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL29ubnhqcy9zZXNzaW9uLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvdGVuc29yLnRzIiwid2VicGFjazovL29ydC8uL2xpYi9vbm54anMvdXRpbC50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvd2FzbS9vcHRpb25zLXV0aWxzLnRzIiwid2VicGFjazovL29ydC8uL2xpYi93YXNtL3J1bi1vcHRpb25zLnRzIiwid2VicGFjazovL29ydC8uL2xpYi93YXNtL3Nlc3Npb24taGFuZGxlci50cyIsIndlYnBhY2s6Ly9vcnQvLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vb3J0Ly4vbGliL3dhc20vc3RyaW5nLXV0aWxzLnRzIiwid2VicGFjazovL29ydC8uL2xpYi93YXNtL3dhc20tZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9vcnQvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL29ubnhqc3xmcyIsIndlYnBhY2s6Ly9vcnQvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL29ubnhqc3x1dGlsIiwid2VicGFjazovL29ydC9pZ25vcmVkfC9ob21lL25odS9jb2RlL29ubnhydW50aW1lL2pzL3dlYi9saWIvd2FzbS9iaW5kaW5nfGZzIiwid2VicGFjazovL29ydC9pZ25vcmVkfC9ob21lL25odS9jb2RlL29ubnhydW50aW1lL2pzL3dlYi9saWIvd2FzbS9iaW5kaW5nfG9zIiwid2VicGFjazovL29ydC9pZ25vcmVkfC9ob21lL25odS9jb2RlL29ubnhydW50aW1lL2pzL3dlYi9saWIvd2FzbS9iaW5kaW5nfHBhdGgiLCJ3ZWJwYWNrOi8vb3J0L2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYi93YXNtL2JpbmRpbmd8cGVyZl9ob29rcyIsIndlYnBhY2s6Ly9vcnQvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL3dhc20vYmluZGluZ3x3b3JrZXJfdGhyZWFkcyIsIndlYnBhY2s6Ly9vcnQvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL3dhc218cGF0aCIsIndlYnBhY2s6Ly9vcnQvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGlifGZzIiwid2VicGFjazovL29ydC9pZ25vcmVkfC9ob21lL25odS9jb2RlL29ubnhydW50aW1lL2pzL3dlYi9saWJ8b3MiLCJ3ZWJwYWNrOi8vb3J0L2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYnx1dGlsIiwid2VicGFjazovL29ydC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9vcnQvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL29ydC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL29ydC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL29ydC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL29ydC93ZWJwYWNrL3N0YXJ0dXAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QztBQUNBLHVCQUF1QixxQ0FBcUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZLHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQkFBb0IsT0FBTyxJQUFJLE1BQU0sY0FBYztBQUMzRztBQUNBLHdDOzs7Ozs7Ozs7Ozs7Ozs7O0FDeEVBO0FBQ0E7QUFDaUQ7QUFDakQsbUM7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsaUJBQWlCO0FB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QTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQiw4Q0FBOEM7QUFDL0UsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFD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TXRCO0FBRUssSUFBTSxPQUFPLEdBQUc7O0lBQ3JCLElBQUksV0FBVyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsT0FBTyxFQUFFO1FBQzVDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFFcEIsTUFBQyxJQUE4QixDQUFDLE9BQU8sMENBQUUsbUJBQW1CLEVBQUUsQ0FBQztRQUUvRCxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDcEIsT0FBTyxHQUFHLElBQUksQ0FBQztLQUNoQjtBQUNILENBQUMsQ0FBQztBQVZXLGVBQU8sV0FVbEI7Ozs7Ozs7Ozs7O0FDcEtGLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBLENBQUMsSTs7Ozs7V0NQRCw2Q0FBNkMsd0RBQXdELEU7Ozs7O1dDQXJHO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRCxrQkFBa0I7V0FDeEU7V0FDQSwrQ0FBK0MsY0FBYztXQUM3RCxFOzs7OztVQ05BO1VBQ0E7VUFDQTtVQUNBIiwiZmlsZSI6Im9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm9ydFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJvcnRcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmNvbnN0IGJhY2tlbmRzID0ge307XG5jb25zdCBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkgPSBbXTtcbi8qKlxuICogUmVnaXN0ZXIgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgYXMgYSBrZXkgdG8gbG9va3VwIGFzIGFuIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAqIEBwYXJhbSBiYWNrZW5kIC0gdGhlIGJhY2tlbmQgb2JqZWN0LlxuICogQHBhcmFtIHByaW9yaXR5IC0gYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBwcmlvcml0eSBvZiB0aGUgYmFja2VuZC4gSGlnaGVyIG51bWJlciBtZWFucyBoaWdoZXIgcHJpb3JpdHkuXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZSwgYmFja2VuZCwgcHJpb3JpdHkpID0+IHtcbiAgICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYWNrZW5kID0gYmFja2VuZHNbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50QmFja2VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBiYWNrZW5kc1tuYW1lXSA9IHsgYmFja2VuZCwgcHJpb3JpdHkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kID09PSBiYWNrZW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhY2tlbmQgXCIke25hbWV9XCIgaXMgYWxyZWFkeSByZWdpc3RlcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChiYWNrZW5kc1tiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV1dLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgdmFsaWQgYmFja2VuZCcpO1xufTtcbi8qKlxuICogUmVzb2x2ZSBiYWNrZW5kIGJ5IHNwZWNpZmllZCBoaW50cy5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZEhpbnRzIC0gYSBsaXN0IG9mIGV4ZWN1dGlvbiBwcm92aWRlciBuYW1lcyB0byBsb29rdXAuIElmIG9taXR0ZWQgdXNlIHJlZ2lzdGVyZWQgYmFja2VuZHMgYXMgbGlzdC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBiYWNrZW5kLlxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZUJhY2tlbmQgPSBhc3luYyAoYmFja2VuZEhpbnRzKSA9PiB7XG4gICAgY29uc3QgYmFja2VuZE5hbWVzID0gYmFja2VuZEhpbnRzLmxlbmd0aCA9PT0gMCA/IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eSA6IGJhY2tlbmRIaW50cztcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJhY2tlbmROYW1lIG9mIGJhY2tlbmROYW1lcykge1xuICAgICAgICBjb25zdCBiYWNrZW5kSW5mbyA9IGJhY2tlbmRzW2JhY2tlbmROYW1lXTtcbiAgICAgICAgaWYgKGJhY2tlbmRJbmZvKSB7XG4gICAgICAgICAgICBpZiAoYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJhY2tlbmRJbmZvLmluaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFja2VuZCBcIiR7YmFja2VuZE5hbWV9XCIgaXMgYmVpbmcgaW5pdGlhbGl6ZWQ7IGNhbm5vdCBpbml0aWFsaXplIG11bHRpcGxlIHRpbWVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmFja2VuZEluZm8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBjdXJyZW50IGJhY2tlbmQgaXMgdW5hdmFpbGFibGU7IHRyeSBuZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmFja2VuZEluZm8uYmFja2VuZC5pbml0KCk7XG4gICAgICAgICAgICAgICAgYmFja2VuZEluZm8uaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IGUgfSk7XG4gICAgICAgICAgICAgICAgYmFja2VuZEluZm8uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC1pbXBsLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IHsgcmVnaXN0ZXJCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCBjbGFzcyBFbnZJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy53YXNtID0ge307XG4gICAgICAgIHRoaXMud2ViZ2wgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dMZXZlbEludGVybmFsID0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICAvLyBUT0RPIHN0YW5kYWRpemUgdGhlIGdldHRlciBhbmQgc2V0dGVyIGNvbnZlbnRpb24gaW4gZW52IGZvciBvdGhlciBmaWVsZHMuXG4gICAgc2V0IGxvZ0xldmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nTGV2ZWxJbnRlcm5hbCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ0xldmVsSW50ZXJuYWw7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LWltcGwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBFbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbCc7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBuZXcgRW52SW1wbCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kJztcbmV4cG9ydCAqIGZyb20gJy4vZW52JztcbmV4cG9ydCAqIGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24nO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3InO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuaW1wb3J0IHsgcmVzb2x2ZUJhY2tlbmQgfSBmcm9tICcuL2JhY2tlbmQtaW1wbCc7XG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvcic7XG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBhc3luYyBydW4oZmVlZHMsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hlcyA9IHt9O1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBjaGVjayBpbnB1dHNcbiAgICAgICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmV0Y2hlc1xcJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IG91dHB1dCBuYW1lIGlzIHByZXNlbnQgYW5kIGl0cyB2YWx1ZSBpcyB2YWxpZCBPbm54VmFsdWUsIHdlIGNvbnNpZGVyIGl0IGZldGNoZXNcbiAgICAgICAgICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBhcmcxW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlIFxcJ2ZldGNoZXNcXCcgb3IgXFwnb3B0aW9uc1xcJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLmlucHV0TmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICAgICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0c1trZXldLnR5cGUsIHJlc3VsdHNba2V5XS5kYXRhLCByZXN1bHRzW2tleV0uZGltcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgLy8gZWl0aGVyIGxvYWQgZnJvbSBhIGZpbGUgb3IgYnVmZmVyXG4gICAgICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBiYWNrZW5kIGhpbnRzXG4gICAgICAgIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICAgICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZChiYWNrZW5kSGludHMpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVTZXNzaW9uSGFuZGxlcihmaWxlUGF0aE9yVWludDhBcnJheSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgICB9XG4gICAgc3RhcnRQcm9maWxpbmcoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICAgIH1cbiAgICBlbmRQcm9maWxpbmcoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGlucHV0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgICB9XG4gICAgZ2V0IG91dHB1dE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS1zZXNzaW9uLWltcGwuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbXBsIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBJbmZlcmVuY2VTZXNzaW9uID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ubngtdmFsdWUuanMubWFwIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5jb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJpZ0ludDY0QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCaWdVaW50NjRBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwKFtcbiAgICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICAgIFsndWludDgnLCBVaW50OEFycmF5XSxcbiAgICBbJ2ludDgnLCBJbnQ4QXJyYXldLFxuICAgIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICAgIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcbiAgICBbJ2ludDMyJywgSW50MzJBcnJheV0sXG4gICAgWydib29sJywgVWludDhBcnJheV0sXG4gICAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcbiAgICBbJ3VpbnQzMicsIFVpbnQzMkFycmF5XSxcbl0pO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAgPSBuZXcgTWFwKFtcbiAgICBbRmxvYXQzMkFycmF5LCAnZmxvYXQzMiddLFxuICAgIFtVaW50OEFycmF5LCAndWludDgnXSxcbiAgICBbSW50OEFycmF5LCAnaW50OCddLFxuICAgIFtVaW50MTZBcnJheSwgJ3VpbnQxNiddLFxuICAgIFtJbnQxNkFycmF5LCAnaW50MTYnXSxcbiAgICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gICAgW0Zsb2F0NjRBcnJheSwgJ2Zsb2F0NjQnXSxcbiAgICBbVWludDMyQXJyYXksICd1aW50MzInXSxcbl0pO1xuaWYgKGlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdpbnQ2NCcsIEJpZ0ludDY0QXJyYXkpO1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ0ludDY0QXJyYXksICdpbnQ2NCcpO1xufVxuaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xuICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ1VpbnQ2NEFycmF5LCAndWludDY0Jyk7XG59XG4vKipcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cbiAqXG4gKiBAcGFyYW0gZGltcyB0aGUgZGltcyBhcnJheS4gTWF5IGJlIGFuIGlsbGVnYWwgaW5wdXQuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltcykgPT4ge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGltID0gZGltc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgKj0gZGltO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICBjb25zdHJ1Y3RvcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIGxldCB0eXBlO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IGRpbXM7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgICAgICBkaW1zID0gYXJnMjtcbiAgICAgICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzdHJpbmcgdGVuc29yXFwncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIHdoZXRoZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgc3RyaW5nOyB0aGlzIGlzIHRvbyBzbG93LiB3ZSBhc3N1bWUgaXQncyBjb3JyZWN0IGFuZFxuICAgICAgICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbnVtZXJpYyB0ZW5zb3JcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldChhcmcwKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2UgVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHR5cGUgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBwcm9kdWNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmNvcnJlY3QgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gJ3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcicgc2hvdWxkIGJlIG9uZSBvZiB0aGUgdHlwZWQgYXJyYXkgcHJvdG90eXBlIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZnJvbShhcmcxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIHR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBkaW1zID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIGlmIChhcmcwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2FyZzAnIGlzIG9mIHR5cGUgJ2Jvb2xlYW5bXScuIFVpbnQ4QXJyYXkuZnJvbShib29sZWFuW10pIGFjdHVhbGx5IHdvcmtzLCBidXQgdHlwZXNjcmlwdCB0aGlua3MgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShhcmcwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7Zmlyc3RFbGVtZW50VHlwZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRlbnNvciB0eXBlIGZyb20gVHlwZWRBcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChhcmcwLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2FyZzAuY29uc3RydWN0b3J9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcbiAgICAgICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0eXBlIGFuZCBkYXRhIGlzIHByb2Nlc3NlZCwgbm93IHByb2Nlc3NpbmcgZGltc1xuICAgICAgICBpZiAoZGltcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgICAgIGRpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGRpbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHRlbnNvclxcJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBjaGVja1xuICAgICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAgICAgaWYgKHNpemUgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHtkYXRhLmxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gICAgcmVzaGFwZShkaW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRoaXMudHlwZSwgdGhpcy5kYXRhLCBkaW1zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3ItaW1wbC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci5qcy5tYXAiLCJcbnZhciBvcnRXYXNtVGhyZWFkZWQgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgX19maWxlbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIF9zY3JpcHREaXIgPSBfc2NyaXB0RGlyIHx8IF9fZmlsZW5hbWU7XG4gIHJldHVybiAoXG5mdW5jdGlvbihvcnRXYXNtVGhyZWFkZWQpIHtcbiAgb3J0V2FzbVRocmVhZGVkID0gb3J0V2FzbVRocmVhZGVkIHx8IHt9O1xuXG5mdW5jdGlvbiBHUk9XQUJMRV9IRUFQX0k4KCl7aWYod2FzbU1lbW9yeS5idWZmZXIhPWJ1ZmZlcil7dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpfXJldHVybiBIRUFQOH1mdW5jdGlvbiBHUk9XQUJMRV9IRUFQX1U4KCl7aWYod2FzbU1lbW9yeS5idWZmZXIhPWJ1ZmZlcil7dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpfXJldHVybiBIRUFQVTh9ZnVuY3Rpb24gR1JPV0FCTEVfSEVBUF9JMzIoKXtpZih3YXNtTWVtb3J5LmJ1ZmZlciE9YnVmZmVyKXt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcil9cmV0dXJuIEhFQVAzMn1mdW5jdGlvbiBHUk9XQUJMRV9IRUFQX1UzMigpe2lmKHdhc21NZW1vcnkuYnVmZmVyIT1idWZmZXIpe3VwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKX1yZXR1cm4gSEVBUFUzMn1mdW5jdGlvbiBHUk9XQUJMRV9IRUFQX0YzMigpe2lmKHdhc21NZW1vcnkuYnVmZmVyIT1idWZmZXIpe3VwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKX1yZXR1cm4gSEVBUEYzMn1mdW5jdGlvbiBHUk9XQUJMRV9IRUFQX0Y2NCgpe2lmKHdhc21NZW1vcnkuYnVmZmVyIT1idWZmZXIpe3VwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKX1yZXR1cm4gSEVBUEY2NH12YXIgTW9kdWxlPXR5cGVvZiBvcnRXYXNtVGhyZWFkZWQhPT1cInVuZGVmaW5lZFwiP29ydFdhc21UaHJlYWRlZDp7fTt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlW1wicmVhZHlcIl09bmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe3JlYWR5UHJvbWlzZVJlc29sdmU9cmVzb2x2ZTtyZWFkeVByb21pc2VSZWplY3Q9cmVqZWN0fSk7dmFyIG1vZHVsZU92ZXJyaWRlcz17fTt2YXIga2V5O2ZvcihrZXkgaW4gTW9kdWxlKXtpZihNb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSl7bW9kdWxlT3ZlcnJpZGVzW2tleV09TW9kdWxlW2tleV19fXZhciBhcmd1bWVudHNfPVtdO3ZhciB0aGlzUHJvZ3JhbT1cIi4vdGhpcy5wcm9ncmFtXCI7dmFyIHF1aXRfPWZ1bmN0aW9uKHN0YXR1cyx0b1Rocm93KXt0aHJvdyB0b1Rocm93fTt2YXIgRU5WSVJPTk1FTlRfSVNfV0VCPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVI9ZmFsc2U7dmFyIEVOVklST05NRU5UX0lTX05PREU9ZmFsc2U7dmFyIEVOVklST05NRU5UX0lTX1NIRUxMPWZhbHNlO0VOVklST05NRU5UX0lTX1dFQj10eXBlb2Ygd2luZG93PT09XCJvYmplY3RcIjtFTlZJUk9OTUVOVF9JU19XT1JLRVI9dHlwZW9mIGltcG9ydFNjcmlwdHM9PT1cImZ1bmN0aW9uXCI7RU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09PVwic3RyaW5nXCI7RU5WSVJPTk1FTlRfSVNfU0hFTEw9IUVOVklST05NRU5UX0lTX1dFQiYmIUVOVklST05NRU5UX0lTX05PREUmJiFFTlZJUk9OTUVOVF9JU19XT1JLRVI7dmFyIEVOVklST05NRU5UX0lTX1BUSFJFQUQ9TW9kdWxlW1wiRU5WSVJPTk1FTlRfSVNfUFRIUkVBRFwiXXx8ZmFsc2U7dmFyIHNjcmlwdERpcmVjdG9yeT1cIlwiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSl7cmV0dXJuIE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0ocGF0aCxzY3JpcHREaXJlY3RvcnkpfXJldHVybiBzY3JpcHREaXJlY3RvcnkrcGF0aH12YXIgcmVhZF8scmVhZEFzeW5jLHJlYWRCaW5hcnksc2V0V2luZG93VGl0bGU7dmFyIG5vZGVGUzt2YXIgbm9kZVBhdGg7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtzY3JpcHREaXJlY3Rvcnk9cmVxdWlyZShcInBhdGhcIikuZGlybmFtZShzY3JpcHREaXJlY3RvcnkpK1wiL1wifWVsc2V7c2NyaXB0RGlyZWN0b3J5PV9fZGlybmFtZStcIi9cIn1yZWFkXz1mdW5jdGlvbiBzaGVsbF9yZWFkKGZpbGVuYW1lLGJpbmFyeSl7aWYoIW5vZGVGUylub2RlRlM9cmVxdWlyZShcImZzXCIpO2lmKCFub2RlUGF0aClub2RlUGF0aD1yZXF1aXJlKFwicGF0aFwiKTtmaWxlbmFtZT1ub2RlUGF0aFtcIm5vcm1hbGl6ZVwiXShmaWxlbmFtZSk7cmV0dXJuIG5vZGVGU1tcInJlYWRGaWxlU3luY1wiXShmaWxlbmFtZSxiaW5hcnk/bnVsbDpcInV0ZjhcIil9O3JlYWRCaW5hcnk9ZnVuY3Rpb24gcmVhZEJpbmFyeShmaWxlbmFtZSl7dmFyIHJldD1yZWFkXyhmaWxlbmFtZSx0cnVlKTtpZighcmV0LmJ1ZmZlcil7cmV0PW5ldyBVaW50OEFycmF5KHJldCl9YXNzZXJ0KHJldC5idWZmZXIpO3JldHVybiByZXR9O2lmKHByb2Nlc3NbXCJhcmd2XCJdLmxlbmd0aD4xKXt0aGlzUHJvZ3JhbT1wcm9jZXNzW1wiYXJndlwiXVsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpfWFyZ3VtZW50c189cHJvY2Vzc1tcImFyZ3ZcIl0uc2xpY2UoMik7cHJvY2Vzc1tcIm9uXCJdKFwidW5jYXVnaHRFeGNlcHRpb25cIixmdW5jdGlvbihleCl7aWYoIShleCBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpKXt0aHJvdyBleH19KTtwcm9jZXNzW1wib25cIl0oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixhYm9ydCk7cXVpdF89ZnVuY3Rpb24oc3RhdHVzKXtwcm9jZXNzW1wiZXhpdFwiXShzdGF0dXMpfTtNb2R1bGVbXCJpbnNwZWN0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifTt2YXIgbm9kZVdvcmtlclRocmVhZHM7dHJ5e25vZGVXb3JrZXJUaHJlYWRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKTt0aHJvdyBlfWdsb2JhbC5Xb3JrZXI9bm9kZVdvcmtlclRocmVhZHMuV29ya2VyfWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfU0hFTEwpe2lmKHR5cGVvZiByZWFkIT1cInVuZGVmaW5lZFwiKXtyZWFkXz1mdW5jdGlvbiBzaGVsbF9yZWFkKGYpe3JldHVybiByZWFkKGYpfX1yZWFkQmluYXJ5PWZ1bmN0aW9uIHJlYWRCaW5hcnkoZil7dmFyIGRhdGE7aWYodHlwZW9mIHJlYWRidWZmZXI9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBuZXcgVWludDhBcnJheShyZWFkYnVmZmVyKGYpKX1kYXRhPXJlYWQoZixcImJpbmFyeVwiKTthc3NlcnQodHlwZW9mIGRhdGE9PT1cIm9iamVjdFwiKTtyZXR1cm4gZGF0YX07aWYodHlwZW9mIHNjcmlwdEFyZ3MhPVwidW5kZWZpbmVkXCIpe2FyZ3VtZW50c189c2NyaXB0QXJnc31lbHNlIGlmKHR5cGVvZiBhcmd1bWVudHMhPVwidW5kZWZpbmVkXCIpe2FyZ3VtZW50c189YXJndW1lbnRzfWlmKHR5cGVvZiBxdWl0PT09XCJmdW5jdGlvblwiKXtxdWl0Xz1mdW5jdGlvbihzdGF0dXMpe3F1aXQoc3RhdHVzKX19aWYodHlwZW9mIHByaW50IT09XCJ1bmRlZmluZWRcIil7aWYodHlwZW9mIGNvbnNvbGU9PT1cInVuZGVmaW5lZFwiKWNvbnNvbGU9e307Y29uc29sZS5sb2c9cHJpbnQ7Y29uc29sZS53YXJuPWNvbnNvbGUuZXJyb3I9dHlwZW9mIHByaW50RXJyIT09XCJ1bmRlZmluZWRcIj9wcmludEVycjpwcmludH19ZWxzZSBpZihFTlZJUk9OTUVOVF9JU19XRUJ8fEVOVklST05NRU5UX0lTX1dPUktFUil7aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtzY3JpcHREaXJlY3Rvcnk9c2VsZi5sb2NhdGlvbi5ocmVmfWVsc2UgaWYodHlwZW9mIGRvY3VtZW50IT09XCJ1bmRlZmluZWRcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7c2NyaXB0RGlyZWN0b3J5PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjfWlmKF9zY3JpcHREaXIpe3NjcmlwdERpcmVjdG9yeT1fc2NyaXB0RGlyfWlmKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKFwiYmxvYjpcIikhPT0wKXtzY3JpcHREaXJlY3Rvcnk9c2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5sYXN0SW5kZXhPZihcIi9cIikrMSl9ZWxzZXtzY3JpcHREaXJlY3Rvcnk9XCJcIn1pZihFTlZJUk9OTUVOVF9JU19OT0RFKXtyZWFkXz1mdW5jdGlvbiBzaGVsbF9yZWFkKGZpbGVuYW1lLGJpbmFyeSl7aWYoIW5vZGVGUylub2RlRlM9cmVxdWlyZShcImZzXCIpO2lmKCFub2RlUGF0aClub2RlUGF0aD1yZXF1aXJlKFwicGF0aFwiKTtmaWxlbmFtZT1ub2RlUGF0aFtcIm5vcm1hbGl6ZVwiXShmaWxlbmFtZSk7cmV0dXJuIG5vZGVGU1tcInJlYWRGaWxlU3luY1wiXShmaWxlbmFtZSxiaW5hcnk/bnVsbDpcInV0ZjhcIil9O3JlYWRCaW5hcnk9ZnVuY3Rpb24gcmVhZEJpbmFyeShmaWxlbmFtZSl7dmFyIHJldD1yZWFkXyhmaWxlbmFtZSx0cnVlKTtpZighcmV0LmJ1ZmZlcil7cmV0PW5ldyBVaW50OEFycmF5KHJldCl9YXNzZXJ0KHJldC5idWZmZXIpO3JldHVybiByZXR9fWVsc2V7cmVhZF89ZnVuY3Rpb24odXJsKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnNlbmQobnVsbCk7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9O2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7cmVhZEJpbmFyeT1mdW5jdGlvbih1cmwpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLGZhbHNlKTt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjt4aHIuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKX19cmVhZEFzeW5jPWZ1bmN0aW9uKHVybCxvbmxvYWQsb25lcnJvcil7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsdHJ1ZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLm9ubG9hZD1mdW5jdGlvbigpe2lmKHhoci5zdGF0dXM9PTIwMHx8eGhyLnN0YXR1cz09MCYmeGhyLnJlc3BvbnNlKXtvbmxvYWQoeGhyLnJlc3BvbnNlKTtyZXR1cm59b25lcnJvcigpfTt4aHIub25lcnJvcj1vbmVycm9yO3hoci5zZW5kKG51bGwpfX1zZXRXaW5kb3dUaXRsZT1mdW5jdGlvbih0aXRsZSl7ZG9jdW1lbnQudGl0bGU9dGl0bGV9fWVsc2V7fWlmKEVOVklST05NRU5UX0lTX05PREUpe2lmKHR5cGVvZiBwZXJmb3JtYW5jZT09PVwidW5kZWZpbmVkXCIpe2dsb2JhbC5wZXJmb3JtYW5jZT1yZXF1aXJlKFwicGVyZl9ob29rc1wiKS5wZXJmb3JtYW5jZX19dmFyIG91dD1Nb2R1bGVbXCJwcmludFwiXXx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKTt2YXIgZXJyPU1vZHVsZVtcInByaW50RXJyXCJdfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3Ioa2V5IGluIG1vZHVsZU92ZXJyaWRlcyl7aWYobW9kdWxlT3ZlcnJpZGVzLmhhc093blByb3BlcnR5KGtleSkpe01vZHVsZVtrZXldPW1vZHVsZU92ZXJyaWRlc1trZXldfX1tb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbXCJhcmd1bWVudHNcIl0pYXJndW1lbnRzXz1Nb2R1bGVbXCJhcmd1bWVudHNcIl07aWYoTW9kdWxlW1widGhpc1Byb2dyYW1cIl0pdGhpc1Byb2dyYW09TW9kdWxlW1widGhpc1Byb2dyYW1cIl07aWYoTW9kdWxlW1wicXVpdFwiXSlxdWl0Xz1Nb2R1bGVbXCJxdWl0XCJdO2Z1bmN0aW9uIHdhcm5PbmNlKHRleHQpe2lmKCF3YXJuT25jZS5zaG93bil3YXJuT25jZS5zaG93bj17fTtpZighd2Fybk9uY2Uuc2hvd25bdGV4dF0pe3dhcm5PbmNlLnNob3duW3RleHRdPTE7ZXJyKHRleHQpfX12YXIgQXRvbWljc19sb2FkPUF0b21pY3MubG9hZDt2YXIgQXRvbWljc19zdG9yZT1BdG9taWNzLnN0b3JlO3ZhciBBdG9taWNzX2NvbXBhcmVFeGNoYW5nZT1BdG9taWNzLmNvbXBhcmVFeGNoYW5nZTt2YXIgd2FzbUJpbmFyeTtpZihNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKXdhc21CaW5hcnk9TW9kdWxlW1wid2FzbUJpbmFyeVwiXTt2YXIgbm9FeGl0UnVudGltZT1Nb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdfHxmYWxzZTtpZih0eXBlb2YgV2ViQXNzZW1ibHkhPT1cIm9iamVjdFwiKXthYm9ydChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIil9dmFyIHdhc21NZW1vcnk7dmFyIHdhc21Nb2R1bGU7dmFyIEFCT1JUPWZhbHNlO3ZhciBFWElUU1RBVFVTO2Z1bmN0aW9uIGFzc2VydChjb25kaXRpb24sdGV4dCl7aWYoIWNvbmRpdGlvbil7YWJvcnQoXCJBc3NlcnRpb24gZmFpbGVkOiBcIit0ZXh0KX19ZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcoaGVhcCxpZHgsbWF4Qnl0ZXNUb1JlYWQpe3ZhciBlbmRJZHg9aWR4K21heEJ5dGVzVG9SZWFkO3ZhciBzdHI9XCJcIjt3aGlsZSghKGlkeD49ZW5kSWR4KSl7dmFyIHUwPWhlYXBbaWR4KytdO2lmKCF1MClyZXR1cm4gc3RyO2lmKCEodTAmMTI4KSl7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtjb250aW51ZX12YXIgdTE9aGVhcFtpZHgrK10mNjM7aWYoKHUwJjIyNCk9PTE5Mil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCYzMSk8PDZ8dTEpO2NvbnRpbnVlfXZhciB1Mj1oZWFwW2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mn1lbHNle3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fGhlYXBbaWR4KytdJjYzfWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApfWVsc2V7dmFyIGNoPXUwLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyl9fXJldHVybiBzdHJ9ZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cixtYXhCeXRlc1RvUmVhZCl7cmV0dXJuIHB0cj9VVEY4QXJyYXlUb1N0cmluZyhHUk9XQUJMRV9IRUFQX1U4KCkscHRyLG1heEJ5dGVzVG9SZWFkKTpcIlwifWZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpe2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXt2YXIgdTE9c3RyLmNoYXJDb2RlQXQoKytpKTt1PTY1NTM2KygodSYxMDIzKTw8MTApfHUxJjEwMjN9aWYodTw9MTI3KXtpZihvdXRJZHg+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT11fWVsc2UgaWYodTw9MjA0Nyl7aWYob3V0SWR4KzE+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0xOTJ8dT4+NjtoZWFwW291dElkeCsrXT0xMjh8dSY2M31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTIyNHx1Pj4xMjtoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2M31lbHNle2lmKG91dElkeCszPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjQwfHU+PjE4O2hlYXBbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2M319aGVhcFtvdXRJZHhdPTA7cmV0dXJuIG91dElkeC1zdGFydElkeH1mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpe3JldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsR1JPV0FCTEVfSEVBUF9VOCgpLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpfWZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpe3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpdT02NTUzNisoKHUmMTAyMyk8PDEwKXxzdHIuY2hhckNvZGVBdCgrK2kpJjEwMjM7aWYodTw9MTI3KSsrbGVuO2Vsc2UgaWYodTw9MjA0NylsZW4rPTI7ZWxzZSBpZih1PD02NTUzNSlsZW4rPTM7ZWxzZSBsZW4rPTR9cmV0dXJuIGxlbn1mdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKXt2YXIgc2l6ZT1sZW5ndGhCeXRlc1VURjgoc3RyKSsxO3ZhciByZXQ9X21hbGxvYyhzaXplKTtpZihyZXQpc3RyaW5nVG9VVEY4QXJyYXkoc3RyLEdST1dBQkxFX0hFQVBfSTgoKSxyZXQsc2l6ZSk7cmV0dXJuIHJldH1mdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksYnVmZmVyKXtHUk9XQUJMRV9IRUFQX0k4KCkuc2V0KGFycmF5LGJ1ZmZlcil9ZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0cixidWZmZXIsZG9udEFkZE51bGwpe2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe0dST1dBQkxFX0hFQVBfSTgoKVtidWZmZXIrKz4+MF09c3RyLmNoYXJDb2RlQXQoaSl9aWYoIWRvbnRBZGROdWxsKUdST1dBQkxFX0hFQVBfSTgoKVtidWZmZXI+PjBdPTB9ZnVuY3Rpb24gYWxpZ25VcCh4LG11bHRpcGxlKXtpZih4JW11bHRpcGxlPjApe3grPW11bHRpcGxlLXglbXVsdGlwbGV9cmV0dXJuIHh9dmFyIGJ1ZmZlcixIRUFQOCxIRUFQVTgsSEVBUDE2LEhFQVBVMTYsSEVBUDMyLEhFQVBVMzIsSEVBUEYzMixIRUFQRjY0O2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpe2J1ZmZlcj1Nb2R1bGVbXCJidWZmZXJcIl19ZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmKXtidWZmZXI9YnVmO01vZHVsZVtcIkhFQVA4XCJdPUhFQVA4PW5ldyBJbnQ4QXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQMTZcIl09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUDMyXCJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShidWYpO01vZHVsZVtcIkhFQVBVOFwiXT1IRUFQVTg9bmV3IFVpbnQ4QXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQVTE2XCJdPUhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUFUzMlwiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShidWYpO01vZHVsZVtcIkhFQVBGMzJcIl09SEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUEY2NFwiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYnVmKX12YXIgSU5JVElBTF9NRU1PUlk9TW9kdWxlW1wiSU5JVElBTF9NRU1PUllcIl18fDE2Nzc3MjE2O2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpe3dhc21NZW1vcnk9TW9kdWxlW1wid2FzbU1lbW9yeVwiXTtidWZmZXI9TW9kdWxlW1wiYnVmZmVyXCJdfWVsc2V7aWYoTW9kdWxlW1wid2FzbU1lbW9yeVwiXSl7d2FzbU1lbW9yeT1Nb2R1bGVbXCJ3YXNtTWVtb3J5XCJdfWVsc2V7d2FzbU1lbW9yeT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcImluaXRpYWxcIjpJTklUSUFMX01FTU9SWS82NTUzNixcIm1heGltdW1cIjoyMTQ3NDgzNjQ4LzY1NTM2LFwic2hhcmVkXCI6dHJ1ZX0pO2lmKCEod2FzbU1lbW9yeS5idWZmZXIgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpe2VycihcInJlcXVlc3RlZCBhIHNoYXJlZCBXZWJBc3NlbWJseS5NZW1vcnkgYnV0IHRoZSByZXR1cm5lZCBidWZmZXIgaXMgbm90IGEgU2hhcmVkQXJyYXlCdWZmZXIsIGluZGljYXRpbmcgdGhhdCB3aGlsZSB0aGUgYnJvd3NlciBoYXMgU2hhcmVkQXJyYXlCdWZmZXIgaXQgZG9lcyBub3QgaGF2ZSBXZWJBc3NlbWJseSB0aHJlYWRzIHN1cHBvcnQgLSB5b3UgbWF5IG5lZWQgdG8gc2V0IGEgZmxhZ1wiKTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtjb25zb2xlLmxvZyhcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kIGFsc28gdXNlIGEgcmVjZW50IHZlcnNpb24pXCIpfXRocm93IEVycm9yKFwiYmFkIG1lbW9yeVwiKX19fWlmKHdhc21NZW1vcnkpe2J1ZmZlcj13YXNtTWVtb3J5LmJ1ZmZlcn1JTklUSUFMX01FTU9SWT1idWZmZXIuYnl0ZUxlbmd0aDt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWZmZXIpO3ZhciB3YXNtVGFibGU7dmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVEVYSVRfXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTt2YXIgcnVudGltZUluaXRpYWxpemVkPWZhbHNlO3ZhciBydW50aW1lRXhpdGVkPWZhbHNlO2Z1bmN0aW9uIHByZVJ1bigpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuO2lmKE1vZHVsZVtcInByZVJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInByZVJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInByZVJ1blwiXT1bTW9kdWxlW1wicHJlUnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwcmVSdW5cIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbXCJwcmVSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyl9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtydW50aW1lSW5pdGlhbGl6ZWQ9dHJ1ZTtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybjtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKX1mdW5jdGlvbiBleGl0UnVudGltZSgpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuO2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRFWElUX18pO2ZsdXNoX05PX0ZJTEVTWVNURU0oKTtQVGhyZWFkLnJ1bkV4aXRIYW5kbGVycygpO3J1bnRpbWVFeGl0ZWQ9dHJ1ZX1mdW5jdGlvbiBwb3N0UnVuKCl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm47aWYoTW9kdWxlW1wicG9zdFJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInBvc3RSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwb3N0UnVuXCJdPVtNb2R1bGVbXCJwb3N0UnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwb3N0UnVuXCJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVtcInBvc3RSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pfWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Jbml0KGNiKXtfX0FUSU5JVF9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKX12YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGw7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe2Fzc2VydCghRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCxcImFkZFJ1bkRlcGVuZGVuY3kgY2Fubm90IGJlIHVzZWQgaW4gYSBwdGhyZWFkIHdvcmtlclwiKTtydW5EZXBlbmRlbmNpZXMrKztpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9fWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO2lmKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pe01vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKX1pZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKHJ1bkRlcGVuZGVuY3lXYXRjaGVyIT09bnVsbCl7Y2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7cnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbH1pZihkZXBlbmRlbmNpZXNGdWxmaWxsZWQpe3ZhciBjYWxsYmFjaz1kZXBlbmRlbmNpZXNGdWxmaWxsZWQ7ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7Y2FsbGJhY2soKX19fU1vZHVsZVtcInByZWxvYWRlZEltYWdlc1wiXT17fTtNb2R1bGVbXCJwcmVsb2FkZWRBdWRpb3NcIl09e307ZnVuY3Rpb24gYWJvcnQod2hhdCl7aWYoTW9kdWxlW1wib25BYm9ydFwiXSl7TW9kdWxlW1wib25BYm9ydFwiXSh3aGF0KX1pZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKWNvbnNvbGUuZXJyb3IoXCJQdGhyZWFkIGFib3J0aW5nIGF0IFwiKyhuZXcgRXJyb3IpLnN0YWNrKTt3aGF0Kz1cIlwiO2Vycih3aGF0KTtBQk9SVD10cnVlO0VYSVRTVEFUVVM9MTt3aGF0PVwiYWJvcnQoXCIrd2hhdCtcIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uXCI7dmFyIGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtyZWFkeVByb21pc2VSZWplY3QoZSk7dGhyb3cgZX12YXIgZGF0YVVSSVByZWZpeD1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIjtmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpfWZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSl7cmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfXZhciB3YXNtQmluYXJ5RmlsZT1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIjtpZighaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSl7d2FzbUJpbmFyeUZpbGU9bG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSl9ZnVuY3Rpb24gZ2V0QmluYXJ5KGZpbGUpe3RyeXtpZihmaWxlPT13YXNtQmluYXJ5RmlsZSYmd2FzbUJpbmFyeSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpfWlmKHJlYWRCaW5hcnkpe3JldHVybiByZWFkQmluYXJ5KGZpbGUpfWVsc2V7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9fWNhdGNoKGVycil7YWJvcnQoZXJyKX19ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpe2lmKCF3YXNtQmluYXJ5JiYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpKXtpZih0eXBlb2YgZmV0Y2g9PT1cImZ1bmN0aW9uXCImJiFpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpKXtyZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe2lmKCFyZXNwb25zZVtcIm9rXCJdKXt0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrd2FzbUJpbmFyeUZpbGUrXCInXCJ9cmV0dXJuIHJlc3BvbnNlW1wiYXJyYXlCdWZmZXJcIl0oKX0pLmNhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSl9KX1lbHNle2lmKHJlYWRBc3luYyl7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtyZWFkQXN5bmMod2FzbUJpbmFyeUZpbGUsZnVuY3Rpb24ocmVzcG9uc2Upe3Jlc29sdmUobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKX0scmVqZWN0KX0pfX19cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKX0pfWZ1bmN0aW9uIGNyZWF0ZVdhc20oKXt2YXIgaW5mbz17XCJhXCI6YXNtTGlicmFyeUFyZ307ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLG1vZHVsZSl7dmFyIGV4cG9ydHM9aW5zdGFuY2UuZXhwb3J0cztNb2R1bGVbXCJhc21cIl09ZXhwb3J0czt3YXNtVGFibGU9TW9kdWxlW1wiYXNtXCJdW1wiZWJcIl07YWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcIk1hXCJdKTtQVGhyZWFkLnRsc0luaXRGdW5jdGlvbnMucHVzaChNb2R1bGVbXCJhc21cIl1bXCJqYlwiXSk7d2FzbU1vZHVsZT1tb2R1bGU7aWYoIUVOVklST05NRU5UX0lTX1BUSFJFQUQpe3JlbW92ZVJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpfX1pZighRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7YWRkUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIil9ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KXtyZWNlaXZlSW5zdGFuY2UocmVzdWx0W1wiaW5zdGFuY2VcIl0scmVzdWx0W1wibW9kdWxlXCJdKX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKXtyZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24oYmluYXJ5KXt2YXIgcmVzdWx0PVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbmZvKTtyZXR1cm4gcmVzdWx0fSkudGhlbihyZWNlaXZlcixmdW5jdGlvbihyZWFzb24pe2VycihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3JlYXNvbik7YWJvcnQocmVhc29uKX0pfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKXtpZighd2FzbUJpbmFyeSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT09XCJmdW5jdGlvblwiJiYhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSYmIWlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkmJnR5cGVvZiBmZXRjaD09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXt2YXIgcmVzdWx0PVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLGluZm8pO3JldHVybiByZXN1bHQudGhlbihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCxmdW5jdGlvbihyZWFzb24pe2VycihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIityZWFzb24pO2VycihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KX0pfSl9ZWxzZXtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCl9fWlmKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSl7dHJ5e3ZhciBleHBvcnRzPU1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLHJlY2VpdmVJbnN0YW5jZSk7cmV0dXJuIGV4cG9ydHN9Y2F0Y2goZSl7ZXJyKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSk7cmV0dXJuIGZhbHNlfX1pbnN0YW50aWF0ZUFzeW5jKCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm57fX12YXIgQVNNX0NPTlNUUz17NjUzOTg4OmZ1bmN0aW9uKCl7dGhyb3dcIkNhbmNlbGVkIVwifSw2NTQwMDY6ZnVuY3Rpb24oJDAsJDEpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtfX2Vtc2NyaXB0ZW5fZG9fZGlzcGF0Y2hfdG9fdGhyZWFkKCQwLCQxKX0sMCl9fTtmdW5jdGlvbiBpbml0UHRocmVhZHNKUygpe1BUaHJlYWQuaW5pdFJ1bnRpbWUoKX1mdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3Mpe3doaWxlKGNhbGxiYWNrcy5sZW5ndGg+MCl7dmFyIGNhbGxiYWNrPWNhbGxiYWNrcy5zaGlmdCgpO2lmKHR5cGVvZiBjYWxsYmFjaz09XCJmdW5jdGlvblwiKXtjYWxsYmFjayhNb2R1bGUpO2NvbnRpbnVlfXZhciBmdW5jPWNhbGxiYWNrLmZ1bmM7aWYodHlwZW9mIGZ1bmM9PT1cIm51bWJlclwiKXtpZihjYWxsYmFjay5hcmc9PT11bmRlZmluZWQpe3dhc21UYWJsZS5nZXQoZnVuYykoKX1lbHNle3dhc21UYWJsZS5nZXQoZnVuYykoY2FsbGJhY2suYXJnKX19ZWxzZXtmdW5jKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZD9udWxsOmNhbGxiYWNrLmFyZyl9fX12YXIgRVJSTk9fQ09ERVM9e0VQRVJNOjYzLEVOT0VOVDo0NCxFU1JDSDo3MSxFSU5UUjoyNyxFSU86MjksRU5YSU86NjAsRTJCSUc6MSxFTk9FWEVDOjQ1LEVCQURGOjgsRUNISUxEOjEyLEVBR0FJTjo2LEVXT1VMREJMT0NLOjYsRU5PTUVNOjQ4LEVBQ0NFUzoyLEVGQVVMVDoyMSxFTk9UQkxLOjEwNSxFQlVTWToxMCxFRVhJU1Q6MjAsRVhERVY6NzUsRU5PREVWOjQzLEVOT1RESVI6NTQsRUlTRElSOjMxLEVJTlZBTDoyOCxFTkZJTEU6NDEsRU1GSUxFOjMzLEVOT1RUWTo1OSxFVFhUQlNZOjc0LEVGQklHOjIyLEVOT1NQQzo1MSxFU1BJUEU6NzAsRVJPRlM6NjksRU1MSU5LOjM0LEVQSVBFOjY0LEVET006MTgsRVJBTkdFOjY4LEVOT01TRzo0OSxFSURSTToyNCxFQ0hSTkc6MTA2LEVMMk5TWU5DOjE1NixFTDNITFQ6MTA3LEVMM1JTVDoxMDgsRUxOUk5HOjEwOSxFVU5BVENIOjExMCxFTk9DU0k6MTExLEVMMkhMVDoxMTIsRURFQURMSzoxNixFTk9MQ0s6NDYsRUJBREU6MTEzLEVCQURSOjExNCxFWEZVTEw6MTE1LEVOT0FOTzoxMDQsRUJBRFJRQzoxMDMsRUJBRFNMVDoxMDIsRURFQURMT0NLOjE2LEVCRk9OVDoxMDEsRU5PU1RSOjEwMCxFTk9EQVRBOjExNixFVElNRToxMTcsRU5PU1I6MTE4LEVOT05FVDoxMTksRU5PUEtHOjEyMCxFUkVNT1RFOjEyMSxFTk9MSU5LOjQ3LEVBRFY6MTIyLEVTUk1OVDoxMjMsRUNPTU06MTI0LEVQUk9UTzo2NSxFTVVMVElIT1A6MzYsRURPVERPVDoxMjUsRUJBRE1TRzo5LEVOT1RVTklROjEyNixFQkFERkQ6MTI3LEVSRU1DSEc6MTI4LEVMSUJBQ0M6MTI5LEVMSUJCQUQ6MTMwLEVMSUJTQ046MTMxLEVMSUJNQVg6MTMyLEVMSUJFWEVDOjEzMyxFTk9TWVM6NTIsRU5PVEVNUFRZOjU1LEVOQU1FVE9PTE9ORzozNyxFTE9PUDozMixFT1BOT1RTVVBQOjEzOCxFUEZOT1NVUFBPUlQ6MTM5LEVDT05OUkVTRVQ6MTUsRU5PQlVGUzo0MixFQUZOT1NVUFBPUlQ6NSxFUFJPVE9UWVBFOjY3LEVOT1RTT0NLOjU3LEVOT1BST1RPT1BUOjUwLEVTSFVURE9XTjoxNDAsRUNPTk5SRUZVU0VEOjE0LEVBRERSSU5VU0U6MyxFQ09OTkFCT1JURUQ6MTMsRU5FVFVOUkVBQ0g6NDAsRU5FVERPV046MzgsRVRJTUVET1VUOjczLEVIT1NURE9XTjoxNDIsRUhPU1RVTlJFQUNIOjIzLEVJTlBST0dSRVNTOjI2LEVBTFJFQURZOjcsRURFU1RBRERSUkVROjE3LEVNU0dTSVpFOjM1LEVQUk9UT05PU1VQUE9SVDo2NixFU09DS1ROT1NVUFBPUlQ6MTM3LEVBRERSTk9UQVZBSUw6NCxFTkVUUkVTRVQ6MzksRUlTQ09OTjozMCxFTk9UQ09OTjo1MyxFVE9PTUFOWVJFRlM6MTQxLEVVU0VSUzoxMzYsRURRVU9UOjE5LEVTVEFMRTo3MixFTk9UU1VQOjEzOCxFTk9NRURJVU06MTQ4LEVJTFNFUToyNSxFT1ZFUkZMT1c6NjEsRUNBTkNFTEVEOjExLEVOT1RSRUNPVkVSQUJMRTo1NixFT1dORVJERUFEOjYyLEVTVFJQSVBFOjEzNX07ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZnV0ZXhfd2FrZShhZGRyLGNvdW50KXtpZihhZGRyPD0wfHxhZGRyPkdST1dBQkxFX0hFQVBfSTgoKS5sZW5ndGh8fGFkZHImMyE9MHx8Y291bnQ8MClyZXR1cm4tMjg7aWYoY291bnQ9PTApcmV0dXJuIDA7aWYoY291bnQ+PTIxNDc0ODM2NDcpY291bnQ9SW5maW5pdHk7dmFyIG1haW5UaHJlYWRXYWl0QWRkcmVzcz1BdG9taWNzLmxvYWQoR1JPV0FCTEVfSEVBUF9JMzIoKSxfX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfZnV0ZXg+PjIpO3ZhciBtYWluVGhyZWFkV29rZW49MDtpZihtYWluVGhyZWFkV2FpdEFkZHJlc3M9PWFkZHIpe3ZhciBsb2FkZWRBZGRyPUF0b21pY3MuY29tcGFyZUV4Y2hhbmdlKEdST1dBQkxFX0hFQVBfSTMyKCksX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4Pj4yLG1haW5UaHJlYWRXYWl0QWRkcmVzcywwKTtpZihsb2FkZWRBZGRyPT1tYWluVGhyZWFkV2FpdEFkZHJlc3Mpey0tY291bnQ7bWFpblRocmVhZFdva2VuPTE7aWYoY291bnQ8PTApcmV0dXJuIDF9fXZhciByZXQ9QXRvbWljcy5ub3RpZnkoR1JPV0FCTEVfSEVBUF9JMzIoKSxhZGRyPj4yLGNvdW50KTtpZihyZXQ+PTApcmV0dXJuIHJldCttYWluVGhyZWFkV29rZW47dGhyb3dcIkF0b21pY3Mubm90aWZ5IHJldHVybmVkIGFuIHVuZXhwZWN0ZWQgdmFsdWUgXCIrcmV0fU1vZHVsZVtcIl9lbXNjcmlwdGVuX2Z1dGV4X3dha2VcIl09X2Vtc2NyaXB0ZW5fZnV0ZXhfd2FrZTtmdW5jdGlvbiBraWxsVGhyZWFkKHB0aHJlYWRfcHRyKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXRocm93XCJJbnRlcm5hbCBFcnJvciEga2lsbFRocmVhZCgpIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIGZyb20gbWFpbiBhcHBsaWNhdGlvbiB0aHJlYWQhXCI7aWYoIXB0aHJlYWRfcHRyKXRocm93XCJJbnRlcm5hbCBFcnJvciEgTnVsbCBwdGhyZWFkX3B0ciBpbiBraWxsVGhyZWFkIVwiO0dST1dBQkxFX0hFQVBfSTMyKClbcHRocmVhZF9wdHIrMTI+PjJdPTA7dmFyIHB0aHJlYWQ9UFRocmVhZC5wdGhyZWFkc1twdGhyZWFkX3B0cl07cHRocmVhZC53b3JrZXIudGVybWluYXRlKCk7UFRocmVhZC5mcmVlVGhyZWFkRGF0YShwdGhyZWFkKTtQVGhyZWFkLnJ1bm5pbmdXb3JrZXJzLnNwbGljZShQVGhyZWFkLnJ1bm5pbmdXb3JrZXJzLmluZGV4T2YocHRocmVhZC53b3JrZXIpLDEpO3B0aHJlYWQud29ya2VyLnB0aHJlYWQ9dW5kZWZpbmVkfWZ1bmN0aW9uIGNhbmNlbFRocmVhZChwdGhyZWFkX3B0cil7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl0aHJvd1wiSW50ZXJuYWwgRXJyb3IhIGNhbmNlbFRocmVhZCgpIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIGZyb20gbWFpbiBhcHBsaWNhdGlvbiB0aHJlYWQhXCI7aWYoIXB0aHJlYWRfcHRyKXRocm93XCJJbnRlcm5hbCBFcnJvciEgTnVsbCBwdGhyZWFkX3B0ciBpbiBjYW5jZWxUaHJlYWQhXCI7dmFyIHB0aHJlYWQ9UFRocmVhZC5wdGhyZWFkc1twdGhyZWFkX3B0cl07cHRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJjYW5jZWxcIn0pfWZ1bmN0aW9uIGNsZWFudXBUaHJlYWQocHRocmVhZF9wdHIpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpdGhyb3dcIkludGVybmFsIEVycm9yISBjbGVhbnVwVGhyZWFkKCkgY2FuIG9ubHkgZXZlciBiZSBjYWxsZWQgZnJvbSBtYWluIGFwcGxpY2F0aW9uIHRocmVhZCFcIjtpZighcHRocmVhZF9wdHIpdGhyb3dcIkludGVybmFsIEVycm9yISBOdWxsIHB0aHJlYWRfcHRyIGluIGNsZWFudXBUaHJlYWQhXCI7dmFyIHB0aHJlYWQ9UFRocmVhZC5wdGhyZWFkc1twdGhyZWFkX3B0cl07aWYocHRocmVhZCl7R1JPV0FCTEVfSEVBUF9JMzIoKVtwdGhyZWFkX3B0cisxMj4+Ml09MDt2YXIgd29ya2VyPXB0aHJlYWQud29ya2VyO1BUaHJlYWQucmV0dXJuV29ya2VyVG9Qb29sKHdvcmtlcil9fXZhciBQVGhyZWFkPXt1bnVzZWRXb3JrZXJzOltdLHJ1bm5pbmdXb3JrZXJzOltdLHRsc0luaXRGdW5jdGlvbnM6W10saW5pdE1haW5UaHJlYWRCbG9jazpmdW5jdGlvbigpe30saW5pdFJ1bnRpbWU6ZnVuY3Rpb24oKXt2YXIgdGI9X21hbGxvYygyMjgpO2Zvcih2YXIgaT0wO2k8MjI4LzQ7KytpKUdST1dBQkxFX0hFQVBfVTMyKClbdGIvNCtpXT0wO0dST1dBQkxFX0hFQVBfSTMyKClbdGIrMTI+PjJdPXRiO3ZhciBoZWFkUHRyPXRiKzE1MjtHUk9XQUJMRV9IRUFQX0kzMigpW2hlYWRQdHI+PjJdPWhlYWRQdHI7dmFyIHRsc01lbW9yeT1fbWFsbG9jKDUxMik7Zm9yKHZhciBpPTA7aTwxMjg7KytpKUdST1dBQkxFX0hFQVBfVTMyKClbdGxzTWVtb3J5LzQraV09MDtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGIrMTAwPj4yLHRsc01lbW9yeSk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzQwPj4yLHRiKTtfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQodGIsIUVOVklST05NRU5UX0lTX1dPUktFUiwxKTtfZW1zY3JpcHRlbl9yZWdpc3Rlcl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkKHRiKX0saW5pdFdvcmtlcjpmdW5jdGlvbigpe30scHRocmVhZHM6e30sdGhyZWFkRXhpdEhhbmRsZXJzOltdLHJ1bkV4aXRIYW5kbGVyczpmdW5jdGlvbigpe3doaWxlKFBUaHJlYWQudGhyZWFkRXhpdEhhbmRsZXJzLmxlbmd0aD4wKXtQVGhyZWFkLnRocmVhZEV4aXRIYW5kbGVycy5wb3AoKSgpfWlmKEVOVklST05NRU5UX0lTX1BUSFJFQUQmJl9wdGhyZWFkX3NlbGYoKSlfX19wdGhyZWFkX3RzZF9ydW5fZHRvcnMoKX0scnVuRXhpdEhhbmRsZXJzQW5kRGVpbml0VGhyZWFkOmZ1bmN0aW9uKHRiLGV4aXRDb2RlKXtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGIrNTY+PjIsMSk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzYwPj4yLDApO1BUaHJlYWQucnVuRXhpdEhhbmRsZXJzKCk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzQ+PjIsZXhpdENvZGUpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0YiswPj4yLDEpO19lbXNjcmlwdGVuX2Z1dGV4X3dha2UodGIrMCwyMTQ3NDgzNjQ3KTtfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoMCwwLDApfSxzZXRFeGl0U3RhdHVzOmZ1bmN0aW9uKHN0YXR1cyl7RVhJVFNUQVRVUz1zdGF0dXN9LHRocmVhZEV4aXQ6ZnVuY3Rpb24oZXhpdENvZGUpe3ZhciB0Yj1fcHRocmVhZF9zZWxmKCk7aWYodGIpe1BUaHJlYWQucnVuRXhpdEhhbmRsZXJzQW5kRGVpbml0VGhyZWFkKHRiLGV4aXRDb2RlKTtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXtwb3N0TWVzc2FnZSh7XCJjbWRcIjpcImV4aXRcIn0pfX19LHRocmVhZENhbmNlbDpmdW5jdGlvbigpe1BUaHJlYWQucnVuRXhpdEhhbmRsZXJzQW5kRGVpbml0VGhyZWFkKF9wdGhyZWFkX3NlbGYoKSwtMSk7cG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJjYW5jZWxEb25lXCJ9KX0sdGVybWluYXRlQWxsVGhyZWFkczpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiBQVGhyZWFkLnB0aHJlYWRzKXt2YXIgcHRocmVhZD1QVGhyZWFkLnB0aHJlYWRzW3RdO2lmKHB0aHJlYWQmJnB0aHJlYWQud29ya2VyKXtQVGhyZWFkLnJldHVybldvcmtlclRvUG9vbChwdGhyZWFkLndvcmtlcil9fVBUaHJlYWQucHRocmVhZHM9e307Zm9yKHZhciBpPTA7aTxQVGhyZWFkLnVudXNlZFdvcmtlcnMubGVuZ3RoOysraSl7dmFyIHdvcmtlcj1QVGhyZWFkLnVudXNlZFdvcmtlcnNbaV07d29ya2VyLnRlcm1pbmF0ZSgpfVBUaHJlYWQudW51c2VkV29ya2Vycz1bXTtmb3IodmFyIGk9MDtpPFBUaHJlYWQucnVubmluZ1dvcmtlcnMubGVuZ3RoOysraSl7dmFyIHdvcmtlcj1QVGhyZWFkLnJ1bm5pbmdXb3JrZXJzW2ldO3ZhciBwdGhyZWFkPXdvcmtlci5wdGhyZWFkO1BUaHJlYWQuZnJlZVRocmVhZERhdGEocHRocmVhZCk7d29ya2VyLnRlcm1pbmF0ZSgpfVBUaHJlYWQucnVubmluZ1dvcmtlcnM9W119LGZyZWVUaHJlYWREYXRhOmZ1bmN0aW9uKHB0aHJlYWQpe2lmKCFwdGhyZWFkKXJldHVybjtpZihwdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3Qpe3ZhciB0bHNNZW1vcnk9R1JPV0FCTEVfSEVBUF9JMzIoKVtwdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3QrMTAwPj4yXTtHUk9XQUJMRV9IRUFQX0kzMigpW3B0aHJlYWQudGhyZWFkSW5mb1N0cnVjdCsxMDA+PjJdPTA7X2ZyZWUodGxzTWVtb3J5KTtfZnJlZShwdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3QpfXB0aHJlYWQudGhyZWFkSW5mb1N0cnVjdD0wO2lmKHB0aHJlYWQuYWxsb2NhdGVkT3duU3RhY2smJnB0aHJlYWQuc3RhY2tCYXNlKV9mcmVlKHB0aHJlYWQuc3RhY2tCYXNlKTtwdGhyZWFkLnN0YWNrQmFzZT0wO2lmKHB0aHJlYWQud29ya2VyKXB0aHJlYWQud29ya2VyLnB0aHJlYWQ9bnVsbH0scmV0dXJuV29ya2VyVG9Qb29sOmZ1bmN0aW9uKHdvcmtlcil7UFRocmVhZC5ydW5XaXRob3V0TWFpblRocmVhZFF1ZXVlZENhbGxzKGZ1bmN0aW9uKCl7ZGVsZXRlIFBUaHJlYWQucHRocmVhZHNbd29ya2VyLnB0aHJlYWQudGhyZWFkSW5mb1N0cnVjdF07UFRocmVhZC51bnVzZWRXb3JrZXJzLnB1c2god29ya2VyKTtQVGhyZWFkLnJ1bm5pbmdXb3JrZXJzLnNwbGljZShQVGhyZWFkLnJ1bm5pbmdXb3JrZXJzLmluZGV4T2Yod29ya2VyKSwxKTtQVGhyZWFkLmZyZWVUaHJlYWREYXRhKHdvcmtlci5wdGhyZWFkKTt3b3JrZXIucHRocmVhZD11bmRlZmluZWR9KX0scnVuV2l0aG91dE1haW5UaHJlYWRRdWV1ZWRDYWxsczpmdW5jdGlvbihmdW5jKXtHUk9XQUJMRV9IRUFQX0kzMigpW19fZW1zY3JpcHRlbl9hbGxvd19tYWluX3J1bnRpbWVfcXVldWVkX2NhbGxzPj4yXT0wO3RyeXtmdW5jKCl9ZmluYWxseXtHUk9XQUJMRV9IRUFQX0kzMigpW19fZW1zY3JpcHRlbl9hbGxvd19tYWluX3J1bnRpbWVfcXVldWVkX2NhbGxzPj4yXT0xfX0scmVjZWl2ZU9iamVjdFRyYW5zZmVyOmZ1bmN0aW9uKGRhdGEpe30sdGhyZWFkSW5pdDpmdW5jdGlvbigpe2Zvcih2YXIgaSBpbiBQVGhyZWFkLnRsc0luaXRGdW5jdGlvbnMpe1BUaHJlYWQudGxzSW5pdEZ1bmN0aW9uc1tpXSgpfX0sbG9hZFdhc21Nb2R1bGVUb1dvcmtlcjpmdW5jdGlvbih3b3JrZXIsb25GaW5pc2hlZExvYWRpbmcpe3dvcmtlci5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7dmFyIGQ9ZVtcImRhdGFcIl07dmFyIGNtZD1kW1wiY21kXCJdO2lmKHdvcmtlci5wdGhyZWFkKVBUaHJlYWQuY3VycmVudFByb3hpZWRPcGVyYXRpb25DYWxsZXJUaHJlYWQ9d29ya2VyLnB0aHJlYWQudGhyZWFkSW5mb1N0cnVjdDtpZihkW1widGFyZ2V0VGhyZWFkXCJdJiZkW1widGFyZ2V0VGhyZWFkXCJdIT1fcHRocmVhZF9zZWxmKCkpe3ZhciB0aHJlYWQ9UFRocmVhZC5wdGhyZWFkc1tkLnRhcmdldFRocmVhZF07aWYodGhyZWFkKXt0aHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKGUuZGF0YSxkW1widHJhbnNmZXJMaXN0XCJdKX1lbHNle2NvbnNvbGUuZXJyb3IoJ0ludGVybmFsIGVycm9yISBXb3JrZXIgc2VudCBhIG1lc3NhZ2UgXCInK2NtZCsnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytkW1widGFyZ2V0VGhyZWFkXCJdK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIil9UFRocmVhZC5jdXJyZW50UHJveGllZE9wZXJhdGlvbkNhbGxlclRocmVhZD11bmRlZmluZWQ7cmV0dXJufWlmKGNtZD09PVwicHJvY2Vzc1F1ZXVlZE1haW5UaHJlYWRXb3JrXCIpe19lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzKCl9ZWxzZSBpZihjbWQ9PT1cInNwYXduVGhyZWFkXCIpe3NwYXduVGhyZWFkKGUuZGF0YSl9ZWxzZSBpZihjbWQ9PT1cImNsZWFudXBUaHJlYWRcIil7Y2xlYW51cFRocmVhZChkW1widGhyZWFkXCJdKX1lbHNlIGlmKGNtZD09PVwia2lsbFRocmVhZFwiKXtraWxsVGhyZWFkKGRbXCJ0aHJlYWRcIl0pfWVsc2UgaWYoY21kPT09XCJjYW5jZWxUaHJlYWRcIil7Y2FuY2VsVGhyZWFkKGRbXCJ0aHJlYWRcIl0pfWVsc2UgaWYoY21kPT09XCJsb2FkZWRcIil7d29ya2VyLmxvYWRlZD10cnVlO2lmKG9uRmluaXNoZWRMb2FkaW5nKW9uRmluaXNoZWRMb2FkaW5nKHdvcmtlcik7aWYod29ya2VyLnJ1blB0aHJlYWQpe3dvcmtlci5ydW5QdGhyZWFkKCk7ZGVsZXRlIHdvcmtlci5ydW5QdGhyZWFkfX1lbHNlIGlmKGNtZD09PVwicHJpbnRcIil7b3V0KFwiVGhyZWFkIFwiK2RbXCJ0aHJlYWRJZFwiXStcIjogXCIrZFtcInRleHRcIl0pfWVsc2UgaWYoY21kPT09XCJwcmludEVyclwiKXtlcnIoXCJUaHJlYWQgXCIrZFtcInRocmVhZElkXCJdK1wiOiBcIitkW1widGV4dFwiXSl9ZWxzZSBpZihjbWQ9PT1cImFsZXJ0XCIpe2FsZXJ0KFwiVGhyZWFkIFwiK2RbXCJ0aHJlYWRJZFwiXStcIjogXCIrZFtcInRleHRcIl0pfWVsc2UgaWYoY21kPT09XCJleGl0XCIpe3ZhciBkZXRhY2hlZD13b3JrZXIucHRocmVhZCYmQXRvbWljcy5sb2FkKEdST1dBQkxFX0hFQVBfVTMyKCksd29ya2VyLnB0aHJlYWQudGhyZWFkSW5mb1N0cnVjdCs2ND4+Mik7aWYoZGV0YWNoZWQpe1BUaHJlYWQucmV0dXJuV29ya2VyVG9Qb29sKHdvcmtlcil9fWVsc2UgaWYoY21kPT09XCJleGl0UHJvY2Vzc1wiKXt0cnl7ZXhpdChkW1wicmV0dXJuQ29kZVwiXSl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpcmV0dXJuO3Rocm93IGV9fWVsc2UgaWYoY21kPT09XCJjYW5jZWxEb25lXCIpe1BUaHJlYWQucmV0dXJuV29ya2VyVG9Qb29sKHdvcmtlcil9ZWxzZSBpZihjbWQ9PT1cIm9iamVjdFRyYW5zZmVyXCIpe1BUaHJlYWQucmVjZWl2ZU9iamVjdFRyYW5zZmVyKGUuZGF0YSl9ZWxzZSBpZihlLmRhdGEudGFyZ2V0PT09XCJzZXRpbW1lZGlhdGVcIil7d29ya2VyLnBvc3RNZXNzYWdlKGUuZGF0YSl9ZWxzZXtlcnIoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrY21kKX1QVGhyZWFkLmN1cnJlbnRQcm94aWVkT3BlcmF0aW9uQ2FsbGVyVGhyZWFkPXVuZGVmaW5lZH07d29ya2VyLm9uZXJyb3I9ZnVuY3Rpb24oZSl7ZXJyKFwicHRocmVhZCBzZW50IGFuIGVycm9yISBcIitlLmZpbGVuYW1lK1wiOlwiK2UubGluZW5vK1wiOiBcIitlLm1lc3NhZ2UpfTtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt3b3JrZXIub24oXCJtZXNzYWdlXCIsZnVuY3Rpb24oZGF0YSl7d29ya2VyLm9ubWVzc2FnZSh7ZGF0YTpkYXRhfSl9KTt3b3JrZXIub24oXCJlcnJvclwiLGZ1bmN0aW9uKGRhdGEpe3dvcmtlci5vbmVycm9yKGRhdGEpfSk7d29ya2VyLm9uKFwiZXhpdFwiLGZ1bmN0aW9uKGRhdGEpe30pfXdvcmtlci5wb3N0TWVzc2FnZSh7XCJjbWRcIjpcImxvYWRcIixcInVybE9yQmxvYlwiOk1vZHVsZVtcIm1haW5TY3JpcHRVcmxPckJsb2JcIl18fF9zY3JpcHREaXIsXCJ3YXNtTWVtb3J5XCI6d2FzbU1lbW9yeSxcIndhc21Nb2R1bGVcIjp3YXNtTW9kdWxlfSl9LGFsbG9jYXRlVW51c2VkV29ya2VyOmZ1bmN0aW9uKCl7dmFyIHB0aHJlYWRNYWluSnM9bG9jYXRlRmlsZShcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtQVGhyZWFkLnVudXNlZFdvcmtlcnMucHVzaChuZXcgV29ya2VyKHB0aHJlYWRNYWluSnMpKX0sZ2V0TmV3V29ya2VyOmZ1bmN0aW9uKCl7aWYoUFRocmVhZC51bnVzZWRXb3JrZXJzLmxlbmd0aD09MCl7UFRocmVhZC5hbGxvY2F0ZVVudXNlZFdvcmtlcigpO1BUaHJlYWQubG9hZFdhc21Nb2R1bGVUb1dvcmtlcihQVGhyZWFkLnVudXNlZFdvcmtlcnNbMF0pfXJldHVybiBQVGhyZWFkLnVudXNlZFdvcmtlcnMucG9wKCl9LGJ1c3lTcGluV2FpdDpmdW5jdGlvbihtc2Vjcyl7dmFyIHQ9cGVyZm9ybWFuY2Uubm93KCkrbXNlY3M7d2hpbGUocGVyZm9ybWFuY2Uubm93KCk8dCl7fX19O2Z1bmN0aW9uIGVzdGFibGlzaFN0YWNrU3BhY2Uoc3RhY2tUb3Asc3RhY2tNYXgpe19lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHMoc3RhY2tUb3Asc3RhY2tNYXgpO3N0YWNrUmVzdG9yZShzdGFja1RvcCl9TW9kdWxlW1wiZXN0YWJsaXNoU3RhY2tTcGFjZVwiXT1lc3RhYmxpc2hTdGFja1NwYWNlO2Z1bmN0aW9uIGludm9rZUVudHJ5UG9pbnQocHRyLGFyZyl7cmV0dXJuIHdhc21UYWJsZS5nZXQocHRyKShhcmcpfU1vZHVsZVtcImludm9rZUVudHJ5UG9pbnRcIl09aW52b2tlRW50cnlQb2ludDt2YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXI9MDtmdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCl7cmV0dXJuIG5vRXhpdFJ1bnRpbWV8fHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyPjB9TW9kdWxlW1wia2VlcFJ1bnRpbWVBbGl2ZVwiXT1rZWVwUnVudGltZUFsaXZlO2Z1bmN0aW9uIF9fX2Fzc2VydF9mYWlsKGNvbmRpdGlvbixmaWxlbmFtZSxsaW5lLGZ1bmMpe2Fib3J0KFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIrVVRGOFRvU3RyaW5nKGNvbmRpdGlvbikrXCIsIGF0OiBcIitbZmlsZW5hbWU/VVRGOFRvU3RyaW5nKGZpbGVuYW1lKTpcInVua25vd24gZmlsZW5hbWVcIixsaW5lLGZ1bmM/VVRGOFRvU3RyaW5nKGZ1bmMpOlwidW5rbm93biBmdW5jdGlvblwiXSl9dmFyIF9lbXNjcmlwdGVuX2dldF9ub3c7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7X2Vtc2NyaXB0ZW5fZ2V0X25vdz1mdW5jdGlvbigpe3ZhciB0PXByb2Nlc3NbXCJocnRpbWVcIl0oKTtyZXR1cm4gdFswXSoxZTMrdFsxXS8xZTZ9fWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7X2Vtc2NyaXB0ZW5fZ2V0X25vdz1mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKS1Nb2R1bGVbXCJfX3BlcmZvcm1hbmNlX25vd19jbG9ja19kcmlmdFwiXX19ZWxzZSBpZih0eXBlb2YgZGF0ZU5vdyE9PVwidW5kZWZpbmVkXCIpe19lbXNjcmlwdGVuX2dldF9ub3c9ZGF0ZU5vd31lbHNlIF9lbXNjcmlwdGVuX2dldF9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9O3ZhciBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYz10cnVlO2Z1bmN0aW9uIHNldEVyck5vKHZhbHVlKXtHUk9XQUJMRV9IRUFQX0kzMigpW19fX2Vycm5vX2xvY2F0aW9uKCk+PjJdPXZhbHVlO3JldHVybiB2YWx1ZX1mdW5jdGlvbiBfY2xvY2tfZ2V0dGltZShjbGtfaWQsdHApe3ZhciBub3c7aWYoY2xrX2lkPT09MCl7bm93PURhdGUubm93KCl9ZWxzZSBpZigoY2xrX2lkPT09MXx8Y2xrX2lkPT09NCkmJl9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKXtub3c9X2Vtc2NyaXB0ZW5fZ2V0X25vdygpfWVsc2V7c2V0RXJyTm8oMjgpO3JldHVybi0xfUdST1dBQkxFX0hFQVBfSTMyKClbdHA+PjJdPW5vdy8xZTN8MDtHUk9XQUJMRV9IRUFQX0kzMigpW3RwKzQ+PjJdPW5vdyUxZTMqMWUzKjFlM3wwO3JldHVybiAwfWZ1bmN0aW9uIF9fX2Nsb2NrX2dldHRpbWUoYTAsYTEpe3JldHVybiBfY2xvY2tfZ2V0dGltZShhMCxhMSl9dmFyIEV4Y2VwdGlvbkluZm9BdHRycz17REVTVFJVQ1RPUl9PRkZTRVQ6MCxSRUZDT1VOVF9PRkZTRVQ6NCxUWVBFX09GRlNFVDo4LENBVUdIVF9PRkZTRVQ6MTIsUkVUSFJPV05fT0ZGU0VUOjEzLFNJWkU6MTZ9O2Z1bmN0aW9uIF9fX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24oc2l6ZSl7cmV0dXJuIF9tYWxsb2Moc2l6ZStFeGNlcHRpb25JbmZvQXR0cnMuU0laRSkrRXhjZXB0aW9uSW5mb0F0dHJzLlNJWkV9ZnVuY3Rpb24gX2F0ZXhpdChmdW5jLGFyZyl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMSwxLGZ1bmMsYXJnKTtfX0FURVhJVF9fLnVuc2hpZnQoe2Z1bmM6ZnVuYyxhcmc6YXJnfSl9ZnVuY3Rpb24gX19fY3hhX2F0ZXhpdChhMCxhMSl7cmV0dXJuIF9hdGV4aXQoYTAsYTEpfWZ1bmN0aW9uIF9wdGhyZWFkX2NsZWFudXBfcHVzaChyb3V0aW5lLGFyZyl7UFRocmVhZC50aHJlYWRFeGl0SGFuZGxlcnMucHVzaChmdW5jdGlvbigpe3dhc21UYWJsZS5nZXQocm91dGluZSkoYXJnKX0pfWZ1bmN0aW9uIF9fX2N4YV90aHJlYWRfYXRleGl0KGEwLGExKXtyZXR1cm4gX3B0aHJlYWRfY2xlYW51cF9wdXNoKGEwLGExKX1mdW5jdGlvbiBFeGNlcHRpb25JbmZvKGV4Y1B0cil7dGhpcy5leGNQdHI9ZXhjUHRyO3RoaXMucHRyPWV4Y1B0ci1FeGNlcHRpb25JbmZvQXR0cnMuU0laRTt0aGlzLnNldF90eXBlPWZ1bmN0aW9uKHR5cGUpe0dST1dBQkxFX0hFQVBfSTMyKClbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlRZUEVfT0ZGU0VUPj4yXT10eXBlfTt0aGlzLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEdST1dBQkxFX0hFQVBfSTMyKClbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlRZUEVfT0ZGU0VUPj4yXX07dGhpcy5zZXRfZGVzdHJ1Y3Rvcj1mdW5jdGlvbihkZXN0cnVjdG9yKXtHUk9XQUJMRV9IRUFQX0kzMigpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5ERVNUUlVDVE9SX09GRlNFVD4+Ml09ZGVzdHJ1Y3Rvcn07dGhpcy5nZXRfZGVzdHJ1Y3Rvcj1mdW5jdGlvbigpe3JldHVybiBHUk9XQUJMRV9IRUFQX0kzMigpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5ERVNUUlVDVE9SX09GRlNFVD4+Ml19O3RoaXMuc2V0X3JlZmNvdW50PWZ1bmN0aW9uKHJlZmNvdW50KXtHUk9XQUJMRV9IRUFQX0kzMigpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5SRUZDT1VOVF9PRkZTRVQ+PjJdPXJlZmNvdW50fTt0aGlzLnNldF9jYXVnaHQ9ZnVuY3Rpb24oY2F1Z2h0KXtjYXVnaHQ9Y2F1Z2h0PzE6MDtHUk9XQUJMRV9IRUFQX0k4KClbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLkNBVUdIVF9PRkZTRVQ+PjBdPWNhdWdodH07dGhpcy5nZXRfY2F1Z2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEdST1dBQkxFX0hFQVBfSTgoKVt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuQ0FVR0hUX09GRlNFVD4+MF0hPTB9O3RoaXMuc2V0X3JldGhyb3duPWZ1bmN0aW9uKHJldGhyb3duKXtyZXRocm93bj1yZXRocm93bj8xOjA7R1JPV0FCTEVfSEVBUF9JOCgpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5SRVRIUk9XTl9PRkZTRVQ+PjBdPXJldGhyb3dufTt0aGlzLmdldF9yZXRocm93bj1mdW5jdGlvbigpe3JldHVybiBHUk9XQUJMRV9IRUFQX0k4KClbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFVEhST1dOX09GRlNFVD4+MF0hPTB9O3RoaXMuaW5pdD1mdW5jdGlvbih0eXBlLGRlc3RydWN0b3Ipe3RoaXMuc2V0X3R5cGUodHlwZSk7dGhpcy5zZXRfZGVzdHJ1Y3RvcihkZXN0cnVjdG9yKTt0aGlzLnNldF9yZWZjb3VudCgwKTt0aGlzLnNldF9jYXVnaHQoZmFsc2UpO3RoaXMuc2V0X3JldGhyb3duKGZhbHNlKX07dGhpcy5hZGRfcmVmPWZ1bmN0aW9uKCl7QXRvbWljcy5hZGQoR1JPV0FCTEVfSEVBUF9JMzIoKSx0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVGQ09VTlRfT0ZGU0VUPj4yLDEpfTt0aGlzLnJlbGVhc2VfcmVmPWZ1bmN0aW9uKCl7dmFyIHByZXY9QXRvbWljcy5zdWIoR1JPV0FCTEVfSEVBUF9JMzIoKSx0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVGQ09VTlRfT0ZGU0VUPj4yLDEpO3JldHVybiBwcmV2PT09MX19dmFyIGV4Y2VwdGlvbkxhc3Q9MDt2YXIgdW5jYXVnaHRFeGNlcHRpb25Db3VudD0wO2Z1bmN0aW9uIF9fX2N4YV90aHJvdyhwdHIsdHlwZSxkZXN0cnVjdG9yKXt2YXIgaW5mbz1uZXcgRXhjZXB0aW9uSW5mbyhwdHIpO2luZm8uaW5pdCh0eXBlLGRlc3RydWN0b3IpO2V4Y2VwdGlvbkxhc3Q9cHRyO3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQrKzt0aHJvdyBwdHJ9dmFyIFNZU0NBTExTPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oc3RyZWFtLGN1cnIpe3ZhciBidWZmZXI9U1lTQ0FMTFMuYnVmZmVyc1tzdHJlYW1dO2lmKGN1cnI9PT0wfHxjdXJyPT09MTApeyhzdHJlYW09PT0xP291dDplcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwwKSk7YnVmZmVyLmxlbmd0aD0wfWVsc2V7YnVmZmVyLnB1c2goY3Vycil9fSx2YXJhcmdzOnVuZGVmaW5lZCxnZXQ6ZnVuY3Rpb24oKXtTWVNDQUxMUy52YXJhcmdzKz00O3ZhciByZXQ9R1JPV0FCTEVfSEVBUF9JMzIoKVtTWVNDQUxMUy52YXJhcmdzLTQ+PjJdO3JldHVybiByZXR9LGdldFN0cjpmdW5jdGlvbihwdHIpe3ZhciByZXQ9VVRGOFRvU3RyaW5nKHB0cik7cmV0dXJuIHJldH0sZ2V0NjQ6ZnVuY3Rpb24obG93LGhpZ2gpe3JldHVybiBsb3d9fTtmdW5jdGlvbiBfX19zeXNfYWNjZXNzKHBhdGgsYW1vZGUpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDIsMSxwYXRoLGFtb2RlKTtwYXRoPVNZU0NBTExTLmdldFN0cihwYXRoKTtyZXR1cm4gU1lTQ0FMTFMuZG9BY2Nlc3MocGF0aCxhbW9kZSl9ZnVuY3Rpb24gX19fc3lzX2ZjbnRsNjQoZmQsY21kLHZhcmFyZ3Mpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDMsMSxmZCxjbWQsdmFyYXJncyk7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3JldHVybiAwfWZ1bmN0aW9uIF9fX3N5c19mc3RhdDY0KGZkLGJ1Zil7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoNCwxLGZkLGJ1Zil9ZnVuY3Rpb24gX19fc3lzX2dldGRlbnRzNjQoZmQsZGlycCxjb3VudCl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoNSwxLGZkLGRpcnAsY291bnQpfWZ1bmN0aW9uIF9fX3N5c19nZXRwaWQoKXtyZXR1cm4gNDJ9ZnVuY3Rpb24gX19fc3lzX2lvY3RsKGZkLG9wLHZhcmFyZ3Mpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDYsMSxmZCxvcCx2YXJhcmdzKTtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7cmV0dXJuIDB9ZnVuY3Rpb24gX19fc3lzX2xzdGF0NjQocGF0aCxidWYpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDcsMSxwYXRoLGJ1Zil9ZnVuY3Rpb24gX19fc3lzX21rZGlyKHBhdGgsbW9kZSl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoOCwxLHBhdGgsbW9kZSk7cGF0aD1TWVNDQUxMUy5nZXRTdHIocGF0aCk7cmV0dXJuIFNZU0NBTExTLmRvTWtkaXIocGF0aCxtb2RlKX1mdW5jdGlvbiBzeXNjYWxsTW1hcDIoYWRkcixsZW4scHJvdCxmbGFncyxmZCxvZmYpe29mZjw8PTEyO3ZhciBwdHI7dmFyIGFsbG9jYXRlZD1mYWxzZTtpZigoZmxhZ3MmMTYpIT09MCYmYWRkciU2NTUzNiE9PTApe3JldHVybi0yOH1pZigoZmxhZ3MmMzIpIT09MCl7cHRyPV9tZW1hbGlnbig2NTUzNixsZW4pO2lmKCFwdHIpcmV0dXJuLTQ4O19tZW1zZXQocHRyLDAsbGVuKTthbGxvY2F0ZWQ9dHJ1ZX1lbHNle3JldHVybi01Mn1TWVNDQUxMUy5tYXBwaW5nc1twdHJdPXttYWxsb2M6cHRyLGxlbjpsZW4sYWxsb2NhdGVkOmFsbG9jYXRlZCxmZDpmZCxwcm90OnByb3QsZmxhZ3M6ZmxhZ3Msb2Zmc2V0Om9mZn07cmV0dXJuIHB0cn1mdW5jdGlvbiBfX19zeXNfbW1hcDIoYWRkcixsZW4scHJvdCxmbGFncyxmZCxvZmYpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDksMSxhZGRyLGxlbixwcm90LGZsYWdzLGZkLG9mZik7cmV0dXJuIHN5c2NhbGxNbWFwMihhZGRyLGxlbixwcm90LGZsYWdzLGZkLG9mZil9ZnVuY3Rpb24gc3lzY2FsbE11bm1hcChhZGRyLGxlbil7aWYoKGFkZHJ8MCk9PT0tMXx8bGVuPT09MCl7cmV0dXJuLTI4fXZhciBpbmZvPVNZU0NBTExTLm1hcHBpbmdzW2FkZHJdO2lmKCFpbmZvKXJldHVybiAwO2lmKGxlbj09PWluZm8ubGVuKXtTWVNDQUxMUy5tYXBwaW5nc1thZGRyXT1udWxsO2lmKGluZm8uYWxsb2NhdGVkKXtfZnJlZShpbmZvLm1hbGxvYyl9fXJldHVybiAwfWZ1bmN0aW9uIF9fX3N5c19tdW5tYXAoYWRkcixsZW4pe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDEwLDEsYWRkcixsZW4pO3JldHVybiBzeXNjYWxsTXVubWFwKGFkZHIsbGVuKX1mdW5jdGlvbiBfX19zeXNfb3BlbihwYXRoLGZsYWdzLHZhcmFyZ3Mpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDExLDEscGF0aCxmbGFncyx2YXJhcmdzKTtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3N9ZnVuY3Rpb24gX19fc3lzX3JlYWRsaW5rKHBhdGgsYnVmLGJ1ZnNpemUpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDEyLDEscGF0aCxidWYsYnVmc2l6ZSk7cGF0aD1TWVNDQUxMUy5nZXRTdHIocGF0aCk7cmV0dXJuIFNZU0NBTExTLmRvUmVhZGxpbmsocGF0aCxidWYsYnVmc2l6ZSl9ZnVuY3Rpb24gX19fc3lzX3JtZGlyKHBhdGgpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDEzLDEscGF0aCl9ZnVuY3Rpb24gX19fc3lzX3N0YXQ2NChwYXRoLGJ1Zil7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMTQsMSxwYXRoLGJ1Zil9ZnVuY3Rpb24gX19fc3lzX3VubGluayhwYXRoKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxNSwxLHBhdGgpfWZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9ub3RpZnlfdGhyZWFkX3F1ZXVlKHRhcmdldFRocmVhZElkLG1haW5UaHJlYWRJZCl7aWYodGFyZ2V0VGhyZWFkSWQ9PW1haW5UaHJlYWRJZCl7cG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJwcm9jZXNzUXVldWVkTWFpblRocmVhZFdvcmtcIn0pfWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7cG9zdE1lc3NhZ2Uoe1widGFyZ2V0VGhyZWFkXCI6dGFyZ2V0VGhyZWFkSWQsXCJjbWRcIjpcInByb2Nlc3NUaHJlYWRRdWV1ZVwifSl9ZWxzZXt2YXIgcHRocmVhZD1QVGhyZWFkLnB0aHJlYWRzW3RhcmdldFRocmVhZElkXTt2YXIgd29ya2VyPXB0aHJlYWQmJnB0aHJlYWQud29ya2VyO2lmKCF3b3JrZXIpe3JldHVybn13b3JrZXIucG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJwcm9jZXNzVGhyZWFkUXVldWVcIn0pfXJldHVybiAxfWZ1bmN0aW9uIF9hYm9ydCgpe2Fib3J0KCl9ZnVuY3Rpb24gX2RpZmZ0aW1lKHRpbWUxLHRpbWUwKXtyZXR1cm4gdGltZTEtdGltZTB9ZnVuY3Rpb24gX2RsY2xvc2UoaGFuZGxlKXthYm9ydChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIHRvIHVzZSBFbXNjcmlwdGVuJ3MgbGlua2luZyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX1mdW5jdGlvbiBfZGxlcnJvcigpe2Fib3J0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgdG8gdXNlIEVtc2NyaXB0ZW4ncyBsaW5raW5nIHN1cHBvcnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfWZ1bmN0aW9uIF9kbG9wZW4oZmlsZW5hbWUsZmxhZyl7YWJvcnQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCB0byB1c2UgRW1zY3JpcHRlbidzIGxpbmtpbmcgc3VwcG9ydCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9ZnVuY3Rpb24gX2Rsc3ltKGhhbmRsZSxzeW1ib2wpe2Fib3J0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgdG8gdXNlIEVtc2NyaXB0ZW4ncyBsaW5raW5nIHN1cHBvcnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfXZhciByZWFkQXNtQ29uc3RBcmdzQXJyYXk9W107ZnVuY3Rpb24gcmVhZEFzbUNvbnN0QXJncyhzaWdQdHIsYnVmKXtyZWFkQXNtQ29uc3RBcmdzQXJyYXkubGVuZ3RoPTA7dmFyIGNoO2J1Zj4+PTI7d2hpbGUoY2g9R1JPV0FCTEVfSEVBUF9VOCgpW3NpZ1B0cisrXSl7dmFyIGRvdWJsZT1jaDwxMDU7aWYoZG91YmxlJiZidWYmMSlidWYrKztyZWFkQXNtQ29uc3RBcmdzQXJyYXkucHVzaChkb3VibGU/R1JPV0FCTEVfSEVBUF9GNjQoKVtidWYrKz4+MV06R1JPV0FCTEVfSEVBUF9JMzIoKVtidWZdKTsrK2J1Zn1yZXR1cm4gcmVhZEFzbUNvbnN0QXJnc0FycmF5fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX2FzbV9jb25zdF9pbnQoY29kZSxzaWdQdHIsYXJnYnVmKXt2YXIgYXJncz1yZWFkQXNtQ29uc3RBcmdzKHNpZ1B0cixhcmdidWYpO3JldHVybiBBU01fQ09OU1RTW2NvZGVdLmFwcGx5KG51bGwsYXJncyl9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fY2hlY2tfYmxvY2tpbmdfYWxsb3dlZCgpe2lmKEVOVklST05NRU5UX0lTX05PREUpcmV0dXJuO2lmKEVOVklST05NRU5UX0lTX1dPUktFUilyZXR1cm47d2Fybk9uY2UoXCJCbG9ja2luZyBvbiB0aGUgbWFpbiB0aHJlYWQgaXMgdmVyeSBkYW5nZXJvdXMsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvcG9ydGluZy9wdGhyZWFkcy5odG1sI2Jsb2NraW5nLW9uLXRoZS1tYWluLWJyb3dzZXItdGhyZWFkXCIpfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX2NvbmRpdGlvbmFsX3NldF9jdXJyZW50X3RocmVhZF9zdGF0dXMoZXhwZWN0ZWRTdGF0dXMsbmV3U3RhdHVzKXt9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZnV0ZXhfd2FpdChhZGRyLHZhbCx0aW1lb3V0KXtpZihhZGRyPD0wfHxhZGRyPkdST1dBQkxFX0hFQVBfSTgoKS5sZW5ndGh8fGFkZHImMyE9MClyZXR1cm4tMjg7aWYoIUVOVklST05NRU5UX0lTX1dFQil7dmFyIHJldD1BdG9taWNzLndhaXQoR1JPV0FCTEVfSEVBUF9JMzIoKSxhZGRyPj4yLHZhbCx0aW1lb3V0KTtpZihyZXQ9PT1cInRpbWVkLW91dFwiKXJldHVybi03MztpZihyZXQ9PT1cIm5vdC1lcXVhbFwiKXJldHVybi02O2lmKHJldD09PVwib2tcIilyZXR1cm4gMDt0aHJvd1wiQXRvbWljcy53YWl0IHJldHVybmVkIGFuIHVuZXhwZWN0ZWQgdmFsdWUgXCIrcmV0fWVsc2V7aWYoQXRvbWljcy5sb2FkKEdST1dBQkxFX0hFQVBfSTMyKCksYWRkcj4+MikhPXZhbCl7cmV0dXJuLTZ9dmFyIHROb3c9cGVyZm9ybWFuY2Uubm93KCk7dmFyIHRFbmQ9dE5vdyt0aW1lb3V0O3ZhciBsYXN0QWRkcj1BdG9taWNzLmV4Y2hhbmdlKEdST1dBQkxFX0hFQVBfSTMyKCksX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4Pj4yLGFkZHIpO3doaWxlKDEpe3ROb3c9cGVyZm9ybWFuY2Uubm93KCk7aWYodE5vdz50RW5kKXtsYXN0QWRkcj1BdG9taWNzLmV4Y2hhbmdlKEdST1dBQkxFX0hFQVBfSTMyKCksX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4Pj4yLDApO3JldHVybi03M31sYXN0QWRkcj1BdG9taWNzLmV4Y2hhbmdlKEdST1dBQkxFX0hFQVBfSTMyKCksX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4Pj4yLDApO2lmKGxhc3RBZGRyPT0wKXticmVha31fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscygpO2lmKEF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX0kzMigpLGFkZHI+PjIpIT12YWwpe3JldHVybi02fWxhc3RBZGRyPUF0b21pY3MuZXhjaGFuZ2UoR1JPV0FCTEVfSEVBUF9JMzIoKSxfX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfZnV0ZXg+PjIsYWRkcil9cmV0dXJuIDB9fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpe3JldHVybiAyMTQ3NDgzNjQ4fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCxzcmMsbnVtKXtHUk9XQUJMRV9IRUFQX1U4KCkuY29weVdpdGhpbihkZXN0LHNyYyxzcmMrbnVtKX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9udW1fbG9naWNhbF9jb3Jlcygpe2lmKEVOVklST05NRU5UX0lTX05PREUpcmV0dXJuIHJlcXVpcmUoXCJvc1wiKS5jcHVzKCkubGVuZ3RoO3JldHVybiBuYXZpZ2F0b3JbXCJoYXJkd2FyZUNvbmN1cnJlbmN5XCJdfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKGluZGV4LHN5bmMpe3ZhciBudW1DYWxsQXJncz1hcmd1bWVudHMubGVuZ3RoLTI7dmFyIHN0YWNrPXN0YWNrU2F2ZSgpO3ZhciBzZXJpYWxpemVkTnVtQ2FsbEFyZ3M9bnVtQ2FsbEFyZ3M7dmFyIGFyZ3M9c3RhY2tBbGxvYyhzZXJpYWxpemVkTnVtQ2FsbEFyZ3MqOCk7dmFyIGI9YXJncz4+Mztmb3IodmFyIGk9MDtpPG51bUNhbGxBcmdzO2krKyl7dmFyIGFyZz1hcmd1bWVudHNbMitpXTtHUk9XQUJMRV9IRUFQX0Y2NCgpW2IraV09YXJnfXZhciByZXQ9X2Vtc2NyaXB0ZW5fcnVuX2luX21haW5fcnVudGltZV90aHJlYWRfanMoaW5kZXgsc2VyaWFsaXplZE51bUNhbGxBcmdzLGFyZ3Msc3luYyk7c3RhY2tSZXN0b3JlKHN0YWNrKTtyZXR1cm4gcmV0fXZhciBfZW1zY3JpcHRlbl9yZWNlaXZlX29uX21haW5fdGhyZWFkX2pzX2NhbGxBcmdzPVtdO2Z1bmN0aW9uIF9lbXNjcmlwdGVuX3JlY2VpdmVfb25fbWFpbl90aHJlYWRfanMoaW5kZXgsbnVtQ2FsbEFyZ3MsYXJncyl7X2Vtc2NyaXB0ZW5fcmVjZWl2ZV9vbl9tYWluX3RocmVhZF9qc19jYWxsQXJncy5sZW5ndGg9bnVtQ2FsbEFyZ3M7dmFyIGI9YXJncz4+Mztmb3IodmFyIGk9MDtpPG51bUNhbGxBcmdzO2krKyl7X2Vtc2NyaXB0ZW5fcmVjZWl2ZV9vbl9tYWluX3RocmVhZF9qc19jYWxsQXJnc1tpXT1HUk9XQUJMRV9IRUFQX0Y2NCgpW2IraV19dmFyIGlzRW1Bc21Db25zdD1pbmRleDwwO3ZhciBmdW5jPSFpc0VtQXNtQ29uc3Q/cHJveGllZEZ1bmN0aW9uVGFibGVbaW5kZXhdOkFTTV9DT05TVFNbLWluZGV4LTFdO3JldHVybiBmdW5jLmFwcGx5KG51bGwsX2Vtc2NyaXB0ZW5fcmVjZWl2ZV9vbl9tYWluX3RocmVhZF9qc19jYWxsQXJncyl9ZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKXt0cnl7d2FzbU1lbW9yeS5ncm93KHNpemUtYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNik7dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpO3JldHVybiAxfWNhdGNoKGUpe319ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSl7dmFyIG9sZFNpemU9R1JPV0FCTEVfSEVBUF9VOCgpLmxlbmd0aDtyZXF1ZXN0ZWRTaXplPXJlcXVlc3RlZFNpemU+Pj4wO2lmKHJlcXVlc3RlZFNpemU8PW9sZFNpemUpe3JldHVybiBmYWxzZX12YXIgbWF4SGVhcFNpemU9MjE0NzQ4MzY0ODtpZihyZXF1ZXN0ZWRTaXplPm1heEhlYXBTaXplKXtyZXR1cm4gZmFsc2V9Zm9yKHZhciBjdXREb3duPTE7Y3V0RG93bjw9NDtjdXREb3duKj0yKXt2YXIgb3Zlckdyb3duSGVhcFNpemU9b2xkU2l6ZSooMSsuMi9jdXREb3duKTtvdmVyR3Jvd25IZWFwU2l6ZT1NYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSxyZXF1ZXN0ZWRTaXplKzEwMDY2MzI5Nik7dmFyIG5ld1NpemU9TWF0aC5taW4obWF4SGVhcFNpemUsYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLG92ZXJHcm93bkhlYXBTaXplKSw2NTUzNikpO3ZhciByZXBsYWNlbWVudD1lbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO2lmKHJlcGxhY2VtZW50KXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfXZhciBKU0V2ZW50cz17aW5FdmVudEhhbmRsZXI6MCxyZW1vdmVBbGxFdmVudExpc3RlbmVyczpmdW5jdGlvbigpe2Zvcih2YXIgaT1KU0V2ZW50cy5ldmVudEhhbmRsZXJzLmxlbmd0aC0xO2k+PTA7LS1pKXtKU0V2ZW50cy5fcmVtb3ZlSGFuZGxlcihpKX1KU0V2ZW50cy5ldmVudEhhbmRsZXJzPVtdO0pTRXZlbnRzLmRlZmVycmVkQ2FsbHM9W119LHJlZ2lzdGVyUmVtb3ZlRXZlbnRMaXN0ZW5lcnM6ZnVuY3Rpb24oKXtpZighSlNFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcnNSZWdpc3RlcmVkKXtfX0FURVhJVF9fLnB1c2goSlNFdmVudHMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMpO0pTRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXJzUmVnaXN0ZXJlZD10cnVlfX0sZGVmZXJyZWRDYWxsczpbXSxkZWZlckNhbGw6ZnVuY3Rpb24odGFyZ2V0RnVuY3Rpb24scHJlY2VkZW5jZSxhcmdzTGlzdCl7ZnVuY3Rpb24gYXJyYXlzSGF2ZUVxdWFsQ29udGVudChhcnJBLGFyckIpe2lmKGFyckEubGVuZ3RoIT1hcnJCLmxlbmd0aClyZXR1cm4gZmFsc2U7Zm9yKHZhciBpIGluIGFyckEpe2lmKGFyckFbaV0hPWFyckJbaV0pcmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfWZvcih2YXIgaSBpbiBKU0V2ZW50cy5kZWZlcnJlZENhbGxzKXt2YXIgY2FsbD1KU0V2ZW50cy5kZWZlcnJlZENhbGxzW2ldO2lmKGNhbGwudGFyZ2V0RnVuY3Rpb249PXRhcmdldEZ1bmN0aW9uJiZhcnJheXNIYXZlRXF1YWxDb250ZW50KGNhbGwuYXJnc0xpc3QsYXJnc0xpc3QpKXtyZXR1cm59fUpTRXZlbnRzLmRlZmVycmVkQ2FsbHMucHVzaCh7dGFyZ2V0RnVuY3Rpb246dGFyZ2V0RnVuY3Rpb24scHJlY2VkZW5jZTpwcmVjZWRlbmNlLGFyZ3NMaXN0OmFyZ3NMaXN0fSk7SlNFdmVudHMuZGVmZXJyZWRDYWxscy5zb3J0KGZ1bmN0aW9uKHgseSl7cmV0dXJuIHgucHJlY2VkZW5jZTx5LnByZWNlZGVuY2V9KX0scmVtb3ZlRGVmZXJyZWRDYWxsczpmdW5jdGlvbih0YXJnZXRGdW5jdGlvbil7Zm9yKHZhciBpPTA7aTxKU0V2ZW50cy5kZWZlcnJlZENhbGxzLmxlbmd0aDsrK2kpe2lmKEpTRXZlbnRzLmRlZmVycmVkQ2FsbHNbaV0udGFyZ2V0RnVuY3Rpb249PXRhcmdldEZ1bmN0aW9uKXtKU0V2ZW50cy5kZWZlcnJlZENhbGxzLnNwbGljZShpLDEpOy0taX19fSxjYW5QZXJmb3JtRXZlbnRIYW5kbGVyUmVxdWVzdHM6ZnVuY3Rpb24oKXtyZXR1cm4gSlNFdmVudHMuaW5FdmVudEhhbmRsZXImJkpTRXZlbnRzLmN1cnJlbnRFdmVudEhhbmRsZXIuYWxsb3dzRGVmZXJyZWRDYWxsc30scnVuRGVmZXJyZWRDYWxsczpmdW5jdGlvbigpe2lmKCFKU0V2ZW50cy5jYW5QZXJmb3JtRXZlbnRIYW5kbGVyUmVxdWVzdHMoKSl7cmV0dXJufWZvcih2YXIgaT0wO2k8SlNFdmVudHMuZGVmZXJyZWRDYWxscy5sZW5ndGg7KytpKXt2YXIgY2FsbD1KU0V2ZW50cy5kZWZlcnJlZENhbGxzW2ldO0pTRXZlbnRzLmRlZmVycmVkQ2FsbHMuc3BsaWNlKGksMSk7LS1pO2NhbGwudGFyZ2V0RnVuY3Rpb24uYXBwbHkobnVsbCxjYWxsLmFyZ3NMaXN0KX19LGV2ZW50SGFuZGxlcnM6W10scmVtb3ZlQWxsSGFuZGxlcnNPblRhcmdldDpmdW5jdGlvbih0YXJnZXQsZXZlbnRUeXBlU3RyaW5nKXtmb3IodmFyIGk9MDtpPEpTRXZlbnRzLmV2ZW50SGFuZGxlcnMubGVuZ3RoOysraSl7aWYoSlNFdmVudHMuZXZlbnRIYW5kbGVyc1tpXS50YXJnZXQ9PXRhcmdldCYmKCFldmVudFR5cGVTdHJpbmd8fGV2ZW50VHlwZVN0cmluZz09SlNFdmVudHMuZXZlbnRIYW5kbGVyc1tpXS5ldmVudFR5cGVTdHJpbmcpKXtKU0V2ZW50cy5fcmVtb3ZlSGFuZGxlcihpLS0pfX19LF9yZW1vdmVIYW5kbGVyOmZ1bmN0aW9uKGkpe3ZhciBoPUpTRXZlbnRzLmV2ZW50SGFuZGxlcnNbaV07aC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50VHlwZVN0cmluZyxoLmV2ZW50TGlzdGVuZXJGdW5jLGgudXNlQ2FwdHVyZSk7SlNFdmVudHMuZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwxKX0scmVnaXN0ZXJPclJlbW92ZUhhbmRsZXI6ZnVuY3Rpb24oZXZlbnRIYW5kbGVyKXt2YXIganNFdmVudEhhbmRsZXI9ZnVuY3Rpb24ganNFdmVudEhhbmRsZXIoZXZlbnQpeysrSlNFdmVudHMuaW5FdmVudEhhbmRsZXI7SlNFdmVudHMuY3VycmVudEV2ZW50SGFuZGxlcj1ldmVudEhhbmRsZXI7SlNFdmVudHMucnVuRGVmZXJyZWRDYWxscygpO2V2ZW50SGFuZGxlci5oYW5kbGVyRnVuYyhldmVudCk7SlNFdmVudHMucnVuRGVmZXJyZWRDYWxscygpOy0tSlNFdmVudHMuaW5FdmVudEhhbmRsZXJ9O2lmKGV2ZW50SGFuZGxlci5jYWxsYmFja2Z1bmMpe2V2ZW50SGFuZGxlci5ldmVudExpc3RlbmVyRnVuYz1qc0V2ZW50SGFuZGxlcjtldmVudEhhbmRsZXIudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRIYW5kbGVyLmV2ZW50VHlwZVN0cmluZyxqc0V2ZW50SGFuZGxlcixldmVudEhhbmRsZXIudXNlQ2FwdHVyZSk7SlNFdmVudHMuZXZlbnRIYW5kbGVycy5wdXNoKGV2ZW50SGFuZGxlcik7SlNFdmVudHMucmVnaXN0ZXJSZW1vdmVFdmVudExpc3RlbmVycygpfWVsc2V7Zm9yKHZhciBpPTA7aTxKU0V2ZW50cy5ldmVudEhhbmRsZXJzLmxlbmd0aDsrK2kpe2lmKEpTRXZlbnRzLmV2ZW50SGFuZGxlcnNbaV0udGFyZ2V0PT1ldmVudEhhbmRsZXIudGFyZ2V0JiZKU0V2ZW50cy5ldmVudEhhbmRsZXJzW2ldLmV2ZW50VHlwZVN0cmluZz09ZXZlbnRIYW5kbGVyLmV2ZW50VHlwZVN0cmluZyl7SlNFdmVudHMuX3JlbW92ZUhhbmRsZXIoaS0tKX19fX0scXVldWVFdmVudEhhbmRsZXJPblRocmVhZF9paWlpOmZ1bmN0aW9uKHRhcmdldFRocmVhZCxldmVudEhhbmRsZXJGdW5jLGV2ZW50VHlwZUlkLGV2ZW50RGF0YSx1c2VyRGF0YSl7dmFyIHN0YWNrVG9wPXN0YWNrU2F2ZSgpO3ZhciB2YXJhcmdzPXN0YWNrQWxsb2MoMTIpO0dST1dBQkxFX0hFQVBfSTMyKClbdmFyYXJncz4+Ml09ZXZlbnRUeXBlSWQ7R1JPV0FCTEVfSEVBUF9JMzIoKVt2YXJhcmdzKzQ+PjJdPWV2ZW50RGF0YTtHUk9XQUJMRV9IRUFQX0kzMigpW3ZhcmFyZ3MrOD4+Ml09dXNlckRhdGE7X19lbXNjcmlwdGVuX2NhbGxfb25fdGhyZWFkKDAsdGFyZ2V0VGhyZWFkLDYzNzUzNDIwOCxldmVudEhhbmRsZXJGdW5jLGV2ZW50RGF0YSx2YXJhcmdzKTtzdGFja1Jlc3RvcmUoc3RhY2tUb3ApfSxnZXRUYXJnZXRUaHJlYWRGb3JFdmVudENhbGxiYWNrOmZ1bmN0aW9uKHRhcmdldFRocmVhZCl7c3dpdGNoKHRhcmdldFRocmVhZCl7Y2FzZSAxOnJldHVybiAwO2Nhc2UgMjpyZXR1cm4gUFRocmVhZC5jdXJyZW50UHJveGllZE9wZXJhdGlvbkNhbGxlclRocmVhZDtkZWZhdWx0OnJldHVybiB0YXJnZXRUaHJlYWR9fSxnZXROb2RlTmFtZUZvclRhcmdldDpmdW5jdGlvbih0YXJnZXQpe2lmKCF0YXJnZXQpcmV0dXJuXCJcIjtpZih0YXJnZXQ9PXdpbmRvdylyZXR1cm5cIiN3aW5kb3dcIjtpZih0YXJnZXQ9PXNjcmVlbilyZXR1cm5cIiNzY3JlZW5cIjtyZXR1cm4gdGFyZ2V0JiZ0YXJnZXQubm9kZU5hbWU/dGFyZ2V0Lm5vZGVOYW1lOlwiXCJ9LGZ1bGxzY3JlZW5FbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmZ1bGxzY3JlZW5FbmFibGVkfHxkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZH19O2Z1bmN0aW9uIHN0cmluZ1RvTmV3VVRGOChqc1N0cmluZyl7dmFyIGxlbmd0aD1sZW5ndGhCeXRlc1VURjgoanNTdHJpbmcpKzE7dmFyIGNTdHJpbmc9X21hbGxvYyhsZW5ndGgpO3N0cmluZ1RvVVRGOChqc1N0cmluZyxjU3RyaW5nLGxlbmd0aCk7cmV0dXJuIGNTdHJpbmd9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fc2V0X29mZnNjcmVlbmNhbnZhc19zaXplX29uX3RhcmdldF90aHJlYWRfanModGFyZ2V0VGhyZWFkLHRhcmdldENhbnZhcyx3aWR0aCxoZWlnaHQpe3ZhciBzdGFja1RvcD1zdGFja1NhdmUoKTt2YXIgdmFyYXJncz1zdGFja0FsbG9jKDEyKTt2YXIgdGFyZ2V0Q2FudmFzUHRyPTA7aWYodGFyZ2V0Q2FudmFzKXt0YXJnZXRDYW52YXNQdHI9c3RyaW5nVG9OZXdVVEY4KHRhcmdldENhbnZhcyl9R1JPV0FCTEVfSEVBUF9JMzIoKVt2YXJhcmdzPj4yXT10YXJnZXRDYW52YXNQdHI7R1JPV0FCTEVfSEVBUF9JMzIoKVt2YXJhcmdzKzQ+PjJdPXdpZHRoO0dST1dBQkxFX0hFQVBfSTMyKClbdmFyYXJncys4Pj4yXT1oZWlnaHQ7X19lbXNjcmlwdGVuX2NhbGxfb25fdGhyZWFkKDAsdGFyZ2V0VGhyZWFkLDY1NzQ1NzE1MiwwLHRhcmdldENhbnZhc1B0cix2YXJhcmdzKTtzdGFja1Jlc3RvcmUoc3RhY2tUb3ApfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9vZmZzY3JlZW5jYW52YXNfc2l6ZV9vbl90YXJnZXRfdGhyZWFkKHRhcmdldFRocmVhZCx0YXJnZXRDYW52YXMsd2lkdGgsaGVpZ2h0KXt0YXJnZXRDYW52YXM9dGFyZ2V0Q2FudmFzP1VURjhUb1N0cmluZyh0YXJnZXRDYW52YXMpOlwiXCI7X2Vtc2NyaXB0ZW5fc2V0X29mZnNjcmVlbmNhbnZhc19zaXplX29uX3RhcmdldF90aHJlYWRfanModGFyZ2V0VGhyZWFkLHRhcmdldENhbnZhcyx3aWR0aCxoZWlnaHQpfWZ1bmN0aW9uIG1heWJlQ1N0cmluZ1RvSnNTdHJpbmcoY1N0cmluZyl7cmV0dXJuIGNTdHJpbmc+Mj9VVEY4VG9TdHJpbmcoY1N0cmluZyk6Y1N0cmluZ312YXIgc3BlY2lhbEhUTUxUYXJnZXRzPVswLHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCI/ZG9jdW1lbnQ6MCx0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6MF07ZnVuY3Rpb24gZmluZEV2ZW50VGFyZ2V0KHRhcmdldCl7dGFyZ2V0PW1heWJlQ1N0cmluZ1RvSnNTdHJpbmcodGFyZ2V0KTt2YXIgZG9tRWxlbWVudD1zcGVjaWFsSFRNTFRhcmdldHNbdGFyZ2V0XXx8KHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCI/ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOnVuZGVmaW5lZCk7cmV0dXJuIGRvbUVsZW1lbnR9ZnVuY3Rpb24gZmluZENhbnZhc0V2ZW50VGFyZ2V0KHRhcmdldCl7cmV0dXJuIGZpbmRFdmVudFRhcmdldCh0YXJnZXQpfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplX2NhbGxpbmdfdGhyZWFkKHRhcmdldCx3aWR0aCxoZWlnaHQpe3ZhciBjYW52YXM9ZmluZENhbnZhc0V2ZW50VGFyZ2V0KHRhcmdldCk7aWYoIWNhbnZhcylyZXR1cm4tNDtpZihjYW52YXMuY2FudmFzU2hhcmVkUHRyKXtHUk9XQUJMRV9IRUFQX0kzMigpW2NhbnZhcy5jYW52YXNTaGFyZWRQdHI+PjJdPXdpZHRoO0dST1dBQkxFX0hFQVBfSTMyKClbY2FudmFzLmNhbnZhc1NoYXJlZFB0cis0Pj4yXT1oZWlnaHR9aWYoY2FudmFzLm9mZnNjcmVlbkNhbnZhc3x8IWNhbnZhcy5jb250cm9sVHJhbnNmZXJyZWRPZmZzY3JlZW4pe2lmKGNhbnZhcy5vZmZzY3JlZW5DYW52YXMpY2FudmFzPWNhbnZhcy5vZmZzY3JlZW5DYW52YXM7dmFyIGF1dG9SZXNpemVWaWV3cG9ydD1mYWxzZTtpZihjYW52YXMuR0xjdHhPYmplY3QmJmNhbnZhcy5HTGN0eE9iamVjdC5HTGN0eCl7dmFyIHByZXZWaWV3cG9ydD1jYW52YXMuR0xjdHhPYmplY3QuR0xjdHguZ2V0UGFyYW1ldGVyKDI5NzgpO2F1dG9SZXNpemVWaWV3cG9ydD1wcmV2Vmlld3BvcnRbMF09PT0wJiZwcmV2Vmlld3BvcnRbMV09PT0wJiZwcmV2Vmlld3BvcnRbMl09PT1jYW52YXMud2lkdGgmJnByZXZWaWV3cG9ydFszXT09PWNhbnZhcy5oZWlnaHR9Y2FudmFzLndpZHRoPXdpZHRoO2NhbnZhcy5oZWlnaHQ9aGVpZ2h0O2lmKGF1dG9SZXNpemVWaWV3cG9ydCl7Y2FudmFzLkdMY3R4T2JqZWN0LkdMY3R4LnZpZXdwb3J0KDAsMCx3aWR0aCxoZWlnaHQpfX1lbHNlIGlmKGNhbnZhcy5jYW52YXNTaGFyZWRQdHIpe3ZhciB0YXJnZXRUaHJlYWQ9R1JPV0FCTEVfSEVBUF9JMzIoKVtjYW52YXMuY2FudmFzU2hhcmVkUHRyKzg+PjJdO19lbXNjcmlwdGVuX3NldF9vZmZzY3JlZW5jYW52YXNfc2l6ZV9vbl90YXJnZXRfdGhyZWFkKHRhcmdldFRocmVhZCx0YXJnZXQsd2lkdGgsaGVpZ2h0KTtyZXR1cm4gMX1lbHNle3JldHVybi00fXJldHVybiAwfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplX21haW5fdGhyZWFkKHRhcmdldCx3aWR0aCxoZWlnaHQpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDE2LDEsdGFyZ2V0LHdpZHRoLGhlaWdodCk7cmV0dXJuIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplX2NhbGxpbmdfdGhyZWFkKHRhcmdldCx3aWR0aCxoZWlnaHQpfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplKHRhcmdldCx3aWR0aCxoZWlnaHQpe3ZhciBjYW52YXM9ZmluZENhbnZhc0V2ZW50VGFyZ2V0KHRhcmdldCk7aWYoY2FudmFzKXtyZXR1cm4gX2Vtc2NyaXB0ZW5fc2V0X2NhbnZhc19lbGVtZW50X3NpemVfY2FsbGluZ190aHJlYWQodGFyZ2V0LHdpZHRoLGhlaWdodCl9ZWxzZXtyZXR1cm4gX2Vtc2NyaXB0ZW5fc2V0X2NhbnZhc19lbGVtZW50X3NpemVfbWFpbl90aHJlYWQodGFyZ2V0LHdpZHRoLGhlaWdodCl9fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9jdXJyZW50X3RocmVhZF9zdGF0dXMobmV3U3RhdHVzKXt9ZnVuY3Rpb24gX193ZWJnbF9lbmFibGVfQU5HTEVfaW5zdGFuY2VkX2FycmF5cyhjdHgpe3ZhciBleHQ9Y3R4LmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7aWYoZXh0KXtjdHhbXCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yXCJdPWZ1bmN0aW9uKGluZGV4LGRpdmlzb3Ipe2V4dFtcInZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRVwiXShpbmRleCxkaXZpc29yKX07Y3R4W1wiZHJhd0FycmF5c0luc3RhbmNlZFwiXT1mdW5jdGlvbihtb2RlLGZpcnN0LGNvdW50LHByaW1jb3VudCl7ZXh0W1wiZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFXCJdKG1vZGUsZmlyc3QsY291bnQscHJpbWNvdW50KX07Y3R4W1wiZHJhd0VsZW1lbnRzSW5zdGFuY2VkXCJdPWZ1bmN0aW9uKG1vZGUsY291bnQsdHlwZSxpbmRpY2VzLHByaW1jb3VudCl7ZXh0W1wiZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEVcIl0obW9kZSxjb3VudCx0eXBlLGluZGljZXMscHJpbWNvdW50KX07cmV0dXJuIDF9fWZ1bmN0aW9uIF9fd2ViZ2xfZW5hYmxlX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0KGN0eCl7dmFyIGV4dD1jdHguZ2V0RXh0ZW5zaW9uKFwiT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIik7aWYoZXh0KXtjdHhbXCJjcmVhdGVWZXJ0ZXhBcnJheVwiXT1mdW5jdGlvbigpe3JldHVybiBleHRbXCJjcmVhdGVWZXJ0ZXhBcnJheU9FU1wiXSgpfTtjdHhbXCJkZWxldGVWZXJ0ZXhBcnJheVwiXT1mdW5jdGlvbih2YW8pe2V4dFtcImRlbGV0ZVZlcnRleEFycmF5T0VTXCJdKHZhbyl9O2N0eFtcImJpbmRWZXJ0ZXhBcnJheVwiXT1mdW5jdGlvbih2YW8pe2V4dFtcImJpbmRWZXJ0ZXhBcnJheU9FU1wiXSh2YW8pfTtjdHhbXCJpc1ZlcnRleEFycmF5XCJdPWZ1bmN0aW9uKHZhbyl7cmV0dXJuIGV4dFtcImlzVmVydGV4QXJyYXlPRVNcIl0odmFvKX07cmV0dXJuIDF9fWZ1bmN0aW9uIF9fd2ViZ2xfZW5hYmxlX1dFQkdMX2RyYXdfYnVmZmVycyhjdHgpe3ZhciBleHQ9Y3R4LmdldEV4dGVuc2lvbihcIldFQkdMX2RyYXdfYnVmZmVyc1wiKTtpZihleHQpe2N0eFtcImRyYXdCdWZmZXJzXCJdPWZ1bmN0aW9uKG4sYnVmcyl7ZXh0W1wiZHJhd0J1ZmZlcnNXRUJHTFwiXShuLGJ1ZnMpfTtyZXR1cm4gMX19ZnVuY3Rpb24gX193ZWJnbF9lbmFibGVfV0VCR0xfbXVsdGlfZHJhdyhjdHgpe3JldHVybiEhKGN0eC5tdWx0aURyYXdXZWJnbD1jdHguZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbXVsdGlfZHJhd1wiKSl9dmFyIEdMPXtjb3VudGVyOjEsYnVmZmVyczpbXSxwcm9ncmFtczpbXSxmcmFtZWJ1ZmZlcnM6W10scmVuZGVyYnVmZmVyczpbXSx0ZXh0dXJlczpbXSxzaGFkZXJzOltdLHZhb3M6W10sY29udGV4dHM6e30sb2Zmc2NyZWVuQ2FudmFzZXM6e30scXVlcmllczpbXSxzdHJpbmdDYWNoZTp7fSx1bnBhY2tBbGlnbm1lbnQ6NCxyZWNvcmRFcnJvcjpmdW5jdGlvbiByZWNvcmRFcnJvcihlcnJvckNvZGUpe2lmKCFHTC5sYXN0RXJyb3Ipe0dMLmxhc3RFcnJvcj1lcnJvckNvZGV9fSxnZXROZXdJZDpmdW5jdGlvbih0YWJsZSl7dmFyIHJldD1HTC5jb3VudGVyKys7Zm9yKHZhciBpPXRhYmxlLmxlbmd0aDtpPHJldDtpKyspe3RhYmxlW2ldPW51bGx9cmV0dXJuIHJldH0sZ2V0U291cmNlOmZ1bmN0aW9uKHNoYWRlcixjb3VudCxzdHJpbmcsbGVuZ3RoKXt2YXIgc291cmNlPVwiXCI7Zm9yKHZhciBpPTA7aTxjb3VudDsrK2kpe3ZhciBsZW49bGVuZ3RoP0dST1dBQkxFX0hFQVBfSTMyKClbbGVuZ3RoK2kqND4+Ml06LTE7c291cmNlKz1VVEY4VG9TdHJpbmcoR1JPV0FCTEVfSEVBUF9JMzIoKVtzdHJpbmcraSo0Pj4yXSxsZW48MD91bmRlZmluZWQ6bGVuKX1yZXR1cm4gc291cmNlfSxjcmVhdGVDb250ZXh0OmZ1bmN0aW9uKGNhbnZhcyx3ZWJHTENvbnRleHRBdHRyaWJ1dGVzKXtpZighY2FudmFzLmdldENvbnRleHRTYWZhcmlXZWJHTDJGaXhlZCl7Y2FudmFzLmdldENvbnRleHRTYWZhcmlXZWJHTDJGaXhlZD1jYW52YXMuZ2V0Q29udGV4dDtjYW52YXMuZ2V0Q29udGV4dD1mdW5jdGlvbih2ZXIsYXR0cnMpe3ZhciBnbD1jYW52YXMuZ2V0Q29udGV4dFNhZmFyaVdlYkdMMkZpeGVkKHZlcixhdHRycyk7cmV0dXJuIHZlcj09XCJ3ZWJnbFwiPT1nbCBpbnN0YW5jZW9mIFdlYkdMUmVuZGVyaW5nQ29udGV4dD9nbDpudWxsfX12YXIgY3R4PWNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIix3ZWJHTENvbnRleHRBdHRyaWJ1dGVzKTtpZighY3R4KXJldHVybiAwO3ZhciBoYW5kbGU9R0wucmVnaXN0ZXJDb250ZXh0KGN0eCx3ZWJHTENvbnRleHRBdHRyaWJ1dGVzKTtyZXR1cm4gaGFuZGxlfSxyZWdpc3RlckNvbnRleHQ6ZnVuY3Rpb24oY3R4LHdlYkdMQ29udGV4dEF0dHJpYnV0ZXMpe3ZhciBoYW5kbGU9X21hbGxvYyg4KTtHUk9XQUJMRV9IRUFQX0kzMigpW2hhbmRsZSs0Pj4yXT1fcHRocmVhZF9zZWxmKCk7dmFyIGNvbnRleHQ9e2hhbmRsZTpoYW5kbGUsYXR0cmlidXRlczp3ZWJHTENvbnRleHRBdHRyaWJ1dGVzLHZlcnNpb246d2ViR0xDb250ZXh0QXR0cmlidXRlcy5tYWpvclZlcnNpb24sR0xjdHg6Y3R4fTtpZihjdHguY2FudmFzKWN0eC5jYW52YXMuR0xjdHhPYmplY3Q9Y29udGV4dDtHTC5jb250ZXh0c1toYW5kbGVdPWNvbnRleHQ7aWYodHlwZW9mIHdlYkdMQ29udGV4dEF0dHJpYnV0ZXMuZW5hYmxlRXh0ZW5zaW9uc0J5RGVmYXVsdD09PVwidW5kZWZpbmVkXCJ8fHdlYkdMQ29udGV4dEF0dHJpYnV0ZXMuZW5hYmxlRXh0ZW5zaW9uc0J5RGVmYXVsdCl7R0wuaW5pdEV4dGVuc2lvbnMoY29udGV4dCl9cmV0dXJuIGhhbmRsZX0sbWFrZUNvbnRleHRDdXJyZW50OmZ1bmN0aW9uKGNvbnRleHRIYW5kbGUpe0dMLmN1cnJlbnRDb250ZXh0PUdMLmNvbnRleHRzW2NvbnRleHRIYW5kbGVdO01vZHVsZS5jdHg9R0xjdHg9R0wuY3VycmVudENvbnRleHQmJkdMLmN1cnJlbnRDb250ZXh0LkdMY3R4O3JldHVybiEoY29udGV4dEhhbmRsZSYmIUdMY3R4KX0sZ2V0Q29udGV4dDpmdW5jdGlvbihjb250ZXh0SGFuZGxlKXtyZXR1cm4gR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV19LGRlbGV0ZUNvbnRleHQ6ZnVuY3Rpb24oY29udGV4dEhhbmRsZSl7aWYoR0wuY3VycmVudENvbnRleHQ9PT1HTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXSlHTC5jdXJyZW50Q29udGV4dD1udWxsO2lmKHR5cGVvZiBKU0V2ZW50cz09PVwib2JqZWN0XCIpSlNFdmVudHMucmVtb3ZlQWxsSGFuZGxlcnNPblRhcmdldChHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXS5HTGN0eC5jYW52YXMpO2lmKEdMLmNvbnRleHRzW2NvbnRleHRIYW5kbGVdJiZHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXS5HTGN0eC5jYW52YXMpR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0uR0xjdHguY2FudmFzLkdMY3R4T2JqZWN0PXVuZGVmaW5lZDtfZnJlZShHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXS5oYW5kbGUpO0dMLmNvbnRleHRzW2NvbnRleHRIYW5kbGVdPW51bGx9LGluaXRFeHRlbnNpb25zOmZ1bmN0aW9uKGNvbnRleHQpe2lmKCFjb250ZXh0KWNvbnRleHQ9R0wuY3VycmVudENvbnRleHQ7aWYoY29udGV4dC5pbml0RXh0ZW5zaW9uc0RvbmUpcmV0dXJuO2NvbnRleHQuaW5pdEV4dGVuc2lvbnNEb25lPXRydWU7dmFyIEdMY3R4PWNvbnRleHQuR0xjdHg7X193ZWJnbF9lbmFibGVfQU5HTEVfaW5zdGFuY2VkX2FycmF5cyhHTGN0eCk7X193ZWJnbF9lbmFibGVfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QoR0xjdHgpO19fd2ViZ2xfZW5hYmxlX1dFQkdMX2RyYXdfYnVmZmVycyhHTGN0eCk7e0dMY3R4LmRpc2pvaW50VGltZXJRdWVyeUV4dD1HTGN0eC5nZXRFeHRlbnNpb24oXCJFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlcIil9X193ZWJnbF9lbmFibGVfV0VCR0xfbXVsdGlfZHJhdyhHTGN0eCk7dmFyIGV4dHM9R0xjdHguZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpfHxbXTtleHRzLmZvckVhY2goZnVuY3Rpb24oZXh0KXtpZighZXh0LmluY2x1ZGVzKFwibG9zZV9jb250ZXh0XCIpJiYhZXh0LmluY2x1ZGVzKFwiZGVidWdcIikpe0dMY3R4LmdldEV4dGVuc2lvbihleHQpfX0pfX07dmFyIF9fZW1zY3JpcHRlbl93ZWJnbF9wb3dlcl9wcmVmZXJlbmNlcz1bXCJkZWZhdWx0XCIsXCJsb3ctcG93ZXJcIixcImhpZ2gtcGVyZm9ybWFuY2VcIl07ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fd2ViZ2xfZG9fY3JlYXRlX2NvbnRleHQodGFyZ2V0LGF0dHJpYnV0ZXMpe3ZhciBhPWF0dHJpYnV0ZXM+PjI7dmFyIHBvd2VyUHJlZmVyZW5jZT1HUk9XQUJMRV9IRUFQX0kzMigpW2ErKDI0Pj4yKV07dmFyIGNvbnRleHRBdHRyaWJ1dGVzPXtcImFscGhhXCI6ISFHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDA+PjIpXSxcImRlcHRoXCI6ISFHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDQ+PjIpXSxcInN0ZW5jaWxcIjohIUdST1dBQkxFX0hFQVBfSTMyKClbYSsoOD4+MildLFwiYW50aWFsaWFzXCI6ISFHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDEyPj4yKV0sXCJwcmVtdWx0aXBsaWVkQWxwaGFcIjohIUdST1dBQkxFX0hFQVBfSTMyKClbYSsoMTY+PjIpXSxcInByZXNlcnZlRHJhd2luZ0J1ZmZlclwiOiEhR1JPV0FCTEVfSEVBUF9JMzIoKVthKygyMD4+MildLFwicG93ZXJQcmVmZXJlbmNlXCI6X19lbXNjcmlwdGVuX3dlYmdsX3Bvd2VyX3ByZWZlcmVuY2VzW3Bvd2VyUHJlZmVyZW5jZV0sXCJmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XCI6ISFHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDI4Pj4yKV0sbWFqb3JWZXJzaW9uOkdST1dBQkxFX0hFQVBfSTMyKClbYSsoMzI+PjIpXSxtaW5vclZlcnNpb246R1JPV0FCTEVfSEVBUF9JMzIoKVthKygzNj4+MildLGVuYWJsZUV4dGVuc2lvbnNCeURlZmF1bHQ6R1JPV0FCTEVfSEVBUF9JMzIoKVthKyg0MD4+MildLGV4cGxpY2l0U3dhcENvbnRyb2w6R1JPV0FCTEVfSEVBUF9JMzIoKVthKyg0ND4+MildLHByb3h5Q29udGV4dFRvTWFpblRocmVhZDpHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDQ4Pj4yKV0scmVuZGVyVmlhT2Zmc2NyZWVuQmFja0J1ZmZlcjpHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDUyPj4yKV19O3ZhciBjYW52YXM9ZmluZENhbnZhc0V2ZW50VGFyZ2V0KHRhcmdldCk7aWYoIWNhbnZhcyl7cmV0dXJuIDB9aWYoY29udGV4dEF0dHJpYnV0ZXMuZXhwbGljaXRTd2FwQ29udHJvbCl7cmV0dXJuIDB9dmFyIGNvbnRleHRIYW5kbGU9R0wuY3JlYXRlQ29udGV4dChjYW52YXMsY29udGV4dEF0dHJpYnV0ZXMpO3JldHVybiBjb250ZXh0SGFuZGxlfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3dlYmdsX2NyZWF0ZV9jb250ZXh0KGEwLGExKXtyZXR1cm4gX2Vtc2NyaXB0ZW5fd2ViZ2xfZG9fY3JlYXRlX2NvbnRleHQoYTAsYTEpfXZhciBXZWJOTj17aW5pdE1hbmFnZXJzOmZ1bmN0aW9uKCl7aWYodGhpc1tcIm1nckNvbnRleHRcIl0pcmV0dXJuO2Z1bmN0aW9uIG1ha2VNYW5hZ2VyKCl7cmV0dXJue29iamVjdHM6e30sbmV4dElkOjEsY3JlYXRlOmZ1bmN0aW9uKG9iamVjdCx3cmFwcGVyKXt3cmFwcGVyPXdyYXBwZXJ8fHt9O3ZhciBpZD10aGlzLm5leHRJZCsrO3dyYXBwZXIucmVmY291bnQ9MTt3cmFwcGVyLm9iamVjdD1vYmplY3Q7dGhpcy5vYmplY3RzW2lkXT13cmFwcGVyO3JldHVybiBpZH0sZ2V0OmZ1bmN0aW9uKGlkKXtpZihpZD09PTApcmV0dXJuIHVuZGVmaW5lZDt2YXIgbz10aGlzLm9iamVjdHNbaWRdO3JldHVybiBvLm9iamVjdH0scmVmZXJlbmNlOmZ1bmN0aW9uKGlkKXt2YXIgbz10aGlzLm9iamVjdHNbaWRdO28ucmVmY291bnQrK30scmVsZWFzZTpmdW5jdGlvbihpZCl7dmFyIG89dGhpcy5vYmplY3RzW2lkXTtvLnJlZmNvdW50LS07aWYoby5yZWZjb3VudDw9MCl7ZGVsZXRlIHRoaXMub2JqZWN0c1tpZF19fX19dGhpc1tcIm1nckNvbnRleHRcIl09dGhpc1tcIm1nckNvbnRleHRcIl18fG1ha2VNYW5hZ2VyKCk7dGhpcy5tZ3JHcmFwaD10aGlzLm1nckdyYXBofHxtYWtlTWFuYWdlcigpO3RoaXMubWdyR3JhcGhCdWlsZGVyPXRoaXMubWdyR3JhcGhCdWlsZGVyfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyTmFtZWRJbnB1dHM9dGhpcy5tZ3JOYW1lZElucHV0c3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkT3BlcmFuZHM9dGhpcy5tZ3JOYW1lZE9wZXJhbmRzfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyTmFtZWRPdXRwdXRzPXRoaXMubWdyTmFtZWRPdXRwdXRzfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyTmFtZWRSZXN1bHRzPXRoaXMubWdyTmFtZWRSZXN1bHRzfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyT3BlcmFuZD10aGlzLm1nck9wZXJhbmR8fG1ha2VNYW5hZ2VyKCk7dGhpcy5tZ3JSZXN1bHQ9dGhpcy5tZ3JSZXN1bHR8fG1ha2VNYW5hZ2VyKCl9LEF1dG9QYWQ6W1wiZXhwbGljaXRcIixcInNhbWUtdXBwZXJcIixcInNhbWUtbG93ZXJcIl0sQnVpbGRHcmFwaFN0YXR1czpbXCJzdWNjZXNzXCIsXCJlcnJvclwiLFwiY29udGV4dC1sb3N0XCIsXCJ1bmtub3duXCJdLENvbXB1dGVHcmFwaFN0YXR1czpbXCJzdWNjZXNzXCIsXCJlcnJvclwiLFwiY29udGV4dC1sb3N0XCIsXCJ1bmtub3duXCJdLEVycm9yRmlsdGVyOltcIm5vbmVcIixcInZhbGlkYXRpb25cIixcIm91dC1vZi1tZW1vcnlcIl0sRXJyb3JUeXBlOltcIm5vLWVycm9yXCIsXCJ2YWxpZGF0aW9uXCIsXCJvdXQtb2YtbWVtb3J5XCIsXCJ1bmtub3duXCIsXCJkZXZpY2UtbG9zdFwiXSxGaWx0ZXJPcGVyYW5kTGF5b3V0OltcIm9paHdcIixcImh3aW9cIixcIm9od2lcIixcImlod29cIl0sRnVzZWRBY3RpdmF0aW9uOltcIm5vbmVcIixcInJlbHVcIl0sSW5wdXRPcGVyYW5kTGF5b3V0OltcIm5jaHdcIixcIm5od2NcIl0sT3BlcmFuZFR5cGU6W1wiZmxvYXQzMlwiLFwiZmxvYXQxNlwiLFwiaW50MzJcIixcInVpbnQzMlwiLFwiaW50OFwiLFwidWludDhcIl0sUG93ZXJQcmVmZXJlbmNlOltcImRlZmF1bHRcIixcImhpZ2hfcGVyZm9ybWFuY2VcIixcImxvd19wb3dlclwiXSxtYWtlSTMyQXJyYXk6ZnVuY3Rpb24oY291bnQsYXJyYXlQdHIpe2lmKGNvdW50PT09MHx8YXJyYXlQdHI9PT0wKXtyZXR1cm4gdW5kZWZpbmVkfXZhciBhcnJheT1bXTtmb3IodmFyIGk9MDtpPGNvdW50OysraSxhcnJheVB0cis9NCl7YXJyYXkucHVzaChHUk9XQUJMRV9IRUFQX0kzMigpW2FycmF5UHRyPj4yXSl9cmV0dXJuIGFycmF5fSxtYWtlQXJyYXlCdWZmZXJWaWV3OmZ1bmN0aW9uKG9mZnNldCxieXRlU2l6ZSx0eXBlPVwiZmxvYXQzMlwiKXthc3NlcnQodHlwZT09PVwiZmxvYXQzMlwiKTtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShHUk9XQUJMRV9IRUFQX1U4KCkuYnVmZmVyLG9mZnNldCxieXRlU2l6ZS9GbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpfSxtYWtlQ2xhbXBPcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wibWluVmFsdWVcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyPj4yXSksXCJtYXhWYWx1ZVwiOnRoaXMubWdyT3BlcmFuZC5nZXQoR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrND4+Ml0pfX0sbWFrZUJhdGNoTm9ybU9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJzY2FsZVwiOnRoaXMubWdyT3BlcmFuZC5nZXQoR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHI+PjJdKSxcImJpYXNcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzQ+PjJdKSxcImF4aXNcIjpHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis4Pj4yXSxcImVwc2lsb25cIjpHUk9XQUJMRV9IRUFQX0YzMigpW3B0cisxMj4+Ml0sXCJhY3RpdmF0aW9uXCI6dGhpcy5GdXNlZEFjdGl2YXRpb25bR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMTY+PjJdXX19LG1ha2VHZW1tT3B0aW9uczpmdW5jdGlvbihwdHIpe3JldHVybntcImNcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyPj4yXSksXCJhbHBoYVwiOkdST1dBQkxFX0hFQVBfRjMyKClbcHRyKzQ+PjJdLFwiYmV0YVwiOkdST1dBQkxFX0hFQVBfRjMyKClbcHRyKzg+PjJdLFwiYVRyYW5zcG9zZVwiOkdST1dBQkxFX0hFQVBfSTgoKVtwdHIrMTI+PjBdIT09MCxcImJUcmFuc3Bvc2VcIjpHUk9XQUJMRV9IRUFQX0k4KClbcHRyKzEzPj4wXSE9PTB9fSxtYWtlT3BlcmFuZERlc2NyaXB0b3I6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJ0eXBlXCI6dGhpcy5PcGVyYW5kVHlwZVtHUk9XQUJMRV9IRUFQX1UzMigpW3B0cj4+Ml1dLFwiZGltZW5zaW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEdST1dBQkxFX0hFQVBfVTMyKClbcHRyKzg+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzQ+PjJdKX19LG1ha2VDb252MmRPcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wicGFkZGluZ1wiOnRoaXMuQXV0b1BhZFtHUk9XQUJMRV9IRUFQX0kzMigpW3B0cisyND4+Ml1dPT09XCJleHBsaWNpdFwiP3RoaXMubWFrZUkzMkFycmF5KEdST1dBQkxFX0hFQVBfVTMyKClbcHRyPj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis0Pj4yXSk6dW5kZWZpbmVkLFwic3RyaWRlc1wiOnRoaXMubWFrZUkzMkFycmF5KEdST1dBQkxFX0hFQVBfVTMyKClbcHRyKzg+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzEyPj4yXSksXCJkaWxhdGlvbnNcIjp0aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cisxNj4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMjA+PjJdKSxcImF1dG9QYWRcIjp0aGlzLkF1dG9QYWRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMjQ+PjJdXSxcImdyb3Vwc1wiOkdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzI4Pj4yXSxcImlucHV0TGF5b3V0XCI6dGhpcy5JbnB1dE9wZXJhbmRMYXlvdXRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMzI+PjJdXSxcImZpbHRlckxheW91dFwiOnRoaXMuRmlsdGVyT3BlcmFuZExheW91dFtHUk9XQUJMRV9IRUFQX0kzMigpW3B0ciszNj4+Ml1dLFwiYmlhc1wiOnRoaXMubWdyT3BlcmFuZC5nZXQoR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrNDA+PjJdKSxcImFjdGl2YXRpb25cIjp0aGlzLkZ1c2VkQWN0aXZhdGlvbltHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis0ND4+Ml1dfX0sbWFrZVBvb2wyZE9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJ3aW5kb3dEaW1lbnNpb25zXCI6dGhpcy5tYWtlSTMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHI+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzQ+PjJdKSxcInBhZGRpbmdcIjp0aGlzLkF1dG9QYWRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMzI+PjJdXT09PVwiZXhwbGljaXRcIj90aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cis4Pj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cisxMj4+Ml0pOnVuZGVmaW5lZCxcInN0cmlkZXNcIjp0aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cisxNj4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMjA+PjJdKSxcImRpbGF0aW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEdST1dBQkxFX0hFQVBfVTMyKClbcHRyKzI0Pj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cisyOD4+Ml0pLFwiYXV0b1BhZFwiOnRoaXMuQXV0b1BhZFtHUk9XQUJMRV9IRUFQX0kzMigpW3B0ciszMj4+Ml1dLFwiaW5wdXRMYXlvdXRcIjp0aGlzLklucHV0T3BlcmFuZExheW91dFtHUk9XQUJMRV9IRUFQX0kzMigpW3B0ciszNj4+Ml1dfX0sbWFrZUlucHV0OmZ1bmN0aW9uKHB0cil7cmV0dXJue1wiZGF0YVwiOnRoaXMubWFrZUFycmF5QnVmZmVyVmlldyhHUk9XQUJMRV9IRUFQX0kzMigpW3B0cj4+Ml0sR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrND4+Ml0pLFwiZGltZW5zaW9uc1wiOkdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzg+PjJdPT09MD91bmRlZmluZWQ6dGhpcy5tYWtlSTMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrMTI+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzg+PjJdKX19LG1ha2VPdXRwdXQ6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJkYXRhXCI6R1JPV0FCTEVfSEVBUF9JMzIoKVtwdHI+PjJdPT09MD91bmRlZmluZWQ6dGhpcy5tYWtlQXJyYXlCdWZmZXJWaWV3KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyPj4yXSxHUk9XQUJMRV9IRUFQX1UzMigpW3B0cis0Pj4yXSksXCJkaW1lbnNpb25zXCI6R1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrOD4+Ml09PT0wP3VuZGVmaW5lZDp0aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cisxMj4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrOD4+Ml0pfX19O2Z1bmN0aW9uIF9lbXNjcmlwdGVuX3dlYm5uX2NyZWF0ZV9jb250ZXh0KCl7dmFyIGNvbnRleHQ9bmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gV2ViTk4ubWdyQ29udGV4dC5jcmVhdGUoY29udGV4dCl9dmFyIEVOVj17fTtmdW5jdGlvbiBnZXRFeGVjdXRhYmxlTmFtZSgpe3JldHVybiB0aGlzUHJvZ3JhbXx8XCIuL3RoaXMucHJvZ3JhbVwifWZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKXtpZighZ2V0RW52U3RyaW5ncy5zdHJpbmdzKXt2YXIgbGFuZz0odHlwZW9mIG5hdmlnYXRvcj09PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiO3ZhciBlbnY9e1wiVVNFUlwiOlwid2ViX3VzZXJcIixcIkxPR05BTUVcIjpcIndlYl91c2VyXCIsXCJQQVRIXCI6XCIvXCIsXCJQV0RcIjpcIi9cIixcIkhPTUVcIjpcIi9ob21lL3dlYl91c2VyXCIsXCJMQU5HXCI6bGFuZyxcIl9cIjpnZXRFeGVjdXRhYmxlTmFtZSgpfTtmb3IodmFyIHggaW4gRU5WKXtlbnZbeF09RU5WW3hdfXZhciBzdHJpbmdzPVtdO2Zvcih2YXIgeCBpbiBlbnYpe3N0cmluZ3MucHVzaCh4K1wiPVwiK2Vudlt4XSl9Z2V0RW52U3RyaW5ncy5zdHJpbmdzPXN0cmluZ3N9cmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5nc31mdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLGVudmlyb25fYnVmKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxNywxLF9fZW52aXJvbixlbnZpcm9uX2J1Zik7dmFyIGJ1ZlNpemU9MDtnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcsaSl7dmFyIHB0cj1lbnZpcm9uX2J1ZitidWZTaXplO0dST1dBQkxFX0hFQVBfSTMyKClbX19lbnZpcm9uK2kqND4+Ml09cHRyO3dyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcscHRyKTtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtyZXR1cm4gMH1mdW5jdGlvbiBfZW52aXJvbl9zaXplc19nZXQocGVudmlyb25fY291bnQscGVudmlyb25fYnVmX3NpemUpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDE4LDEscGVudmlyb25fY291bnQscGVudmlyb25fYnVmX3NpemUpO3ZhciBzdHJpbmdzPWdldEVudlN0cmluZ3MoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3BlbnZpcm9uX2NvdW50Pj4yXT1zdHJpbmdzLmxlbmd0aDt2YXIgYnVmU2l6ZT0wO3N0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpe2J1ZlNpemUrPXN0cmluZy5sZW5ndGgrMX0pO0dST1dBQkxFX0hFQVBfSTMyKClbcGVudmlyb25fYnVmX3NpemU+PjJdPWJ1ZlNpemU7cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX2Nsb3NlKGZkKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxOSwxLGZkKTtyZXR1cm4gMH1mdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCxwYnVmKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygyMCwxLGZkLHBidWYpO3ZhciB0eXBlPWZkPT0xfHxmZD09Mj8yOmFib3J0KCk7R1JPV0FCTEVfSEVBUF9JOCgpW3BidWY+PjBdPXR5cGU7cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX3JlYWQoZmQsaW92LGlvdmNudCxwbnVtKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygyMSwxLGZkLGlvdixpb3ZjbnQscG51bSk7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO3ZhciBudW09U1lTQ0FMTFMuZG9SZWFkdihzdHJlYW0saW92LGlvdmNudCk7R1JPV0FCTEVfSEVBUF9JMzIoKVtwbnVtPj4yXT1udW07cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX3NlZWsoZmQsb2Zmc2V0X2xvdyxvZmZzZXRfaGlnaCx3aGVuY2UsbmV3T2Zmc2V0KXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygyMiwxLGZkLG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gsd2hlbmNlLG5ld09mZnNldCl9ZnVuY3Rpb24gZmx1c2hfTk9fRklMRVNZU1RFTSgpe2lmKHR5cGVvZiBfZmZsdXNoIT09XCJ1bmRlZmluZWRcIilfZmZsdXNoKDApO3ZhciBidWZmZXJzPVNZU0NBTExTLmJ1ZmZlcnM7aWYoYnVmZmVyc1sxXS5sZW5ndGgpU1lTQ0FMTFMucHJpbnRDaGFyKDEsMTApO2lmKGJ1ZmZlcnNbMl0ubGVuZ3RoKVNZU0NBTExTLnByaW50Q2hhcigyLDEwKX1mdW5jdGlvbiBfZmRfd3JpdGUoZmQsaW92LGlvdmNudCxwbnVtKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygyMywxLGZkLGlvdixpb3ZjbnQscG51bSk7dmFyIG51bT0wO2Zvcih2YXIgaT0wO2k8aW92Y250O2krKyl7dmFyIHB0cj1HUk9XQUJMRV9IRUFQX0kzMigpW2lvditpKjg+PjJdO3ZhciBsZW49R1JPV0FCTEVfSEVBUF9JMzIoKVtpb3YrKGkqOCs0KT4+Ml07Zm9yKHZhciBqPTA7ajxsZW47aisrKXtTWVNDQUxMUy5wcmludENoYXIoZmQsR1JPV0FCTEVfSEVBUF9VOCgpW3B0citqXSl9bnVtKz1sZW59R1JPV0FCTEVfSEVBUF9JMzIoKVtwbnVtPj4yXT1udW07cmV0dXJuIDB9ZnVuY3Rpb24gX2dldHRpbWVvZmRheShwdHIpe3ZhciBub3c9RGF0ZS5ub3coKTtHUk9XQUJMRV9IRUFQX0kzMigpW3B0cj4+Ml09bm93LzFlM3wwO0dST1dBQkxFX0hFQVBfSTMyKClbcHRyKzQ+PjJdPW5vdyUxZTMqMWUzfDA7cmV0dXJuIDB9ZnVuY3Rpb24gX2dtdGltZV9yKHRpbWUsdG1QdHIpe3ZhciBkYXRlPW5ldyBEYXRlKEdST1dBQkxFX0hFQVBfSTMyKClbdGltZT4+Ml0qMWUzKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyPj4yXT1kYXRlLmdldFVUQ1NlY29uZHMoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzQ+PjJdPWRhdGUuZ2V0VVRDTWludXRlcygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrOD4+Ml09ZGF0ZS5nZXRVVENIb3VycygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTI+PjJdPWRhdGUuZ2V0VVRDRGF0ZSgpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTY+PjJdPWRhdGUuZ2V0VVRDTW9udGgoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzIwPj4yXT1kYXRlLmdldFVUQ0Z1bGxZZWFyKCktMTkwMDtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzI0Pj4yXT1kYXRlLmdldFVUQ0RheSgpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMzY+PjJdPTA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0ciszMj4+Ml09MDt2YXIgc3RhcnQ9RGF0ZS5VVEMoZGF0ZS5nZXRVVENGdWxsWWVhcigpLDAsMSwwLDAsMCwwKTt2YXIgeWRheT0oZGF0ZS5nZXRUaW1lKCktc3RhcnQpLygxZTMqNjAqNjAqMjQpfDA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisyOD4+Ml09eWRheTtpZighX2dtdGltZV9yLkdNVFN0cmluZylfZ210aW1lX3IuR01UU3RyaW5nPWFsbG9jYXRlVVRGOChcIkdNVFwiKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzQwPj4yXT1fZ210aW1lX3IuR01UU3RyaW5nO3JldHVybiB0bVB0cn1mdW5jdGlvbiBfdHpzZXQoKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygyNCwxKTtpZihfdHpzZXQuY2FsbGVkKXJldHVybjtfdHpzZXQuY2FsbGVkPXRydWU7dmFyIGN1cnJlbnRZZWFyPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKTt2YXIgd2ludGVyPW5ldyBEYXRlKGN1cnJlbnRZZWFyLDAsMSk7dmFyIHN1bW1lcj1uZXcgRGF0ZShjdXJyZW50WWVhciw2LDEpO3ZhciB3aW50ZXJPZmZzZXQ9d2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHN1bW1lck9mZnNldD1zdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3RkVGltZXpvbmVPZmZzZXQ9TWF0aC5tYXgod2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCk7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2dldF90aW1lem9uZSgpPj4yXT1zdGRUaW1lem9uZU9mZnNldCo2MDtHUk9XQUJMRV9IRUFQX0kzMigpW19fZ2V0X2RheWxpZ2h0KCk+PjJdPU51bWJlcih3aW50ZXJPZmZzZXQhPXN1bW1lck9mZnNldCk7ZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSl7dmFyIG1hdGNoPWRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKTtyZXR1cm4gbWF0Y2g/bWF0Y2hbMV06XCJHTVRcIn12YXIgd2ludGVyTmFtZT1leHRyYWN0Wm9uZSh3aW50ZXIpO3ZhciBzdW1tZXJOYW1lPWV4dHJhY3Rab25lKHN1bW1lcik7dmFyIHdpbnRlck5hbWVQdHI9YWxsb2NhdGVVVEY4KHdpbnRlck5hbWUpO3ZhciBzdW1tZXJOYW1lUHRyPWFsbG9jYXRlVVRGOChzdW1tZXJOYW1lKTtpZihzdW1tZXJPZmZzZXQ8d2ludGVyT2Zmc2V0KXtHUk9XQUJMRV9IRUFQX0kzMigpW19fZ2V0X3R6bmFtZSgpPj4yXT13aW50ZXJOYW1lUHRyO0dST1dBQkxFX0hFQVBfSTMyKClbX19nZXRfdHpuYW1lKCkrND4+Ml09c3VtbWVyTmFtZVB0cn1lbHNle0dST1dBQkxFX0hFQVBfSTMyKClbX19nZXRfdHpuYW1lKCk+PjJdPXN1bW1lck5hbWVQdHI7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2dldF90em5hbWUoKSs0Pj4yXT13aW50ZXJOYW1lUHRyfX1mdW5jdGlvbiBfbG9jYWx0aW1lX3IodGltZSx0bVB0cil7X3R6c2V0KCk7dmFyIGRhdGU9bmV3IERhdGUoR1JPV0FCTEVfSEVBUF9JMzIoKVt0aW1lPj4yXSoxZTMpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHI+PjJdPWRhdGUuZ2V0U2Vjb25kcygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrND4+Ml09ZGF0ZS5nZXRNaW51dGVzKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cis4Pj4yXT1kYXRlLmdldEhvdXJzKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisxMj4+Ml09ZGF0ZS5nZXREYXRlKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisxNj4+Ml09ZGF0ZS5nZXRNb250aCgpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMjA+PjJdPWRhdGUuZ2V0RnVsbFllYXIoKS0xOTAwO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMjQ+PjJdPWRhdGUuZ2V0RGF5KCk7dmFyIHN0YXJ0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwwLDEpO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydC5nZXRUaW1lKCkpLygxZTMqNjAqNjAqMjQpfDA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisyOD4+Ml09eWRheTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzM2Pj4yXT0tKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MCk7dmFyIHN1bW1lck9mZnNldD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB3aW50ZXJPZmZzZXQ9c3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgZHN0PShzdW1tZXJPZmZzZXQhPXdpbnRlck9mZnNldCYmZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbih3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KSl8MDtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzMyPj4yXT1kc3Q7dmFyIHpvbmVQdHI9R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2dldF90em5hbWUoKSsoZHN0PzQ6MCk+PjJdO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrNDA+PjJdPXpvbmVQdHI7cmV0dXJuIHRtUHRyfWZ1bmN0aW9uIF9ta3RpbWUodG1QdHIpe190enNldCgpO3ZhciBkYXRlPW5ldyBEYXRlKEdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMjA+PjJdKzE5MDAsR1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisxNj4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisxMj4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cis4Pj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzQ+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHI+PjJdLDApO3ZhciBkc3Q9R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0ciszMj4+Ml07dmFyIGd1ZXNzZWRPZmZzZXQ9ZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdGFydD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTt2YXIgc3VtbWVyT2Zmc2V0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHdpbnRlck9mZnNldD1zdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBkc3RPZmZzZXQ9TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCk7aWYoZHN0PDApe0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMzI+PjJdPU51bWJlcihzdW1tZXJPZmZzZXQhPXdpbnRlck9mZnNldCYmZHN0T2Zmc2V0PT1ndWVzc2VkT2Zmc2V0KX1lbHNlIGlmKGRzdD4wIT0oZHN0T2Zmc2V0PT1ndWVzc2VkT2Zmc2V0KSl7dmFyIG5vbkRzdE9mZnNldD1NYXRoLm1heCh3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KTt2YXIgdHJ1ZU9mZnNldD1kc3Q+MD9kc3RPZmZzZXQ6bm9uRHN0T2Zmc2V0O2RhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSsodHJ1ZU9mZnNldC1ndWVzc2VkT2Zmc2V0KSo2ZTQpfUdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMjQ+PjJdPWRhdGUuZ2V0RGF5KCk7dmFyIHlkYXk9KGRhdGUuZ2V0VGltZSgpLXN0YXJ0LmdldFRpbWUoKSkvKDFlMyo2MCo2MCoyNCl8MDtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzI4Pj4yXT15ZGF5O0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHI+PjJdPWRhdGUuZ2V0U2Vjb25kcygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrND4+Ml09ZGF0ZS5nZXRNaW51dGVzKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cis4Pj4yXT1kYXRlLmdldEhvdXJzKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisxMj4+Ml09ZGF0ZS5nZXREYXRlKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisxNj4+Ml09ZGF0ZS5nZXRNb250aCgpO3JldHVybiBkYXRlLmdldFRpbWUoKS8xZTN8MH1mdW5jdGlvbiBfbWxDb250ZXh0UmVmZXJlbmNlKGlkKXtXZWJOTi5tZ3JDb250ZXh0LnJlZmVyZW5jZShpZCl9ZnVuY3Rpb24gX21sQ29udGV4dFJlbGVhc2UoaWQpe1dlYk5OLm1nckNvbnRleHQucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQWRkKGJ1aWxkZXJJZCxhSWQsYklkKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGE9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYUlkKTt2YXIgYj1XZWJOTi5tZ3JPcGVyYW5kLmdldChiSWQpO3ZhciBjPWJ1aWxkZXIuYWRkKGEsYik7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKGMpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckF2ZXJhZ2VQb29sMmQoYnVpbGRlcklkLGlucHV0SWQsb3B0aW9uc1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgb3B0aW9ucz1XZWJOTi5tYWtlUG9vbDJkT3B0aW9ucyhvcHRpb25zUHRyKTt2YXIgcG9vbDJkPWJ1aWxkZXIuYXZlcmFnZVBvb2wyZChpbnB1dCxvcHRpb25zKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUocG9vbDJkKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJCYXRjaE5vcm0oYnVpbGRlcklkLGlucHV0SWQsbWVhbklkLHZhcmlhbmNlSWQsb3B0aW9uc1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgbWVhbj1XZWJOTi5tZ3JPcGVyYW5kLmdldChtZWFuSWQpO3ZhciB2YXJpYW5jZT1XZWJOTi5tZ3JPcGVyYW5kLmdldCh2YXJpYW5jZUlkKTt2YXIgb3B0aW9ucz1XZWJOTi5tYWtlQmF0Y2hOb3JtT3B0aW9ucyhvcHRpb25zUHRyKTt2YXIgb3V0cHV0PWJ1aWxkZXIuYmF0Y2hOb3JtYWxpemF0aW9uKGlucHV0LG1lYW4sdmFyaWFuY2Usb3B0aW9ucyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKG91dHB1dCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQnVpbGRTeW5jKGJ1aWxkZXJJZCxuYW1lZE9wZXJhbmRzSWQpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgbmFtZWRPcGVyYW5kcz1XZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLmdldChuYW1lZE9wZXJhbmRzSWQpO3RyeXt2YXIgZ3JhcGg9YnVpbGRlci5idWlsZFN5bmMobmFtZWRPcGVyYW5kcyk7cmV0dXJuIFdlYk5OLm1nckdyYXBoLmNyZWF0ZShncmFwaCl9Y2F0Y2goZXJyb3Ipe2NvbnNvbGUubG9nKFwiYnVpbGRlci5idWlsZFN5bmMgZmFpbGVkOiBcIitlcnJvcik7cmV0dXJuIDB9fWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckNvbmNhdChidWlsZGVySWQsaW5wdXRzQ291bnQsaW5wdXRzUHRyLGF4aXMpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXRJZHM9V2ViTk4ubWFrZUkzMkFycmF5KGlucHV0c0NvdW50LGlucHV0c1B0cik7dmFyIGlucHV0cz1bXTtmb3IodmFyIGk9MDtpPGlucHV0SWRzLmxlbmd0aDsrK2kpe2lucHV0cy5wdXNoKFdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWRzW2ldKSl9dmFyIG91dHB1dD1idWlsZGVyLmNvbmNhdChpbnB1dHMsYXhpcyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKG91dHB1dCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQ29uc3RhbnQoYnVpbGRlcklkLGRlc2NQdHIsdmFsdWVQdHIsc2l6ZSl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBkZXNjPVdlYk5OLm1ha2VPcGVyYW5kRGVzY3JpcHRvcihkZXNjUHRyKTt2YXIgYnVmZmVyPVdlYk5OLm1ha2VBcnJheUJ1ZmZlclZpZXcodmFsdWVQdHIsc2l6ZSk7dmFyIGNvbnN0YW50PWJ1aWxkZXIuY29uc3RhbnQoZGVzYyxidWZmZXIpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShjb25zdGFudCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQ29udjJkKGJ1aWxkZXJJZCxpbnB1dElkLGZpbHRlcklkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIGZpbHRlcj1XZWJOTi5tZ3JPcGVyYW5kLmdldChmaWx0ZXJJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZUNvbnYyZE9wdGlvbnMob3B0aW9uc1B0cik7dmFyIGNvbnYyZD1idWlsZGVyLmNvbnYyZChpbnB1dCxmaWx0ZXIsb3B0aW9ucyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKGNvbnYyZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyR2VtbShidWlsZGVySWQsYUlkLGJJZCxvcHRpb25zUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGE9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYUlkKTt2YXIgYj1XZWJOTi5tZ3JPcGVyYW5kLmdldChiSWQpO3ZhciBvcHRpb25zPVdlYk5OLm1ha2VHZW1tT3B0aW9ucyhvcHRpb25zUHRyKTt2YXIgb3V0cHV0PWJ1aWxkZXIuZ2VtbShhLGIsb3B0aW9ucyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKG91dHB1dCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVySW5wdXQoYnVpbGRlcklkLG5hbWVQdHIsZGVzY1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBuYW1lPVVURjhUb1N0cmluZyhuYW1lUHRyKTt2YXIgZGVzYz1XZWJOTi5tYWtlT3BlcmFuZERlc2NyaXB0b3IoZGVzY1B0cik7dmFyIGlucHV0PWJ1aWxkZXIuaW5wdXQobmFtZSxkZXNjKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoaW5wdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlck1hdG11bChidWlsZGVySWQsYUlkLGJJZCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBhPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGFJZCk7dmFyIGI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYklkKTt2YXIgYz1idWlsZGVyLm1hdG11bChhLGIpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShjKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJNYXhQb29sMmQoYnVpbGRlcklkLGlucHV0SWQsb3B0aW9uc1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgb3B0aW9ucz1XZWJOTi5tYWtlUG9vbDJkT3B0aW9ucyhvcHRpb25zUHRyKTt2YXIgcG9vbDJkPWJ1aWxkZXIubWF4UG9vbDJkKGlucHV0LG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShwb29sMmQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlclJlbGVhc2UoaWQpe1dlYk5OLm1nckdyYXBoQnVpbGRlci5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJSZWx1KGJ1aWxkZXJJZCxpbnB1dElkKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBvdXRwdXQ9YnVpbGRlci5yZWx1KGlucHV0KTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUob3V0cHV0KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJSZXNoYXBlKGJ1aWxkZXJJZCxpbnB1dElkLG5ld1NoYXBlUHRyLG5ld1NoYXBlQ291bnQpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG5ld1NoYXBlPVdlYk5OLm1ha2VJMzJBcnJheShuZXdTaGFwZUNvdW50LG5ld1NoYXBlUHRyKTt2YXIgb3V0cHV0PWJ1aWxkZXIucmVzaGFwZShpbnB1dCxuZXdTaGFwZSk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKG91dHB1dCl9ZnVuY3Rpb24gX21sR3JhcGhDb21wdXRlU3luYyhncmFwaElkLGlucHV0c0lkLG91dHB1dHNJZCl7dmFyIGdyYXBoPVdlYk5OLm1nckdyYXBoLmdldChncmFwaElkKTt2YXIgaW5wdXRzPVdlYk5OLm1nck5hbWVkSW5wdXRzLmdldChpbnB1dHNJZCk7dmFyIG91dHB1dHM9V2ViTk4ubWdyTmFtZWRPdXRwdXRzLmdldChvdXRwdXRzSWQpO3JldHVybiBncmFwaC5jb21wdXRlU3luYyhpbnB1dHMsb3V0cHV0cyl9ZnVuY3Rpb24gX21sR3JhcGhSZWZlcmVuY2UoaWQpe1dlYk5OLm1nckdyYXBoLnJlZmVyZW5jZShpZCl9ZnVuY3Rpb24gX21sR3JhcGhSZWxlYXNlKGlkKXtXZWJOTi5tZ3JHcmFwaC5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxOYW1lZElucHV0c1JlbGVhc2UoaWQpe1dlYk5OLm1nck5hbWVkSW5wdXRzLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbE5hbWVkSW5wdXRzU2V0KG5hbWVkSW5wdXRzSWQsbmFtZVB0cixpbnB1dFB0cil7dmFyIG5hbWVkSW5wdXRzPVdlYk5OLm1nck5hbWVkSW5wdXRzLmdldChuYW1lZElucHV0c0lkKTt2YXIgbmFtZT1VVEY4VG9TdHJpbmcobmFtZVB0cik7dmFyIGlucHV0PVdlYk5OLm1ha2VJbnB1dChpbnB1dFB0cik7bmFtZWRJbnB1dHNbbmFtZV09aW5wdXR9ZnVuY3Rpb24gX21sTmFtZWRPcGVyYW5kc1JlbGVhc2UoaWQpe1dlYk5OLm1nck5hbWVkT3BlcmFuZHMucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sTmFtZWRPcGVyYW5kc1NldChuYW1lZE9wZXJhbmRzSWQsbmFtZVB0cixvcGVyYW5kSWQpe3ZhciBuYW1lZE9wZXJhbmRzPVdlYk5OLm1nck5hbWVkT3BlcmFuZHMuZ2V0KG5hbWVkT3BlcmFuZHNJZCk7dmFyIG5hbWU9VVRGOFRvU3RyaW5nKG5hbWVQdHIpO3ZhciBvcGVyYW5kPVdlYk5OLm1nck9wZXJhbmQuZ2V0KG9wZXJhbmRJZCk7bmFtZWRPcGVyYW5kc1tuYW1lXT1vcGVyYW5kfWZ1bmN0aW9uIF9tbE5hbWVkT3V0cHV0c1JlbGVhc2UoaWQpe1dlYk5OLm1nck5hbWVkT3V0cHV0cy5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxOYW1lZE91dHB1dHNTZXQobmFtZWRPdXRwdXRzSWQsbmFtZVB0cixvdXRwdXRQdHIpe3ZhciBuYW1lZE91dHB1dHM9V2ViTk4ubWdyTmFtZWRPdXRwdXRzLmdldChuYW1lZE91dHB1dHNJZCk7dmFyIG5hbWU9VVRGOFRvU3RyaW5nKG5hbWVQdHIpO3ZhciBvdXRwdXQ9V2ViTk4ubWFrZU91dHB1dChvdXRwdXRQdHIpO25hbWVkT3V0cHV0c1tuYW1lXT1vdXRwdXR9ZnVuY3Rpb24gX21sT3BlcmFuZFJlZmVyZW5jZShpZCl7V2ViTk4ubWdyT3BlcmFuZC5yZWZlcmVuY2UoaWQpfWZ1bmN0aW9uIF9tbE9wZXJhbmRSZWxlYXNlKGlkKXtXZWJOTi5tZ3JPcGVyYW5kLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIHNwYXduVGhyZWFkKHRocmVhZFBhcmFtcyl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl0aHJvd1wiSW50ZXJuYWwgRXJyb3IhIHNwYXduVGhyZWFkKCkgY2FuIG9ubHkgZXZlciBiZSBjYWxsZWQgZnJvbSBtYWluIGFwcGxpY2F0aW9uIHRocmVhZCFcIjt2YXIgd29ya2VyPVBUaHJlYWQuZ2V0TmV3V29ya2VyKCk7aWYoIXdvcmtlcil7cmV0dXJuIDZ9aWYod29ya2VyLnB0aHJlYWQhPT11bmRlZmluZWQpdGhyb3dcIkludGVybmFsIGVycm9yIVwiO2lmKCF0aHJlYWRQYXJhbXMucHRocmVhZF9wdHIpdGhyb3dcIkludGVybmFsIGVycm9yLCBubyBwdGhyZWFkIHB0ciFcIjtQVGhyZWFkLnJ1bm5pbmdXb3JrZXJzLnB1c2god29ya2VyKTt2YXIgdGxzTWVtb3J5PV9tYWxsb2MoMTI4KjQpO2Zvcih2YXIgaT0wO2k8MTI4OysraSl7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bHNNZW1vcnkraSo0Pj4yXT0wfXZhciBzdGFja0hpZ2g9dGhyZWFkUGFyYW1zLnN0YWNrQmFzZSt0aHJlYWRQYXJhbXMuc3RhY2tTaXplO3ZhciBwdGhyZWFkPVBUaHJlYWQucHRocmVhZHNbdGhyZWFkUGFyYW1zLnB0aHJlYWRfcHRyXT17d29ya2VyOndvcmtlcixzdGFja0Jhc2U6dGhyZWFkUGFyYW1zLnN0YWNrQmFzZSxzdGFja1NpemU6dGhyZWFkUGFyYW1zLnN0YWNrU2l6ZSxhbGxvY2F0ZWRPd25TdGFjazp0aHJlYWRQYXJhbXMuYWxsb2NhdGVkT3duU3RhY2ssdGhyZWFkSW5mb1N0cnVjdDp0aHJlYWRQYXJhbXMucHRocmVhZF9wdHJ9O3ZhciB0aXM9cHRocmVhZC50aHJlYWRJbmZvU3RydWN0Pj4yO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aXMrKDY0Pj4yKSx0aHJlYWRQYXJhbXMuZGV0YWNoZWQpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aXMrKDEwMD4+MiksdGxzTWVtb3J5KTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKyg0MD4+MikscHRocmVhZC50aHJlYWRJbmZvU3RydWN0KTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKyg4MD4+MiksdGhyZWFkUGFyYW1zLnN0YWNrU2l6ZSk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRpcysoNzY+PjIpLHN0YWNrSGlnaCk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRpcysoMTA0Pj4yKSx0aHJlYWRQYXJhbXMuc3RhY2tTaXplKTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKygxMDQrOD4+Miksc3RhY2tIaWdoKTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKygxMDQrMTI+PjIpLHRocmVhZFBhcmFtcy5kZXRhY2hlZCk7dmFyIGdsb2JhbF9saWJjPV9lbXNjcmlwdGVuX2dldF9nbG9iYWxfbGliYygpO3ZhciBnbG9iYWxfbG9jYWxlPWdsb2JhbF9saWJjKzQwO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aXMrKDE3Mj4+MiksZ2xvYmFsX2xvY2FsZSk7d29ya2VyLnB0aHJlYWQ9cHRocmVhZDt2YXIgbXNnPXtcImNtZFwiOlwicnVuXCIsXCJzdGFydF9yb3V0aW5lXCI6dGhyZWFkUGFyYW1zLnN0YXJ0Um91dGluZSxcImFyZ1wiOnRocmVhZFBhcmFtcy5hcmcsXCJ0aHJlYWRJbmZvU3RydWN0XCI6dGhyZWFkUGFyYW1zLnB0aHJlYWRfcHRyLFwic3RhY2tCYXNlXCI6dGhyZWFkUGFyYW1zLnN0YWNrQmFzZSxcInN0YWNrU2l6ZVwiOnRocmVhZFBhcmFtcy5zdGFja1NpemV9O3dvcmtlci5ydW5QdGhyZWFkPWZ1bmN0aW9uKCl7bXNnLnRpbWU9cGVyZm9ybWFuY2Uubm93KCk7d29ya2VyLnBvc3RNZXNzYWdlKG1zZyx0aHJlYWRQYXJhbXMudHJhbnNmZXJMaXN0KX07aWYod29ya2VyLmxvYWRlZCl7d29ya2VyLnJ1blB0aHJlYWQoKTtkZWxldGUgd29ya2VyLnJ1blB0aHJlYWR9cmV0dXJuIDB9ZnVuY3Rpb24gX3B0aHJlYWRfY3JlYXRlKHB0aHJlYWRfcHRyLGF0dHIsc3RhcnRfcm91dGluZSxhcmcpe2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCIpe2VycihcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpO3JldHVybiA2fWlmKCFwdGhyZWFkX3B0cil7ZXJyKFwicHRocmVhZF9jcmVhdGUgY2FsbGVkIHdpdGggYSBudWxsIHRocmVhZCBwb2ludGVyIVwiKTtyZXR1cm4gMjh9dmFyIHRyYW5zZmVyTGlzdD1bXTt2YXIgZXJyb3I9MDtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEJiYodHJhbnNmZXJMaXN0Lmxlbmd0aD09PTB8fGVycm9yKSl7cmV0dXJuIF9lbXNjcmlwdGVuX3N5bmNfcnVuX2luX21haW5fdGhyZWFkXzQoNjg3ODY1ODU2LHB0aHJlYWRfcHRyLGF0dHIsc3RhcnRfcm91dGluZSxhcmcpfWlmKGVycm9yKXJldHVybiBlcnJvcjt2YXIgc3RhY2tTaXplPTA7dmFyIHN0YWNrQmFzZT0wO3ZhciBkZXRhY2hlZD0wO2lmKGF0dHImJmF0dHIhPS0xKXtzdGFja1NpemU9R1JPV0FCTEVfSEVBUF9JMzIoKVthdHRyPj4yXTtzdGFja1NpemUrPTgxOTIwO3N0YWNrQmFzZT1HUk9XQUJMRV9IRUFQX0kzMigpW2F0dHIrOD4+Ml07ZGV0YWNoZWQ9R1JPV0FCTEVfSEVBUF9JMzIoKVthdHRyKzEyPj4yXSE9PTB9ZWxzZXtzdGFja1NpemU9MjA5NzE1Mn12YXIgYWxsb2NhdGVkT3duU3RhY2s9c3RhY2tCYXNlPT0wO2lmKGFsbG9jYXRlZE93blN0YWNrKXtzdGFja0Jhc2U9X21lbWFsaWduKDE2LHN0YWNrU2l6ZSl9ZWxzZXtzdGFja0Jhc2UtPXN0YWNrU2l6ZTthc3NlcnQoc3RhY2tCYXNlPjApfXZhciB0aHJlYWRJbmZvU3RydWN0PV9tYWxsb2MoMjI4KTtmb3IodmFyIGk9MDtpPDIyOD4+MjsrK2kpR1JPV0FCTEVfSEVBUF9VMzIoKVsodGhyZWFkSW5mb1N0cnVjdD4+MikraV09MDtHUk9XQUJMRV9IRUFQX0kzMigpW3B0aHJlYWRfcHRyPj4yXT10aHJlYWRJbmZvU3RydWN0O0dST1dBQkxFX0hFQVBfSTMyKClbdGhyZWFkSW5mb1N0cnVjdCsxMj4+Ml09dGhyZWFkSW5mb1N0cnVjdDt2YXIgaGVhZFB0cj10aHJlYWRJbmZvU3RydWN0KzE1MjtHUk9XQUJMRV9IRUFQX0kzMigpW2hlYWRQdHI+PjJdPWhlYWRQdHI7dmFyIHRocmVhZFBhcmFtcz17c3RhY2tCYXNlOnN0YWNrQmFzZSxzdGFja1NpemU6c3RhY2tTaXplLGFsbG9jYXRlZE93blN0YWNrOmFsbG9jYXRlZE93blN0YWNrLGRldGFjaGVkOmRldGFjaGVkLHN0YXJ0Um91dGluZTpzdGFydF9yb3V0aW5lLHB0aHJlYWRfcHRyOnRocmVhZEluZm9TdHJ1Y3QsYXJnOmFyZyx0cmFuc2Zlckxpc3Q6dHJhbnNmZXJMaXN0fTtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXt0aHJlYWRQYXJhbXMuY21kPVwic3Bhd25UaHJlYWRcIjtwb3N0TWVzc2FnZSh0aHJlYWRQYXJhbXMsdHJhbnNmZXJMaXN0KTtyZXR1cm4gMH1yZXR1cm4gc3Bhd25UaHJlYWQodGhyZWFkUGFyYW1zKX1mdW5jdGlvbiBfX3B0aHJlYWRfdGVzdGNhbmNlbF9qcygpe2lmKCFFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybjt2YXIgdGI9X3B0aHJlYWRfc2VsZigpO2lmKCF0YilyZXR1cm47dmFyIGNhbmNlbERpc2FibGVkPUF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzU2Pj4yKTtpZihjYW5jZWxEaXNhYmxlZClyZXR1cm47dmFyIGNhbmNlbGVkPUF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzA+PjIpO2lmKGNhbmNlbGVkPT0yKXRocm93XCJDYW5jZWxlZCFcIn1mdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fZG9fcHRocmVhZF9qb2luKHRocmVhZCxzdGF0dXMsYmxvY2spe2lmKCF0aHJlYWQpe2VycihcInB0aHJlYWRfam9pbiBhdHRlbXB0ZWQgb24gYSBudWxsIHRocmVhZCBwb2ludGVyIVwiKTtyZXR1cm4gRVJSTk9fQ09ERVMuRVNSQ0h9aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCYmX3B0aHJlYWRfc2VsZigpPT10aHJlYWQpe2VycihcIlBUaHJlYWQgXCIrdGhyZWFkK1wiIGlzIGF0dGVtcHRpbmcgdG8gam9pbiB0byBpdHNlbGYhXCIpO3JldHVybiBFUlJOT19DT0RFUy5FREVBRExLfWVsc2UgaWYoIUVOVklST05NRU5UX0lTX1BUSFJFQUQmJl9lbXNjcmlwdGVuX21haW5fYnJvd3Nlcl90aHJlYWRfaWQoKT09dGhyZWFkKXtlcnIoXCJNYWluIHRocmVhZCBcIit0aHJlYWQrXCIgaXMgYXR0ZW1wdGluZyB0byBqb2luIHRvIGl0c2VsZiFcIik7cmV0dXJuIEVSUk5PX0NPREVTLkVERUFETEt9dmFyIHNlbGY9R1JPV0FCTEVfSEVBUF9JMzIoKVt0aHJlYWQrMTI+PjJdO2lmKHNlbGYhPT10aHJlYWQpe2VycihcInB0aHJlYWRfam9pbiBhdHRlbXB0ZWQgb24gdGhyZWFkIFwiK3RocmVhZCtcIiwgd2hpY2ggZG9lcyBub3QgcG9pbnQgdG8gYSB2YWxpZCB0aHJlYWQsIG9yIGRvZXMgbm90IGV4aXN0IGFueW1vcmUhXCIpO3JldHVybiBFUlJOT19DT0RFUy5FU1JDSH12YXIgZGV0YWNoZWQ9QXRvbWljcy5sb2FkKEdST1dBQkxFX0hFQVBfVTMyKCksdGhyZWFkKzY0Pj4yKTtpZihkZXRhY2hlZCl7ZXJyKFwiQXR0ZW1wdGVkIHRvIGpvaW4gdGhyZWFkIFwiK3RocmVhZCtcIiwgd2hpY2ggd2FzIGFscmVhZHkgZGV0YWNoZWQhXCIpO3JldHVybiBFUlJOT19DT0RFUy5FSU5WQUx9aWYoYmxvY2spe19lbXNjcmlwdGVuX2NoZWNrX2Jsb2NraW5nX2FsbG93ZWQoKX1mb3IoOzspe3ZhciB0aHJlYWRTdGF0dXM9QXRvbWljcy5sb2FkKEdST1dBQkxFX0hFQVBfVTMyKCksdGhyZWFkKzA+PjIpO2lmKHRocmVhZFN0YXR1cz09MSl7dmFyIHRocmVhZEV4aXRDb2RlPUF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX1UzMigpLHRocmVhZCs0Pj4yKTtpZihzdGF0dXMpR1JPV0FCTEVfSEVBUF9JMzIoKVtzdGF0dXM+PjJdPXRocmVhZEV4aXRDb2RlO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aHJlYWQrNjQ+PjIsMSk7aWYoIUVOVklST05NRU5UX0lTX1BUSFJFQUQpY2xlYW51cFRocmVhZCh0aHJlYWQpO2Vsc2UgcG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJjbGVhbnVwVGhyZWFkXCIsXCJ0aHJlYWRcIjp0aHJlYWR9KTtyZXR1cm4gMH1pZighYmxvY2spe3JldHVybiBFUlJOT19DT0RFUy5FQlVTWX1fX3B0aHJlYWRfdGVzdGNhbmNlbF9qcygpO2lmKCFFTlZJUk9OTUVOVF9JU19QVEhSRUFEKV9lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzKCk7X2Vtc2NyaXB0ZW5fZnV0ZXhfd2FpdCh0aHJlYWQrMCx0aHJlYWRTdGF0dXMsRU5WSVJPTk1FTlRfSVNfUFRIUkVBRD8xMDA6MSl9fWZ1bmN0aW9uIF9wdGhyZWFkX2pvaW4odGhyZWFkLHN0YXR1cyl7cmV0dXJuIF9fZW1zY3JpcHRlbl9kb19wdGhyZWFkX2pvaW4odGhyZWFkLHN0YXR1cyx0cnVlKX1mdW5jdGlvbiBfX2lzTGVhcFllYXIoeWVhcil7cmV0dXJuIHllYXIlND09PTAmJih5ZWFyJTEwMCE9PTB8fHllYXIlNDAwPT09MCl9ZnVuY3Rpb24gX19hcnJheVN1bShhcnJheSxpbmRleCl7dmFyIHN1bT0wO2Zvcih2YXIgaT0wO2k8PWluZGV4O3N1bSs9YXJyYXlbaSsrXSl7fXJldHVybiBzdW19dmFyIF9fTU9OVEhfREFZU19MRUFQPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07dmFyIF9fTU9OVEhfREFZU19SRUdVTEFSPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gX19hZGREYXlzKGRhdGUsZGF5cyl7dmFyIG5ld0RhdGU9bmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO3doaWxlKGRheXM+MCl7dmFyIGxlYXA9X19pc0xlYXBZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSk7dmFyIGN1cnJlbnRNb250aD1uZXdEYXRlLmdldE1vbnRoKCk7dmFyIGRheXNJbkN1cnJlbnRNb250aD0obGVhcD9fX01PTlRIX0RBWVNfTEVBUDpfX01PTlRIX0RBWVNfUkVHVUxBUilbY3VycmVudE1vbnRoXTtpZihkYXlzPmRheXNJbkN1cnJlbnRNb250aC1uZXdEYXRlLmdldERhdGUoKSl7ZGF5cy09ZGF5c0luQ3VycmVudE1vbnRoLW5ld0RhdGUuZ2V0RGF0ZSgpKzE7bmV3RGF0ZS5zZXREYXRlKDEpO2lmKGN1cnJlbnRNb250aDwxMSl7bmV3RGF0ZS5zZXRNb250aChjdXJyZW50TW9udGgrMSl9ZWxzZXtuZXdEYXRlLnNldE1vbnRoKDApO25ld0RhdGUuc2V0RnVsbFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKzEpfX1lbHNle25ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKStkYXlzKTtyZXR1cm4gbmV3RGF0ZX19cmV0dXJuIG5ld0RhdGV9ZnVuY3Rpb24gX3N0cmZ0aW1lKHMsbWF4c2l6ZSxmb3JtYXQsdG0pe3ZhciB0bV96b25lPUdST1dBQkxFX0hFQVBfSTMyKClbdG0rNDA+PjJdO3ZhciBkYXRlPXt0bV9zZWM6R1JPV0FCTEVfSEVBUF9JMzIoKVt0bT4+Ml0sdG1fbWluOkdST1dBQkxFX0hFQVBfSTMyKClbdG0rND4+Ml0sdG1faG91cjpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzg+PjJdLHRtX21kYXk6R1JPV0FCTEVfSEVBUF9JMzIoKVt0bSsxMj4+Ml0sdG1fbW9uOkdST1dBQkxFX0hFQVBfSTMyKClbdG0rMTY+PjJdLHRtX3llYXI6R1JPV0FCTEVfSEVBUF9JMzIoKVt0bSsyMD4+Ml0sdG1fd2RheTpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzI0Pj4yXSx0bV95ZGF5OkdST1dBQkxFX0hFQVBfSTMyKClbdG0rMjg+PjJdLHRtX2lzZHN0OkdST1dBQkxFX0hFQVBfSTMyKClbdG0rMzI+PjJdLHRtX2dtdG9mZjpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzM2Pj4yXSx0bV96b25lOnRtX3pvbmU/VVRGOFRvU3RyaW5nKHRtX3pvbmUpOlwiXCJ9O3ZhciBwYXR0ZXJuPVVURjhUb1N0cmluZyhmb3JtYXQpO3ZhciBFWFBBTlNJT05fUlVMRVNfMT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMSl7cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLFwiZ1wiKSxFWFBBTlNJT05fUlVMRVNfMVtydWxlXSl9dmFyIFdFRUtEQVlTPVtcIlN1bmRheVwiLFwiTW9uZGF5XCIsXCJUdWVzZGF5XCIsXCJXZWRuZXNkYXlcIixcIlRodXJzZGF5XCIsXCJGcmlkYXlcIixcIlNhdHVyZGF5XCJdO3ZhciBNT05USFM9W1wiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdO2Z1bmN0aW9uIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsZGlnaXRzLGNoYXJhY3Rlcil7dmFyIHN0cj10eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiP3ZhbHVlLnRvU3RyaW5nKCk6dmFsdWV8fFwiXCI7d2hpbGUoc3RyLmxlbmd0aDxkaWdpdHMpe3N0cj1jaGFyYWN0ZXJbMF0rc3RyfXJldHVybiBzdHJ9ZnVuY3Rpb24gbGVhZGluZ051bGxzKHZhbHVlLGRpZ2l0cyl7cmV0dXJuIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsZGlnaXRzLFwiMFwiKX1mdW5jdGlvbiBjb21wYXJlQnlEYXkoZGF0ZTEsZGF0ZTIpe2Z1bmN0aW9uIHNnbih2YWx1ZSl7cmV0dXJuIHZhbHVlPDA/LTE6dmFsdWU+MD8xOjB9dmFyIGNvbXBhcmU7aWYoKGNvbXBhcmU9c2duKGRhdGUxLmdldEZ1bGxZZWFyKCktZGF0ZTIuZ2V0RnVsbFllYXIoKSkpPT09MCl7aWYoKGNvbXBhcmU9c2duKGRhdGUxLmdldE1vbnRoKCktZGF0ZTIuZ2V0TW9udGgoKSkpPT09MCl7Y29tcGFyZT1zZ24oZGF0ZTEuZ2V0RGF0ZSgpLWRhdGUyLmdldERhdGUoKSl9fXJldHVybiBjb21wYXJlfWZ1bmN0aW9uIGdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGgpe3N3aXRjaChqYW5Gb3VydGguZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBqYW5Gb3VydGg7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpe3ZhciB0aGlzRGF0ZT1fX2FkZERheXMobmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCwxKSxkYXRlLnRtX3lkYXkpO3ZhciBqYW5Gb3VydGhUaGlzWWVhcj1uZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLDAsNCk7dmFyIGphbkZvdXJ0aE5leHRZZWFyPW5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkrMSwwLDQpO3ZhciBmaXJzdFdlZWtTdGFydFRoaXNZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhUaGlzWWVhcik7dmFyIGZpcnN0V2Vla1N0YXJ0TmV4dFllYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aE5leHRZZWFyKTtpZihjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnRUaGlzWWVhcix0aGlzRGF0ZSk8PTApe2lmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydE5leHRZZWFyLHRoaXNEYXRlKTw9MCl7cmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkrMX1lbHNle3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpfX1lbHNle3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLTF9fXZhciBFWFBBTlNJT05fUlVMRVNfMj17XCIlYVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV19LFwiJWJcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBNT05USFNbZGF0ZS50bV9tb25dfSxcIiVDXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIHllYXI9ZGF0ZS50bV95ZWFyKzE5MDA7cmV0dXJuIGxlYWRpbmdOdWxscyh5ZWFyLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXksMil9LFwiJWVcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ1NvbWV0aGluZyhkYXRlLnRtX21kYXksMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpfSxcIiVIXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX2hvdXIsMil9LFwiJUlcIjpmdW5jdGlvbihkYXRlKXt2YXIgdHdlbHZlSG91cj1kYXRlLnRtX2hvdXI7aWYodHdlbHZlSG91cj09MCl0d2VsdmVIb3VyPTEyO2Vsc2UgaWYodHdlbHZlSG91cj4xMil0d2VsdmVIb3VyLT0xMjtyZXR1cm4gbGVhZGluZ051bGxzKHR3ZWx2ZUhvdXIsMil9LFwiJWpcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheStfX2FycmF5U3VtKF9faXNMZWFwWWVhcihkYXRlLnRtX3llYXIrMTkwMCk/X19NT05USF9EQVlTX0xFQVA6X19NT05USF9EQVlTX1JFR1VMQVIsZGF0ZS50bV9tb24tMSksMyl9LFwiJW1cIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbW9uKzEsMil9LFwiJU1cIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWluLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZGF0ZSl7aWYoZGF0ZS50bV9ob3VyPj0wJiZkYXRlLnRtX2hvdXI8MTIpe3JldHVyblwiQU1cIn1lbHNle3JldHVyblwiUE1cIn19LFwiJVNcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fc2VjLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcdFwifSxcIiV1XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fd2RheXx8N30sXCIlVVwiOmZ1bmN0aW9uKGRhdGUpe3ZhciBqYW5GaXJzdD1uZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCwwLDEpO3ZhciBmaXJzdFN1bmRheT1qYW5GaXJzdC5nZXREYXkoKT09PTA/amFuRmlyc3Q6X19hZGREYXlzKGphbkZpcnN0LDctamFuRmlyc3QuZ2V0RGF5KCkpO3ZhciBlbmREYXRlPW5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLGRhdGUudG1fbW9uLGRhdGUudG1fbWRheSk7aWYoY29tcGFyZUJ5RGF5KGZpcnN0U3VuZGF5LGVuZERhdGUpPDApe3ZhciBmZWJydWFyeUZpcnN0VW50aWxFbmRNb250aD1fX2FycmF5U3VtKF9faXNMZWFwWWVhcihlbmREYXRlLmdldEZ1bGxZZWFyKCkpP19fTU9OVEhfREFZU19MRUFQOl9fTU9OVEhfREFZU19SRUdVTEFSLGVuZERhdGUuZ2V0TW9udGgoKS0xKS0zMTt2YXIgZmlyc3RTdW5kYXlVbnRpbEVuZEphbnVhcnk9MzEtZmlyc3RTdW5kYXkuZ2V0RGF0ZSgpO3ZhciBkYXlzPWZpcnN0U3VuZGF5VW50aWxFbmRKYW51YXJ5K2ZlYnJ1YXJ5Rmlyc3RVbnRpbEVuZE1vbnRoK2VuZERhdGUuZ2V0RGF0ZSgpO3JldHVybiBsZWFkaW5nTnVsbHMoTWF0aC5jZWlsKGRheXMvNyksMil9cmV0dXJuIGNvbXBhcmVCeURheShmaXJzdFN1bmRheSxqYW5GaXJzdCk9PT0wP1wiMDFcIjpcIjAwXCJ9LFwiJVZcIjpmdW5jdGlvbihkYXRlKXt2YXIgamFuRm91cnRoVGhpc1llYXI9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCw0KTt2YXIgamFuRm91cnRoTmV4dFllYXI9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDEsMCw0KTt2YXIgZmlyc3RXZWVrU3RhcnRUaGlzWWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoVGhpc1llYXIpO3ZhciBmaXJzdFdlZWtTdGFydE5leHRZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhOZXh0WWVhcik7dmFyIGVuZERhdGU9X19hZGREYXlzKG5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsMSksZGF0ZS50bV95ZGF5KTtpZihjb21wYXJlQnlEYXkoZW5kRGF0ZSxmaXJzdFdlZWtTdGFydFRoaXNZZWFyKTwwKXtyZXR1cm5cIjUzXCJ9aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIsZW5kRGF0ZSk8PTApe3JldHVyblwiMDFcIn12YXIgZGF5c0RpZmZlcmVuY2U7aWYoZmlyc3RXZWVrU3RhcnRUaGlzWWVhci5nZXRGdWxsWWVhcigpPGRhdGUudG1feWVhcisxOTAwKXtkYXlzRGlmZmVyZW5jZT1kYXRlLnRtX3lkYXkrMzItZmlyc3RXZWVrU3RhcnRUaGlzWWVhci5nZXREYXRlKCl9ZWxzZXtkYXlzRGlmZmVyZW5jZT1kYXRlLnRtX3lkYXkrMS1maXJzdFdlZWtTdGFydFRoaXNZZWFyLmdldERhdGUoKX1yZXR1cm4gbGVhZGluZ051bGxzKE1hdGguY2VpbChkYXlzRGlmZmVyZW5jZS83KSwyKX0sXCIld1wiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3dkYXl9LFwiJVdcIjpmdW5jdGlvbihkYXRlKXt2YXIgamFuRmlyc3Q9bmV3IERhdGUoZGF0ZS50bV95ZWFyLDAsMSk7dmFyIGZpcnN0TW9uZGF5PWphbkZpcnN0LmdldERheSgpPT09MT9qYW5GaXJzdDpfX2FkZERheXMoamFuRmlyc3QsamFuRmlyc3QuZ2V0RGF5KCk9PT0wPzE6Ny1qYW5GaXJzdC5nZXREYXkoKSsxKTt2YXIgZW5kRGF0ZT1uZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCxkYXRlLnRtX21vbixkYXRlLnRtX21kYXkpO2lmKGNvbXBhcmVCeURheShmaXJzdE1vbmRheSxlbmREYXRlKTwwKXt2YXIgZmVicnVhcnlGaXJzdFVudGlsRW5kTW9udGg9X19hcnJheVN1bShfX2lzTGVhcFllYXIoZW5kRGF0ZS5nZXRGdWxsWWVhcigpKT9fX01PTlRIX0RBWVNfTEVBUDpfX01PTlRIX0RBWVNfUkVHVUxBUixlbmREYXRlLmdldE1vbnRoKCktMSktMzE7dmFyIGZpcnN0TW9uZGF5VW50aWxFbmRKYW51YXJ5PTMxLWZpcnN0TW9uZGF5LmdldERhdGUoKTt2YXIgZGF5cz1maXJzdE1vbmRheVVudGlsRW5kSmFudWFyeStmZWJydWFyeUZpcnN0VW50aWxFbmRNb250aCtlbmREYXRlLmdldERhdGUoKTtyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguY2VpbChkYXlzLzcpLDIpfXJldHVybiBjb21wYXJlQnlEYXkoZmlyc3RNb25kYXksamFuRmlyc3QpPT09MD9cIjAxXCI6XCIwMFwifSxcIiV5XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuKGRhdGUudG1feWVhcisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3llYXIrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGRhdGUpe3ZhciBvZmY9ZGF0ZS50bV9nbXRvZmY7dmFyIGFoZWFkPW9mZj49MDtvZmY9TWF0aC5hYnMob2ZmKS82MDtvZmY9b2ZmLzYwKjEwMCtvZmYlNjA7cmV0dXJuKGFoZWFkP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrb2ZmKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV96b25lfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19O2Zvcih2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMil7aWYocGF0dGVybi5pbmNsdWRlcyhydWxlKSl7cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLFwiZ1wiKSxFWFBBTlNJT05fUlVMRVNfMltydWxlXShkYXRlKSl9fXZhciBieXRlcz1pbnRBcnJheUZyb21TdHJpbmcocGF0dGVybixmYWxzZSk7aWYoYnl0ZXMubGVuZ3RoPm1heHNpemUpe3JldHVybiAwfXdyaXRlQXJyYXlUb01lbW9yeShieXRlcyxzKTtyZXR1cm4gYnl0ZXMubGVuZ3RoLTF9ZnVuY3Rpb24gX3N0cmZ0aW1lX2wocyxtYXhzaXplLGZvcm1hdCx0bSl7cmV0dXJuIF9zdHJmdGltZShzLG1heHNpemUsZm9ybWF0LHRtKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVHcmFwaEJ1aWxkZXIoY29udGV4dElkKXt2YXIgY29udGV4dD1XZWJOTi5tZ3JDb250ZXh0LmdldChjb250ZXh0SWQpO3ZhciBidWlsZGVyPW5ldyBNTEdyYXBoQnVpbGRlcihjb250ZXh0KTtyZXR1cm4gV2ViTk4ubWdyR3JhcGhCdWlsZGVyLmNyZWF0ZShidWlsZGVyKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVOYW1lZElucHV0cygpe3ZhciBpbnB1dHM9e307cmV0dXJuIFdlYk5OLm1nck5hbWVkSW5wdXRzLmNyZWF0ZShpbnB1dHMpfWZ1bmN0aW9uIF93ZWJubkNyZWF0ZU5hbWVkT3BlcmFuZHMoKXt2YXIgb3BlcmFuZHM9e307cmV0dXJuIFdlYk5OLm1nck5hbWVkT3BlcmFuZHMuY3JlYXRlKG9wZXJhbmRzKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVOYW1lZE91dHB1dHMoKXt2YXIgb3V0cHV0cz17fTtyZXR1cm4gV2ViTk4ubWdyTmFtZWRPdXRwdXRzLmNyZWF0ZShvdXRwdXRzKX1pZighRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClQVGhyZWFkLmluaXRNYWluVGhyZWFkQmxvY2soKTt2YXIgR0xjdHg7V2ViTk4uaW5pdE1hbmFnZXJzKCk7dmFyIHByb3hpZWRGdW5jdGlvblRhYmxlPVtudWxsLF9hdGV4aXQsX19fc3lzX2FjY2VzcyxfX19zeXNfZmNudGw2NCxfX19zeXNfZnN0YXQ2NCxfX19zeXNfZ2V0ZGVudHM2NCxfX19zeXNfaW9jdGwsX19fc3lzX2xzdGF0NjQsX19fc3lzX21rZGlyLF9fX3N5c19tbWFwMixfX19zeXNfbXVubWFwLF9fX3N5c19vcGVuLF9fX3N5c19yZWFkbGluayxfX19zeXNfcm1kaXIsX19fc3lzX3N0YXQ2NCxfX19zeXNfdW5saW5rLF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplX21haW5fdGhyZWFkLF9lbnZpcm9uX2dldCxfZW52aXJvbl9zaXplc19nZXQsX2ZkX2Nsb3NlLF9mZF9mZHN0YXRfZ2V0LF9mZF9yZWFkLF9mZF9zZWVrLF9mZF93cml0ZSxfdHpzZXRdO2Z1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LGRvbnRBZGROdWxsLGxlbmd0aCl7dmFyIGxlbj1sZW5ndGg+MD9sZW5ndGg6bGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7dmFyIHU4YXJyYXk9bmV3IEFycmF5KGxlbik7dmFyIG51bUJ5dGVzV3JpdHRlbj1zdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LHU4YXJyYXksMCx1OGFycmF5Lmxlbmd0aCk7aWYoZG9udEFkZE51bGwpdThhcnJheS5sZW5ndGg9bnVtQnl0ZXNXcml0dGVuO3JldHVybiB1OGFycmF5fXZhciBhc21MaWJyYXJ5QXJnPXtcImhcIjpfX19hc3NlcnRfZmFpbCxcImJhXCI6X19fY2xvY2tfZ2V0dGltZSxcImJcIjpfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uLFwiZFwiOl9fX2N4YV9hdGV4aXQsXCJlXCI6X19fY3hhX3RocmVhZF9hdGV4aXQsXCJjXCI6X19fY3hhX3Rocm93LFwiUVwiOl9fX3N5c19hY2Nlc3MsXCJyXCI6X19fc3lzX2ZjbnRsNjQsXCJYXCI6X19fc3lzX2ZzdGF0NjQsXCJSXCI6X19fc3lzX2dldGRlbnRzNjQsXCJ0XCI6X19fc3lzX2dldHBpZCxcIklcIjpfX19zeXNfaW9jdGwsXCJTXCI6X19fc3lzX2xzdGF0NjQsXCJXXCI6X19fc3lzX21rZGlyLFwiVlwiOl9fX3N5c19tbWFwMixcIlVcIjpfX19zeXNfbXVubWFwLFwicVwiOl9fX3N5c19vcGVuLFwiUFwiOl9fX3N5c19yZWFkbGluayxcIk5cIjpfX19zeXNfcm1kaXIsXCJ1XCI6X19fc3lzX3N0YXQ2NCxcIk9cIjpfX19zeXNfdW5saW5rLFwiYWFcIjpfX2Vtc2NyaXB0ZW5fbm90aWZ5X3RocmVhZF9xdWV1ZSxcImdcIjpfYWJvcnQsXCJ5XCI6X2Nsb2NrX2dldHRpbWUsXCJLYVwiOl9kaWZmdGltZSxcIk1cIjpfZGxjbG9zZSxcIm1cIjpfZGxlcnJvcixcIlRcIjpfZGxvcGVuLFwiRFwiOl9kbHN5bSxcIndcIjpfZW1zY3JpcHRlbl9hc21fY29uc3RfaW50LFwiSFwiOl9lbXNjcmlwdGVuX2NoZWNrX2Jsb2NraW5nX2FsbG93ZWQsXCJuXCI6X2Vtc2NyaXB0ZW5fY29uZGl0aW9uYWxfc2V0X2N1cnJlbnRfdGhyZWFkX3N0YXR1cyxcImpcIjpfZW1zY3JpcHRlbl9mdXRleF93YWl0LFwia1wiOl9lbXNjcmlwdGVuX2Z1dGV4X3dha2UsXCJZXCI6X2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4LFwiaVwiOl9lbXNjcmlwdGVuX2dldF9ub3csXCJGXCI6X2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcIm9cIjpfZW1zY3JpcHRlbl9udW1fbG9naWNhbF9jb3JlcyxcIlpcIjpfZW1zY3JpcHRlbl9yZWNlaXZlX29uX21haW5fdGhyZWFkX2pzLFwiR1wiOl9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLFwiX1wiOl9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplLFwidlwiOl9lbXNjcmlwdGVuX3NldF9jdXJyZW50X3RocmVhZF9zdGF0dXMsXCIkXCI6X2Vtc2NyaXB0ZW5fd2ViZ2xfY3JlYXRlX2NvbnRleHQsXCJJYVwiOl9lbXNjcmlwdGVuX3dlYm5uX2NyZWF0ZV9jb250ZXh0LFwiS1wiOl9lbnZpcm9uX2dldCxcIkxcIjpfZW52aXJvbl9zaXplc19nZXQsXCJsXCI6X2ZkX2Nsb3NlLFwiSlwiOl9mZF9mZHN0YXRfZ2V0LFwic1wiOl9mZF9yZWFkLFwiQ1wiOl9mZF9zZWVrLFwicFwiOl9mZF93cml0ZSxcIm5hXCI6X2dldHRpbWVvZmRheSxcIkxhXCI6X2dtdGltZV9yLFwiRVwiOmluaXRQdGhyZWFkc0pTLFwiQVwiOl9sb2NhbHRpbWVfcixcImFcIjp3YXNtTWVtb3J5fHxNb2R1bGVbXCJ3YXNtTWVtb3J5XCJdLFwielwiOl9ta3RpbWUsXCJIYVwiOl9tbENvbnRleHRSZWZlcmVuY2UsXCJHYVwiOl9tbENvbnRleHRSZWxlYXNlLFwiQ2FcIjpfbWxHcmFwaEJ1aWxkZXJBZGQsXCJCYVwiOl9tbEdyYXBoQnVpbGRlckF2ZXJhZ2VQb29sMmQsXCJBYVwiOl9tbEdyYXBoQnVpbGRlckJhdGNoTm9ybSxcInphXCI6X21sR3JhcGhCdWlsZGVyQnVpbGRTeW5jLFwieWFcIjpfbWxHcmFwaEJ1aWxkZXJDb25jYXQsXCJ4YVwiOl9tbEdyYXBoQnVpbGRlckNvbnN0YW50LFwid2FcIjpfbWxHcmFwaEJ1aWxkZXJDb252MmQsXCJ2YVwiOl9tbEdyYXBoQnVpbGRlckdlbW0sXCJ1YVwiOl9tbEdyYXBoQnVpbGRlcklucHV0LFwidGFcIjpfbWxHcmFwaEJ1aWxkZXJNYXRtdWwsXCJzYVwiOl9tbEdyYXBoQnVpbGRlck1heFBvb2wyZCxcInBhXCI6X21sR3JhcGhCdWlsZGVyUmVsZWFzZSxcInJhXCI6X21sR3JhcGhCdWlsZGVyUmVsdSxcInFhXCI6X21sR3JhcGhCdWlsZGVyUmVzaGFwZSxcIkZhXCI6X21sR3JhcGhDb21wdXRlU3luYyxcIkVhXCI6X21sR3JhcGhSZWZlcmVuY2UsXCJEYVwiOl9tbEdyYXBoUmVsZWFzZSxcIm1hXCI6X21sTmFtZWRJbnB1dHNSZWxlYXNlLFwib2FcIjpfbWxOYW1lZElucHV0c1NldCxcImthXCI6X21sTmFtZWRPcGVyYW5kc1JlbGVhc2UsXCJsYVwiOl9tbE5hbWVkT3BlcmFuZHNTZXQsXCJpYVwiOl9tbE5hbWVkT3V0cHV0c1JlbGVhc2UsXCJqYVwiOl9tbE5hbWVkT3V0cHV0c1NldCxcImhhXCI6X21sT3BlcmFuZFJlZmVyZW5jZSxcImdhXCI6X21sT3BlcmFuZFJlbGVhc2UsXCJ4XCI6X3B0aHJlYWRfY3JlYXRlLFwiQlwiOl9wdGhyZWFkX2pvaW4sXCJKYVwiOl9zdHJmdGltZSxcImZcIjpfc3RyZnRpbWVfbCxcImZhXCI6X3dlYm5uQ3JlYXRlR3JhcGhCdWlsZGVyLFwiZWFcIjpfd2Vibm5DcmVhdGVOYW1lZElucHV0cyxcImRhXCI6X3dlYm5uQ3JlYXRlTmFtZWRPcGVyYW5kcyxcImNhXCI6X3dlYm5uQ3JlYXRlTmFtZWRPdXRwdXRzfTt2YXIgYXNtPWNyZWF0ZVdhc20oKTt2YXIgX19fd2FzbV9jYWxsX2N0b3JzPU1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXT1mdW5jdGlvbigpe3JldHVybihfX193YXNtX2NhbGxfY3RvcnM9TW9kdWxlW1wiX19fd2FzbV9jYWxsX2N0b3JzXCJdPU1vZHVsZVtcImFzbVwiXVtcIk1hXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0SW5pdD1Nb2R1bGVbXCJfT3J0SW5pdFwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0SW5pdD1Nb2R1bGVbXCJfT3J0SW5pdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJOYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9uc1wiXT1mdW5jdGlvbigpe3JldHVybihfT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9TW9kdWxlW1wiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcIk9hXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OPU1vZHVsZVtcIl9PcnRTZXNzaW9uT3B0aW9uc0FwcGVuZEV4ZWN1dGlvblByb3ZpZGVyV2ViTk5cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFNlc3Npb25PcHRpb25zQXBwZW5kRXhlY3V0aW9uUHJvdmlkZXJXZWJOTj1Nb2R1bGVbXCJfT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OXCJdPU1vZHVsZVtcImFzbVwiXVtcIlBhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PU1vZHVsZVtcIl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnlcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5XCJdPU1vZHVsZVtcImFzbVwiXVtcIlFhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPU1vZHVsZVtcIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1Nb2R1bGVbXCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcIlJhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0Q3JlYXRlU2Vzc2lvbj1Nb2R1bGVbXCJfT3J0Q3JlYXRlU2Vzc2lvblwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0Q3JlYXRlU2Vzc2lvbj1Nb2R1bGVbXCJfT3J0Q3JlYXRlU2Vzc2lvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJTYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VTZXNzaW9uPU1vZHVsZVtcIl9PcnRSZWxlYXNlU2Vzc2lvblwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0UmVsZWFzZVNlc3Npb249TW9kdWxlW1wiX09ydFJlbGVhc2VTZXNzaW9uXCJdPU1vZHVsZVtcImFzbVwiXVtcIlRhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0SW5wdXRDb3VudD1Nb2R1bGVbXCJfT3J0R2V0SW5wdXRDb3VudFwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0SW5wdXRDb3VudD1Nb2R1bGVbXCJfT3J0R2V0SW5wdXRDb3VudFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJVYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldE91dHB1dENvdW50PU1vZHVsZVtcIl9PcnRHZXRPdXRwdXRDb3VudFwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0T3V0cHV0Q291bnQ9TW9kdWxlW1wiX09ydEdldE91dHB1dENvdW50XCJdPU1vZHVsZVtcImFzbVwiXVtcIlZhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0SW5wdXROYW1lPU1vZHVsZVtcIl9PcnRHZXRJbnB1dE5hbWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldElucHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0SW5wdXROYW1lXCJdPU1vZHVsZVtcImFzbVwiXVtcIldhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0T3V0cHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0T3V0cHV0TmFtZVwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0T3V0cHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0T3V0cHV0TmFtZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJYYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEZyZWU9TW9kdWxlW1wiX09ydEZyZWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEZyZWU9TW9kdWxlW1wiX09ydEZyZWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiWWFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRDcmVhdGVUZW5zb3I9TW9kdWxlW1wiX09ydENyZWF0ZVRlbnNvclwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0Q3JlYXRlVGVuc29yPU1vZHVsZVtcIl9PcnRDcmVhdGVUZW5zb3JcIl09TW9kdWxlW1wiYXNtXCJdW1wiWmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRHZXRUZW5zb3JEYXRhPU1vZHVsZVtcIl9PcnRHZXRUZW5zb3JEYXRhXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRHZXRUZW5zb3JEYXRhPU1vZHVsZVtcIl9PcnRHZXRUZW5zb3JEYXRhXCJdPU1vZHVsZVtcImFzbVwiXVtcIl9hXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0UmVsZWFzZVRlbnNvcj1Nb2R1bGVbXCJfT3J0UmVsZWFzZVRlbnNvclwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0UmVsZWFzZVRlbnNvcj1Nb2R1bGVbXCJfT3J0UmVsZWFzZVRlbnNvclwiXT1Nb2R1bGVbXCJhc21cIl1bXCIkYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydENyZWF0ZVJ1bk9wdGlvbnM9TW9kdWxlW1wiX09ydENyZWF0ZVJ1bk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVJ1bk9wdGlvbnM9TW9kdWxlW1wiX09ydENyZWF0ZVJ1bk9wdGlvbnNcIl09TW9kdWxlW1wiYXNtXCJdW1wiYWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRBZGRSdW5Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkUnVuQ29uZmlnRW50cnlcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PU1vZHVsZVtcIl9PcnRBZGRSdW5Db25maWdFbnRyeVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJiYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRSZWxlYXNlUnVuT3B0aW9uc1wiXT1mdW5jdGlvbigpe3JldHVybihfT3J0UmVsZWFzZVJ1bk9wdGlvbnM9TW9kdWxlW1wiX09ydFJlbGVhc2VSdW5PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcImNiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0UnVuPU1vZHVsZVtcIl9PcnRSdW5cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJ1bj1Nb2R1bGVbXCJfT3J0UnVuXCJdPU1vZHVsZVtcImFzbVwiXVtcImRiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbWFsbG9jPU1vZHVsZVtcIl9tYWxsb2NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPU1vZHVsZVtcImFzbVwiXVtcImZiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbXCJfX19lcnJub19sb2NhdGlvblwiXT1mdW5jdGlvbigpe3JldHVybihfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbXCJfX19lcnJub19sb2NhdGlvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJnYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2ZyZWU9TW9kdWxlW1wiX2ZyZWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2ZyZWU9TW9kdWxlW1wiX2ZyZWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiaGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9wdGhyZWFkX3NlbGY9TW9kdWxlW1wiX3B0aHJlYWRfc2VsZlwiXT1mdW5jdGlvbigpe3JldHVybihfcHRocmVhZF9zZWxmPU1vZHVsZVtcIl9wdGhyZWFkX3NlbGZcIl09TW9kdWxlW1wiYXNtXCJdW1wiaWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX3Rsc19pbml0PU1vZHVsZVtcIl9lbXNjcmlwdGVuX3Rsc19pbml0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX3Rsc19pbml0PU1vZHVsZVtcIl9lbXNjcmlwdGVuX3Rsc19pbml0XCJdPU1vZHVsZVtcImFzbVwiXVtcImpiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZW1zY3JpcHRlbl9jdXJyZW50X3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscz1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9jdXJyZW50X3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxsc1wiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9jdXJyZW50X3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscz1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9jdXJyZW50X3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxsc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJrYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fcmVnaXN0ZXJfbWFpbl9icm93c2VyX3RocmVhZF9pZD1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9yZWdpc3Rlcl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX3JlZ2lzdGVyX21haW5fYnJvd3Nlcl90aHJlYWRfaWQ9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fcmVnaXN0ZXJfbWFpbl9icm93c2VyX3RocmVhZF9pZFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJsYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fbWFpbl9icm93c2VyX3RocmVhZF9pZD1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX21haW5fYnJvd3Nlcl90aHJlYWRfaWQ9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fbWFpbl9icm93c2VyX3RocmVhZF9pZFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJtYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19lbXNjcmlwdGVuX2RvX2Rpc3BhdGNoX3RvX3RocmVhZD1Nb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fZG9fZGlzcGF0Y2hfdG9fdGhyZWFkXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZW1zY3JpcHRlbl9kb19kaXNwYXRjaF90b190aHJlYWQ9TW9kdWxlW1wiX19lbXNjcmlwdGVuX2RvX2Rpc3BhdGNoX3RvX3RocmVhZFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJuYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fc3luY19ydW5faW5fbWFpbl90aHJlYWRfND1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9zeW5jX3J1bl9pbl9tYWluX3RocmVhZF80XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX3N5bmNfcnVuX2luX21haW5fdGhyZWFkXzQ9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3luY19ydW5faW5fbWFpbl90aHJlYWRfNFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJvYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHNcIl09TW9kdWxlW1wiYXNtXCJdW1wicGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPU1vZHVsZVtcIl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzPU1vZHVsZVtcIl9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzXCJdPU1vZHVsZVtcImFzbVwiXVtcInFiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2Vtc2NyaXB0ZW5fY2FsbF9vbl90aHJlYWQ9TW9kdWxlW1wiX19lbXNjcmlwdGVuX2NhbGxfb25fdGhyZWFkXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZW1zY3JpcHRlbl9jYWxsX29uX3RocmVhZD1Nb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fY2FsbF9vbl90aHJlYWRcIl09TW9kdWxlW1wiYXNtXCJdW1wicmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1Nb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PU1vZHVsZVtcIl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJzYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX21lbXNldD1Nb2R1bGVbXCJfbWVtc2V0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9tZW1zZXQ9TW9kdWxlW1wiX21lbXNldFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ0YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19fcHRocmVhZF90c2RfcnVuX2R0b3JzPU1vZHVsZVtcIl9fX3B0aHJlYWRfdHNkX3J1bl9kdG9yc1wiXT1mdW5jdGlvbigpe3JldHVybihfX19wdGhyZWFkX3RzZF9ydW5fZHRvcnM9TW9kdWxlW1wiX19fcHRocmVhZF90c2RfcnVuX2R0b3JzXCJdPU1vZHVsZVtcImFzbVwiXVtcInViXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZW1zY3JpcHRlbl9nZXRfZ2xvYmFsX2xpYmM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fZ2V0X2dsb2JhbF9saWJjXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX2dldF9nbG9iYWxfbGliYz1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9nZXRfZ2xvYmFsX2xpYmNcIl09TW9kdWxlW1wiYXNtXCJdW1widmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZ2V0X3R6bmFtZT1Nb2R1bGVbXCJfX2dldF90em5hbWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19nZXRfdHpuYW1lPU1vZHVsZVtcIl9fZ2V0X3R6bmFtZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ3YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19nZXRfZGF5bGlnaHQ9TW9kdWxlW1wiX19nZXRfZGF5bGlnaHRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19nZXRfZGF5bGlnaHQ9TW9kdWxlW1wiX19nZXRfZGF5bGlnaHRcIl09TW9kdWxlW1wiYXNtXCJdW1wieGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZ2V0X3RpbWV6b25lPU1vZHVsZVtcIl9fZ2V0X3RpbWV6b25lXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZ2V0X3RpbWV6b25lPU1vZHVsZVtcIl9fZ2V0X3RpbWV6b25lXCJdPU1vZHVsZVtcImFzbVwiXVtcInliXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja1NhdmU9TW9kdWxlW1wic3RhY2tTYXZlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrU2F2ZT1Nb2R1bGVbXCJzdGFja1NhdmVcIl09TW9kdWxlW1wiYXNtXCJdW1wiemJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHN0YWNrUmVzdG9yZT1Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oc3RhY2tSZXN0b3JlPU1vZHVsZVtcInN0YWNrUmVzdG9yZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJBYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tBbGxvYz1Nb2R1bGVbXCJzdGFja0FsbG9jXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrQWxsb2M9TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJCYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0cz1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0c1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJDYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX21lbWFsaWduPU1vZHVsZVtcIl9tZW1hbGlnblwiXT1mdW5jdGlvbigpe3JldHVybihfbWVtYWxpZ249TW9kdWxlW1wiX21lbWFsaWduXCJdPU1vZHVsZVtcImFzbVwiXVtcIkRiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2Vtc2NyaXB0ZW5fYWxsb3dfbWFpbl9ydW50aW1lX3F1ZXVlZF9jYWxscz1Nb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fYWxsb3dfbWFpbl9ydW50aW1lX3F1ZXVlZF9jYWxsc1wiXT02NTM1MzY7dmFyIF9fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9mdXRleD1Nb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfZnV0ZXhcIl09NjU4OTA0O01vZHVsZVtcIlVURjhUb1N0cmluZ1wiXT1VVEY4VG9TdHJpbmc7TW9kdWxlW1wic3RyaW5nVG9VVEY4XCJdPXN0cmluZ1RvVVRGODtNb2R1bGVbXCJsZW5ndGhCeXRlc1VURjhcIl09bGVuZ3RoQnl0ZXNVVEY4O01vZHVsZVtcIlBUaHJlYWRcIl09UFRocmVhZDtNb2R1bGVbXCJzdGFja1NhdmVcIl09c3RhY2tTYXZlO01vZHVsZVtcInN0YWNrUmVzdG9yZVwiXT1zdGFja1Jlc3RvcmU7TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1zdGFja0FsbG9jO01vZHVsZVtcIlBUaHJlYWRcIl09UFRocmVhZDtNb2R1bGVbXCJ3YXNtTWVtb3J5XCJdPXdhc21NZW1vcnk7TW9kdWxlW1wiRXhpdFN0YXR1c1wiXT1FeGl0U3RhdHVzO3ZhciBjYWxsZWRSdW47ZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIjt0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3N0YXR1cytcIilcIjt0aGlzLnN0YXR1cz1zdGF0dXN9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyfTtmdW5jdGlvbiBydW4oYXJncyl7YXJncz1hcmdzfHxhcmd1bWVudHNfO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2luaXRSdW50aW1lKCk7cG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJsb2FkZWRcIn0pO3JldHVybn1wcmVSdW4oKTtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufWZ1bmN0aW9uIGRvUnVuKCl7aWYoY2FsbGVkUnVuKXJldHVybjtjYWxsZWRSdW49dHJ1ZTtNb2R1bGVbXCJjYWxsZWRSdW5cIl09dHJ1ZTtpZihBQk9SVClyZXR1cm47aW5pdFJ1bnRpbWUoKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0oKTtwb3N0UnVuKCl9aWYoTW9kdWxlW1wic2V0U3RhdHVzXCJdKXtNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiXCIpfSwxKTtkb1J1bigpfSwxKX1lbHNle2RvUnVuKCl9fU1vZHVsZVtcInJ1blwiXT1ydW47ZnVuY3Rpb24gZXhpdChzdGF0dXMsaW1wbGljaXQpe0VYSVRTVEFUVVM9c3RhdHVzO2lmKGltcGxpY2l0JiZrZWVwUnVudGltZUFsaXZlKCkmJnN0YXR1cz09PTApe3JldHVybn1pZighaW1wbGljaXQpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpe3Bvc3RNZXNzYWdlKHtcImNtZFwiOlwiZXhpdFByb2Nlc3NcIixcInJldHVybkNvZGVcIjpzdGF0dXN9KTt0aHJvdyBuZXcgRXhpdFN0YXR1cyhzdGF0dXMpfWVsc2V7fX1pZihrZWVwUnVudGltZUFsaXZlKCkpe31lbHNle1BUaHJlYWQudGVybWluYXRlQWxsVGhyZWFkcygpO2V4aXRSdW50aW1lKCk7aWYoTW9kdWxlW1wib25FeGl0XCJdKU1vZHVsZVtcIm9uRXhpdFwiXShzdGF0dXMpO0FCT1JUPXRydWV9cXVpdF8oc3RhdHVzLG5ldyBFeGl0U3RhdHVzKHN0YXR1cykpfWlmKE1vZHVsZVtcInByZUluaXRcIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlSW5pdFwiXT1bTW9kdWxlW1wicHJlSW5pdFwiXV07d2hpbGUoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGg+MCl7TW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpfX1pZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXtub0V4aXRSdW50aW1lPWZhbHNlO1BUaHJlYWQuaW5pdFdvcmtlcigpfXJ1bigpO1xuXG5cbiAgcmV0dXJuIG9ydFdhc21UaHJlYWRlZC5yZWFkeVxufVxuKTtcbn0pKCk7XG5pZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICBtb2R1bGUuZXhwb3J0cyA9IG9ydFdhc21UaHJlYWRlZDtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9ydFdhc21UaHJlYWRlZDsgfSk7XG5lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gIGV4cG9ydHNbXCJvcnRXYXNtVGhyZWFkZWRcIl0gPSBvcnRXYXNtVGhyZWFkZWQ7XG4iLCJcbnZhciBvcnRXYXNtID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIF9fZmlsZW5hbWUgIT09ICd1bmRlZmluZWQnKSBfc2NyaXB0RGlyID0gX3NjcmlwdERpciB8fCBfX2ZpbGVuYW1lO1xuICByZXR1cm4gKFxuZnVuY3Rpb24ob3J0V2FzbSkge1xuICBvcnRXYXNtID0gb3J0V2FzbSB8fCB7fTtcblxudmFyIE1vZHVsZT10eXBlb2Ygb3J0V2FzbSE9PVwidW5kZWZpbmVkXCI/b3J0V2FzbTp7fTt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlW1wicmVhZHlcIl09bmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe3JlYWR5UHJvbWlzZVJlc29sdmU9cmVzb2x2ZTtyZWFkeVByb21pc2VSZWplY3Q9cmVqZWN0fSk7dmFyIG1vZHVsZU92ZXJyaWRlcz17fTt2YXIga2V5O2ZvcihrZXkgaW4gTW9kdWxlKXtpZihNb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSl7bW9kdWxlT3ZlcnJpZGVzW2tleV09TW9kdWxlW2tleV19fXZhciBhcmd1bWVudHNfPVtdO3ZhciB0aGlzUHJvZ3JhbT1cIi4vdGhpcy5wcm9ncmFtXCI7dmFyIHF1aXRfPWZ1bmN0aW9uKHN0YXR1cyx0b1Rocm93KXt0aHJvdyB0b1Rocm93fTt2YXIgRU5WSVJPTk1FTlRfSVNfV0VCPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVI9ZmFsc2U7dmFyIEVOVklST05NRU5UX0lTX05PREU9ZmFsc2U7dmFyIEVOVklST05NRU5UX0lTX1NIRUxMPWZhbHNlO0VOVklST05NRU5UX0lTX1dFQj10eXBlb2Ygd2luZG93PT09XCJvYmplY3RcIjtFTlZJUk9OTUVOVF9JU19XT1JLRVI9dHlwZW9mIGltcG9ydFNjcmlwdHM9PT1cImZ1bmN0aW9uXCI7RU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZT09PVwic3RyaW5nXCI7RU5WSVJPTk1FTlRfSVNfU0hFTEw9IUVOVklST05NRU5UX0lTX1dFQiYmIUVOVklST05NRU5UX0lTX05PREUmJiFFTlZJUk9OTUVOVF9JU19XT1JLRVI7dmFyIHNjcmlwdERpcmVjdG9yeT1cIlwiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSl7cmV0dXJuIE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0ocGF0aCxzY3JpcHREaXJlY3RvcnkpfXJldHVybiBzY3JpcHREaXJlY3RvcnkrcGF0aH12YXIgcmVhZF8scmVhZEFzeW5jLHJlYWRCaW5hcnksc2V0V2luZG93VGl0bGU7dmFyIG5vZGVGUzt2YXIgbm9kZVBhdGg7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtzY3JpcHREaXJlY3Rvcnk9cmVxdWlyZShcInBhdGhcIikuZGlybmFtZShzY3JpcHREaXJlY3RvcnkpK1wiL1wifWVsc2V7c2NyaXB0RGlyZWN0b3J5PV9fZGlybmFtZStcIi9cIn1yZWFkXz1mdW5jdGlvbiBzaGVsbF9yZWFkKGZpbGVuYW1lLGJpbmFyeSl7aWYoIW5vZGVGUylub2RlRlM9cmVxdWlyZShcImZzXCIpO2lmKCFub2RlUGF0aClub2RlUGF0aD1yZXF1aXJlKFwicGF0aFwiKTtmaWxlbmFtZT1ub2RlUGF0aFtcIm5vcm1hbGl6ZVwiXShmaWxlbmFtZSk7cmV0dXJuIG5vZGVGU1tcInJlYWRGaWxlU3luY1wiXShmaWxlbmFtZSxiaW5hcnk/bnVsbDpcInV0ZjhcIil9O3JlYWRCaW5hcnk9ZnVuY3Rpb24gcmVhZEJpbmFyeShmaWxlbmFtZSl7dmFyIHJldD1yZWFkXyhmaWxlbmFtZSx0cnVlKTtpZighcmV0LmJ1ZmZlcil7cmV0PW5ldyBVaW50OEFycmF5KHJldCl9YXNzZXJ0KHJldC5idWZmZXIpO3JldHVybiByZXR9O2lmKHByb2Nlc3NbXCJhcmd2XCJdLmxlbmd0aD4xKXt0aGlzUHJvZ3JhbT1wcm9jZXNzW1wiYXJndlwiXVsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpfWFyZ3VtZW50c189cHJvY2Vzc1tcImFyZ3ZcIl0uc2xpY2UoMik7cHJvY2Vzc1tcIm9uXCJdKFwidW5jYXVnaHRFeGNlcHRpb25cIixmdW5jdGlvbihleCl7aWYoIShleCBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpKXt0aHJvdyBleH19KTtwcm9jZXNzW1wib25cIl0oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIixhYm9ydCk7cXVpdF89ZnVuY3Rpb24oc3RhdHVzKXtwcm9jZXNzW1wiZXhpdFwiXShzdGF0dXMpfTtNb2R1bGVbXCJpbnNwZWN0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuXCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifX1lbHNlIGlmKEVOVklST05NRU5UX0lTX1NIRUxMKXtpZih0eXBlb2YgcmVhZCE9XCJ1bmRlZmluZWRcIil7cmVhZF89ZnVuY3Rpb24gc2hlbGxfcmVhZChmKXtyZXR1cm4gcmVhZChmKX19cmVhZEJpbmFyeT1mdW5jdGlvbiByZWFkQmluYXJ5KGYpe3ZhciBkYXRhO2lmKHR5cGVvZiByZWFkYnVmZmVyPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihmKSl9ZGF0YT1yZWFkKGYsXCJiaW5hcnlcIik7YXNzZXJ0KHR5cGVvZiBkYXRhPT09XCJvYmplY3RcIik7cmV0dXJuIGRhdGF9O2lmKHR5cGVvZiBzY3JpcHRBcmdzIT1cInVuZGVmaW5lZFwiKXthcmd1bWVudHNfPXNjcmlwdEFyZ3N9ZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzIT1cInVuZGVmaW5lZFwiKXthcmd1bWVudHNfPWFyZ3VtZW50c31pZih0eXBlb2YgcXVpdD09PVwiZnVuY3Rpb25cIil7cXVpdF89ZnVuY3Rpb24oc3RhdHVzKXtxdWl0KHN0YXR1cyl9fWlmKHR5cGVvZiBwcmludCE9PVwidW5kZWZpbmVkXCIpe2lmKHR5cGVvZiBjb25zb2xlPT09XCJ1bmRlZmluZWRcIiljb25zb2xlPXt9O2NvbnNvbGUubG9nPXByaW50O2NvbnNvbGUud2Fybj1jb25zb2xlLmVycm9yPXR5cGVvZiBwcmludEVyciE9PVwidW5kZWZpbmVkXCI/cHJpbnRFcnI6cHJpbnR9fWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZn1lbHNlIGlmKHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3NjcmlwdERpcmVjdG9yeT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31pZihfc2NyaXB0RGlyKXtzY3JpcHREaXJlY3Rvcnk9X3NjcmlwdERpcn1pZihzY3JpcHREaXJlY3RvcnkuaW5kZXhPZihcImJsb2I6XCIpIT09MCl7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkubGFzdEluZGV4T2YoXCIvXCIpKzEpfWVsc2V7c2NyaXB0RGlyZWN0b3J5PVwiXCJ9e3JlYWRfPWZ1bmN0aW9uKHVybCl7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5zZW5kKG51bGwpO3JldHVybiB4aHIucmVzcG9uc2VUZXh0fTtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3JlYWRCaW5hcnk9ZnVuY3Rpb24odXJsKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLnNlbmQobnVsbCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSl9fXJlYWRBc3luYz1mdW5jdGlvbih1cmwsb25sb2FkLG9uZXJyb3Ipe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLHRydWUpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5vbmxvYWQ9ZnVuY3Rpb24oKXtpZih4aHIuc3RhdHVzPT0yMDB8fHhoci5zdGF0dXM9PTAmJnhoci5yZXNwb25zZSl7b25sb2FkKHhoci5yZXNwb25zZSk7cmV0dXJufW9uZXJyb3IoKX07eGhyLm9uZXJyb3I9b25lcnJvcjt4aHIuc2VuZChudWxsKX19c2V0V2luZG93VGl0bGU9ZnVuY3Rpb24odGl0bGUpe2RvY3VtZW50LnRpdGxlPXRpdGxlfX1lbHNle312YXIgb3V0PU1vZHVsZVtcInByaW50XCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlW1wicHJpbnRFcnJcIl18fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO2ZvcihrZXkgaW4gbW9kdWxlT3ZlcnJpZGVzKXtpZihtb2R1bGVPdmVycmlkZXMuaGFzT3duUHJvcGVydHkoa2V5KSl7TW9kdWxlW2tleV09bW9kdWxlT3ZlcnJpZGVzW2tleV19fW1vZHVsZU92ZXJyaWRlcz1udWxsO2lmKE1vZHVsZVtcImFyZ3VtZW50c1wiXSlhcmd1bWVudHNfPU1vZHVsZVtcImFyZ3VtZW50c1wiXTtpZihNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSl0aGlzUHJvZ3JhbT1Nb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXTtpZihNb2R1bGVbXCJxdWl0XCJdKXF1aXRfPU1vZHVsZVtcInF1aXRcIl07dmFyIHdhc21CaW5hcnk7aWYoTW9kdWxlW1wid2FzbUJpbmFyeVwiXSl3YXNtQmluYXJ5PU1vZHVsZVtcIndhc21CaW5hcnlcIl07dmFyIG5vRXhpdFJ1bnRpbWU9TW9kdWxlW1wibm9FeGl0UnVudGltZVwiXXx8ZmFsc2U7aWYodHlwZW9mIFdlYkFzc2VtYmx5IT09XCJvYmplY3RcIil7YWJvcnQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpfXZhciB3YXNtTWVtb3J5O3ZhciBBQk9SVD1mYWxzZTt2YXIgRVhJVFNUQVRVUztmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLHRleHQpe2lmKCFjb25kaXRpb24pe2Fib3J0KFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIrdGV4dCl9fXZhciBVVEY4RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPT1cInVuZGVmaW5lZFwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dW5kZWZpbmVkO2Z1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXAsaWR4LG1heEJ5dGVzVG9SZWFkKXt2YXIgZW5kSWR4PWlkeCttYXhCeXRlc1RvUmVhZDt2YXIgZW5kUHRyPWlkeDt3aGlsZShoZWFwW2VuZFB0cl0mJiEoZW5kUHRyPj1lbmRJZHgpKSsrZW5kUHRyO2lmKGVuZFB0ci1pZHg+MTYmJmhlYXAuc3ViYXJyYXkmJlVURjhEZWNvZGVyKXtyZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXAuc3ViYXJyYXkoaWR4LGVuZFB0cikpfWVsc2V7dmFyIHN0cj1cIlwiO3doaWxlKGlkeDxlbmRQdHIpe3ZhciB1MD1oZWFwW2lkeCsrXTtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX12YXIgdTI9aGVhcFtpZHgrK10mNjM7aWYoKHUwJjI0MCk9PTIyNCl7dTA9KHUwJjE1KTw8MTJ8dTE8PDZ8dTJ9ZWxzZXt1MD0odTAmNyk8PDE4fHUxPDwxMnx1Mjw8NnxoZWFwW2lkeCsrXSY2M31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKX1lbHNle3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfX19cmV0dXJuIHN0cn1mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLG1heEJ5dGVzVG9SZWFkKXtyZXR1cm4gcHRyP1VURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIsbWF4Qnl0ZXNUb1JlYWQpOlwiXCJ9ZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLGhlYXAsb3V0SWR4LG1heEJ5dGVzVG9Xcml0ZSl7aWYoIShtYXhCeXRlc1RvV3JpdGU+MCkpcmV0dXJuIDA7dmFyIHN0YXJ0SWR4PW91dElkeDt2YXIgZW5kSWR4PW91dElkeCttYXhCeXRlc1RvV3JpdGUtMTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpe3ZhciB1MT1zdHIuY2hhckNvZGVBdCgrK2kpO3U9NjU1MzYrKCh1JjEwMjMpPDwxMCl8dTEmMTAyM31pZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPXV9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTE5Mnx1Pj42O2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjI0fHU+PjEyO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2V7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yNDB8dT4+MTg7aGVhcFtvdXRJZHgrK109MTI4fHU+PjEyJjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfX1oZWFwW291dElkeF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fWZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSl7cmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSl9ZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cil7dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl1PTY1NTM2KygodSYxMDIzKTw8MTApfHN0ci5jaGFyQ29kZUF0KCsraSkmMTAyMztpZih1PD0xMjcpKytsZW47ZWxzZSBpZih1PD0yMDQ3KWxlbis9MjtlbHNlIGlmKHU8PTY1NTM1KWxlbis9MztlbHNlIGxlbis9NH1yZXR1cm4gbGVufWZ1bmN0aW9uIGFsbG9jYXRlVVRGOChzdHIpe3ZhciBzaXplPWxlbmd0aEJ5dGVzVVRGOChzdHIpKzE7dmFyIHJldD1fbWFsbG9jKHNpemUpO2lmKHJldClzdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUDgscmV0LHNpemUpO3JldHVybiByZXR9ZnVuY3Rpb24gd3JpdGVBcnJheVRvTWVtb3J5KGFycmF5LGJ1ZmZlcil7SEVBUDguc2V0KGFycmF5LGJ1ZmZlcil9ZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0cixidWZmZXIsZG9udEFkZE51bGwpe2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe0hFQVA4W2J1ZmZlcisrPj4wXT1zdHIuY2hhckNvZGVBdChpKX1pZighZG9udEFkZE51bGwpSEVBUDhbYnVmZmVyPj4wXT0wfWZ1bmN0aW9uIGFsaWduVXAoeCxtdWx0aXBsZSl7aWYoeCVtdWx0aXBsZT4wKXt4Kz1tdWx0aXBsZS14JW11bHRpcGxlfXJldHVybiB4fXZhciBidWZmZXIsSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyhidWYpe2J1ZmZlcj1idWY7TW9kdWxlW1wiSEVBUDhcIl09SEVBUDg9bmV3IEludDhBcnJheShidWYpO01vZHVsZVtcIkhFQVAxNlwiXT1IRUFQMTY9bmV3IEludDE2QXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQMzJcIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUFU4XCJdPUhFQVBVOD1uZXcgVWludDhBcnJheShidWYpO01vZHVsZVtcIkhFQVBVMTZcIl09SEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQVTMyXCJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUEYzMlwiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQRjY0XCJdPUhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShidWYpfXZhciBJTklUSUFMX01FTU9SWT1Nb2R1bGVbXCJJTklUSUFMX01FTU9SWVwiXXx8MTY3NzcyMTY7dmFyIHdhc21UYWJsZTt2YXIgX19BVFBSRVJVTl9fPVtdO3ZhciBfX0FUSU5JVF9fPVtdO3ZhciBfX0FURVhJVF9fPVtdO3ZhciBfX0FUUE9TVFJVTl9fPVtdO3ZhciBydW50aW1lSW5pdGlhbGl6ZWQ9ZmFsc2U7ZnVuY3Rpb24gcHJlUnVuKCl7aWYoTW9kdWxlW1wicHJlUnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicHJlUnVuXCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlUnVuXCJdPVtNb2R1bGVbXCJwcmVSdW5cIl1dO3doaWxlKE1vZHVsZVtcInByZVJ1blwiXS5sZW5ndGgpe2FkZE9uUHJlUnVuKE1vZHVsZVtcInByZVJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKX1mdW5jdGlvbiBpbml0UnVudGltZSgpe3J1bnRpbWVJbml0aWFsaXplZD10cnVlO2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pfWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGVbXCJwb3N0UnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInBvc3RSdW5cIl09W01vZHVsZVtcInBvc3RSdW5cIl1dO3doaWxlKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyl9ZnVuY3Rpb24gYWRkT25QcmVSdW4oY2Ipe19fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKX1mdW5jdGlvbiBhZGRPbkluaXQoY2Ipe19fQVRJTklUX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKXtfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpfXZhciBydW5EZXBlbmRlbmNpZXM9MDt2YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbDt2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7ZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihydW5EZXBlbmRlbmN5V2F0Y2hlciE9PW51bGwpe2NsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO3J1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGx9aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCl9fX1Nb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl09e307TW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdPXt9O2Z1bmN0aW9uIGFib3J0KHdoYXQpe2lmKE1vZHVsZVtcIm9uQWJvcnRcIl0pe01vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCl9d2hhdCs9XCJcIjtlcnIod2hhdCk7QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPTE7d2hhdD1cImFib3J0KFwiK3doYXQrXCIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLlwiO3ZhciBlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKXtyZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KX1mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKX12YXIgd2FzbUJpbmFyeUZpbGU9XCJvcnQtd2FzbS53YXNtXCI7aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPWxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpfWZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKXt0cnl7aWYoZmlsZT09d2FzbUJpbmFyeUZpbGUmJndhc21CaW5hcnkpe3JldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KX1pZihyZWFkQmluYXJ5KXtyZXR1cm4gcmVhZEJpbmFyeShmaWxlKX1lbHNle3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifX1jYXRjaChlcnIpe2Fib3J0KGVycil9fWZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKXtpZighd2FzbUJpbmFyeSYmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKSl7aWYodHlwZW9mIGZldGNoPT09XCJmdW5jdGlvblwiJiYhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSl7cmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtpZighcmVzcG9uc2VbXCJva1wiXSl7dGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK3dhc21CaW5hcnlGaWxlK1wiJ1wifXJldHVybiByZXNwb25zZVtcImFycmF5QnVmZmVyXCJdKCl9KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpfSl9ZWxzZXtpZihyZWFkQXN5bmMpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7cmVhZEFzeW5jKHdhc21CaW5hcnlGaWxlLGZ1bmN0aW9uKHJlc3BvbnNlKXtyZXNvbHZlKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSl9LHJlamVjdCl9KX19fXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSl9KX1mdW5jdGlvbiBjcmVhdGVXYXNtKCl7dmFyIGluZm89e1wiYVwiOmFzbUxpYnJhcnlBcmd9O2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSxtb2R1bGUpe3ZhciBleHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7TW9kdWxlW1wiYXNtXCJdPWV4cG9ydHM7d2FzbU1lbW9yeT1Nb2R1bGVbXCJhc21cIl1bXCJ4YVwiXTt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcik7d2FzbVRhYmxlPU1vZHVsZVtcImFzbVwiXVtcImJiXCJdO2FkZE9uSW5pdChNb2R1bGVbXCJhc21cIl1bXCJ5YVwiXSk7cmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIil9YWRkUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KXtyZWNlaXZlSW5zdGFuY2UocmVzdWx0W1wiaW5zdGFuY2VcIl0pfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKCkudGhlbihmdW5jdGlvbihiaW5hcnkpe3ZhciByZXN1bHQ9V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LGluZm8pO3JldHVybiByZXN1bHR9KS50aGVuKHJlY2VpdmVyLGZ1bmN0aW9uKHJlYXNvbil7ZXJyKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrcmVhc29uKTthYm9ydChyZWFzb24pfSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYygpe2lmKCF3YXNtQmluYXJ5JiZ0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmc9PT1cImZ1bmN0aW9uXCImJiFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpJiYhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSYmdHlwZW9mIGZldGNoPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmV0Y2god2FzbUJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe3ZhciByZXN1bHQ9V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsaW5mbyk7cmV0dXJuIHJlc3VsdC50aGVuKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0LGZ1bmN0aW9uKHJlYXNvbil7ZXJyKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3JlYXNvbik7ZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpfSl9KX1lbHNle3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KX19aWYoTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKXt0cnl7dmFyIGV4cG9ydHM9TW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKGluZm8scmVjZWl2ZUluc3RhbmNlKTtyZXR1cm4gZXhwb3J0c31jYXRjaChlKXtlcnIoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitlKTtyZXR1cm4gZmFsc2V9fWluc3RhbnRpYXRlQXN5bmMoKS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO3JldHVybnt9fWZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcyl7d2hpbGUoY2FsbGJhY2tzLmxlbmd0aD4wKXt2YXIgY2FsbGJhY2s9Y2FsbGJhY2tzLnNoaWZ0KCk7aWYodHlwZW9mIGNhbGxiYWNrPT1cImZ1bmN0aW9uXCIpe2NhbGxiYWNrKE1vZHVsZSk7Y29udGludWV9dmFyIGZ1bmM9Y2FsbGJhY2suZnVuYztpZih0eXBlb2YgZnVuYz09PVwibnVtYmVyXCIpe2lmKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZCl7d2FzbVRhYmxlLmdldChmdW5jKSgpfWVsc2V7d2FzbVRhYmxlLmdldChmdW5jKShjYWxsYmFjay5hcmcpfX1lbHNle2Z1bmMoY2FsbGJhY2suYXJnPT09dW5kZWZpbmVkP251bGw6Y2FsbGJhY2suYXJnKX19fXZhciBFeGNlcHRpb25JbmZvQXR0cnM9e0RFU1RSVUNUT1JfT0ZGU0VUOjAsUkVGQ09VTlRfT0ZGU0VUOjQsVFlQRV9PRkZTRVQ6OCxDQVVHSFRfT0ZGU0VUOjEyLFJFVEhST1dOX09GRlNFVDoxMyxTSVpFOjE2fTtmdW5jdGlvbiBfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uKHNpemUpe3JldHVybiBfbWFsbG9jKHNpemUrRXhjZXB0aW9uSW5mb0F0dHJzLlNJWkUpK0V4Y2VwdGlvbkluZm9BdHRycy5TSVpFfWZ1bmN0aW9uIF9hdGV4aXQoZnVuYyxhcmcpe19fQVRFWElUX18udW5zaGlmdCh7ZnVuYzpmdW5jLGFyZzphcmd9KX1mdW5jdGlvbiBfX19jeGFfYXRleGl0KGEwLGExKXtyZXR1cm4gX2F0ZXhpdChhMCxhMSl9ZnVuY3Rpb24gX19fY3hhX3RocmVhZF9hdGV4aXQoYTAsYTEpe3JldHVybiBfYXRleGl0KGEwLGExKX1mdW5jdGlvbiBFeGNlcHRpb25JbmZvKGV4Y1B0cil7dGhpcy5leGNQdHI9ZXhjUHRyO3RoaXMucHRyPWV4Y1B0ci1FeGNlcHRpb25JbmZvQXR0cnMuU0laRTt0aGlzLnNldF90eXBlPWZ1bmN0aW9uKHR5cGUpe0hFQVAzMlt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuVFlQRV9PRkZTRVQ+PjJdPXR5cGV9O3RoaXMuZ2V0X3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUDMyW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5UWVBFX09GRlNFVD4+Ml19O3RoaXMuc2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oZGVzdHJ1Y3Rvcil7SEVBUDMyW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5ERVNUUlVDVE9SX09GRlNFVD4+Ml09ZGVzdHJ1Y3Rvcn07dGhpcy5nZXRfZGVzdHJ1Y3Rvcj1mdW5jdGlvbigpe3JldHVybiBIRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLkRFU1RSVUNUT1JfT0ZGU0VUPj4yXX07dGhpcy5zZXRfcmVmY291bnQ9ZnVuY3Rpb24ocmVmY291bnQpe0hFQVAzMlt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVGQ09VTlRfT0ZGU0VUPj4yXT1yZWZjb3VudH07dGhpcy5zZXRfY2F1Z2h0PWZ1bmN0aW9uKGNhdWdodCl7Y2F1Z2h0PWNhdWdodD8xOjA7SEVBUDhbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLkNBVUdIVF9PRkZTRVQ+PjBdPWNhdWdodH07dGhpcy5nZXRfY2F1Z2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5DQVVHSFRfT0ZGU0VUPj4wXSE9MH07dGhpcy5zZXRfcmV0aHJvd249ZnVuY3Rpb24ocmV0aHJvd24pe3JldGhyb3duPXJldGhyb3duPzE6MDtIRUFQOFt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVUSFJPV05fT0ZGU0VUPj4wXT1yZXRocm93bn07dGhpcy5nZXRfcmV0aHJvd249ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUDhbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFVEhST1dOX09GRlNFVD4+MF0hPTB9O3RoaXMuaW5pdD1mdW5jdGlvbih0eXBlLGRlc3RydWN0b3Ipe3RoaXMuc2V0X3R5cGUodHlwZSk7dGhpcy5zZXRfZGVzdHJ1Y3RvcihkZXN0cnVjdG9yKTt0aGlzLnNldF9yZWZjb3VudCgwKTt0aGlzLnNldF9jYXVnaHQoZmFsc2UpO3RoaXMuc2V0X3JldGhyb3duKGZhbHNlKX07dGhpcy5hZGRfcmVmPWZ1bmN0aW9uKCl7dmFyIHZhbHVlPUhFQVAzMlt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVGQ09VTlRfT0ZGU0VUPj4yXTtIRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+Ml09dmFsdWUrMX07dGhpcy5yZWxlYXNlX3JlZj1mdW5jdGlvbigpe3ZhciBwcmV2PUhFQVAzMlt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVGQ09VTlRfT0ZGU0VUPj4yXTtIRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+Ml09cHJldi0xO3JldHVybiBwcmV2PT09MX19dmFyIGV4Y2VwdGlvbkxhc3Q9MDt2YXIgdW5jYXVnaHRFeGNlcHRpb25Db3VudD0wO2Z1bmN0aW9uIF9fX2N4YV90aHJvdyhwdHIsdHlwZSxkZXN0cnVjdG9yKXt2YXIgaW5mbz1uZXcgRXhjZXB0aW9uSW5mbyhwdHIpO2luZm8uaW5pdCh0eXBlLGRlc3RydWN0b3IpO2V4Y2VwdGlvbkxhc3Q9cHRyO3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQrKzt0aHJvdyBwdHJ9dmFyIFNZU0NBTExTPXttYXBwaW5nczp7fSxidWZmZXJzOltudWxsLFtdLFtdXSxwcmludENoYXI6ZnVuY3Rpb24oc3RyZWFtLGN1cnIpe3ZhciBidWZmZXI9U1lTQ0FMTFMuYnVmZmVyc1tzdHJlYW1dO2lmKGN1cnI9PT0wfHxjdXJyPT09MTApeyhzdHJlYW09PT0xP291dDplcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwwKSk7YnVmZmVyLmxlbmd0aD0wfWVsc2V7YnVmZmVyLnB1c2goY3Vycil9fSx2YXJhcmdzOnVuZGVmaW5lZCxnZXQ6ZnVuY3Rpb24oKXtTWVNDQUxMUy52YXJhcmdzKz00O3ZhciByZXQ9SEVBUDMyW1NZU0NBTExTLnZhcmFyZ3MtND4+Ml07cmV0dXJuIHJldH0sZ2V0U3RyOmZ1bmN0aW9uKHB0cil7dmFyIHJldD1VVEY4VG9TdHJpbmcocHRyKTtyZXR1cm4gcmV0fSxnZXQ2NDpmdW5jdGlvbihsb3csaGlnaCl7cmV0dXJuIGxvd319O2Z1bmN0aW9uIF9fX3N5c19hY2Nlc3MocGF0aCxhbW9kZSl7cGF0aD1TWVNDQUxMUy5nZXRTdHIocGF0aCk7cmV0dXJuIFNZU0NBTExTLmRvQWNjZXNzKHBhdGgsYW1vZGUpfWZ1bmN0aW9uIHNldEVyck5vKHZhbHVlKXtIRUFQMzJbX19fZXJybm9fbG9jYXRpb24oKT4+Ml09dmFsdWU7cmV0dXJuIHZhbHVlfWZ1bmN0aW9uIF9fX3N5c19mY250bDY0KGZkLGNtZCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7cmV0dXJuIDB9ZnVuY3Rpb24gX19fc3lzX2ZzdGF0NjQoZmQsYnVmKXt9ZnVuY3Rpb24gX19fc3lzX2dldGRlbnRzNjQoZmQsZGlycCxjb3VudCl7fWZ1bmN0aW9uIF9fX3N5c19nZXRwaWQoKXtyZXR1cm4gNDJ9ZnVuY3Rpb24gX19fc3lzX2lvY3RsKGZkLG9wLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJncztyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNfbHN0YXQ2NChwYXRoLGJ1Zil7fWZ1bmN0aW9uIF9fX3N5c19ta2RpcihwYXRoLG1vZGUpe3BhdGg9U1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO3JldHVybiBTWVNDQUxMUy5kb01rZGlyKHBhdGgsbW9kZSl9ZnVuY3Rpb24gc3lzY2FsbE1tYXAyKGFkZHIsbGVuLHByb3QsZmxhZ3MsZmQsb2ZmKXtvZmY8PD0xMjt2YXIgcHRyO3ZhciBhbGxvY2F0ZWQ9ZmFsc2U7aWYoKGZsYWdzJjE2KSE9PTAmJmFkZHIlNjU1MzYhPT0wKXtyZXR1cm4tMjh9aWYoKGZsYWdzJjMyKSE9PTApe3B0cj1fbWVtYWxpZ24oNjU1MzYsbGVuKTtpZighcHRyKXJldHVybi00ODtfbWVtc2V0KHB0ciwwLGxlbik7YWxsb2NhdGVkPXRydWV9ZWxzZXtyZXR1cm4tNTJ9U1lTQ0FMTFMubWFwcGluZ3NbcHRyXT17bWFsbG9jOnB0cixsZW46bGVuLGFsbG9jYXRlZDphbGxvY2F0ZWQsZmQ6ZmQscHJvdDpwcm90LGZsYWdzOmZsYWdzLG9mZnNldDpvZmZ9O3JldHVybiBwdHJ9ZnVuY3Rpb24gX19fc3lzX21tYXAyKGFkZHIsbGVuLHByb3QsZmxhZ3MsZmQsb2ZmKXtyZXR1cm4gc3lzY2FsbE1tYXAyKGFkZHIsbGVuLHByb3QsZmxhZ3MsZmQsb2ZmKX1mdW5jdGlvbiBzeXNjYWxsTXVubWFwKGFkZHIsbGVuKXtpZigoYWRkcnwwKT09PS0xfHxsZW49PT0wKXtyZXR1cm4tMjh9dmFyIGluZm89U1lTQ0FMTFMubWFwcGluZ3NbYWRkcl07aWYoIWluZm8pcmV0dXJuIDA7aWYobGVuPT09aW5mby5sZW4pe1NZU0NBTExTLm1hcHBpbmdzW2FkZHJdPW51bGw7aWYoaW5mby5hbGxvY2F0ZWQpe19mcmVlKGluZm8ubWFsbG9jKX19cmV0dXJuIDB9ZnVuY3Rpb24gX19fc3lzX211bm1hcChhZGRyLGxlbil7cmV0dXJuIHN5c2NhbGxNdW5tYXAoYWRkcixsZW4pfWZ1bmN0aW9uIF9fX3N5c19vcGVuKHBhdGgsZmxhZ3MsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzfWZ1bmN0aW9uIF9fX3N5c19yZWFkbGluayhwYXRoLGJ1ZixidWZzaXplKXtwYXRoPVNZU0NBTExTLmdldFN0cihwYXRoKTtyZXR1cm4gU1lTQ0FMTFMuZG9SZWFkbGluayhwYXRoLGJ1ZixidWZzaXplKX1mdW5jdGlvbiBfX19zeXNfcm1kaXIocGF0aCl7fWZ1bmN0aW9uIF9fX3N5c19zdGF0NjQocGF0aCxidWYpe31mdW5jdGlvbiBfX19zeXNfdW5saW5rKHBhdGgpe31mdW5jdGlvbiBfYWJvcnQoKXthYm9ydCgpfXZhciBfZW1zY3JpcHRlbl9nZXRfbm93O2lmKEVOVklST05NRU5UX0lTX05PREUpe19lbXNjcmlwdGVuX2dldF9ub3c9ZnVuY3Rpb24oKXt2YXIgdD1wcm9jZXNzW1wiaHJ0aW1lXCJdKCk7cmV0dXJuIHRbMF0qMWUzK3RbMV0vMWU2fX1lbHNlIGlmKHR5cGVvZiBkYXRlTm93IT09XCJ1bmRlZmluZWRcIil7X2Vtc2NyaXB0ZW5fZ2V0X25vdz1kYXRlTm93fWVsc2UgX2Vtc2NyaXB0ZW5fZ2V0X25vdz1mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX07dmFyIF9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljPXRydWU7ZnVuY3Rpb24gX2Nsb2NrX2dldHRpbWUoY2xrX2lkLHRwKXt2YXIgbm93O2lmKGNsa19pZD09PTApe25vdz1EYXRlLm5vdygpfWVsc2UgaWYoKGNsa19pZD09PTF8fGNsa19pZD09PTQpJiZfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyl7bm93PV9lbXNjcmlwdGVuX2dldF9ub3coKX1lbHNle3NldEVyck5vKDI4KTtyZXR1cm4tMX1IRUFQMzJbdHA+PjJdPW5vdy8xZTN8MDtIRUFQMzJbdHArND4+Ml09bm93JTFlMyoxZTMqMWUzfDA7cmV0dXJuIDB9ZnVuY3Rpb24gX2RpZmZ0aW1lKHRpbWUxLHRpbWUwKXtyZXR1cm4gdGltZTEtdGltZTB9ZnVuY3Rpb24gX2RsY2xvc2UoaGFuZGxlKXthYm9ydChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIHRvIHVzZSBFbXNjcmlwdGVuJ3MgbGlua2luZyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX1mdW5jdGlvbiBfZGxlcnJvcigpe2Fib3J0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgdG8gdXNlIEVtc2NyaXB0ZW4ncyBsaW5raW5nIHN1cHBvcnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfWZ1bmN0aW9uIF9kbG9wZW4oZmlsZW5hbWUsZmxhZyl7YWJvcnQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCB0byB1c2UgRW1zY3JpcHRlbidzIGxpbmtpbmcgc3VwcG9ydCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9ZnVuY3Rpb24gX2Rsc3ltKGhhbmRsZSxzeW1ib2wpe2Fib3J0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgdG8gdXNlIEVtc2NyaXB0ZW4ncyBsaW5raW5nIHN1cHBvcnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpe3JldHVybiAyMTQ3NDgzNjQ4fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCxzcmMsbnVtKXtIRUFQVTguY29weVdpdGhpbihkZXN0LHNyYyxzcmMrbnVtKX1mdW5jdGlvbiBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKHNpemUpe3RyeXt3YXNtTWVtb3J5Lmdyb3coc2l6ZS1idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KTt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcik7cmV0dXJuIDF9Y2F0Y2goZSl7fX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcChyZXF1ZXN0ZWRTaXplKXt2YXIgb2xkU2l6ZT1IRUFQVTgubGVuZ3RoO3JlcXVlc3RlZFNpemU9cmVxdWVzdGVkU2l6ZT4+PjA7dmFyIG1heEhlYXBTaXplPTIxNDc0ODM2NDg7aWYocmVxdWVzdGVkU2l6ZT5tYXhIZWFwU2l6ZSl7cmV0dXJuIGZhbHNlfWZvcih2YXIgY3V0RG93bj0xO2N1dERvd248PTQ7Y3V0RG93bio9Mil7dmFyIG92ZXJHcm93bkhlYXBTaXplPW9sZFNpemUqKDErLjIvY3V0RG93bik7b3Zlckdyb3duSGVhcFNpemU9TWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUscmVxdWVzdGVkU2l6ZSsxMDA2NjMyOTYpO3ZhciBuZXdTaXplPU1hdGgubWluKG1heEhlYXBTaXplLGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSxvdmVyR3Jvd25IZWFwU2l6ZSksNjU1MzYpKTt2YXIgcmVwbGFjZW1lbnQ9ZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtpZihyZXBsYWNlbWVudCl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX1mdW5jdGlvbiBfZW1zY3JpcHRlbl90aHJlYWRfc2xlZXAobXNlY3Mpe3ZhciBzdGFydD1fZW1zY3JpcHRlbl9nZXRfbm93KCk7d2hpbGUoX2Vtc2NyaXB0ZW5fZ2V0X25vdygpLXN0YXJ0PG1zZWNzKXt9fXZhciBXZWJOTj17aW5pdE1hbmFnZXJzOmZ1bmN0aW9uKCl7aWYodGhpc1tcIm1nckNvbnRleHRcIl0pcmV0dXJuO2Z1bmN0aW9uIG1ha2VNYW5hZ2VyKCl7cmV0dXJue29iamVjdHM6e30sbmV4dElkOjEsY3JlYXRlOmZ1bmN0aW9uKG9iamVjdCx3cmFwcGVyKXt3cmFwcGVyPXdyYXBwZXJ8fHt9O3ZhciBpZD10aGlzLm5leHRJZCsrO3dyYXBwZXIucmVmY291bnQ9MTt3cmFwcGVyLm9iamVjdD1vYmplY3Q7dGhpcy5vYmplY3RzW2lkXT13cmFwcGVyO3JldHVybiBpZH0sZ2V0OmZ1bmN0aW9uKGlkKXtpZihpZD09PTApcmV0dXJuIHVuZGVmaW5lZDt2YXIgbz10aGlzLm9iamVjdHNbaWRdO3JldHVybiBvLm9iamVjdH0scmVmZXJlbmNlOmZ1bmN0aW9uKGlkKXt2YXIgbz10aGlzLm9iamVjdHNbaWRdO28ucmVmY291bnQrK30scmVsZWFzZTpmdW5jdGlvbihpZCl7dmFyIG89dGhpcy5vYmplY3RzW2lkXTtvLnJlZmNvdW50LS07aWYoby5yZWZjb3VudDw9MCl7ZGVsZXRlIHRoaXMub2JqZWN0c1tpZF19fX19dGhpc1tcIm1nckNvbnRleHRcIl09dGhpc1tcIm1nckNvbnRleHRcIl18fG1ha2VNYW5hZ2VyKCk7dGhpcy5tZ3JHcmFwaD10aGlzLm1nckdyYXBofHxtYWtlTWFuYWdlcigpO3RoaXMubWdyR3JhcGhCdWlsZGVyPXRoaXMubWdyR3JhcGhCdWlsZGVyfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyTmFtZWRJbnB1dHM9dGhpcy5tZ3JOYW1lZElucHV0c3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkT3BlcmFuZHM9dGhpcy5tZ3JOYW1lZE9wZXJhbmRzfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyTmFtZWRPdXRwdXRzPXRoaXMubWdyTmFtZWRPdXRwdXRzfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyTmFtZWRSZXN1bHRzPXRoaXMubWdyTmFtZWRSZXN1bHRzfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyT3BlcmFuZD10aGlzLm1nck9wZXJhbmR8fG1ha2VNYW5hZ2VyKCk7dGhpcy5tZ3JSZXN1bHQ9dGhpcy5tZ3JSZXN1bHR8fG1ha2VNYW5hZ2VyKCl9LEF1dG9QYWQ6W1wiZXhwbGljaXRcIixcInNhbWUtdXBwZXJcIixcInNhbWUtbG93ZXJcIl0sQnVpbGRHcmFwaFN0YXR1czpbXCJzdWNjZXNzXCIsXCJlcnJvclwiLFwiY29udGV4dC1sb3N0XCIsXCJ1bmtub3duXCJdLENvbXB1dGVHcmFwaFN0YXR1czpbXCJzdWNjZXNzXCIsXCJlcnJvclwiLFwiY29udGV4dC1sb3N0XCIsXCJ1bmtub3duXCJdLEVycm9yRmlsdGVyOltcIm5vbmVcIixcInZhbGlkYXRpb25cIixcIm91dC1vZi1tZW1vcnlcIl0sRXJyb3JUeXBlOltcIm5vLWVycm9yXCIsXCJ2YWxpZGF0aW9uXCIsXCJvdXQtb2YtbWVtb3J5XCIsXCJ1bmtub3duXCIsXCJkZXZpY2UtbG9zdFwiXSxGaWx0ZXJPcGVyYW5kTGF5b3V0OltcIm9paHdcIixcImh3aW9cIixcIm9od2lcIixcImlod29cIl0sRnVzZWRBY3RpdmF0aW9uOltcIm5vbmVcIixcInJlbHVcIl0sSW5wdXRPcGVyYW5kTGF5b3V0OltcIm5jaHdcIixcIm5od2NcIl0sT3BlcmFuZFR5cGU6W1wiZmxvYXQzMlwiLFwiZmxvYXQxNlwiLFwiaW50MzJcIixcInVpbnQzMlwiLFwiaW50OFwiLFwidWludDhcIl0sUG93ZXJQcmVmZXJlbmNlOltcImRlZmF1bHRcIixcImhpZ2hfcGVyZm9ybWFuY2VcIixcImxvd19wb3dlclwiXSxtYWtlSTMyQXJyYXk6ZnVuY3Rpb24oY291bnQsYXJyYXlQdHIpe2lmKGNvdW50PT09MHx8YXJyYXlQdHI9PT0wKXtyZXR1cm4gdW5kZWZpbmVkfXZhciBhcnJheT1bXTtmb3IodmFyIGk9MDtpPGNvdW50OysraSxhcnJheVB0cis9NCl7YXJyYXkucHVzaChIRUFQMzJbYXJyYXlQdHI+PjJdKX1yZXR1cm4gYXJyYXl9LG1ha2VBcnJheUJ1ZmZlclZpZXc6ZnVuY3Rpb24ob2Zmc2V0LGJ5dGVTaXplLHR5cGU9XCJmbG9hdDMyXCIpe2Fzc2VydCh0eXBlPT09XCJmbG9hdDMyXCIpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KEhFQVBVOC5idWZmZXIsb2Zmc2V0LGJ5dGVTaXplL0Zsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCl9LG1ha2VDbGFtcE9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJtaW5WYWx1ZVwiOnRoaXMubWdyT3BlcmFuZC5nZXQoSEVBUDMyW3B0cj4+Ml0pLFwibWF4VmFsdWVcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEhFQVAzMltwdHIrND4+Ml0pfX0sbWFrZUJhdGNoTm9ybU9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJzY2FsZVwiOnRoaXMubWdyT3BlcmFuZC5nZXQoSEVBUDMyW3B0cj4+Ml0pLFwiYmlhc1wiOnRoaXMubWdyT3BlcmFuZC5nZXQoSEVBUDMyW3B0cis0Pj4yXSksXCJheGlzXCI6SEVBUDMyW3B0cis4Pj4yXSxcImVwc2lsb25cIjpIRUFQRjMyW3B0cisxMj4+Ml0sXCJhY3RpdmF0aW9uXCI6dGhpcy5GdXNlZEFjdGl2YXRpb25bSEVBUDMyW3B0cisxNj4+Ml1dfX0sbWFrZUdlbW1PcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wiY1wiOnRoaXMubWdyT3BlcmFuZC5nZXQoSEVBUDMyW3B0cj4+Ml0pLFwiYWxwaGFcIjpIRUFQRjMyW3B0cis0Pj4yXSxcImJldGFcIjpIRUFQRjMyW3B0cis4Pj4yXSxcImFUcmFuc3Bvc2VcIjpIRUFQOFtwdHIrMTI+PjBdIT09MCxcImJUcmFuc3Bvc2VcIjpIRUFQOFtwdHIrMTM+PjBdIT09MH19LG1ha2VPcGVyYW5kRGVzY3JpcHRvcjpmdW5jdGlvbihwdHIpe3JldHVybntcInR5cGVcIjp0aGlzLk9wZXJhbmRUeXBlW0hFQVBVMzJbcHRyPj4yXV0sXCJkaW1lbnNpb25zXCI6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrOD4+Ml0sSEVBUDMyW3B0cis0Pj4yXSl9fSxtYWtlQ29udjJkT3B0aW9uczpmdW5jdGlvbihwdHIpe3JldHVybntcInBhZGRpbmdcIjp0aGlzLkF1dG9QYWRbSEVBUDMyW3B0cisyND4+Ml1dPT09XCJleHBsaWNpdFwiP3RoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyPj4yXSxIRUFQMzJbcHRyKzQ+PjJdKTp1bmRlZmluZWQsXCJzdHJpZGVzXCI6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrOD4+Ml0sSEVBUDMyW3B0cisxMj4+Ml0pLFwiZGlsYXRpb25zXCI6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrMTY+PjJdLEhFQVAzMltwdHIrMjA+PjJdKSxcImF1dG9QYWRcIjp0aGlzLkF1dG9QYWRbSEVBUDMyW3B0cisyND4+Ml1dLFwiZ3JvdXBzXCI6SEVBUDMyW3B0cisyOD4+Ml0sXCJpbnB1dExheW91dFwiOnRoaXMuSW5wdXRPcGVyYW5kTGF5b3V0W0hFQVAzMltwdHIrMzI+PjJdXSxcImZpbHRlckxheW91dFwiOnRoaXMuRmlsdGVyT3BlcmFuZExheW91dFtIRUFQMzJbcHRyKzM2Pj4yXV0sXCJiaWFzXCI6dGhpcy5tZ3JPcGVyYW5kLmdldChIRUFQMzJbcHRyKzQwPj4yXSksXCJhY3RpdmF0aW9uXCI6dGhpcy5GdXNlZEFjdGl2YXRpb25bSEVBUDMyW3B0cis0ND4+Ml1dfX0sbWFrZVBvb2wyZE9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJ3aW5kb3dEaW1lbnNpb25zXCI6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHI+PjJdLEhFQVAzMltwdHIrND4+Ml0pLFwicGFkZGluZ1wiOnRoaXMuQXV0b1BhZFtIRUFQMzJbcHRyKzMyPj4yXV09PT1cImV4cGxpY2l0XCI/dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrOD4+Ml0sSEVBUDMyW3B0cisxMj4+Ml0pOnVuZGVmaW5lZCxcInN0cmlkZXNcIjp0aGlzLm1ha2VJMzJBcnJheShIRUFQVTMyW3B0cisxNj4+Ml0sSEVBUDMyW3B0cisyMD4+Ml0pLFwiZGlsYXRpb25zXCI6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrMjQ+PjJdLEhFQVAzMltwdHIrMjg+PjJdKSxcImF1dG9QYWRcIjp0aGlzLkF1dG9QYWRbSEVBUDMyW3B0ciszMj4+Ml1dLFwiaW5wdXRMYXlvdXRcIjp0aGlzLklucHV0T3BlcmFuZExheW91dFtIRUFQMzJbcHRyKzM2Pj4yXV19fSxtYWtlSW5wdXQ6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJkYXRhXCI6dGhpcy5tYWtlQXJyYXlCdWZmZXJWaWV3KEhFQVAzMltwdHI+PjJdLEhFQVBVMzJbcHRyKzQ+PjJdKSxcImRpbWVuc2lvbnNcIjpIRUFQMzJbcHRyKzg+PjJdPT09MD91bmRlZmluZWQ6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrMTI+PjJdLEhFQVAzMltwdHIrOD4+Ml0pfX0sbWFrZU91dHB1dDpmdW5jdGlvbihwdHIpe3JldHVybntcImRhdGFcIjpIRUFQMzJbcHRyPj4yXT09PTA/dW5kZWZpbmVkOnRoaXMubWFrZUFycmF5QnVmZmVyVmlldyhIRUFQMzJbcHRyPj4yXSxIRUFQVTMyW3B0cis0Pj4yXSksXCJkaW1lbnNpb25zXCI6SEVBUDMyW3B0cis4Pj4yXT09PTA/dW5kZWZpbmVkOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzEyPj4yXSxIRUFQMzJbcHRyKzg+PjJdKX19fTtmdW5jdGlvbiBfZW1zY3JpcHRlbl93ZWJubl9jcmVhdGVfY29udGV4dCgpe3ZhciBjb250ZXh0PW5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7cmV0dXJuIFdlYk5OLm1nckNvbnRleHQuY3JlYXRlKGNvbnRleHQpfXZhciBFTlY9e307ZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKXtyZXR1cm4gdGhpc1Byb2dyYW18fFwiLi90aGlzLnByb2dyYW1cIn1mdW5jdGlvbiBnZXRFbnZTdHJpbmdzKCl7aWYoIWdldEVudlN0cmluZ3Muc3RyaW5ncyl7dmFyIGxhbmc9KHR5cGVvZiBuYXZpZ2F0b3I9PT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIjt2YXIgZW52PXtcIlVTRVJcIjpcIndlYl91c2VyXCIsXCJMT0dOQU1FXCI6XCJ3ZWJfdXNlclwiLFwiUEFUSFwiOlwiL1wiLFwiUFdEXCI6XCIvXCIsXCJIT01FXCI6XCIvaG9tZS93ZWJfdXNlclwiLFwiTEFOR1wiOmxhbmcsXCJfXCI6Z2V0RXhlY3V0YWJsZU5hbWUoKX07Zm9yKHZhciB4IGluIEVOVil7ZW52W3hdPUVOVlt4XX12YXIgc3RyaW5ncz1bXTtmb3IodmFyIHggaW4gZW52KXtzdHJpbmdzLnB1c2goeCtcIj1cIitlbnZbeF0pfWdldEVudlN0cmluZ3Muc3RyaW5ncz1zdHJpbmdzfXJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3N9ZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbixlbnZpcm9uX2J1Zil7dmFyIGJ1ZlNpemU9MDtnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcsaSl7dmFyIHB0cj1lbnZpcm9uX2J1ZitidWZTaXplO0hFQVAzMltfX2Vudmlyb24raSo0Pj4yXT1wdHI7d3JpdGVBc2NpaVRvTWVtb3J5KHN0cmluZyxwdHIpO2J1ZlNpemUrPXN0cmluZy5sZW5ndGgrMX0pO3JldHVybiAwfWZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCxwZW52aXJvbl9idWZfc2l6ZSl7dmFyIHN0cmluZ3M9Z2V0RW52U3RyaW5ncygpO0hFQVAzMltwZW52aXJvbl9jb3VudD4+Ml09c3RyaW5ncy5sZW5ndGg7dmFyIGJ1ZlNpemU9MDtzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nKXtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtIRUFQMzJbcGVudmlyb25fYnVmX3NpemU+PjJdPWJ1ZlNpemU7cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX2Nsb3NlKGZkKXtyZXR1cm4gMH1mdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCxwYnVmKXt2YXIgdHlwZT1mZD09MXx8ZmQ9PTI/MjphYm9ydCgpO0hFQVA4W3BidWY+PjBdPXR5cGU7cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX3JlYWQoZmQsaW92LGlvdmNudCxwbnVtKXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7dmFyIG51bT1TWVNDQUxMUy5kb1JlYWR2KHN0cmVhbSxpb3YsaW92Y250KTtIRUFQMzJbcG51bT4+Ml09bnVtO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9zZWVrKGZkLG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gsd2hlbmNlLG5ld09mZnNldCl7fWZ1bmN0aW9uIF9mZF93cml0ZShmZCxpb3YsaW92Y250LHBudW0pe3ZhciBudW09MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUDMyW2lvditpKjg+PjJdO3ZhciBsZW49SEVBUDMyW2lvdisoaSo4KzQpPj4yXTtmb3IodmFyIGo9MDtqPGxlbjtqKyspe1NZU0NBTExTLnByaW50Q2hhcihmZCxIRUFQVThbcHRyK2pdKX1udW0rPWxlbn1IRUFQMzJbcG51bT4+Ml09bnVtO3JldHVybiAwfWZ1bmN0aW9uIF9nZXR0aW1lb2ZkYXkocHRyKXt2YXIgbm93PURhdGUubm93KCk7SEVBUDMyW3B0cj4+Ml09bm93LzFlM3wwO0hFQVAzMltwdHIrND4+Ml09bm93JTFlMyoxZTN8MDtyZXR1cm4gMH1mdW5jdGlvbiBfZ210aW1lX3IodGltZSx0bVB0cil7dmFyIGRhdGU9bmV3IERhdGUoSEVBUDMyW3RpbWU+PjJdKjFlMyk7SEVBUDMyW3RtUHRyPj4yXT1kYXRlLmdldFVUQ1NlY29uZHMoKTtIRUFQMzJbdG1QdHIrND4+Ml09ZGF0ZS5nZXRVVENNaW51dGVzKCk7SEVBUDMyW3RtUHRyKzg+PjJdPWRhdGUuZ2V0VVRDSG91cnMoKTtIRUFQMzJbdG1QdHIrMTI+PjJdPWRhdGUuZ2V0VVRDRGF0ZSgpO0hFQVAzMlt0bVB0cisxNj4+Ml09ZGF0ZS5nZXRVVENNb250aCgpO0hFQVAzMlt0bVB0cisyMD4+Ml09ZGF0ZS5nZXRVVENGdWxsWWVhcigpLTE5MDA7SEVBUDMyW3RtUHRyKzI0Pj4yXT1kYXRlLmdldFVUQ0RheSgpO0hFQVAzMlt0bVB0ciszNj4+Ml09MDtIRUFQMzJbdG1QdHIrMzI+PjJdPTA7dmFyIHN0YXJ0PURhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCk7dmFyIHlkYXk9KGRhdGUuZ2V0VGltZSgpLXN0YXJ0KS8oMWUzKjYwKjYwKjI0KXwwO0hFQVAzMlt0bVB0cisyOD4+Ml09eWRheTtpZighX2dtdGltZV9yLkdNVFN0cmluZylfZ210aW1lX3IuR01UU3RyaW5nPWFsbG9jYXRlVVRGOChcIkdNVFwiKTtIRUFQMzJbdG1QdHIrNDA+PjJdPV9nbXRpbWVfci5HTVRTdHJpbmc7cmV0dXJuIHRtUHRyfWZ1bmN0aW9uIF90enNldCgpe2lmKF90enNldC5jYWxsZWQpcmV0dXJuO190enNldC5jYWxsZWQ9dHJ1ZTt2YXIgY3VycmVudFllYXI9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpO3ZhciB3aW50ZXI9bmV3IERhdGUoY3VycmVudFllYXIsMCwxKTt2YXIgc3VtbWVyPW5ldyBEYXRlKGN1cnJlbnRZZWFyLDYsMSk7dmFyIHdpbnRlck9mZnNldD13aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3VtbWVyT2Zmc2V0PXN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdGRUaW1lem9uZU9mZnNldD1NYXRoLm1heCh3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KTtIRUFQMzJbX19nZXRfdGltZXpvbmUoKT4+Ml09c3RkVGltZXpvbmVPZmZzZXQqNjA7SEVBUDMyW19fZ2V0X2RheWxpZ2h0KCk+PjJdPU51bWJlcih3aW50ZXJPZmZzZXQhPXN1bW1lck9mZnNldCk7ZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSl7dmFyIG1hdGNoPWRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKTtyZXR1cm4gbWF0Y2g/bWF0Y2hbMV06XCJHTVRcIn12YXIgd2ludGVyTmFtZT1leHRyYWN0Wm9uZSh3aW50ZXIpO3ZhciBzdW1tZXJOYW1lPWV4dHJhY3Rab25lKHN1bW1lcik7dmFyIHdpbnRlck5hbWVQdHI9YWxsb2NhdGVVVEY4KHdpbnRlck5hbWUpO3ZhciBzdW1tZXJOYW1lUHRyPWFsbG9jYXRlVVRGOChzdW1tZXJOYW1lKTtpZihzdW1tZXJPZmZzZXQ8d2ludGVyT2Zmc2V0KXtIRUFQMzJbX19nZXRfdHpuYW1lKCk+PjJdPXdpbnRlck5hbWVQdHI7SEVBUDMyW19fZ2V0X3R6bmFtZSgpKzQ+PjJdPXN1bW1lck5hbWVQdHJ9ZWxzZXtIRUFQMzJbX19nZXRfdHpuYW1lKCk+PjJdPXN1bW1lck5hbWVQdHI7SEVBUDMyW19fZ2V0X3R6bmFtZSgpKzQ+PjJdPXdpbnRlck5hbWVQdHJ9fWZ1bmN0aW9uIF9sb2NhbHRpbWVfcih0aW1lLHRtUHRyKXtfdHpzZXQoKTt2YXIgZGF0ZT1uZXcgRGF0ZShIRUFQMzJbdGltZT4+Ml0qMWUzKTtIRUFQMzJbdG1QdHI+PjJdPWRhdGUuZ2V0U2Vjb25kcygpO0hFQVAzMlt0bVB0cis0Pj4yXT1kYXRlLmdldE1pbnV0ZXMoKTtIRUFQMzJbdG1QdHIrOD4+Ml09ZGF0ZS5nZXRIb3VycygpO0hFQVAzMlt0bVB0cisxMj4+Ml09ZGF0ZS5nZXREYXRlKCk7SEVBUDMyW3RtUHRyKzE2Pj4yXT1kYXRlLmdldE1vbnRoKCk7SEVBUDMyW3RtUHRyKzIwPj4yXT1kYXRlLmdldEZ1bGxZZWFyKCktMTkwMDtIRUFQMzJbdG1QdHIrMjQ+PjJdPWRhdGUuZ2V0RGF5KCk7dmFyIHN0YXJ0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwwLDEpO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydC5nZXRUaW1lKCkpLygxZTMqNjAqNjAqMjQpfDA7SEVBUDMyW3RtUHRyKzI4Pj4yXT15ZGF5O0hFQVAzMlt0bVB0ciszNj4+Ml09LShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjApO3ZhciBzdW1tZXJPZmZzZXQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgd2ludGVyT2Zmc2V0PXN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGRzdD0oc3VtbWVyT2Zmc2V0IT13aW50ZXJPZmZzZXQmJmRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCkpfDA7SEVBUDMyW3RtUHRyKzMyPj4yXT1kc3Q7dmFyIHpvbmVQdHI9SEVBUDMyW19fZ2V0X3R6bmFtZSgpKyhkc3Q/NDowKT4+Ml07SEVBUDMyW3RtUHRyKzQwPj4yXT16b25lUHRyO3JldHVybiB0bVB0cn1mdW5jdGlvbiBfbWt0aW1lKHRtUHRyKXtfdHpzZXQoKTt2YXIgZGF0ZT1uZXcgRGF0ZShIRUFQMzJbdG1QdHIrMjA+PjJdKzE5MDAsSEVBUDMyW3RtUHRyKzE2Pj4yXSxIRUFQMzJbdG1QdHIrMTI+PjJdLEhFQVAzMlt0bVB0cis4Pj4yXSxIRUFQMzJbdG1QdHIrND4+Ml0sSEVBUDMyW3RtUHRyPj4yXSwwKTt2YXIgZHN0PUhFQVAzMlt0bVB0ciszMj4+Ml07dmFyIGd1ZXNzZWRPZmZzZXQ9ZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdGFydD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTt2YXIgc3VtbWVyT2Zmc2V0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHdpbnRlck9mZnNldD1zdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBkc3RPZmZzZXQ9TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCk7aWYoZHN0PDApe0hFQVAzMlt0bVB0ciszMj4+Ml09TnVtYmVyKHN1bW1lck9mZnNldCE9d2ludGVyT2Zmc2V0JiZkc3RPZmZzZXQ9PWd1ZXNzZWRPZmZzZXQpfWVsc2UgaWYoZHN0PjAhPShkc3RPZmZzZXQ9PWd1ZXNzZWRPZmZzZXQpKXt2YXIgbm9uRHN0T2Zmc2V0PU1hdGgubWF4KHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO3ZhciB0cnVlT2Zmc2V0PWRzdD4wP2RzdE9mZnNldDpub25Ec3RPZmZzZXQ7ZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpKyh0cnVlT2Zmc2V0LWd1ZXNzZWRPZmZzZXQpKjZlNCl9SEVBUDMyW3RtUHRyKzI0Pj4yXT1kYXRlLmdldERheSgpO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydC5nZXRUaW1lKCkpLygxZTMqNjAqNjAqMjQpfDA7SEVBUDMyW3RtUHRyKzI4Pj4yXT15ZGF5O0hFQVAzMlt0bVB0cj4+Ml09ZGF0ZS5nZXRTZWNvbmRzKCk7SEVBUDMyW3RtUHRyKzQ+PjJdPWRhdGUuZ2V0TWludXRlcygpO0hFQVAzMlt0bVB0cis4Pj4yXT1kYXRlLmdldEhvdXJzKCk7SEVBUDMyW3RtUHRyKzEyPj4yXT1kYXRlLmdldERhdGUoKTtIRUFQMzJbdG1QdHIrMTY+PjJdPWRhdGUuZ2V0TW9udGgoKTtyZXR1cm4gZGF0ZS5nZXRUaW1lKCkvMWUzfDB9ZnVuY3Rpb24gX21sQ29udGV4dFJlZmVyZW5jZShpZCl7V2ViTk4ubWdyQ29udGV4dC5yZWZlcmVuY2UoaWQpfWZ1bmN0aW9uIF9tbENvbnRleHRSZWxlYXNlKGlkKXtXZWJOTi5tZ3JDb250ZXh0LnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckFkZChidWlsZGVySWQsYUlkLGJJZCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBhPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGFJZCk7dmFyIGI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYklkKTt2YXIgYz1idWlsZGVyLmFkZChhLGIpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShjKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJBdmVyYWdlUG9vbDJkKGJ1aWxkZXJJZCxpbnB1dElkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZVBvb2wyZE9wdGlvbnMob3B0aW9uc1B0cik7dmFyIHBvb2wyZD1idWlsZGVyLmF2ZXJhZ2VQb29sMmQoaW5wdXQsb3B0aW9ucyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKHBvb2wyZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQmF0Y2hOb3JtKGJ1aWxkZXJJZCxpbnB1dElkLG1lYW5JZCx2YXJpYW5jZUlkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG1lYW49V2ViTk4ubWdyT3BlcmFuZC5nZXQobWVhbklkKTt2YXIgdmFyaWFuY2U9V2ViTk4ubWdyT3BlcmFuZC5nZXQodmFyaWFuY2VJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZUJhdGNoTm9ybU9wdGlvbnMob3B0aW9uc1B0cik7dmFyIG91dHB1dD1idWlsZGVyLmJhdGNoTm9ybWFsaXphdGlvbihpbnB1dCxtZWFuLHZhcmlhbmNlLG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckJ1aWxkU3luYyhidWlsZGVySWQsbmFtZWRPcGVyYW5kc0lkKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIG5hbWVkT3BlcmFuZHM9V2ViTk4ubWdyTmFtZWRPcGVyYW5kcy5nZXQobmFtZWRPcGVyYW5kc0lkKTt0cnl7dmFyIGdyYXBoPWJ1aWxkZXIuYnVpbGRTeW5jKG5hbWVkT3BlcmFuZHMpO3JldHVybiBXZWJOTi5tZ3JHcmFwaC5jcmVhdGUoZ3JhcGgpfWNhdGNoKGVycm9yKXtjb25zb2xlLmxvZyhcImJ1aWxkZXIuYnVpbGRTeW5jIGZhaWxlZDogXCIrZXJyb3IpO3JldHVybiAwfX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJDb25jYXQoYnVpbGRlcklkLGlucHV0c0NvdW50LGlucHV0c1B0cixheGlzKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0SWRzPVdlYk5OLm1ha2VJMzJBcnJheShpbnB1dHNDb3VudCxpbnB1dHNQdHIpO3ZhciBpbnB1dHM9W107Zm9yKHZhciBpPTA7aTxpbnB1dElkcy5sZW5ndGg7KytpKXtpbnB1dHMucHVzaChXZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkc1tpXSkpfXZhciBvdXRwdXQ9YnVpbGRlci5jb25jYXQoaW5wdXRzLGF4aXMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckNvbnN0YW50KGJ1aWxkZXJJZCxkZXNjUHRyLHZhbHVlUHRyLHNpemUpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgZGVzYz1XZWJOTi5tYWtlT3BlcmFuZERlc2NyaXB0b3IoZGVzY1B0cik7dmFyIGJ1ZmZlcj1XZWJOTi5tYWtlQXJyYXlCdWZmZXJWaWV3KHZhbHVlUHRyLHNpemUpO3ZhciBjb25zdGFudD1idWlsZGVyLmNvbnN0YW50KGRlc2MsYnVmZmVyKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoY29uc3RhbnQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckNvbnYyZChidWlsZGVySWQsaW5wdXRJZCxmaWx0ZXJJZCxvcHRpb25zUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBmaWx0ZXI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoZmlsdGVySWQpO3ZhciBvcHRpb25zPVdlYk5OLm1ha2VDb252MmRPcHRpb25zKG9wdGlvbnNQdHIpO3ZhciBjb252MmQ9YnVpbGRlci5jb252MmQoaW5wdXQsZmlsdGVyLG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShjb252MmQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckdlbW0oYnVpbGRlcklkLGFJZCxiSWQsb3B0aW9uc1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBhPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGFJZCk7dmFyIGI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYklkKTt2YXIgb3B0aW9ucz1XZWJOTi5tYWtlR2VtbU9wdGlvbnMob3B0aW9uc1B0cik7dmFyIG91dHB1dD1idWlsZGVyLmdlbW0oYSxiLG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlcklucHV0KGJ1aWxkZXJJZCxuYW1lUHRyLGRlc2NQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgbmFtZT1VVEY4VG9TdHJpbmcobmFtZVB0cik7dmFyIGRlc2M9V2ViTk4ubWFrZU9wZXJhbmREZXNjcmlwdG9yKGRlc2NQdHIpO3ZhciBpbnB1dD1idWlsZGVyLmlucHV0KG5hbWUsZGVzYyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKGlucHV0KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJNYXRtdWwoYnVpbGRlcklkLGFJZCxiSWQpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgYT1XZWJOTi5tZ3JPcGVyYW5kLmdldChhSWQpO3ZhciBiPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGJJZCk7dmFyIGM9YnVpbGRlci5tYXRtdWwoYSxiKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoYyl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyTWF4UG9vbDJkKGJ1aWxkZXJJZCxpbnB1dElkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZVBvb2wyZE9wdGlvbnMob3B0aW9uc1B0cik7dmFyIHBvb2wyZD1idWlsZGVyLm1heFBvb2wyZChpbnB1dCxvcHRpb25zKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUocG9vbDJkKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJSZWxlYXNlKGlkKXtXZWJOTi5tZ3JHcmFwaEJ1aWxkZXIucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyUmVsdShidWlsZGVySWQsaW5wdXRJZCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgb3V0cHV0PWJ1aWxkZXIucmVsdShpbnB1dCk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKG91dHB1dCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyUmVzaGFwZShidWlsZGVySWQsaW5wdXRJZCxuZXdTaGFwZVB0cixuZXdTaGFwZUNvdW50KXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBuZXdTaGFwZT1XZWJOTi5tYWtlSTMyQXJyYXkobmV3U2hhcGVDb3VudCxuZXdTaGFwZVB0cik7dmFyIG91dHB1dD1idWlsZGVyLnJlc2hhcGUoaW5wdXQsbmV3U2hhcGUpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQ29tcHV0ZVN5bmMoZ3JhcGhJZCxpbnB1dHNJZCxvdXRwdXRzSWQpe3ZhciBncmFwaD1XZWJOTi5tZ3JHcmFwaC5nZXQoZ3JhcGhJZCk7dmFyIGlucHV0cz1XZWJOTi5tZ3JOYW1lZElucHV0cy5nZXQoaW5wdXRzSWQpO3ZhciBvdXRwdXRzPVdlYk5OLm1nck5hbWVkT3V0cHV0cy5nZXQob3V0cHV0c0lkKTtyZXR1cm4gZ3JhcGguY29tcHV0ZVN5bmMoaW5wdXRzLG91dHB1dHMpfWZ1bmN0aW9uIF9tbEdyYXBoUmVmZXJlbmNlKGlkKXtXZWJOTi5tZ3JHcmFwaC5yZWZlcmVuY2UoaWQpfWZ1bmN0aW9uIF9tbEdyYXBoUmVsZWFzZShpZCl7V2ViTk4ubWdyR3JhcGgucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sTmFtZWRJbnB1dHNSZWxlYXNlKGlkKXtXZWJOTi5tZ3JOYW1lZElucHV0cy5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxOYW1lZElucHV0c1NldChuYW1lZElucHV0c0lkLG5hbWVQdHIsaW5wdXRQdHIpe3ZhciBuYW1lZElucHV0cz1XZWJOTi5tZ3JOYW1lZElucHV0cy5nZXQobmFtZWRJbnB1dHNJZCk7dmFyIG5hbWU9VVRGOFRvU3RyaW5nKG5hbWVQdHIpO3ZhciBpbnB1dD1XZWJOTi5tYWtlSW5wdXQoaW5wdXRQdHIpO25hbWVkSW5wdXRzW25hbWVdPWlucHV0fWZ1bmN0aW9uIF9tbE5hbWVkT3BlcmFuZHNSZWxlYXNlKGlkKXtXZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbE5hbWVkT3BlcmFuZHNTZXQobmFtZWRPcGVyYW5kc0lkLG5hbWVQdHIsb3BlcmFuZElkKXt2YXIgbmFtZWRPcGVyYW5kcz1XZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLmdldChuYW1lZE9wZXJhbmRzSWQpO3ZhciBuYW1lPVVURjhUb1N0cmluZyhuYW1lUHRyKTt2YXIgb3BlcmFuZD1XZWJOTi5tZ3JPcGVyYW5kLmdldChvcGVyYW5kSWQpO25hbWVkT3BlcmFuZHNbbmFtZV09b3BlcmFuZH1mdW5jdGlvbiBfbWxOYW1lZE91dHB1dHNSZWxlYXNlKGlkKXtXZWJOTi5tZ3JOYW1lZE91dHB1dHMucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sTmFtZWRPdXRwdXRzU2V0KG5hbWVkT3V0cHV0c0lkLG5hbWVQdHIsb3V0cHV0UHRyKXt2YXIgbmFtZWRPdXRwdXRzPVdlYk5OLm1nck5hbWVkT3V0cHV0cy5nZXQobmFtZWRPdXRwdXRzSWQpO3ZhciBuYW1lPVVURjhUb1N0cmluZyhuYW1lUHRyKTt2YXIgb3V0cHV0PVdlYk5OLm1ha2VPdXRwdXQob3V0cHV0UHRyKTtuYW1lZE91dHB1dHNbbmFtZV09b3V0cHV0fWZ1bmN0aW9uIF9tbE9wZXJhbmRSZWZlcmVuY2UoaWQpe1dlYk5OLm1nck9wZXJhbmQucmVmZXJlbmNlKGlkKX1mdW5jdGlvbiBfbWxPcGVyYW5kUmVsZWFzZShpZCl7V2ViTk4ubWdyT3BlcmFuZC5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfcHRocmVhZF9jcmVhdGUoKXtyZXR1cm4gNn1mdW5jdGlvbiBfcHRocmVhZF9qb2luKCl7cmV0dXJuIDI4fWZ1bmN0aW9uIF9faXNMZWFwWWVhcih5ZWFyKXtyZXR1cm4geWVhciU0PT09MCYmKHllYXIlMTAwIT09MHx8eWVhciU0MDA9PT0wKX1mdW5jdGlvbiBfX2FycmF5U3VtKGFycmF5LGluZGV4KXt2YXIgc3VtPTA7Zm9yKHZhciBpPTA7aTw9aW5kZXg7c3VtKz1hcnJheVtpKytdKXt9cmV0dXJuIHN1bX12YXIgX19NT05USF9EQVlTX0xFQVA9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTt2YXIgX19NT05USF9EQVlTX1JFR1VMQVI9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTtmdW5jdGlvbiBfX2FkZERheXMoZGF0ZSxkYXlzKXt2YXIgbmV3RGF0ZT1uZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7d2hpbGUoZGF5cz4wKXt2YXIgbGVhcD1fX2lzTGVhcFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKTt2YXIgY3VycmVudE1vbnRoPW5ld0RhdGUuZ2V0TW9udGgoKTt2YXIgZGF5c0luQ3VycmVudE1vbnRoPShsZWFwP19fTU9OVEhfREFZU19MRUFQOl9fTU9OVEhfREFZU19SRUdVTEFSKVtjdXJyZW50TW9udGhdO2lmKGRheXM+ZGF5c0luQ3VycmVudE1vbnRoLW5ld0RhdGUuZ2V0RGF0ZSgpKXtkYXlzLT1kYXlzSW5DdXJyZW50TW9udGgtbmV3RGF0ZS5nZXREYXRlKCkrMTtuZXdEYXRlLnNldERhdGUoMSk7aWYoY3VycmVudE1vbnRoPDExKXtuZXdEYXRlLnNldE1vbnRoKGN1cnJlbnRNb250aCsxKX1lbHNle25ld0RhdGUuc2V0TW9udGgoMCk7bmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkrMSl9fWVsc2V7bmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpK2RheXMpO3JldHVybiBuZXdEYXRlfX1yZXR1cm4gbmV3RGF0ZX1mdW5jdGlvbiBfc3RyZnRpbWUocyxtYXhzaXplLGZvcm1hdCx0bSl7dmFyIHRtX3pvbmU9SEVBUDMyW3RtKzQwPj4yXTt2YXIgZGF0ZT17dG1fc2VjOkhFQVAzMlt0bT4+Ml0sdG1fbWluOkhFQVAzMlt0bSs0Pj4yXSx0bV9ob3VyOkhFQVAzMlt0bSs4Pj4yXSx0bV9tZGF5OkhFQVAzMlt0bSsxMj4+Ml0sdG1fbW9uOkhFQVAzMlt0bSsxNj4+Ml0sdG1feWVhcjpIRUFQMzJbdG0rMjA+PjJdLHRtX3dkYXk6SEVBUDMyW3RtKzI0Pj4yXSx0bV95ZGF5OkhFQVAzMlt0bSsyOD4+Ml0sdG1faXNkc3Q6SEVBUDMyW3RtKzMyPj4yXSx0bV9nbXRvZmY6SEVBUDMyW3RtKzM2Pj4yXSx0bV96b25lOnRtX3pvbmU/VVRGOFRvU3RyaW5nKHRtX3pvbmUpOlwiXCJ9O3ZhciBwYXR0ZXJuPVVURjhUb1N0cmluZyhmb3JtYXQpO3ZhciBFWFBBTlNJT05fUlVMRVNfMT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMSl7cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLFwiZ1wiKSxFWFBBTlNJT05fUlVMRVNfMVtydWxlXSl9dmFyIFdFRUtEQVlTPVtcIlN1bmRheVwiLFwiTW9uZGF5XCIsXCJUdWVzZGF5XCIsXCJXZWRuZXNkYXlcIixcIlRodXJzZGF5XCIsXCJGcmlkYXlcIixcIlNhdHVyZGF5XCJdO3ZhciBNT05USFM9W1wiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdO2Z1bmN0aW9uIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsZGlnaXRzLGNoYXJhY3Rlcil7dmFyIHN0cj10eXBlb2YgdmFsdWU9PT1cIm51bWJlclwiP3ZhbHVlLnRvU3RyaW5nKCk6dmFsdWV8fFwiXCI7d2hpbGUoc3RyLmxlbmd0aDxkaWdpdHMpe3N0cj1jaGFyYWN0ZXJbMF0rc3RyfXJldHVybiBzdHJ9ZnVuY3Rpb24gbGVhZGluZ051bGxzKHZhbHVlLGRpZ2l0cyl7cmV0dXJuIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsZGlnaXRzLFwiMFwiKX1mdW5jdGlvbiBjb21wYXJlQnlEYXkoZGF0ZTEsZGF0ZTIpe2Z1bmN0aW9uIHNnbih2YWx1ZSl7cmV0dXJuIHZhbHVlPDA/LTE6dmFsdWU+MD8xOjB9dmFyIGNvbXBhcmU7aWYoKGNvbXBhcmU9c2duKGRhdGUxLmdldEZ1bGxZZWFyKCktZGF0ZTIuZ2V0RnVsbFllYXIoKSkpPT09MCl7aWYoKGNvbXBhcmU9c2duKGRhdGUxLmdldE1vbnRoKCktZGF0ZTIuZ2V0TW9udGgoKSkpPT09MCl7Y29tcGFyZT1zZ24oZGF0ZTEuZ2V0RGF0ZSgpLWRhdGUyLmdldERhdGUoKSl9fXJldHVybiBjb21wYXJlfWZ1bmN0aW9uIGdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGgpe3N3aXRjaChqYW5Gb3VydGguZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBqYW5Gb3VydGg7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpe3ZhciB0aGlzRGF0ZT1fX2FkZERheXMobmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCwxKSxkYXRlLnRtX3lkYXkpO3ZhciBqYW5Gb3VydGhUaGlzWWVhcj1uZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLDAsNCk7dmFyIGphbkZvdXJ0aE5leHRZZWFyPW5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkrMSwwLDQpO3ZhciBmaXJzdFdlZWtTdGFydFRoaXNZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhUaGlzWWVhcik7dmFyIGZpcnN0V2Vla1N0YXJ0TmV4dFllYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aE5leHRZZWFyKTtpZihjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnRUaGlzWWVhcix0aGlzRGF0ZSk8PTApe2lmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydE5leHRZZWFyLHRoaXNEYXRlKTw9MCl7cmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkrMX1lbHNle3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpfX1lbHNle3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLTF9fXZhciBFWFBBTlNJT05fUlVMRVNfMj17XCIlYVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV19LFwiJWJcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBNT05USFNbZGF0ZS50bV9tb25dfSxcIiVDXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIHllYXI9ZGF0ZS50bV95ZWFyKzE5MDA7cmV0dXJuIGxlYWRpbmdOdWxscyh5ZWFyLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXksMil9LFwiJWVcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ1NvbWV0aGluZyhkYXRlLnRtX21kYXksMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpfSxcIiVIXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX2hvdXIsMil9LFwiJUlcIjpmdW5jdGlvbihkYXRlKXt2YXIgdHdlbHZlSG91cj1kYXRlLnRtX2hvdXI7aWYodHdlbHZlSG91cj09MCl0d2VsdmVIb3VyPTEyO2Vsc2UgaWYodHdlbHZlSG91cj4xMil0d2VsdmVIb3VyLT0xMjtyZXR1cm4gbGVhZGluZ051bGxzKHR3ZWx2ZUhvdXIsMil9LFwiJWpcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheStfX2FycmF5U3VtKF9faXNMZWFwWWVhcihkYXRlLnRtX3llYXIrMTkwMCk/X19NT05USF9EQVlTX0xFQVA6X19NT05USF9EQVlTX1JFR1VMQVIsZGF0ZS50bV9tb24tMSksMyl9LFwiJW1cIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbW9uKzEsMil9LFwiJU1cIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWluLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZGF0ZSl7aWYoZGF0ZS50bV9ob3VyPj0wJiZkYXRlLnRtX2hvdXI8MTIpe3JldHVyblwiQU1cIn1lbHNle3JldHVyblwiUE1cIn19LFwiJVNcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fc2VjLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcdFwifSxcIiV1XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fd2RheXx8N30sXCIlVVwiOmZ1bmN0aW9uKGRhdGUpe3ZhciBqYW5GaXJzdD1uZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCwwLDEpO3ZhciBmaXJzdFN1bmRheT1qYW5GaXJzdC5nZXREYXkoKT09PTA/amFuRmlyc3Q6X19hZGREYXlzKGphbkZpcnN0LDctamFuRmlyc3QuZ2V0RGF5KCkpO3ZhciBlbmREYXRlPW5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLGRhdGUudG1fbW9uLGRhdGUudG1fbWRheSk7aWYoY29tcGFyZUJ5RGF5KGZpcnN0U3VuZGF5LGVuZERhdGUpPDApe3ZhciBmZWJydWFyeUZpcnN0VW50aWxFbmRNb250aD1fX2FycmF5U3VtKF9faXNMZWFwWWVhcihlbmREYXRlLmdldEZ1bGxZZWFyKCkpP19fTU9OVEhfREFZU19MRUFQOl9fTU9OVEhfREFZU19SRUdVTEFSLGVuZERhdGUuZ2V0TW9udGgoKS0xKS0zMTt2YXIgZmlyc3RTdW5kYXlVbnRpbEVuZEphbnVhcnk9MzEtZmlyc3RTdW5kYXkuZ2V0RGF0ZSgpO3ZhciBkYXlzPWZpcnN0U3VuZGF5VW50aWxFbmRKYW51YXJ5K2ZlYnJ1YXJ5Rmlyc3RVbnRpbEVuZE1vbnRoK2VuZERhdGUuZ2V0RGF0ZSgpO3JldHVybiBsZWFkaW5nTnVsbHMoTWF0aC5jZWlsKGRheXMvNyksMil9cmV0dXJuIGNvbXBhcmVCeURheShmaXJzdFN1bmRheSxqYW5GaXJzdCk9PT0wP1wiMDFcIjpcIjAwXCJ9LFwiJVZcIjpmdW5jdGlvbihkYXRlKXt2YXIgamFuRm91cnRoVGhpc1llYXI9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCw0KTt2YXIgamFuRm91cnRoTmV4dFllYXI9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDEsMCw0KTt2YXIgZmlyc3RXZWVrU3RhcnRUaGlzWWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoVGhpc1llYXIpO3ZhciBmaXJzdFdlZWtTdGFydE5leHRZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhOZXh0WWVhcik7dmFyIGVuZERhdGU9X19hZGREYXlzKG5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsMSksZGF0ZS50bV95ZGF5KTtpZihjb21wYXJlQnlEYXkoZW5kRGF0ZSxmaXJzdFdlZWtTdGFydFRoaXNZZWFyKTwwKXtyZXR1cm5cIjUzXCJ9aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIsZW5kRGF0ZSk8PTApe3JldHVyblwiMDFcIn12YXIgZGF5c0RpZmZlcmVuY2U7aWYoZmlyc3RXZWVrU3RhcnRUaGlzWWVhci5nZXRGdWxsWWVhcigpPGRhdGUudG1feWVhcisxOTAwKXtkYXlzRGlmZmVyZW5jZT1kYXRlLnRtX3lkYXkrMzItZmlyc3RXZWVrU3RhcnRUaGlzWWVhci5nZXREYXRlKCl9ZWxzZXtkYXlzRGlmZmVyZW5jZT1kYXRlLnRtX3lkYXkrMS1maXJzdFdlZWtTdGFydFRoaXNZZWFyLmdldERhdGUoKX1yZXR1cm4gbGVhZGluZ051bGxzKE1hdGguY2VpbChkYXlzRGlmZmVyZW5jZS83KSwyKX0sXCIld1wiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3dkYXl9LFwiJVdcIjpmdW5jdGlvbihkYXRlKXt2YXIgamFuRmlyc3Q9bmV3IERhdGUoZGF0ZS50bV95ZWFyLDAsMSk7dmFyIGZpcnN0TW9uZGF5PWphbkZpcnN0LmdldERheSgpPT09MT9qYW5GaXJzdDpfX2FkZERheXMoamFuRmlyc3QsamFuRmlyc3QuZ2V0RGF5KCk9PT0wPzE6Ny1qYW5GaXJzdC5nZXREYXkoKSsxKTt2YXIgZW5kRGF0ZT1uZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCxkYXRlLnRtX21vbixkYXRlLnRtX21kYXkpO2lmKGNvbXBhcmVCeURheShmaXJzdE1vbmRheSxlbmREYXRlKTwwKXt2YXIgZmVicnVhcnlGaXJzdFVudGlsRW5kTW9udGg9X19hcnJheVN1bShfX2lzTGVhcFllYXIoZW5kRGF0ZS5nZXRGdWxsWWVhcigpKT9fX01PTlRIX0RBWVNfTEVBUDpfX01PTlRIX0RBWVNfUkVHVUxBUixlbmREYXRlLmdldE1vbnRoKCktMSktMzE7dmFyIGZpcnN0TW9uZGF5VW50aWxFbmRKYW51YXJ5PTMxLWZpcnN0TW9uZGF5LmdldERhdGUoKTt2YXIgZGF5cz1maXJzdE1vbmRheVVudGlsRW5kSmFudWFyeStmZWJydWFyeUZpcnN0VW50aWxFbmRNb250aCtlbmREYXRlLmdldERhdGUoKTtyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguY2VpbChkYXlzLzcpLDIpfXJldHVybiBjb21wYXJlQnlEYXkoZmlyc3RNb25kYXksamFuRmlyc3QpPT09MD9cIjAxXCI6XCIwMFwifSxcIiV5XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuKGRhdGUudG1feWVhcisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3llYXIrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGRhdGUpe3ZhciBvZmY9ZGF0ZS50bV9nbXRvZmY7dmFyIGFoZWFkPW9mZj49MDtvZmY9TWF0aC5hYnMob2ZmKS82MDtvZmY9b2ZmLzYwKjEwMCtvZmYlNjA7cmV0dXJuKGFoZWFkP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrb2ZmKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV96b25lfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19O2Zvcih2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMil7aWYocGF0dGVybi5pbmNsdWRlcyhydWxlKSl7cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLFwiZ1wiKSxFWFBBTlNJT05fUlVMRVNfMltydWxlXShkYXRlKSl9fXZhciBieXRlcz1pbnRBcnJheUZyb21TdHJpbmcocGF0dGVybixmYWxzZSk7aWYoYnl0ZXMubGVuZ3RoPm1heHNpemUpe3JldHVybiAwfXdyaXRlQXJyYXlUb01lbW9yeShieXRlcyxzKTtyZXR1cm4gYnl0ZXMubGVuZ3RoLTF9ZnVuY3Rpb24gX3N0cmZ0aW1lX2wocyxtYXhzaXplLGZvcm1hdCx0bSl7cmV0dXJuIF9zdHJmdGltZShzLG1heHNpemUsZm9ybWF0LHRtKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVHcmFwaEJ1aWxkZXIoY29udGV4dElkKXt2YXIgY29udGV4dD1XZWJOTi5tZ3JDb250ZXh0LmdldChjb250ZXh0SWQpO3ZhciBidWlsZGVyPW5ldyBNTEdyYXBoQnVpbGRlcihjb250ZXh0KTtyZXR1cm4gV2ViTk4ubWdyR3JhcGhCdWlsZGVyLmNyZWF0ZShidWlsZGVyKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVOYW1lZElucHV0cygpe3ZhciBpbnB1dHM9e307cmV0dXJuIFdlYk5OLm1nck5hbWVkSW5wdXRzLmNyZWF0ZShpbnB1dHMpfWZ1bmN0aW9uIF93ZWJubkNyZWF0ZU5hbWVkT3BlcmFuZHMoKXt2YXIgb3BlcmFuZHM9e307cmV0dXJuIFdlYk5OLm1nck5hbWVkT3BlcmFuZHMuY3JlYXRlKG9wZXJhbmRzKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVOYW1lZE91dHB1dHMoKXt2YXIgb3V0cHV0cz17fTtyZXR1cm4gV2ViTk4ubWdyTmFtZWRPdXRwdXRzLmNyZWF0ZShvdXRwdXRzKX1XZWJOTi5pbml0TWFuYWdlcnMoKTtmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSxkb250QWRkTnVsbCxsZW5ndGgpe3ZhciBsZW49bGVuZ3RoPjA/bGVuZ3RoOmxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO3ZhciB1OGFycmF5PW5ldyBBcnJheShsZW4pO3ZhciBudW1CeXRlc1dyaXR0ZW49c3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSx1OGFycmF5LDAsdThhcnJheS5sZW5ndGgpO2lmKGRvbnRBZGROdWxsKXU4YXJyYXkubGVuZ3RoPW51bUJ5dGVzV3JpdHRlbjtyZXR1cm4gdThhcnJheX12YXIgYXNtTGlicmFyeUFyZz17XCJhXCI6X19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbixcImNcIjpfX19jeGFfYXRleGl0LFwiZlwiOl9fX2N4YV90aHJlYWRfYXRleGl0LFwiYlwiOl9fX2N4YV90aHJvdyxcIkxcIjpfX19zeXNfYWNjZXNzLFwibVwiOl9fX3N5c19mY250bDY0LFwiUlwiOl9fX3N5c19mc3RhdDY0LFwiTVwiOl9fX3N5c19nZXRkZW50czY0LFwicVwiOl9fX3N5c19nZXRwaWQsXCJEXCI6X19fc3lzX2lvY3RsLFwiTlwiOl9fX3N5c19sc3RhdDY0LFwiUVwiOl9fX3N5c19ta2RpcixcIlBcIjpfX19zeXNfbW1hcDIsXCJPXCI6X19fc3lzX211bm1hcCxcImxcIjpfX19zeXNfb3BlbixcIktcIjpfX19zeXNfcmVhZGxpbmssXCJJXCI6X19fc3lzX3JtZGlyLFwic1wiOl9fX3N5c19zdGF0NjQsXCJKXCI6X19fc3lzX3VubGluayxcImpcIjpfYWJvcnQsXCJ1XCI6X2Nsb2NrX2dldHRpbWUsXCJ6XCI6X2RpZmZ0aW1lLFwidmFcIjpfZGxjbG9zZSxcImlcIjpfZGxlcnJvcixcIndhXCI6X2Rsb3BlbixcInVhXCI6X2Rsc3ltLFwiU1wiOl9lbXNjcmlwdGVuX2dldF9oZWFwX21heCxcIkNcIjpfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFwia1wiOl9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLFwiSFwiOl9lbXNjcmlwdGVuX3RocmVhZF9zbGVlcCxcInNhXCI6X2Vtc2NyaXB0ZW5fd2Vibm5fY3JlYXRlX2NvbnRleHQsXCJGXCI6X2Vudmlyb25fZ2V0LFwiR1wiOl9lbnZpcm9uX3NpemVzX2dldCxcImhcIjpfZmRfY2xvc2UsXCJFXCI6X2ZkX2Zkc3RhdF9nZXQsXCJvXCI6X2ZkX3JlYWQsXCJCXCI6X2ZkX3NlZWssXCJwXCI6X2ZkX3dyaXRlLFwiYWFcIjpfZ2V0dGltZW9mZGF5LFwiQVwiOl9nbXRpbWVfcixcIm5cIjpfbG9jYWx0aW1lX3IsXCJ5XCI6X21rdGltZSxcInhcIjpfbWxDb250ZXh0UmVmZXJlbmNlLFwid1wiOl9tbENvbnRleHRSZWxlYXNlLFwicGFcIjpfbWxHcmFwaEJ1aWxkZXJBZGQsXCJvYVwiOl9tbEdyYXBoQnVpbGRlckF2ZXJhZ2VQb29sMmQsXCJuYVwiOl9tbEdyYXBoQnVpbGRlckJhdGNoTm9ybSxcIm1hXCI6X21sR3JhcGhCdWlsZGVyQnVpbGRTeW5jLFwibGFcIjpfbWxHcmFwaEJ1aWxkZXJDb25jYXQsXCJrYVwiOl9tbEdyYXBoQnVpbGRlckNvbnN0YW50LFwiamFcIjpfbWxHcmFwaEJ1aWxkZXJDb252MmQsXCJpYVwiOl9tbEdyYXBoQnVpbGRlckdlbW0sXCJoYVwiOl9tbEdyYXBoQnVpbGRlcklucHV0LFwiZ2FcIjpfbWxHcmFwaEJ1aWxkZXJNYXRtdWwsXCJmYVwiOl9tbEdyYXBoQnVpbGRlck1heFBvb2wyZCxcInRcIjpfbWxHcmFwaEJ1aWxkZXJSZWxlYXNlLFwiZWFcIjpfbWxHcmFwaEJ1aWxkZXJSZWx1LFwiZGFcIjpfbWxHcmFwaEJ1aWxkZXJSZXNoYXBlLFwicmFcIjpfbWxHcmFwaENvbXB1dGVTeW5jLFwicWFcIjpfbWxHcmFwaFJlZmVyZW5jZSxcInZcIjpfbWxHcmFwaFJlbGVhc2UsXCJiYVwiOl9tbE5hbWVkSW5wdXRzUmVsZWFzZSxcImNhXCI6X21sTmFtZWRJbnB1dHNTZXQsXCJfXCI6X21sTmFtZWRPcGVyYW5kc1JlbGVhc2UsXCIkXCI6X21sTmFtZWRPcGVyYW5kc1NldCxcIllcIjpfbWxOYW1lZE91dHB1dHNSZWxlYXNlLFwiWlwiOl9tbE5hbWVkT3V0cHV0c1NldCxcImVcIjpfbWxPcGVyYW5kUmVmZXJlbmNlLFwiZFwiOl9tbE9wZXJhbmRSZWxlYXNlLFwiVFwiOl9wdGhyZWFkX2NyZWF0ZSxcInJcIjpfcHRocmVhZF9qb2luLFwidGFcIjpfc3RyZnRpbWUsXCJnXCI6X3N0cmZ0aW1lX2wsXCJYXCI6X3dlYm5uQ3JlYXRlR3JhcGhCdWlsZGVyLFwiV1wiOl93ZWJubkNyZWF0ZU5hbWVkSW5wdXRzLFwiVlwiOl93ZWJubkNyZWF0ZU5hbWVkT3BlcmFuZHMsXCJVXCI6X3dlYm5uQ3JlYXRlTmFtZWRPdXRwdXRzfTt2YXIgYXNtPWNyZWF0ZVdhc20oKTt2YXIgX19fd2FzbV9jYWxsX2N0b3JzPU1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXT1mdW5jdGlvbigpe3JldHVybihfX193YXNtX2NhbGxfY3RvcnM9TW9kdWxlW1wiX19fd2FzbV9jYWxsX2N0b3JzXCJdPU1vZHVsZVtcImFzbVwiXVtcInlhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0SW5pdD1Nb2R1bGVbXCJfT3J0SW5pdFwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0SW5pdD1Nb2R1bGVbXCJfT3J0SW5pdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ6YVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9uc1wiXT1mdW5jdGlvbigpe3JldHVybihfT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9TW9kdWxlW1wiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcIkFhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OPU1vZHVsZVtcIl9PcnRTZXNzaW9uT3B0aW9uc0FwcGVuZEV4ZWN1dGlvblByb3ZpZGVyV2ViTk5cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFNlc3Npb25PcHRpb25zQXBwZW5kRXhlY3V0aW9uUHJvdmlkZXJXZWJOTj1Nb2R1bGVbXCJfT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OXCJdPU1vZHVsZVtcImFzbVwiXVtcIkJhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PU1vZHVsZVtcIl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnlcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5XCJdPU1vZHVsZVtcImFzbVwiXVtcIkNhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPU1vZHVsZVtcIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1Nb2R1bGVbXCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcIkRhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0Q3JlYXRlU2Vzc2lvbj1Nb2R1bGVbXCJfT3J0Q3JlYXRlU2Vzc2lvblwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0Q3JlYXRlU2Vzc2lvbj1Nb2R1bGVbXCJfT3J0Q3JlYXRlU2Vzc2lvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJFYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VTZXNzaW9uPU1vZHVsZVtcIl9PcnRSZWxlYXNlU2Vzc2lvblwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0UmVsZWFzZVNlc3Npb249TW9kdWxlW1wiX09ydFJlbGVhc2VTZXNzaW9uXCJdPU1vZHVsZVtcImFzbVwiXVtcIkZhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0SW5wdXRDb3VudD1Nb2R1bGVbXCJfT3J0R2V0SW5wdXRDb3VudFwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0SW5wdXRDb3VudD1Nb2R1bGVbXCJfT3J0R2V0SW5wdXRDb3VudFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJHYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldE91dHB1dENvdW50PU1vZHVsZVtcIl9PcnRHZXRPdXRwdXRDb3VudFwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0T3V0cHV0Q291bnQ9TW9kdWxlW1wiX09ydEdldE91dHB1dENvdW50XCJdPU1vZHVsZVtcImFzbVwiXVtcIkhhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0SW5wdXROYW1lPU1vZHVsZVtcIl9PcnRHZXRJbnB1dE5hbWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldElucHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0SW5wdXROYW1lXCJdPU1vZHVsZVtcImFzbVwiXVtcIklhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0T3V0cHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0T3V0cHV0TmFtZVwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0T3V0cHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0T3V0cHV0TmFtZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJKYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEZyZWU9TW9kdWxlW1wiX09ydEZyZWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEZyZWU9TW9kdWxlW1wiX09ydEZyZWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiS2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRDcmVhdGVUZW5zb3I9TW9kdWxlW1wiX09ydENyZWF0ZVRlbnNvclwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0Q3JlYXRlVGVuc29yPU1vZHVsZVtcIl9PcnRDcmVhdGVUZW5zb3JcIl09TW9kdWxlW1wiYXNtXCJdW1wiTGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRHZXRUZW5zb3JEYXRhPU1vZHVsZVtcIl9PcnRHZXRUZW5zb3JEYXRhXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRHZXRUZW5zb3JEYXRhPU1vZHVsZVtcIl9PcnRHZXRUZW5zb3JEYXRhXCJdPU1vZHVsZVtcImFzbVwiXVtcIk1hXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0UmVsZWFzZVRlbnNvcj1Nb2R1bGVbXCJfT3J0UmVsZWFzZVRlbnNvclwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0UmVsZWFzZVRlbnNvcj1Nb2R1bGVbXCJfT3J0UmVsZWFzZVRlbnNvclwiXT1Nb2R1bGVbXCJhc21cIl1bXCJOYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydENyZWF0ZVJ1bk9wdGlvbnM9TW9kdWxlW1wiX09ydENyZWF0ZVJ1bk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVJ1bk9wdGlvbnM9TW9kdWxlW1wiX09ydENyZWF0ZVJ1bk9wdGlvbnNcIl09TW9kdWxlW1wiYXNtXCJdW1wiT2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRBZGRSdW5Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkUnVuQ29uZmlnRW50cnlcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PU1vZHVsZVtcIl9PcnRBZGRSdW5Db25maWdFbnRyeVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJQYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRSZWxlYXNlUnVuT3B0aW9uc1wiXT1mdW5jdGlvbigpe3JldHVybihfT3J0UmVsZWFzZVJ1bk9wdGlvbnM9TW9kdWxlW1wiX09ydFJlbGVhc2VSdW5PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcIlFhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0UnVuPU1vZHVsZVtcIl9PcnRSdW5cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJ1bj1Nb2R1bGVbXCJfT3J0UnVuXCJdPU1vZHVsZVtcImFzbVwiXVtcIlJhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbWFsbG9jPU1vZHVsZVtcIl9tYWxsb2NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPU1vZHVsZVtcImFzbVwiXVtcIlNhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbXCJfX19lcnJub19sb2NhdGlvblwiXT1mdW5jdGlvbigpe3JldHVybihfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbXCJfX19lcnJub19sb2NhdGlvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJUYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2ZyZWU9TW9kdWxlW1wiX2ZyZWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2ZyZWU9TW9kdWxlW1wiX2ZyZWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiVWFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9tZW1zZXQ9TW9kdWxlW1wiX21lbXNldFwiXT1mdW5jdGlvbigpe3JldHVybihfbWVtc2V0PU1vZHVsZVtcIl9tZW1zZXRcIl09TW9kdWxlW1wiYXNtXCJdW1wiVmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZ2V0X3R6bmFtZT1Nb2R1bGVbXCJfX2dldF90em5hbWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19nZXRfdHpuYW1lPU1vZHVsZVtcIl9fZ2V0X3R6bmFtZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJXYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19nZXRfZGF5bGlnaHQ9TW9kdWxlW1wiX19nZXRfZGF5bGlnaHRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19nZXRfZGF5bGlnaHQ9TW9kdWxlW1wiX19nZXRfZGF5bGlnaHRcIl09TW9kdWxlW1wiYXNtXCJdW1wiWGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZ2V0X3RpbWV6b25lPU1vZHVsZVtcIl9fZ2V0X3RpbWV6b25lXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZ2V0X3RpbWV6b25lPU1vZHVsZVtcIl9fZ2V0X3RpbWV6b25lXCJdPU1vZHVsZVtcImFzbVwiXVtcIllhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja1NhdmU9TW9kdWxlW1wic3RhY2tTYXZlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrU2F2ZT1Nb2R1bGVbXCJzdGFja1NhdmVcIl09TW9kdWxlW1wiYXNtXCJdW1wiWmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHN0YWNrUmVzdG9yZT1Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oc3RhY2tSZXN0b3JlPU1vZHVsZVtcInN0YWNrUmVzdG9yZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJfYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tBbGxvYz1Nb2R1bGVbXCJzdGFja0FsbG9jXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrQWxsb2M9TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1Nb2R1bGVbXCJhc21cIl1bXCIkYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX21lbWFsaWduPU1vZHVsZVtcIl9tZW1hbGlnblwiXT1mdW5jdGlvbigpe3JldHVybihfbWVtYWxpZ249TW9kdWxlW1wiX21lbWFsaWduXCJdPU1vZHVsZVtcImFzbVwiXVtcImFiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O01vZHVsZVtcIlVURjhUb1N0cmluZ1wiXT1VVEY4VG9TdHJpbmc7TW9kdWxlW1wic3RyaW5nVG9VVEY4XCJdPXN0cmluZ1RvVVRGODtNb2R1bGVbXCJsZW5ndGhCeXRlc1VURjhcIl09bGVuZ3RoQnl0ZXNVVEY4O01vZHVsZVtcInN0YWNrU2F2ZVwiXT1zdGFja1NhdmU7TW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdPXN0YWNrUmVzdG9yZTtNb2R1bGVbXCJzdGFja0FsbG9jXCJdPXN0YWNrQWxsb2M7dmFyIGNhbGxlZFJ1bjtmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiO3RoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrc3RhdHVzK1wiKVwiO3RoaXMuc3RhdHVzPXN0YXR1c31kZXBlbmRlbmNpZXNGdWxmaWxsZWQ9ZnVuY3Rpb24gcnVuQ2FsbGVyKCl7aWYoIWNhbGxlZFJ1bilydW4oKTtpZighY2FsbGVkUnVuKWRlcGVuZGVuY2llc0Z1bGZpbGxlZD1ydW5DYWxsZXJ9O2Z1bmN0aW9uIHJ1bihhcmdzKXthcmdzPWFyZ3N8fGFyZ3VtZW50c187aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1wcmVSdW4oKTtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufWZ1bmN0aW9uIGRvUnVuKCl7aWYoY2FsbGVkUnVuKXJldHVybjtjYWxsZWRSdW49dHJ1ZTtNb2R1bGVbXCJjYWxsZWRSdW5cIl09dHJ1ZTtpZihBQk9SVClyZXR1cm47aW5pdFJ1bnRpbWUoKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0oKTtwb3N0UnVuKCl9aWYoTW9kdWxlW1wic2V0U3RhdHVzXCJdKXtNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiXCIpfSwxKTtkb1J1bigpfSwxKX1lbHNle2RvUnVuKCl9fU1vZHVsZVtcInJ1blwiXT1ydW47aWYoTW9kdWxlW1wicHJlSW5pdFwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInByZUluaXRcIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwcmVJbml0XCJdPVtNb2R1bGVbXCJwcmVJbml0XCJdXTt3aGlsZShNb2R1bGVbXCJwcmVJbml0XCJdLmxlbmd0aD4wKXtNb2R1bGVbXCJwcmVJbml0XCJdLnBvcCgpKCl9fXJ1bigpO1xuXG5cbiAgcmV0dXJuIG9ydFdhc20ucmVhZHlcbn1cbik7XG59KSgpO1xuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgbW9kdWxlLmV4cG9ydHMgPSBvcnRXYXNtO1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKVxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3J0V2FzbTsgfSk7XG5lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gIGV4cG9ydHNbXCJvcnRXYXNtXCJdID0gb3J0V2FzbTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmFzUHJvbWlzZX0uXHJcbiAqIEB0eXBlZGVmIGFzUHJvbWlzZUNhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEFkZGl0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIGZyb20gYSBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge2FzUHJvbWlzZUNhbGxiYWNrfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gY3R4IEZ1bmN0aW9uIGNvbnRleHRcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgRnVuY3Rpb24gYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBQcm9taXNpZmllZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgvKiwgdmFyYXJncyAqLykge1xyXG4gICAgdmFyIHBhcmFtcyAgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIG9mZnNldCAgPSAwLFxyXG4gICAgICAgIGluZGV4ICAgPSAyLFxyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLyosIHZhcmFyZ3MgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBiYXNlNjQgaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBiYXNlNjQgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxuYmFzZTY0Lmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBwID0gc3RyaW5nLmxlbmd0aDtcclxuICAgIGlmICghcClcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciBuID0gMDtcclxuICAgIHdoaWxlICgtLXAgJSA0ID4gMSAmJiBzdHJpbmcuY2hhckF0KHApID09PSBcIj1cIilcclxuICAgICAgICArK247XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggKiAzKSAvIDQgLSBuO1xyXG59O1xyXG5cclxuLy8gQmFzZTY0IGVuY29kaW5nIHRhYmxlXHJcbnZhciBiNjQgPSBuZXcgQXJyYXkoNjQpO1xyXG5cclxuLy8gQmFzZTY0IGRlY29kaW5nIHRhYmxlXHJcbnZhciBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcclxuXHJcbi8vIDY1Li45MCwgOTcuLjEyMiwgNDguLjU3LCA0MywgNDdcclxuZm9yICh2YXIgaSA9IDA7IGkgPCA2NDspXHJcbiAgICBzNjRbYjY0W2ldID0gaSA8IDI2ID8gaSArIDY1IDogaSA8IDUyID8gaSArIDcxIDogaSA8IDYyID8gaSAtIDQgOiBpIC0gNTkgfCA0M10gPSBpKys7XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIGJ1ZmZlciB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW107XHJcbiAgICB2YXIgaSA9IDAsIC8vIG91dHB1dCBpbmRleFxyXG4gICAgICAgIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdmFyIGIgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiA+PiAyXTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDMpIDw8IDQ7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDRdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMTUpIDw8IDI7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDZdO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiICYgNjNdO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqKSB7XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0XTtcclxuICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICAgICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG52YXIgaW52YWxpZEVuY29kaW5nID0gXCJpbnZhbGlkIGVuY29kaW5nXCI7XHJcblxyXG4vKipcclxuICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZW5jb2RpbmcgaXMgaW52YWxpZFxyXG4gKi9cclxuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICB2YXIgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7KSB7XHJcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKyspO1xyXG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKChjID0gczY0W2NdKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB0IDw8IDIgfCAoYyAmIDQ4KSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDMpIDw8IDYgfCBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGFwcGVhcnMgdG8gYmUgYmFzZTY0IGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBwcm9iYWJseSBiYXNlNjQgZW5jb2RlZCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xyXG5iYXNlNjQudGVzdCA9IGZ1bmN0aW9uIHRlc3Qoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyaW5nKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIG9ubHkgaWYgYXZhaWxhYmxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBNb2R1bGUgdG8gcmVxdWlyZVxyXG4gKiBAcmV0dXJucyB7P09iamVjdH0gUmVxdWlyZWQgbW9kdWxlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGVtcHR5LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHBvb2w7XHJcblxyXG4vKipcclxuICogQW4gYWxsb2NhdG9yIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwucG9vbH0uXHJcbiAqIEB0eXBlZGVmIFBvb2xBbGxvY2F0b3JcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc2xpY2VyIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwucG9vbH0uXHJcbiAqIEB0eXBlZGVmIFBvb2xTbGljZXJcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyIHNsaWNlXHJcbiAqIEB0aGlzIHtVaW50OEFycmF5fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgcHVycG9zZSBidWZmZXIgcG9vbC5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7UG9vbEFsbG9jYXRvcn0gYWxsb2MgQWxsb2NhdG9yXHJcbiAqIEBwYXJhbSB7UG9vbFNsaWNlcn0gc2xpY2UgU2xpY2VyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT04MTkyXSBTbGFiIHNpemVcclxuICogQHJldHVybnMge1Bvb2xBbGxvY2F0b3J9IFBvb2xlZCBhbGxvY2F0b3JcclxuICovXHJcbmZ1bmN0aW9uIHBvb2woYWxsb2MsIHNsaWNlLCBzaXplKSB7XHJcbiAgICB2YXIgU0laRSAgID0gc2l6ZSB8fCA4MTkyO1xyXG4gICAgdmFyIE1BWCAgICA9IFNJWkUgPj4+IDE7XHJcbiAgICB2YXIgc2xhYiAgID0gbnVsbDtcclxuICAgIHZhciBvZmZzZXQgPSBTSVpFO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvb2xfYWxsb2Moc2l6ZSkge1xyXG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gTUFYKVxyXG4gICAgICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCArIHNpemUgPiBTSVpFKSB7XHJcbiAgICAgICAgICAgIHNsYWIgPSBhbGxvYyhTSVpFKTtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IHNsaWNlLmNhbGwoc2xhYiwgb2Zmc2V0LCBvZmZzZXQgKz0gc2l6ZSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAmIDcpIC8vIGFsaWduIHRvIDMyIGJpdFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IHwgNykgKyAxO1xyXG4gICAgICAgIHJldHVybiBidWY7XHJcbiAgICB9O1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBVVEY4IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdXRmOCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbnV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgbGVuID0gMCxcclxuICAgICAgICBjID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcclxuICAgICAgICAgICAgbGVuICs9IDI7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGxlbiArPSA0O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBsZW4gKz0gMztcclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gKi9cclxudXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW10sXHJcbiAgICAgICAgaSA9IDAsIC8vIGNoYXIgb2Zmc2V0XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBpZiAodCA8IDEyOClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xyXG4gICAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4RDgwMCArICh0ID4+IDEwKTtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4REMwMCArICh0ICYgMTAyMyk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZyBhcyBVVEY4IGJ5dGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cclxuICovXHJcbnV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICBjMSwgLy8gY2hhcmFjdGVyIDFcclxuICAgICAgICBjMjsgLy8gY2hhcmFjdGVyIDJcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAgICAgIHwgMTkyO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICBjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM0ZGKSA8PCAxMCkgKyAoYzIgJiAweDAzRkYpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCAgICAgIHwgMjQwO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAgICAgIHwgMjI0O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG4iLCIvLy8gQGZpbGVcbi8vLyBAYWRkdG9ncm91cCBmbGF0YnVmZmVyc19qYXZhc2NyaXB0X2FwaVxuLy8vIEB7XG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKlxuICogTmVlZCB0byBzdXBwcmVzcyAnZ2xvYmFsIHRoaXMnIGVycm9yIHNvIHRoZSBOb2RlLmpzIGV4cG9ydCBsaW5lIGRvZXNuJ3QgY2F1c2VcbiAqIGNsb3N1cmUgY29tcGlsZSB0byBlcnJvciBvdXQuXG4gKiBAc3VwcHJlc3Mge2dsb2JhbFRoaXN9XG4gKi9cblxuLyoqXG4gKiBAY29uc3RcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGZsYXRidWZmZXJzID0ge307XG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuT2Zmc2V0O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLFxuICogICBiYl9wb3M6IG51bWJlclxuICogfX1cbiAqL1xuZmxhdGJ1ZmZlcnMuVGFibGU7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5TSVpFT0ZfU0hPUlQgPSAyO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCA9IDQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIID0gNDtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCA9IDQ7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuRW5jb2RpbmcgPSB7XG4gIFVURjhfQllURVM6IDEsXG4gIFVURjE2X1NUUklORzogMlxufTtcblxuLyoqXG4gKiBAdHlwZSB7SW50MzJBcnJheX1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5pbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuXG4vKipcbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoZmxhdGJ1ZmZlcnMuaW50MzIuYnVmZmVyKTtcblxuLyoqXG4gKiBAdHlwZSB7RmxvYXQ2NEFycmF5fVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGZsYXRidWZmZXJzLmludDMyLmJ1ZmZlcik7XG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPSBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsIDBdKS5idWZmZXIpWzBdID09PSAxO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqL1xuICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcuY3JlYXRlID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIC8vIFNwZWNpYWwtY2FzZSB6ZXJvIHRvIGF2b2lkIEdDIG92ZXJoZWFkIGZvciBkZWZhdWx0IHZhbHVlc1xuICByZXR1cm4gbG93ID09IDAgJiYgaGlnaCA9PSAwID8gZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPIDogbmV3IGZsYXRidWZmZXJzLkxvbmcobG93LCBoaWdoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5sb3cgPj4+IDApICsgdGhpcy5oaWdoICogMHgxMDAwMDAwMDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gb3RoZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mbGF0YnVmZmVycy5Mb25nLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5sb3cgPT0gb3RoZXIubG93ICYmIHRoaXMuaGlnaCA9PSBvdGhlci5oaWdoO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5aRVJPID0gbmV3IGZsYXRidWZmZXJzLkxvbmcoMCwgMCk7XG5cbi8vLyBAZW5kY29uZFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogQ3JlYXRlIGEgRmxhdEJ1ZmZlckJ1aWxkZXIuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9pbml0aWFsX3NpemVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlciA9IGZ1bmN0aW9uKG9wdF9pbml0aWFsX3NpemUpIHtcbiAgaWYgKCFvcHRfaW5pdGlhbF9zaXplKSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IDEwMjQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluaXRpYWxfc2l6ZSA9IG9wdF9pbml0aWFsX3NpemU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xuXG4gIC8qKlxuICAgKiBSZW1haW5pbmcgc3BhY2UgaW4gdGhlIEJ5dGVCdWZmZXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnNwYWNlID0gaW5pdGlhbF9zaXplO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm1pbmFsaWduID0gMTtcblxuICAvKipcbiAgICogVGhlIHZ0YWJsZSBmb3IgdGhlIGN1cnJlbnQgdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudnRhYmxlID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgc2VyaWFsaXppbmcgYSB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFN0YXJ0aW5nIG9mZnNldCBvZiB0aGUgY3VycmVudCBzdHJ1Y3QvdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLm9iamVjdF9zdGFydCA9IDA7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2Ygb2Zmc2V0cyBvZiBhbGwgdnRhYmxlcy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52dGFibGVzID0gW107XG5cbiAgLyoqXG4gICAqIEZvciB0aGUgY3VycmVudCB2ZWN0b3IgYmVpbmcgYnVpbHQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSAwO1xuXG4gIC8qKlxuICAgKiBGYWxzZSBvbWl0cyBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoZSBzZXJpYWxpemVkIGRhdGFcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZmFsc2U7XG59O1xuXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJiLmNsZWFyKCk7XG4gIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gIHRoaXMubWluYWxpZ24gPSAxO1xuICB0aGlzLnZ0YWJsZSA9IG51bGw7XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IDA7XG4gIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuICB0aGlzLnZ0YWJsZXMgPSBbXTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcbiAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXG4gKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlRGVmYXVsdHMgdHJ1ZSBhbHdheXMgc2VyaWFsaXplcyBkZWZhdWx0IHZhbHVlc1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzID0gZnVuY3Rpb24oZm9yY2VEZWZhdWx0cykge1xuICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZm9yY2VEZWZhdWx0cztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBCeXRlQnVmZmVyIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gKiBjYWxsZWQgZmluaXNoKCkuIFRoZSBhY3R1YWwgZGF0YSBzdGFydHMgYXQgdGhlIEJ5dGVCdWZmZXIncyBjdXJyZW50IHBvc2l0aW9uLFxuICogbm90IG5lY2Vzc2FyaWx5IGF0IDAuXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmRhdGFCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmI7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcbiAqIGNhbGxlZCBmaW5pc2goKS5cbiAqXG4gKiBAcmV0dXJucyB7IVVpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFzVWludDhBcnJheSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSwgdGhpcy5iYi5wb3NpdGlvbigpICsgdGhpcy5vZmZzZXQoKSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogUHJlcGFyZSB0byB3cml0ZSBhbiBlbGVtZW50IG9mIGBzaXplYCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2AgaGF2ZSBiZWVuXG4gKiB3cml0dGVuLCBlLmcuIGlmIHlvdSB3cml0ZSBhIHN0cmluZywgeW91IG5lZWQgdG8gYWxpZ24gc3VjaCB0aGUgaW50IGxlbmd0aFxuICogZmllbGQgaXMgYWxpZ25lZCB0byA0IGJ5dGVzLCBhbmQgdGhlIHN0cmluZyBkYXRhIGZvbGxvd3MgaXQgZGlyZWN0bHkuIElmIGFsbFxuICogeW91IG5lZWQgdG8gZG8gaXMgYWxpZ25tZW50LCBgYWRkaXRpb25hbF9ieXRlc2Agd2lsbCBiZSAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoaXMgaXMgdGhlIG9mIHRoZSBuZXcgZWxlbWVudCB0byB3cml0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGl0aW9uYWxfYnl0ZXMgVGhlIHBhZGRpbmcgc2l6ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5wcmVwID0gZnVuY3Rpb24oc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xuICAvLyBUcmFjayB0aGUgYmlnZ2VzdCB0aGluZyB3ZSd2ZSBldmVyIGFsaWduZWQgdG8uXG4gIGlmIChzaXplID4gdGhpcy5taW5hbGlnbikge1xuICAgIHRoaXMubWluYWxpZ24gPSBzaXplO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgYW1vdW50IG9mIGFsaWdubWVudCBuZWVkZWQgc3VjaCB0aGF0IGBzaXplYCBpcyBwcm9wZXJseVxuICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxuICB2YXIgYWxpZ25fc2l6ZSA9ICgofih0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlICsgYWRkaXRpb25hbF9ieXRlcykpICsgMSkgJiAoc2l6ZSAtIDEpO1xuXG4gIC8vIFJlYWxsb2NhdGUgdGhlIGJ1ZmZlciBpZiBuZWVkZWQuXG4gIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XG4gICAgdmFyIG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcbiAgICB0aGlzLmJiID0gZmxhdGJ1ZmZlcnMuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlcih0aGlzLmJiKTtcbiAgICB0aGlzLnNwYWNlICs9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIG9sZF9idWZfc2l6ZTtcbiAgfVxuXG4gIHRoaXMucGFkKGFsaWduX3NpemUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZV9zaXplXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XG4gICAgdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUludDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUZsb2F0MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ4ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDEsIDApO1xuICB0aGlzLndyaXRlSW50OCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MTZgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MTZgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTYgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoMiwgMCk7XG4gIHRoaXMud3JpdGVJbnQxNih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgaW50MzJgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZSBUaGUgYGludDY0YCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlSW50NjQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBgZmxvYXQzMmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGBmbG9hdDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZsb2F0MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLnByZXAoNCwgMCk7XG4gIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDgsIDApO1xuICB0aGlzLndyaXRlRmxvYXQ2NCh2YWx1ZSk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDggPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQzMiA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCAhdmFsdWUuZXF1YWxzKGRlZmF1bHRWYWx1ZSkpIHtcbiAgICB0aGlzLmFkZEludDY0KHZhbHVlKTtcbiAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0MzIgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkRmxvYXQzMih2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDY0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEZsb2F0NjQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZE9mZnNldCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHMgYXJlIHN0b3JlZCBpbmxpbmUsIHNvIG5vdGhpbmcgYWRkaXRpb25hbCBpcyBiZWluZyBhZGRlZC4gYGRgIGlzIGFsd2F5cyAwLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdmFsdWVcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRTdHJ1Y3QgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLm5lc3RlZCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0cnVjdHVyZXMgYXJlIGFsd2F5cyBzdG9yZWQgaW5saW5lLCB0aGV5IG5lZWQgdG8gYmUgY3JlYXRlZCByaWdodFxuICogd2hlcmUgdGhleSdyZSB1c2VkLiAgWW91J2xsIGdldCB0aGlzIGFzc2VydGlvbiBmYWlsdXJlIGlmIHlvdVxuICogY3JlYXRlZCBpdCBlbHNld2hlcmUuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9iaiBUaGUgb2Zmc2V0IG9mIHRoZSBjcmVhdGVkIG9iamVjdFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXG4gKiB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgY29uc3RydWN0ZWRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUubm90TmVzdGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlzTmVzdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogb2JqZWN0IHNlcmlhbGl6YXRpb24gbXVzdCBub3QgYmUgbmVzdGVkLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCB2dGFibGUgYXQgYHZvZmZzZXRgIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc2xvdCA9IGZ1bmN0aW9uKHZvZmZzZXQpIHtcbiAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XG59O1xuXG4vKipcbiAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXG4gKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBiYiBUaGUgY3VycmVudCBidWZmZXIgd2l0aCB0aGUgZXhpc3RpbmcgZGF0YVxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5CeXRlQnVmZmVyfSBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcbiAqIHRvIGl0LiBUaGUgZGF0YSBpcyBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cbiAqXG4gKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcbiAqIGl0IGEgdWludDhBcnJheSB3ZSBuZWVkIHRvIHN1cHByZXNzIHRoZSB0eXBlIGNoZWNrOlxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyID0gZnVuY3Rpb24oYmIpIHtcbiAgdmFyIG9sZF9idWZfc2l6ZSA9IGJiLmNhcGFjaXR5KCk7XG5cbiAgLy8gRW5zdXJlIHdlIGRvbid0IGdyb3cgYmV5b25kIHdoYXQgZml0cyBpbiBhbiBpbnQuXG4gIGlmIChvbGRfYnVmX3NpemUgJiAweEMwMDAwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy4nKTtcbiAgfVxuXG4gIHZhciBuZXdfYnVmX3NpemUgPSBvbGRfYnVmX3NpemUgPDwgMTtcbiAgdmFyIG5iYiA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcbiAgbmJiLnNldFBvc2l0aW9uKG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gIG5iYi5ieXRlcygpLnNldChiYi5ieXRlcygpLCBuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICByZXR1cm4gbmJiO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEFkZHMgb24gb2Zmc2V0LCByZWxhdGl2ZSB0byB3aGVyZSBpdCB3aWxsIGJlIHdyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IG9mZnNldCBUaGUgb2Zmc2V0IHRvIGFkZC5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHRoaXMucHJlcChmbGF0YnVmZmVycy5TSVpFT0ZfSU5ULCAwKTsgLy8gRW5zdXJlIGFsaWdubWVudCBpcyBhbHJlYWR5IGRvbmUuXG4gIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCk7XG59O1xuXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogU3RhcnQgZW5jb2RpbmcgYSBuZXcgb2JqZWN0IGluIHRoZSBidWZmZXIuICBVc2VycyB3aWxsIG5vdCB1c3VhbGx5IG5lZWQgdG9cbiAqIGNhbGwgdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgZ2VuZXJhdGUgaGVscGVyIG1ldGhvZHNcbiAqIHRoYXQgY2FsbCB0aGlzIG1ldGhvZCBpbnRlcm5hbGx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1maWVsZHNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRPYmplY3QgPSBmdW5jdGlvbihudW1maWVsZHMpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwpIHtcbiAgICB0aGlzLnZ0YWJsZSA9IFtdO1xuICB9XG4gIHRoaXMudnRhYmxlX2luX3VzZSA9IG51bWZpZWxkcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xuICAgIHRoaXMudnRhYmxlW2ldID0gMDsgLy8gVGhpcyB3aWxsIHB1c2ggYWRkaXRpb25hbCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgfVxuICB0aGlzLmlzTmVzdGVkID0gdHJ1ZTtcbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSB0aGlzLm9mZnNldCgpO1xufTtcblxuLyoqXG4gKiBGaW5pc2ggb2ZmIHdyaXRpbmcgdGhlIG9iamVjdCB0aGF0IGlzIHVuZGVyIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IHRvIHRoZSBvYmplY3QgaW5zaWRlIGBkYXRhQnVmZmVyYFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudnRhYmxlID09IG51bGwgfHwgIXRoaXMuaXNOZXN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3QnKTtcbiAgfVxuXG4gIHRoaXMuYWRkSW50MzIoMCk7XG4gIHZhciB2dGFibGVsb2MgPSB0aGlzLm9mZnNldCgpO1xuXG4gIC8vIFRyaW0gdHJhaWxpbmcgemVyb2VzLlxuICB2YXIgaSA9IHRoaXMudnRhYmxlX2luX3VzZSAtIDE7XG4gIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7fVxuICB2YXIgdHJpbW1lZF9zaXplID0gaSArIDE7XG5cbiAgLy8gV3JpdGUgb3V0IHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUuXG4gICAgdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVtpXSAhPSAwID8gdnRhYmxlbG9jIC0gdGhpcy52dGFibGVbaV0gOiAwKTtcbiAgfVxuXG4gIHZhciBzdGFuZGFyZF9maWVsZHMgPSAyOyAvLyBUaGUgZmllbGRzIGJlbG93OlxuICB0aGlzLmFkZEludDE2KHZ0YWJsZWxvYyAtIHRoaXMub2JqZWN0X3N0YXJ0KTtcbiAgdmFyIGxlbiA9ICh0cmltbWVkX3NpemUgKyBzdGFuZGFyZF9maWVsZHMpICogZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUO1xuICB0aGlzLmFkZEludDE2KGxlbik7XG5cbiAgLy8gU2VhcmNoIGZvciBhbiBleGlzdGluZyB2dGFibGUgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIGV4aXN0aW5nX3Z0YWJsZSA9IDA7XG4gIHZhciB2dDEgPSB0aGlzLnNwYWNlO1xub3V0ZXJfbG9vcDpcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMudnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2dDIgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgaWYgKGxlbiA9PSB0aGlzLmJiLnJlYWRJbnQxNih2dDIpKSB7XG4gICAgICBmb3IgKHZhciBqID0gZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUOyBqIDwgbGVuOyBqICs9IGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVCkge1xuICAgICAgICBpZiAodGhpcy5iYi5yZWFkSW50MTYodnQxICsgaikgIT0gdGhpcy5iYi5yZWFkSW50MTYodnQyICsgaikpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcl9sb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBleGlzdGluZ192dGFibGUgPSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpc3RpbmdfdnRhYmxlKSB7XG4gICAgLy8gRm91bmQgYSBtYXRjaDpcbiAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2M7XG5cbiAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXG4gICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UsIGV4aXN0aW5nX3Z0YWJsZSAtIHZ0YWJsZWxvYyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gbWF0Y2g6XG4gICAgLy8gQWRkIHRoZSBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCB2dGFibGUgdG8gdGhlIGxpc3Qgb2YgdnRhYmxlcy5cbiAgICB0aGlzLnZ0YWJsZXMucHVzaCh0aGlzLm9mZnNldCgpKTtcblxuICAgIC8vIFBvaW50IHRhYmxlIHRvIGN1cnJlbnQgdnRhYmxlLlxuICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2MsIHRoaXMub2Zmc2V0KCkgLSB2dGFibGVsb2MpO1xuICB9XG5cbiAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuICByZXR1cm4gdnRhYmxlbG9jO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEZpbmFsaXplIGEgYnVmZmVyLCBwb2l0aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHJvb3RfdGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2ZpbGVfaWRlbnRpZmllclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpemVfcHJlZml4XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIG9wdF9zaXplX3ByZWZpeCkge1xuICB2YXIgc2l6ZV9wcmVmaXggPSBvcHRfc2l6ZV9wcmVmaXggPyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEggOiAwO1xuICBpZiAob3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICAgIHZhciBmaWxlX2lkZW50aWZpZXIgPSBvcHRfZmlsZV9pZGVudGlmaWVyO1xuICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICtcbiAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XG4gICAgaWYgKGZpbGVfaWRlbnRpZmllci5sZW5ndGggIT0gZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy53cml0ZUludDgoZmlsZV9pZGVudGlmaWVyLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArIHNpemVfcHJlZml4KTtcbiAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XG4gIGlmIChzaXplX3ByZWZpeCkge1xuICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XG4gIH1cbiAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKTtcbn07XG5cbi8qKlxuICogRmluYWxpemUgYSBzaXplIHByZWZpeGVkIGJ1ZmZlciwgcG9pbnRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gcm9vdF90YWJsZVxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfZmlsZV9pZGVudGlmaWVyXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaFNpemVQcmVmaXhlZCA9IGZ1bmN0aW9uIChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XG4gIHRoaXMuZmluaXNoKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIHRydWUpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcbiAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cbiAqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gdGFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkID0gZnVuY3Rpb24odGFibGUsIGZpZWxkKSB7XG4gIHZhciB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xuICB2YXIgdnRhYmxlX3N0YXJ0ID0gdGFibGVfc3RhcnQgLSB0aGlzLmJiLnJlYWRJbnQzMih0YWJsZV9zdGFydCk7XG4gIHZhciBvayA9IHRoaXMuYmIucmVhZEludDE2KHZ0YWJsZV9zdGFydCArIGZpZWxkKSAhPSAwO1xuXG4gIC8vIElmIHRoaXMgZmFpbHMsIHRoZSBjYWxsZXIgd2lsbCBzaG93IHdoYXQgZmllbGQgbmVlZHMgdG8gYmUgc2V0LlxuICBpZiAoIW9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmllbGQgJyArIGZpZWxkICsgJyBtdXN0IGJlIHNldCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0IGEgbmV3IGFycmF5L3ZlY3RvciBvZiBvYmplY3RzLiAgVXNlcnMgdXN1YWxseSB3aWxsIG5vdCBjYWxsXG4gKiB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBjcmVhdGUgYSBzdGFydC9lbmRcbiAqIG1ldGhvZCBmb3IgdmVjdG9yIHR5cGVzIGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbGVtX3NpemUgVGhlIHNpemUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IG51bV9lbGVtcyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGFsaWdubWVudCBUaGUgYWxpZ25tZW50IG9mIHRoZSBhcnJheVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5zdGFydFZlY3RvciA9IGZ1bmN0aW9uKGVsZW1fc2l6ZSwgbnVtX2VsZW1zLCBhbGlnbm1lbnQpIHtcbiAgdGhpcy5ub3ROZXN0ZWQoKTtcbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gbnVtX2VsZW1zO1xuICB0aGlzLnByZXAoZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTtcbiAgdGhpcy5wcmVwKGFsaWdubWVudCwgZWxlbV9zaXplICogbnVtX2VsZW1zKTsgLy8gSnVzdCBpbiBjYXNlIGFsaWdubWVudCA+IGludC5cbn07XG5cbi8qKlxuICogRmluaXNoIG9mZiB0aGUgY3JlYXRpb24gb2YgYW4gYXJyYXkgYW5kIGFsbCBpdHMgZWxlbWVudHMuIFRoZSBhcnJheSBtdXN0IGJlXG4gKiBjcmVhdGVkIHdpdGggYHN0YXJ0VmVjdG9yYC5cbiAqXG4gKiBAcmV0dXJucyB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBuZXdseSBjcmVhdGVkIGFycmF5XG4gKiBzdGFydHMuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmVuZFZlY3RvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKTtcbiAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG59O1xuLy8vIEBlbmRjb25kXG5cbi8qKlxuICogRW5jb2RlIHRoZSBzdHJpbmcgYHNgIGluIHRoZSBidWZmZXIgdXNpbmcgVVRGLTguIElmIGEgVWludDhBcnJheSBpcyBwYXNzZWRcbiAqIGluc3RlYWQgb2YgYSBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gY29udGFpbiB2YWxpZCBVVEYtOCBlbmNvZGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHZhciB1dGY4ID0gcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdXRmOCA9IFtdO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQ7XG5cbiAgICAgIC8vIERlY29kZSBVVEYtMTZcbiAgICAgIHZhciBhID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYSA8IDB4RDgwMCB8fCBhID49IDB4REMwMCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGIgPSBzLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xuICAgICAgfVxuXG4gICAgICAvLyBFbmNvZGUgVVRGLThcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgIHV0ZjgucHVzaChjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwLFxuICAgICAgICAgICAgICAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1dGY4LnB1c2goKChjb2RlUG9pbnQgPj4gNikgJiAweDNGKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIHV0ZjgucHVzaCgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmFkZEludDgoMCk7XG4gIHRoaXMuc3RhcnRWZWN0b3IoMSwgdXRmOC5sZW5ndGgsIDEpO1xuICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdXRmOC5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbb2Zmc2V0KytdID0gdXRmOFtpXTtcbiAgfVxuICByZXR1cm4gdGhpcy5lbmRWZWN0b3IoKTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8gQGNvbmQgRkxBVEJVRkZFUlNfSU5URVJOQUxcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEJ5dGVCdWZmZXIgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGJ5dGVzIChgVWludDhBcnJheWApLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5ieXRlc18gPSBieXRlcztcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucG9zaXRpb25fID0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCBhbGxvY2F0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBzaXplLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlX3NpemVcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5hbGxvY2F0ZSA9IGZ1bmN0aW9uKGJ5dGVfc2l6ZSkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZV9zaXplKSk7XG59O1xuXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdW5kZXJseWluZyBgVWludDhBcnJheWAuXG4gKlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzXztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wb3NpdGlvbl87XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdGhpcy5wb3NpdGlvbl8gPSBwb3NpdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBidWZmZXIncyBjYXBhY2l0eS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkVWludDgob2Zmc2V0KSA8PCAyNCA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVpbnQxNihvZmZzZXQpIDw8IDE2ID4+IDE2O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDJdIDw8IDE2IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPDwgMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCkgPj4+IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiBuZXcgZmxhdGJ1ZmZlcnMuTG9uZyh0aGlzLnJlYWRJbnQzMihvZmZzZXQpLCB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkxvbmcodGhpcy5yZWFkVWludDMyKG9mZnNldCksIHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyWzBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0MzJbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGZsYXRidWZmZXJzLmludDMyW2ZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID8gMCA6IDFdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIGZsYXRidWZmZXJzLmZsb2F0NjRbMF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPSB2YWx1ZSA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiAxNjtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+IDI0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlLmxvdyk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgdmFsdWUubG93KTtcbiAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCArIDQsIHZhbHVlLmhpZ2gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICBmbGF0YnVmZmVycy5mbG9hdDMyWzBdID0gdmFsdWU7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGZsYXRidWZmZXJzLmludDMyWzBdKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgZmxhdGJ1ZmZlcnMuZmxvYXQ2NFswXSA9IHZhbHVlO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSk7XG4gIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcbiAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXG4gKiBzdGFydCBvZiBhIHRoZSByb290IHZ0YWJsZSkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmJ5dGVzXy5sZW5ndGggPCB0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgK1xuICAgICAgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0ZsYXRCdWZmZXJzOiBCeXRlQnVmZmVyIGlzIHRvbyBzaG9ydCB0byBjb250YWluIGFuIGlkZW50aWZpZXIuJyk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICsgaSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIExvb2sgdXAgYSBmaWVsZCBpbiB0aGUgdnRhYmxlLCByZXR1cm4gYW4gb2Zmc2V0IGludG8gdGhlIG9iamVjdCwgb3IgMCBpZiB0aGVcbiAqIGZpZWxkIGlzIG5vdCBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYl9wb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB2dGFibGVfb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldCA9IGZ1bmN0aW9uKGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xuICB2YXIgdnRhYmxlID0gYmJfcG9zIC0gdGhpcy5yZWFkSW50MzIoYmJfcG9zKTtcbiAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5UYWJsZX0gdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLlRhYmxlfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3VuaW9uID0gZnVuY3Rpb24odCwgb2Zmc2V0KSB7XG4gIHQuYmJfcG9zID0gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgdC5iYiA9IHRoaXM7XG4gIHJldHVybiB0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBKYXZhU2NyaXB0IHN0cmluZyBmcm9tIFVURi04IGRhdGEgc3RvcmVkIGluc2lkZSB0aGUgRmxhdEJ1ZmZlci5cbiAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxuICpcbiAqIFRvIGF2b2lkIHRoZSBjb252ZXJzaW9uIHRvIFVURi0xNiwgcGFzcyBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTIGFzXG4gKiB0aGUgXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHRvXG4gKiBhbmQgZnJvbSBVVEYtMTYgd2hlbiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyXG4gKiBGbGF0QnVmZmVyIGxhdGVyIG9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9fSBvcHRfZW5jb2RpbmcgRGVmYXVsdHMgdG8gVVRGMTZfU1RSSU5HXG4gKiBAcmV0dXJucyB7c3RyaW5nfCFVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XG4gIG9mZnNldCArPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuXG4gIHZhciBsZW5ndGggPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBpID0gMDtcblxuICBvZmZzZXQgKz0gZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVDtcblxuICBpZiAob3B0X2VuY29kaW5nID09PSBmbGF0YnVmZmVycy5FbmNvZGluZy5VVEY4X0JZVEVTKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgfVxuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGNvZGVQb2ludDtcblxuICAgIC8vIERlY29kZSBVVEYtOFxuICAgIHZhciBhID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICBpZiAoYSA8IDB4QzApIHtcbiAgICAgIGNvZGVQb2ludCA9IGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgIGlmIChhIDwgMHhFMCkge1xuICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICgoYSAmIDB4MUYpIDw8IDYpIHxcbiAgICAgICAgICAoYiAmIDB4M0YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICBpZiAoYSA8IDB4RjApIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICAgKChhICYgMHgwRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYiAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChjICYgMHgzRik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xuICAgICAgICAgIGNvZGVQb2ludCA9XG4gICAgICAgICAgICAoKGEgJiAweDA3KSA8PCAxOCkgfFxuICAgICAgICAgICAgKChiICYgMHgzRikgPDwgMTIpIHxcbiAgICAgICAgICAgICgoYyAmIDB4M0YpIDw8IDYpIHxcbiAgICAgICAgICAgIChkICYgMHgzRik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmNvZGUgVVRGLTE2XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwLFxuICAgICAgICAoY29kZVBvaW50ICYgKCgxIDw8IDEwKSAtIDEpKSArIDB4REMwMCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHJlbGF0aXZlIG9mZnNldCBzdG9yZWQgYXQgXCJvZmZzZXRcIlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19pbmRpcmVjdCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdGFydCBvZiBkYXRhIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3RvciA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQ7IC8vIGRhdGEgc3RhcnRzIGFmdGVyIHRoZSBsZW5ndGhcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3Igd2hvc2Ugb2Zmc2V0IGlzIHN0b3JlZCBhdCBcIm9mZnNldFwiIGluIHRoaXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faGFzX2lkZW50aWZpZXIgPSBmdW5jdGlvbihpZGVudCkge1xuICBpZiAoaWRlbnQubGVuZ3RoICE9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSDsgaSsrKSB7XG4gICAgaWYgKGlkZW50LmNoYXJDb2RlQXQoaSkgIT0gdGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXyArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgKyBpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYXZvaWQgZ2VuZXJhdGVkIGNvZGUgZGVwZW5kaW5nIG9uIHRoaXMgZmlsZSBkaXJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gIHJldHVybiBmbGF0YnVmZmVycy5Mb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xufTtcblxuLy8gRXhwb3J0cyBmb3IgTm9kZS5qcyBhbmQgUmVxdWlyZUpTXG5leHBvcnQgeyBmbGF0YnVmZmVycyB9O1xuXG4vLy8gQGVuZGNvbmRcbi8vLyBAfVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbnZhciBHdWlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR3VpZChndWlkKSB7XHJcbiAgICAgICAgaWYgKCFndWlkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50OyBgdmFsdWVgIGhhcyBubyB2YWx1ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWUgPSBHdWlkLkVNUFRZO1xyXG4gICAgICAgIGlmIChndWlkICYmIEd1aWQuaXNHdWlkKGd1aWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBndWlkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEd1aWQuaXNHdWlkID0gZnVuY3Rpb24gKGd1aWQpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBndWlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIGd1aWQgJiYgKGd1aWQgaW5zdGFuY2VvZiBHdWlkIHx8IEd1aWQudmFsaWRhdG9yLnRlc3QodmFsdWUpKTtcclxuICAgIH07XHJcbiAgICBHdWlkLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEd1aWQoW0d1aWQuZ2VuKDIpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigzKV0uam9pbihcIi1cIikpO1xyXG4gICAgfTtcclxuICAgIEd1aWQuY3JlYXRlRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWlkKFwiZW1wdHlndWlkXCIpO1xyXG4gICAgfTtcclxuICAgIEd1aWQucGFyc2UgPSBmdW5jdGlvbiAoZ3VpZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3VpZChndWlkKTtcclxuICAgIH07XHJcbiAgICBHdWlkLnJhdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW0d1aWQuZ2VuKDIpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigzKV0uam9pbihcIi1cIik7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5nZW4gPSBmdW5jdGlvbiAoY291bnQpIHtcclxuICAgICAgICB2YXIgb3V0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcclxuICAgICAgICAgICAgb3V0ICs9ICgoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApIHwgMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICBHdWlkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAvLyBDb21wYXJpbmcgc3RyaW5nIGB2YWx1ZWAgYWdhaW5zdCBwcm92aWRlZCBgZ3VpZGAgd2lsbCBhdXRvLWNhbGxcclxuICAgICAgICAvLyB0b1N0cmluZyBvbiBgZ3VpZGAgZm9yIGNvbXBhcmlzb25cclxuICAgICAgICByZXR1cm4gR3VpZC5pc0d1aWQob3RoZXIpICYmIHRoaXMudmFsdWUgPT09IG90aGVyLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gR3VpZC5FTVBUWTtcclxuICAgIH07XHJcbiAgICBHdWlkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBHdWlkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIEd1aWQudmFsaWRhdG9yID0gbmV3IFJlZ0V4cChcIl5bYS16MC05XXs4fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXs0fS1bYS16MC05XXsxMn0kXCIsIFwiaVwiKTtcclxuICAgIEd1aWQuRU1QVFkgPSBcIjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMFwiO1xyXG4gICAgcmV0dXJuIEd1aWQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuR3VpZCA9IEd1aWQ7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIiwiLyplc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBpZC1sZW5ndGgsIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1hZ2ljLW51bWJlcnMsIG5vLXByb3RvdHlwZS1idWlsdGlucywgbm8tcmVkZWNsYXJlLCBuby1zaGFkb3csIG5vLXZhciwgc29ydC12YXJzKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuXG4kcm9vdC5vbm54ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIG9ubnguXG4gICAgICogQGV4cG9ydHMgb25ueFxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICB2YXIgb25ueCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBlbnVtLlxuICAgICAqIEBuYW1lIG9ubnguVmVyc2lvblxuICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9TVEFSVF9WRVJTSU9OPTAgX1NUQVJUX1ZFUlNJT04gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE3XzEwXzEwPTEgSVJfVkVSU0lPTl8yMDE3XzEwXzEwIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxN18xMF8zMD0yIElSX1ZFUlNJT05fMjAxN18xMF8zMCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTdfMTFfMz0zIElSX1ZFUlNJT05fMjAxN18xMV8zIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxOV8xXzIyPTQgSVJfVkVSU0lPTl8yMDE5XzFfMjIgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTj01IElSX1ZFUlNJT04gdmFsdWVcbiAgICAgKi9cbiAgICBvbm54LlZlcnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJfU1RBUlRfVkVSU0lPTlwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJJUl9WRVJTSU9OXzIwMTdfMTBfMTBcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIklSX1ZFUlNJT05fMjAxN18xMV8zXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIklSX1ZFUlNJT05fMjAxOV8xXzIyXCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIklSX1ZFUlNJT05cIl0gPSA1O1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LkF0dHJpYnV0ZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGFuIEF0dHJpYnV0ZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gQXR0cmlidXRlUHJvdG8gbmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcmVmQXR0ck5hbWVdIEF0dHJpYnV0ZVByb3RvIHJlZkF0dHJOYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEF0dHJpYnV0ZVByb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZXxudWxsfSBbdHlwZV0gQXR0cmlidXRlUHJvdG8gdHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZl0gQXR0cmlidXRlUHJvdG8gZlxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtpXSBBdHRyaWJ1dGVQcm90byBpXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbc10gQXR0cmlidXRlUHJvdG8gc1xuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSVRlbnNvclByb3RvfG51bGx9IFt0XSBBdHRyaWJ1dGVQcm90byB0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ10gQXR0cmlidXRlUHJvdG8gZ1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtmbG9hdHNdIEF0dHJpYnV0ZVByb3RvIGZsb2F0c1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2ludHNdIEF0dHJpYnV0ZVByb3RvIGludHNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48VWludDhBcnJheT58bnVsbH0gW3N0cmluZ3NdIEF0dHJpYnV0ZVByb3RvIHN0cmluZ3NcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fG51bGx9IFt0ZW5zb3JzXSBBdHRyaWJ1dGVQcm90byB0ZW5zb3JzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSUdyYXBoUHJvdG8+fG51bGx9IFtncmFwaHNdIEF0dHJpYnV0ZVByb3RvIGdyYXBoc1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBBdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIEF0dHJpYnV0ZVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRzID0gW107XG4gICAgICAgICAgICB0aGlzLmludHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50ZW5zb3JzID0gW107XG4gICAgICAgICAgICB0aGlzLmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHJlZkF0dHJOYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHJlZkF0dHJOYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnJlZkF0dHJOYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byB0eXBlLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGV9IHR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudHlwZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGYuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5mID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gaS5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuaSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBzLlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnMgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byB0LlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklUZW5zb3JQcm90b3xudWxsfHVuZGVmaW5lZH0gdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gZy5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5nID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gZmxvYXRzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gZmxvYXRzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmZsb2F0cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGludHMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXJ8TG9uZz59IGludHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuaW50cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHN0cmluZ3MuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxVaW50OEFycmF5Pn0gc3RyaW5nc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zdHJpbmdzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gdGVuc29ycy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPn0gdGVuc29yc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50ZW5zb3JzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gZ3JhcGhzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JR3JhcGhQcm90bz59IGdyYXBoc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5ncmFwaHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEF0dHJpYnV0ZVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgNSA9Ki8yMSkuZmxvYXQobWVzc2FnZS5mKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLmludDY0KG1lc3NhZ2UuaSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5ieXRlcyhtZXNzYWdlLnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0XCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UudCwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJnXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5nLCB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mbG9hdHMgIT0gbnVsbCAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuZmxvYXQobWVzc2FnZS5mbG9hdHNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQ2NChtZXNzYWdlLmludHNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ3MgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDksIHdpcmVUeXBlIDIgPSovNzQpLmJ5dGVzKG1lc3NhZ2Uuc3RyaW5nc1tpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JzICE9IG51bGwgJiYgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS50ZW5zb3JzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLzgyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGhzICE9IG51bGwgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaHNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovOTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovMTA2KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDAgPSovMTYwKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyMSwgd2lyZVR5cGUgMiA9Ki8xNzApLnN0cmluZyhtZXNzYWdlLnJlZkF0dHJOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklBdHRyaWJ1dGVQcm90b30gbWVzc2FnZSBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVmQXR0ck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmYgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmkgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5mbG9hdHMgJiYgbWVzc2FnZS5mbG9hdHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0cy5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0cy5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmludHMgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50cy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdzICYmIG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50ZW5zb3JzICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29ycy5wdXNoKCRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZ3JhcGhzICYmIG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBocy5wdXNoKCRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5yZWZBdHRyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJlZkF0dHJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZlwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZiAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZjogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pKSAmJiAhKG1lc3NhZ2UuaSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImk6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzXCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucyAmJiB0eXBlb2YgbWVzc2FnZS5zLmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnMpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiczogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLnQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJnXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmcpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZsb2F0c1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmZsb2F0cykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZmxvYXRzW2ldICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXRzOiBudW1iZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnRzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW50cykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50c1tpXSkgJiYgIShtZXNzYWdlLmludHNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50c1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50czogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnN0cmluZ3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmluZ3NbaV0gJiYgdHlwZW9mIG1lc3NhZ2Uuc3RyaW5nc1tpXS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zdHJpbmdzW2ldKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdzOiBidWZmZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29ycyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudGVuc29ycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS50ZW5zb3JzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVuc29ycy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmdyYXBocyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncmFwaHNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ncmFwaHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJncmFwaHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmdyYXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZ3JhcGhzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JhcGhzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gQXR0cmlidXRlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZWZBdHRyTmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVmQXR0ck5hbWUgPSBTdHJpbmcob2JqZWN0LnJlZkF0dHJOYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiVU5ERUZJTkVEXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGTE9BVFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSU5UXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTVFJJTkdcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRFTlNPUlwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiR1JBUEhcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkZMT0FUU1wiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSU5UU1wiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU1RSSU5HU1wiOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVEVOU09SU1wiOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiR1JBUEhTXCI6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5mICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mID0gTnVtYmVyKG9iamVjdC5mKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmkpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pID0gcGFyc2VJbnQob2JqZWN0LmksIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IG9iamVjdC5pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pLmxvdyA+Pj4gMCwgb2JqZWN0LmkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnMsIG1lc3NhZ2UucyA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zKSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5zLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zID0gb2JqZWN0LnM7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5nICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5mbG9hdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZsb2F0cykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5mbG9hdHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzW2ldID0gTnVtYmVyKG9iamVjdC5mbG9hdHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pbnRzW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludHNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBwYXJzZUludChvYmplY3QuaW50c1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBvYmplY3QuaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRzW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnRzW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmludHNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5ncykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5ncykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmluZ3NbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zdHJpbmdzW2ldLCBtZXNzYWdlLnN0cmluZ3NbaV0gPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Quc3RyaW5nc1tpXSkpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnN0cmluZ3NbaV0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdzW2ldID0gb2JqZWN0LnN0cmluZ3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC50ZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnRlbnNvcnNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50ZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yc1tpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QudGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5ncmFwaHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmdyYXBocykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5ncmFwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZ3JhcGhzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhcGhzW2ldID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmdyYXBoc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5BdHRyaWJ1dGVQcm90b30gbWVzc2FnZSBBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0cyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5zID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiVU5ERUZJTkVEXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5yZWZBdHRyTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmYgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZikgPyBTdHJpbmcobWVzc2FnZS5mKSA6IG1lc3NhZ2UuZjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaVwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pKSA6IG1lc3NhZ2UuaTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmkpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaS5sb3cgPj4+IDAsIG1lc3NhZ2UuaS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5zID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnMsIDAsIG1lc3NhZ2Uucy5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnMpIDogbWVzc2FnZS5zO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJnXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mbG9hdHMgJiYgbWVzc2FnZS5mbG9hdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5mbG9hdHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdHNbal0gPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZmxvYXRzW2pdKSA/IFN0cmluZyhtZXNzYWdlLmZsb2F0c1tqXSkgOiBtZXNzYWdlLmZsb2F0c1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pbnRzW2pdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmludHNbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pbnRzW2pdKSA6IG1lc3NhZ2UuaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmludHNbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaW50c1tqXSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnRzW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5pbnRzW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmludHNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICYmIG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nc1tqXSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdzW2pdLCAwLCBtZXNzYWdlLnN0cmluZ3Nbal0ubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5zdHJpbmdzW2pdKSA6IG1lc3NhZ2Uuc3RyaW5nc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgJiYgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JzW2pdID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnRlbnNvcnNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGhzICYmIG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZ3JhcGhzW2pdID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZ3JhcGhzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW21lc3NhZ2UudHlwZV0gOiBtZXNzYWdlLnR5cGU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yZWZBdHRyTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucmVmQXR0ck5hbWUgPSBtZXNzYWdlLnJlZkF0dHJOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBBdHRyaWJ1dGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVR5cGUgZW51bS5cbiAgICAgICAgICogQG5hbWUgb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlXG4gICAgICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVD0yIElOVCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU1RSSU5HPTMgU1RSSU5HIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1I9NCBURU5TT1IgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdSQVBIPTUgR1JBUEggdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUUz02IEZMT0FUUyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSU5UUz03IElOVFMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklOR1M9OCBTVFJJTkdTIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1JTPTkgVEVOU09SUyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gR1JBUEhTPTEwIEdSQVBIUyB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiVU5ERUZJTkVEXCJdID0gMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJGTE9BVFwiXSA9IDE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiSU5UXCJdID0gMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJTVFJJTkdcIl0gPSAzO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIlRFTlNPUlwiXSA9IDQ7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiR1JBUEhcIl0gPSA1O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIkZMT0FUU1wiXSA9IDY7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs3XSA9IFwiSU5UU1wiXSA9IDc7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiU1RSSU5HU1wiXSA9IDg7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiVEVOU09SU1wiXSA9IDk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIkdSQVBIU1wiXSA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gQXR0cmlidXRlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVmFsdWVJbmZvUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBWYWx1ZUluZm9Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIFZhbHVlSW5mb1Byb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUeXBlUHJvdG98bnVsbH0gW3R5cGVdIFZhbHVlSW5mb1Byb3RvIHR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gVmFsdWVJbmZvUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFZhbHVlSW5mb1Byb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBWYWx1ZUluZm9Qcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBWYWx1ZUluZm9Qcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlSW5mb1Byb3RvIG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVJbmZvUHJvdG8gdHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB0eXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLnR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZUluZm9Qcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVmFsdWVJbmZvUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklWYWx1ZUluZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlSW5mb1Byb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UudHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVmFsdWVJbmZvUHJvdG8udHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5WYWx1ZUluZm9Qcm90b30gbWVzc2FnZSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmFsdWVJbmZvUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBWYWx1ZUluZm9Qcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5Ob2RlUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBOb2RlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSU5vZGVQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtpbnB1dF0gTm9kZVByb3RvIGlucHV0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW291dHB1dF0gTm9kZVByb3RvIG91dHB1dFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gTm9kZVByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW29wVHlwZV0gTm9kZVByb3RvIG9wVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBOb2RlUHJvdG8gZG9tYWluXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPnxudWxsfSBbYXR0cmlidXRlXSBOb2RlUHJvdG8gYXR0cmlidXRlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIE5vZGVQcm90byBkb2NTdHJpbmdcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTm9kZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBOb2RlUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElOb2RlUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOb2RlUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBpbnB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGlucHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUuaW5wdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gb3V0cHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gb3V0cHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUub3V0cHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gb3BUeXBlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG9wVHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLm9wVHlwZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBkb21haW4uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUuZG9tYWluID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIGF0dHJpYnV0ZS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUuYXR0cmlidXRlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIGRvY1N0cmluZy5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IE5vZGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklOb2RlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguTm9kZVByb3RvfSBOb2RlUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBOb2RlUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5Ob2RlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklOb2RlUHJvdG99IG1lc3NhZ2UgTm9kZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5pbnB1dFtpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXQgIT0gbnVsbCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuc3RyaW5nKG1lc3NhZ2Uub3BUeXBlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAhPSBudWxsICYmIG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShtZXNzYWdlLmF0dHJpYnV0ZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNywgd2lyZVR5cGUgMiA9Ki81OCkuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBOb2RlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5Ob2RlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklOb2RlUHJvdG99IG1lc3NhZ2UgTm9kZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgTm9kZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTm9kZVByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wVHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUucHVzaCgkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgTm9kZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIE5vZGVQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5pbnB1dFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm91dHB1dFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm9wVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9wVHlwZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb21haW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmF0dHJpYnV0ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KG1lc3NhZ2UuYXR0cmlidXRlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgTm9kZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguTm9kZVByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk5vZGVQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dFtpXSA9IFN0cmluZyhvYmplY3QuaW5wdXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFtpXSA9IFN0cmluZyhvYmplY3Qub3V0cHV0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm9wVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BUeXBlID0gU3RyaW5nKG9iamVjdC5vcFR5cGUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IFN0cmluZyhvYmplY3QuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5hdHRyaWJ1dGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmF0dHJpYnV0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5hdHRyaWJ1dGVbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlW2ldID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTm9kZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5Ob2RlUHJvdG99IG1lc3NhZ2UgTm9kZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcFR5cGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dFtqXSA9IG1lc3NhZ2UuaW5wdXRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXRbal0gPSBtZXNzYWdlLm91dHB1dFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvcFR5cGVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wVHlwZSA9IG1lc3NhZ2Uub3BUeXBlO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlICYmIG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlW2pdID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdChtZXNzYWdlLmF0dHJpYnV0ZVtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IG1lc3NhZ2UuZG9tYWluO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBOb2RlUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE5vZGVQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5Nb2RlbFByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTW9kZWxQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJTW9kZWxQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtpclZlcnNpb25dIE1vZGVsUHJvdG8gaXJWZXJzaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSU9wZXJhdG9yU2V0SWRQcm90bz58bnVsbH0gW29wc2V0SW1wb3J0XSBNb2RlbFByb3RvIG9wc2V0SW1wb3J0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtwcm9kdWNlck5hbWVdIE1vZGVsUHJvdG8gcHJvZHVjZXJOYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtwcm9kdWNlclZlcnNpb25dIE1vZGVsUHJvdG8gcHJvZHVjZXJWZXJzaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb21haW5dIE1vZGVsUHJvdG8gZG9tYWluXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW21vZGVsVmVyc2lvbl0gTW9kZWxQcm90byBtb2RlbFZlcnNpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gTW9kZWxQcm90byBkb2NTdHJpbmdcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklHcmFwaFByb3RvfG51bGx9IFtncmFwaF0gTW9kZWxQcm90byBncmFwaFxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbbWV0YWRhdGFQcm9wc10gTW9kZWxQcm90byBtZXRhZGF0YVByb3BzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1vZGVsUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIE1vZGVsUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElNb2RlbFByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE1vZGVsUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gaXJWZXJzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gaXJWZXJzaW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5pclZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBvcHNldEltcG9ydC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSU9wZXJhdG9yU2V0SWRQcm90bz59IG9wc2V0SW1wb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5vcHNldEltcG9ydCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gcHJvZHVjZXJOYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb2R1Y2VyTmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUucHJvZHVjZXJOYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBwcm9kdWNlclZlcnNpb24uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gcHJvZHVjZXJWZXJzaW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5wcm9kdWNlclZlcnNpb24gPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGRvbWFpbi5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb21haW5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gbW9kZWxWZXJzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gbW9kZWxWZXJzaW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5tb2RlbFZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGdyYXBoLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBncmFwaFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuZ3JhcGggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIG1ldGFkYXRhUHJvcHMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gbWV0YWRhdGFQcm9wc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUubWV0YWRhdGFQcm9wcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgTW9kZWxQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklNb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQ2NChtZXNzYWdlLmlyVmVyc2lvbik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UucHJvZHVjZXJOYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5wcm9kdWNlclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovMzQpLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMCA9Ki80MCkuaW50NjQobWVzc2FnZS5tb2RlbFZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZ3JhcGgsIHdyaXRlci51aW50MzIoLyogaWQgNywgd2lyZVR5cGUgMiA9Ki81OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUobWVzc2FnZS5vcHNldEltcG9ydFtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAhPSBudWxsICYmIG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUobWVzc2FnZS5tZXRhZGF0YVByb3BzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDE0LCB3aXJlVHlwZSAyID0qLzExNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklNb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgTW9kZWxQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguTW9kZWxQcm90b30gTW9kZWxQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Nb2RlbFByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQucHVzaCgkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb2R1Y2VyTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhcGggPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5tZXRhZGF0YVByb3BzICYmIG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIE1vZGVsUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pclZlcnNpb24pICYmICEobWVzc2FnZS5pclZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXJWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wc2V0SW1wb3J0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uub3BzZXRJbXBvcnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHNldEltcG9ydC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnByb2R1Y2VyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcm9kdWNlclZlcnNpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1vZGVsVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5tb2RlbFZlcnNpb24pICYmICEobWVzc2FnZS5tb2RlbFZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibW9kZWxWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5ncmFwaCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJncmFwaC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtZXRhZGF0YVByb3BzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UubWV0YWRhdGFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhZGF0YVByb3BzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguTW9kZWxQcm90b30gTW9kZWxQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54Lk1vZGVsUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTW9kZWxQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5pclZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaXJWZXJzaW9uID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmlyVmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pclZlcnNpb24gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gcGFyc2VJbnQob2JqZWN0LmlyVmVyc2lvbiwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlyVmVyc2lvbiA9IG9iamVjdC5pclZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pclZlcnNpb24gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pclZlcnNpb24ubG93ID4+PiAwLCBvYmplY3QuaXJWZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm9wc2V0SW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vcHNldEltcG9ydCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ub3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5vcHNldEltcG9ydC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vcHNldEltcG9ydFtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ub3BzZXRJbXBvcnQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydFtpXSA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm9wc2V0SW1wb3J0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnByb2R1Y2VyTmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvZHVjZXJOYW1lID0gU3RyaW5nKG9iamVjdC5wcm9kdWNlck5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5wcm9kdWNlclZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiA9IFN0cmluZyhvYmplY3QucHJvZHVjZXJWZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1vZGVsVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5tb2RlbFZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QubW9kZWxWZXJzaW9uKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSBwYXJzZUludChvYmplY3QubW9kZWxWZXJzaW9uLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5tb2RlbFZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gb2JqZWN0Lm1vZGVsVmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0Lm1vZGVsVmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC5tb2RlbFZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmdyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ncmFwaCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5ncmFwaDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhcGggPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5tZXRhZGF0YVByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5tZXRhZGF0YVByb3BzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm1ldGFkYXRhUHJvcHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YVByb3BzW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm1ldGFkYXRhUHJvcHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBNb2RlbFByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguTW9kZWxQcm90b30gbWVzc2FnZSBNb2RlbFByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXJWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICBvYmplY3QucHJvZHVjZXJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QucHJvZHVjZXJWZXJzaW9uID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBoID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmlyVmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmlyVmVyc2lvbikgOiBtZXNzYWdlLmlyVmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaXJWZXJzaW9uKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmlyVmVyc2lvbi5sb3cgPj4+IDAsIG1lc3NhZ2UuaXJWZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmlyVmVyc2lvbjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyTmFtZSA9IG1lc3NhZ2UucHJvZHVjZXJOYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucHJvZHVjZXJWZXJzaW9uID0gbWVzc2FnZS5wcm9kdWNlclZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1vZGVsVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1vZGVsVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLm1vZGVsVmVyc2lvbikgOiBtZXNzYWdlLm1vZGVsVmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UubW9kZWxWZXJzaW9uKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLm1vZGVsVmVyc2lvbi5sb3cgPj4+IDAsIG1lc3NhZ2UubW9kZWxWZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLm1vZGVsVmVyc2lvbjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3BzZXRJbXBvcnQgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5vcHNldEltcG9ydFtqXSA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uub3BzZXRJbXBvcnRbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm1ldGFkYXRhUHJvcHNbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS5tZXRhZGF0YVByb3BzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgTW9kZWxQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBNb2RlbFByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtrZXldIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt2YWx1ZV0gU3RyaW5nU3RyaW5nRW50cnlQcm90byB2YWx1ZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nU3RyaW5nRW50cnlQcm90byBrZXkuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS5rZXkgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS52YWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgU3RyaW5nU3RyaW5nRW50cnlQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IG1lc3NhZ2UgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmtleSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImtleTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gU3RyaW5nKG9iamVjdC5rZXkpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBTdHJpbmcob2JqZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gbWVzc2FnZSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBtZXNzYWdlLmtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gU3RyaW5nU3RyaW5nRW50cnlQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5UZW5zb3JBbm5vdGF0aW9uID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yQW5ub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdGVuc29yTmFtZV0gVGVuc29yQW5ub3RhdGlvbiB0ZW5zb3JOYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXSBUZW5zb3JBbm5vdGF0aW9uIHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yQW5ub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yQW5ub3RhdGlvbi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVGVuc29yQW5ub3RhdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yQW5ub3RhdGlvbiB0ZW5zb3JOYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRlbnNvck5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnRlbnNvck5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JBbm5vdGF0aW9uIHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gcXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5wcm90b3R5cGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvckFubm90YXRpb24ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JBbm5vdGF0aW9ufSBtZXNzYWdlIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS50ZW5zb3JOYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgIT0gbnVsbCAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb259IG1lc3NhZ2UgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JOYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRlbnNvck5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZW5zb3JOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVuc29yTmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yTmFtZSA9IFN0cmluZyhvYmplY3QudGVuc29yTmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBtZXNzYWdlIFRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QudGVuc29yTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvck5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvck5hbWUgPSBtZXNzYWdlLnRlbnNvck5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBUZW5zb3JBbm5vdGF0aW9uIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvckFubm90YXRpb247XG4gICAgfSkoKTtcblxuICAgIG9ubnguR3JhcGhQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUdyYXBoUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JTm9kZVByb3RvPnxudWxsfSBbbm9kZV0gR3JhcGhQcm90byBub2RlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBHcmFwaFByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fG51bGx9IFtpbml0aWFsaXplcl0gR3JhcGhQcm90byBpbml0aWFsaXplclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBHcmFwaFByb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW2lucHV0XSBHcmFwaFByb3RvIGlucHV0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbb3V0cHV0XSBHcmFwaFByb3RvIG91dHB1dFxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW3ZhbHVlSW5mb10gR3JhcGhQcm90byB2YWx1ZUluZm9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yQW5ub3RhdGlvbj58bnVsbH0gW3F1YW50aXphdGlvbkFubm90YXRpb25dIEdyYXBoUHJvdG8gcXVhbnRpemF0aW9uQW5ub3RhdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBHcmFwaFByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHcmFwaFByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJR3JhcGhQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBHcmFwaFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICB0aGlzLnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JTm9kZVByb3RvPn0gbm9kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUubm9kZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBpbml0aWFsaXplci5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPn0gaW5pdGlhbGl6ZXJcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemVyID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIGlucHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fSBpbnB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUuaW5wdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIG91dHB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPn0gb3V0cHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5vdXRwdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIHZhbHVlSW5mby5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPn0gdmFsdWVJbmZvXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS52YWx1ZUluZm8gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIHF1YW50aXphdGlvbkFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUZW5zb3JBbm5vdGF0aW9uPn0gcXVhbnRpemF0aW9uQW5ub3RhdGlvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JR3JhcGhQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdyYXBoUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHcmFwaFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguR3JhcGhQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvfSBtZXNzYWdlIEdyYXBoUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5Ob2RlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uubm9kZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5pbml0aWFsaXplcltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLzgyKS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2UuaW5wdXRbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovOTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXQgIT0gbnVsbCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUobWVzc2FnZS5vdXRwdXRbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTIsIHdpcmVUeXBlIDIgPSovOTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZUluZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZUluZm9baV0sIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovMTA2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDE0LCB3aXJlVHlwZSAyID0qLzExNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHcmFwaFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguR3JhcGhQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvfSBtZXNzYWdlIEdyYXBoUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguR3JhcGhQcm90b30gR3JhcGhQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5HcmFwaFByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbml0aWFsaXplciAmJiBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6ZXIucHVzaCgkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZhbHVlSW5mbyAmJiBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZUluZm8ucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLnB1c2goJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguR3JhcGhQcm90b30gR3JhcGhQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgR3JhcGhQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5vZGU6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8udmVyaWZ5KG1lc3NhZ2Uubm9kZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5vZGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemVyICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemVyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5pdGlhbGl6ZXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS5pbml0aWFsaXplcltpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluaXRpYWxpemVyLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkobWVzc2FnZS5pbnB1dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlucHV0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2Uub3V0cHV0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3V0cHV0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlSW5mb1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnZhbHVlSW5mbykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UudmFsdWVJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVJbmZvLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLnZlcmlmeShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb25baV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguR3JhcGhQcm90b30gR3JhcGhQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkdyYXBoUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguR3JhcGhQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5ub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5ub2RlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm5vZGVbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm5vZGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlW2ldID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8uZnJvbU9iamVjdChvYmplY3Qubm9kZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmluaXRpYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmluaXRpYWxpemVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemVyW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemVyW2ldID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbml0aWFsaXplcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmlucHV0W2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vdXRwdXRbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFtpXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3Qub3V0cHV0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlSW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVJbmZvKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlSW5mb1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvW2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZUluZm9baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgR3JhcGhQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LkdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qubm9kZSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplcltqXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXplcltqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXRbal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5wdXRbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0W2pdID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChtZXNzYWdlLm91dHB1dFtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZUluZm9bal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVJbmZvW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdID0gJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEdyYXBoUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gR3JhcGhQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5UZW5zb3JQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvclByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2RpbXNdIFRlbnNvclByb3RvIGRpbXNcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2RhdGFUeXBlXSBUZW5zb3JQcm90byBkYXRhVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR8bnVsbH0gW3NlZ21lbnRdIFRlbnNvclByb3RvIHNlZ21lbnRcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZmxvYXREYXRhXSBUZW5zb3JQcm90byBmbG9hdERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbaW50MzJEYXRhXSBUZW5zb3JQcm90byBpbnQzMkRhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48VWludDhBcnJheT58bnVsbH0gW3N0cmluZ0RhdGFdIFRlbnNvclByb3RvIHN0cmluZ0RhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtpbnQ2NERhdGFdIFRlbnNvclByb3RvIGludDY0RGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gVGVuc29yUHJvdG8gbmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBUZW5zb3JQcm90byBkb2NTdHJpbmdcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtyYXdEYXRhXSBUZW5zb3JQcm90byByYXdEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtleHRlcm5hbERhdGFdIFRlbnNvclByb3RvIGV4dGVybmFsRGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9ufG51bGx9IFtkYXRhTG9jYXRpb25dIFRlbnNvclByb3RvIGRhdGFMb2NhdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtkb3VibGVEYXRhXSBUZW5zb3JQcm90byBkb3VibGVEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcnxMb25nPnxudWxsfSBbdWludDY0RGF0YV0gVGVuc29yUHJvdG8gdWludDY0RGF0YVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUZW5zb3JQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVGVuc29yUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5kaW1zID0gW107XG4gICAgICAgICAgICB0aGlzLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBkaW1zLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBkaW1zXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRpbXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBkYXRhVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBkYXRhVHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kYXRhVHlwZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHNlZ21lbnQuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR8bnVsbHx1bmRlZmluZWR9IHNlZ21lbnRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuc2VnbWVudCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGZsb2F0RGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGZsb2F0RGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5mbG9hdERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBpbnQzMkRhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBpbnQzMkRhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuaW50MzJEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gc3RyaW5nRGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPFVpbnQ4QXJyYXk+fSBzdHJpbmdEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnN0cmluZ0RhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBpbnQ2NERhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXJ8TG9uZz59IGludDY0RGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5pbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGRvY1N0cmluZy5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gcmF3RGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gcmF3RGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5yYXdEYXRhID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZXh0ZXJuYWxEYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IGV4dGVybmFsRGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5leHRlcm5hbERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBkYXRhTG9jYXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9ufSBkYXRhTG9jYXRpb25cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZGF0YUxvY2F0aW9uID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZG91YmxlRGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGRvdWJsZURhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZG91YmxlRGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHVpbnQ2NERhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXJ8TG9uZz59IHVpbnQ2NERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUudWludDY0RGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvclByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmludDY0KG1lc3NhZ2UuZGltc1tpXSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQzMihtZXNzYWdlLmRhdGFUeXBlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNlZ21lbnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZW5jb2RlKG1lc3NhZ2Uuc2VnbWVudCwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmZsb2F0KG1lc3NhZ2UuZmxvYXREYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50MzIobWVzc2FnZS5pbnQzMkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLmJ5dGVzKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50NjQobWVzc2FnZS5pbnQ2NERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDgsIHdpcmVUeXBlIDIgPSovNjYpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOSwgd2lyZVR5cGUgMiA9Ki83NCkuYnl0ZXMobWVzc2FnZS5yYXdEYXRhKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvdWJsZURhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84MikuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuZG91YmxlKG1lc3NhZ2UuZG91YmxlRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudWludDY0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50NjQobWVzc2FnZS51aW50NjREYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTIsIHdpcmVUeXBlIDIgPSovOTgpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leHRlcm5hbERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxMywgd2lyZVR5cGUgMiA9Ki8xMDYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTQsIHdpcmVUeXBlIDAgPSovMTEyKS5pbnQzMihtZXNzYWdlLmRhdGFMb2NhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRpbXMgJiYgbWVzc2FnZS5kaW1zLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhVHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VnbWVudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZmxvYXREYXRhICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGEucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGEucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnQzMkRhdGEgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YS5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YS5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmluZ0RhdGEgJiYgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW50NjREYXRhICYmIG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJhd0RhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5leHRlcm5hbERhdGEgJiYgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLnB1c2goJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YS5wdXNoKHJlYWRlci5kb3VibGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhLnB1c2gocmVhZGVyLmRvdWJsZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS51aW50NjREYXRhICYmIG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YS5wdXNoKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRpbXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW1zOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0pICYmICEobWVzc2FnZS5kaW1zW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbXM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRhdGFUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNlZ21lbnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnkobWVzc2FnZS5zZWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNlZ21lbnQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmbG9hdERhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdERhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmbG9hdERhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZsb2F0RGF0YVtpXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0RGF0YTogbnVtYmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludDMyRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnQzMkRhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQzMkRhdGFbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nRGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnN0cmluZ0RhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmluZ0RhdGFbaV0gJiYgdHlwZW9mIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zdHJpbmdEYXRhW2ldKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdEYXRhOiBidWZmZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImludDY0RGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmludDY0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDY0RGF0YVtpXSkgJiYgIShtZXNzYWdlLmludDY0RGF0YVtpXSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucmF3RGF0YSAmJiB0eXBlb2YgbWVzc2FnZS5yYXdEYXRhLmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnJhd0RhdGEpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmF3RGF0YTogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leHRlcm5hbERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXh0ZXJuYWxEYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImV4dGVybmFsRGF0YS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFMb2NhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmRhdGFMb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGFMb2NhdGlvbjogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvdWJsZURhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG91YmxlRGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRvdWJsZURhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZG91YmxlRGF0YVtpXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvdWJsZURhdGE6IG51bWJlcltdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInVpbnQ2NERhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS51aW50NjREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS51aW50NjREYXRhW2ldKSAmJiAhKG1lc3NhZ2UudWludDY0RGF0YVtpXSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS51aW50NjREYXRhW2ldLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudWludDY0RGF0YVtpXS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1aW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZGltcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGltcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRpbXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuZGltc1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kaW1zW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gcGFyc2VJbnQob2JqZWN0LmRpbXNbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gb2JqZWN0LmRpbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltc1tpXSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGltc1tpXS5sb3cgPj4+IDAsIG9iamVjdC5kaW1zW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRhdGFUeXBlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhVHlwZSA9IG9iamVjdC5kYXRhVHlwZSB8IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNlZ21lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNlZ21lbnQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnNlZ21lbnQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZnJvbU9iamVjdChvYmplY3Quc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmZsb2F0RGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZmxvYXREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmZsb2F0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGFbaV0gPSBOdW1iZXIob2JqZWN0LmZsb2F0RGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmludDMyRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuaW50MzJEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmludDMyRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGFbaV0gPSBvYmplY3QuaW50MzJEYXRhW2ldIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5nRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5nRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnN0cmluZ0RhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmluZ0RhdGFbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zdHJpbmdEYXRhW2ldLCBtZXNzYWdlLnN0cmluZ0RhdGFbaV0gPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Quc3RyaW5nRGF0YVtpXSkpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnN0cmluZ0RhdGFbaV0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhW2ldID0gb2JqZWN0LnN0cmluZ0RhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmludDY0RGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuaW50NjREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pbnQ2NERhdGFbaV0gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuaW50NjREYXRhW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnQ2NERhdGFbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YVtpXSA9IHBhcnNlSW50KG9iamVjdC5pbnQ2NERhdGFbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnQ2NERhdGFbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YVtpXSA9IG9iamVjdC5pbnQ2NERhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmludDY0RGF0YVtpXS5sb3cgPj4+IDAsIG9iamVjdC5pbnQ2NERhdGFbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yYXdEYXRhICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucmF3RGF0YSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QucmF3RGF0YSwgbWVzc2FnZS5yYXdEYXRhID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LnJhd0RhdGEpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnJhd0RhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJhd0RhdGEgPSBvYmplY3QucmF3RGF0YTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5leHRlcm5hbERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmV4dGVybmFsRGF0YVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5leHRlcm5hbERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0LmRhdGFMb2NhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcIkRFRkFVTFRcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRVhURVJOQUxcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvdWJsZURhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmRvdWJsZURhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kb3VibGVEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5kb3VibGVEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvdWJsZURhdGFbaV0gPSBOdW1iZXIob2JqZWN0LmRvdWJsZURhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC51aW50NjREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC51aW50NjREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8udWludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudWludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS51aW50NjREYXRhW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LnVpbnQ2NERhdGFbaV0pKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudWludDY0RGF0YVtpXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YVtpXSA9IHBhcnNlSW50KG9iamVjdC51aW50NjREYXRhW2ldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudWludDY0RGF0YVtpXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YVtpXSA9IG9iamVjdC51aW50NjREYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LnVpbnQ2NERhdGFbaV0ubG93ID4+PiAwLCBvYmplY3QudWludDY0RGF0YVtpXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90b30gbWVzc2FnZSBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludDMyRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhVHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNlZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucmF3RGF0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5yYXdEYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRhdGFMb2NhdGlvbiA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiREVGQVVMVFwiIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgJiYgbWVzc2FnZS5kaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kaW1zW2pdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbXNbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5kaW1zW2pdKSA6IG1lc3NhZ2UuZGltc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbXNbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGltc1tqXSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kaW1zW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5kaW1zW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmRpbXNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZGF0YVR5cGUgPSBtZXNzYWdlLmRhdGFUeXBlO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5zZWdtZW50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnRvT2JqZWN0KG1lc3NhZ2Uuc2VnbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mbG9hdERhdGEgJiYgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdERhdGFbal0gPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZmxvYXREYXRhW2pdKSA/IFN0cmluZyhtZXNzYWdlLmZsb2F0RGF0YVtqXSkgOiBtZXNzYWdlLmZsb2F0RGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludDMyRGF0YSAmJiBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmludDMyRGF0YVtqXSA9IG1lc3NhZ2UuaW50MzJEYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ0RhdGFbal0gPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uuc3RyaW5nRGF0YVtqXSwgMCwgbWVzc2FnZS5zdHJpbmdEYXRhW2pdLmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2Uuc3RyaW5nRGF0YVtqXSkgOiBtZXNzYWdlLnN0cmluZ0RhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgJiYgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pbnQ2NERhdGFbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaW50NjREYXRhW2pdKSA6IG1lc3NhZ2UuaW50NjREYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmludDY0RGF0YVtqXSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnQ2NERhdGFbal0ubG93ID4+PiAwLCBtZXNzYWdlLmludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pbnQ2NERhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yYXdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnJhd0RhdGEgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UucmF3RGF0YSwgMCwgbWVzc2FnZS5yYXdEYXRhLmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UucmF3RGF0YSkgOiBtZXNzYWdlLnJhd0RhdGE7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICYmIG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZG91YmxlRGF0YVtqXSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5kb3VibGVEYXRhW2pdKSA/IFN0cmluZyhtZXNzYWdlLmRvdWJsZURhdGFbal0pIDogbWVzc2FnZS5kb3VibGVEYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudWludDY0RGF0YSAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnVpbnQ2NERhdGFbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YVtqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnVpbnQ2NERhdGFbal0pIDogbWVzc2FnZS51aW50NjREYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YVtqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS51aW50NjREYXRhW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLnVpbnQ2NERhdGFbal0ubG93ID4+PiAwLCBtZXNzYWdlLnVpbnQ2NERhdGFbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtZXNzYWdlLnVpbnQ2NERhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4dGVybmFsRGF0YSAmJiBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVybmFsRGF0YVtqXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChtZXNzYWdlLmV4dGVybmFsRGF0YVtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhTG9jYXRpb24gPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblttZXNzYWdlLmRhdGFMb2NhdGlvbl0gOiBtZXNzYWdlLmRhdGFMb2NhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhVHlwZSBlbnVtLlxuICAgICAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlXG4gICAgICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQ4PTIgVUlOVDggdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDg9MyBJTlQ4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UMTY9NCBVSU5UMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDE2PTUgSU5UMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDMyPTYgSU5UMzIgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDY0PTcgSU5UNjQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklORz04IFNUUklORyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQk9PTD05IEJPT0wgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUMTY9MTAgRkxPQVQxNiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRE9VQkxFPTExIERPVUJMRSB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDMyPTEyIFVJTlQzMiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDY0PTEzIFVJTlQ2NCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDY0PTE0IENPTVBMRVg2NCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDEyOD0xNSBDT01QTEVYMTI4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCRkxPQVQxNj0xNiBCRkxPQVQxNiB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uRGF0YVR5cGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIlVOREVGSU5FRFwiXSA9IDA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiRkxPQVRcIl0gPSAxO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlVJTlQ4XCJdID0gMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJJTlQ4XCJdID0gMztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJVSU5UMTZcIl0gPSA0O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIklOVDE2XCJdID0gNTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJJTlQzMlwiXSA9IDY7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs3XSA9IFwiSU5UNjRcIl0gPSA3O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIlNUUklOR1wiXSA9IDg7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiQk9PTFwiXSA9IDk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIkZMT0FUMTZcIl0gPSAxMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExXSA9IFwiRE9VQkxFXCJdID0gMTE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMl0gPSBcIlVJTlQzMlwiXSA9IDEyO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTNdID0gXCJVSU5UNjRcIl0gPSAxMztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzE0XSA9IFwiQ09NUExFWDY0XCJdID0gMTQ7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNV0gPSBcIkNPTVBMRVgxMjhcIl0gPSAxNTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzE2XSA9IFwiQkZMT0FUMTZcIl0gPSAxNjtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgVGVuc29yUHJvdG8uU2VnbWVudCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgU2VnbWVudC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElTZWdtZW50XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtiZWdpbl0gU2VnbWVudCBiZWdpblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbZW5kXSBTZWdtZW50IGVuZFxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTZWdtZW50LlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNlZ21lbnQuXG4gICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJU2VnbWVudFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnQ9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gU2VnbWVudChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWdtZW50IGJlZ2luLlxuICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGJlZ2luXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5wcm90b3R5cGUuYmVnaW4gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWdtZW50IGVuZC5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBlbmRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LnByb3RvdHlwZS5lbmQgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFNlZ21lbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50IGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlZ21lbnQocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTZWdtZW50IG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudH0gbWVzc2FnZSBTZWdtZW50IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5iZWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW5kICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLmVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlZ21lbnQgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fSBtZXNzYWdlIFNlZ21lbnQgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZWdtZW50IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5kID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcmlmaWVzIGEgU2VnbWVudCBtZXNzYWdlLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmJlZ2luKSAmJiAhKG1lc3NhZ2UuYmVnaW4gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iZWdpbi5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJiZWdpbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW5kICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQpICYmICEobWVzc2FnZS5lbmQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZW5kLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZW5kLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVuZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBTZWdtZW50IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmJlZ2luICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuYmVnaW4gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuYmVnaW4pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IHBhcnNlSW50KG9iamVjdC5iZWdpbiwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IG9iamVjdC5iZWdpbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5iZWdpbiA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmVnaW4gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmJlZ2luLmxvdyA+Pj4gMCwgb2JqZWN0LmJlZ2luLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5lbmQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZW5kKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IHBhcnNlSW50KG9iamVjdC5lbmQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IG9iamVjdC5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZW5kID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmVuZC5sb3cgPj4+IDAsIG9iamVjdC5lbmQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU2VnbWVudCBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBtZXNzYWdlIFNlZ21lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJlZ2luID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbmQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbmQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmJlZ2luICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJlZ2luXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuYmVnaW4gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5iZWdpbikgOiBtZXNzYWdlLmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuYmVnaW4pIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuYmVnaW4ubG93ID4+PiAwLCBtZXNzYWdlLmJlZ2luLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmJlZ2luO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVuZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbmRcIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5lbmQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW5kID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZW5kKSA6IG1lc3NhZ2UuZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW5kID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmVuZCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5lbmQubG93ID4+PiAwLCBtZXNzYWdlLmVuZC5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5lbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgdGhpcyBTZWdtZW50IHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFNlZ21lbnQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGFMb2NhdGlvbiBlbnVtLlxuICAgICAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblxuICAgICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gREVGQVVMVD0wIERFRkFVTFQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEVYVEVSTkFMPTEgRVhURVJOQUwgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLkRhdGFMb2NhdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiREVGQVVMVFwiXSA9IDA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiRVhURVJOQUxcIl0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gVGVuc29yUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yU2hhcGVQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvclNoYXBlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb24+fG51bGx9IFtkaW1dIFRlbnNvclNoYXBlUHJvdG8gZGltXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvclNoYXBlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvclNoYXBlUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvclNoYXBlUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5kaW0gPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yU2hhcGVQcm90byBkaW0uXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj59IGRpbVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5wcm90b3R5cGUuZGltID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBUZW5zb3JTaGFwZVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JTaGFwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yU2hhcGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JTaGFwZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG99IG1lc3NhZ2UgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbSAhPSBudWxsICYmIG1lc3NhZ2UuZGltLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZShtZXNzYWdlLmRpbVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JTaGFwZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG99IG1lc3NhZ2UgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW0gJiYgbWVzc2FnZS5kaW0ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltLnB1c2goJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kaW0pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW06IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeShtZXNzYWdlLmRpbVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZGltKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW0pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kaW0gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5kaW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGltW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1baV0gPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmZyb21PYmplY3Qob2JqZWN0LmRpbVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBtZXNzYWdlIFRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kaW0gPSBbXTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbSAmJiBtZXNzYWdlLmRpbS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRpbS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbVtqXSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udG9PYmplY3QobWVzc2FnZS5kaW1bal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBUZW5zb3JTaGFwZVByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIERpbWVuc2lvbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSURpbWVuc2lvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbZGltVmFsdWVdIERpbWVuc2lvbiBkaW1WYWx1ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RpbVBhcmFtXSBEaW1lbnNpb24gZGltUGFyYW1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBEaW1lbnNpb24gZGVub3RhdGlvblxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gRGltZW5zaW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiBkaW1WYWx1ZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBkaW1WYWx1ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24ucHJvdG90eXBlLmRpbVZhbHVlID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGltZW5zaW9uIGRpbVBhcmFtLlxuICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkaW1QYXJhbVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24ucHJvdG90eXBlLmRpbVBhcmFtID0gXCJcIjtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaW1lbnNpb24gZGVub3RhdGlvbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZGVub3RhdGlvblxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24ucHJvdG90eXBlLmRlbm90YXRpb24gPSBcIlwiO1xuXG4gICAgICAgICAgICAvLyBPbmVPZiBmaWVsZCBuYW1lcyBib3VuZCB0byB2aXJ0dWFsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAgICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGltZW5zaW9uIHZhbHVlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7XCJkaW1WYWx1ZVwifFwiZGltUGFyYW1cInx1bmRlZmluZWR9IHZhbHVlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaW1lbnNpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImRpbVZhbHVlXCIsIFwiZGltUGFyYW1cIl0pLFxuICAgICAgICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBEaW1lbnNpb24gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb24gaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaW1lbnNpb24ocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBEaW1lbnNpb24gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9ufSBtZXNzYWdlIERpbWVuc2lvbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5kaW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UuZGltUGFyYW0pO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgRGltZW5zaW9uIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbn0gbWVzc2FnZSBEaW1lbnNpb24gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIERpbWVuc2lvbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVZhbHVlID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1QYXJhbSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm90YXRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBEaW1lbnNpb24gbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbVZhbHVlKSAmJiAhKG1lc3NhZ2UuZGltVmFsdWUgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltVmFsdWUubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW1WYWx1ZTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVBhcmFtICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRpbVBhcmFtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbVBhcmFtOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZGVub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIERpbWVuc2lvbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmRpbVZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuZGltVmFsdWUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZGltVmFsdWUpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IHBhcnNlSW50KG9iamVjdC5kaW1WYWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IG9iamVjdC5kaW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1WYWx1ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltVmFsdWUgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmRpbVZhbHVlLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5kaW1QYXJhbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVBhcmFtID0gU3RyaW5nKG9iamVjdC5kaW1QYXJhbSk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5kZW5vdGF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub3RhdGlvbiA9IFN0cmluZyhvYmplY3QuZGVub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIERpbWVuc2lvbiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1WYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGltVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5kaW1WYWx1ZSkgOiBtZXNzYWdlLmRpbVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGltVmFsdWUpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZGltVmFsdWUubG93ID4+PiAwLCBtZXNzYWdlLmRpbVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmRpbVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImRpbVZhbHVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVBhcmFtICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1QYXJhbSA9IG1lc3NhZ2UuZGltUGFyYW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGltUGFyYW1cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGVub3RhdGlvbiA9IG1lc3NhZ2UuZGVub3RhdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIERpbWVuc2lvbiB0byBKU09OLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb247XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvclNoYXBlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVHlwZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVHlwZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUeXBlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx9IFt0ZW5zb3JUeXBlXSBUeXBlUHJvdG8gdGVuc29yVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZGVub3RhdGlvbl0gVHlwZVByb3RvIGRlbm90YXRpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVHlwZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUeXBlUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUeXBlUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBUeXBlUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gdGVuc29yVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcnxudWxsfHVuZGVmaW5lZH0gdGVuc29yVHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8ucHJvdG90eXBlLnRlbnNvclR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gZGVub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkZW5vdGF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUuZGVub3RhdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7XCJ0ZW5zb3JUeXBlXCJ8dW5kZWZpbmVkfSB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHlwZVByb3RvLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcInRlbnNvclR5cGVcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFR5cGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUeXBlUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmVuY29kZShtZXNzYWdlLnRlbnNvclR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLnN0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFR5cGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVHlwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90b30gVHlwZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFR5cGVQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnkobWVzc2FnZS50ZW5zb3JUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVuc29yVHlwZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZGVub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90b30gVHlwZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlbnNvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnRlbnNvclR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by50ZW5zb3JUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmZyb21PYmplY3Qob2JqZWN0LnRlbnNvclR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kZW5vdGF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUeXBlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRlbm90YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QobWVzc2FnZS50ZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwidGVuc29yVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBUeXBlUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgVHlwZVByb3RvLlRlbnNvciA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtlbGVtVHlwZV0gVGVuc29yIGVsZW1UeXBlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSVRlbnNvclNoYXBlUHJvdG98bnVsbH0gW3NoYXBlXSBUZW5zb3Igc2hhcGVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUZW5zb3IuXG4gICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBUZW5zb3IocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGVuc29yIGVsZW1UeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBlbGVtVHlwZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5wcm90b3R5cGUuZWxlbVR5cGUgPSAwO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbnNvciBzaGFwZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclNoYXBlUHJvdG98bnVsbHx1bmRlZmluZWR9IHNoYXBlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnByb3RvdHlwZS5zaGFwZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBUZW5zb3IgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3IgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yfSBtZXNzYWdlIFRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobWVzc2FnZS5zaGFwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3IgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yfSBtZXNzYWdlIFRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3JcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcmlmaWVzIGEgVGVuc29yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbGVtVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkobWVzc2FnZS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNoYXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lbGVtVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gb2JqZWN0LmVsZW1UeXBlIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2hhcGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hhcGUgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVGVuc29yIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IG1lc3NhZ2UgVGVuc29yXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbGVtVHlwZSA9IG1lc3NhZ2UuZWxlbVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChtZXNzYWdlLnNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFRlbnNvciB0byBKU09OLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFRlbnNvcjtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gVHlwZVByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54Lk9wZXJhdG9yU2V0SWRQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBPcGVyYXRvclNldElkUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSU9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBPcGVyYXRvclNldElkUHJvdG8gZG9tYWluXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW3ZlcnNpb25dIE9wZXJhdG9yU2V0SWRQcm90byB2ZXJzaW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE9wZXJhdG9yU2V0SWRQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIE9wZXJhdG9yU2V0SWRQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSU9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklPcGVyYXRvclNldElkUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE9wZXJhdG9yU2V0SWRQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZXJhdG9yU2V0SWRQcm90byBkb21haW4uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5wcm90b3R5cGUuZG9tYWluID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3BlcmF0b3JTZXRJZFByb3RvIHZlcnNpb24uXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSB2ZXJzaW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5wcm90b3R5cGUudmVyc2lvbiA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IE9wZXJhdG9yU2V0SWRQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklPcGVyYXRvclNldElkUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRvclNldElkUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklPcGVyYXRvclNldElkUHJvdG99IG1lc3NhZ2UgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDY0KG1lc3NhZ2UudmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvfSBtZXNzYWdlIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb21haW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudmVyc2lvbikgJiYgIShtZXNzYWdlLnZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudmVyc2lvbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UudmVyc2lvbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC52ZXJzaW9uKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnZlcnNpb24gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHBhcnNlSW50KG9iamVjdC52ZXJzaW9uLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBvYmplY3QudmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnZlcnNpb24gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguT3BlcmF0b3JTZXRJZFByb3RvfSBtZXNzYWdlIE9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52ZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52ZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UudmVyc2lvbikgOiBtZXNzYWdlLnZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS52ZXJzaW9uKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLnZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLnZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UudmVyc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgT3BlcmF0b3JTZXRJZFByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBPcGVyYXRvclNldElkUHJvdG87XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBvbm54O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSAkcm9vdDtcbiIsIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBleHBvcnRzO1xuXG4vKipcbiAqIEJ1aWxkIHR5cGUsIG9uZSBvZiBgXCJmdWxsXCJgLCBgXCJsaWdodFwiYCBvciBgXCJtaW5pbWFsXCJgLlxuICogQG5hbWUgYnVpbGRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xucHJvdG9idWYuQnVmZmVyV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyX2J1ZmZlclwiKTtcbnByb3RvYnVmLlJlYWRlciAgICAgICA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcbnByb3RvYnVmLnJwYyAgICAgICAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcbnByb3RvYnVmLnJvb3RzICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBSZWNvbmZpZ3VyZXMgdGhlIGxpYnJhcnkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICBwcm90b2J1Zi51dGlsLl9jb25maWd1cmUoKTtcbiAgICBwcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xuICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XG59XG5cbi8vIFNldCB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50XG5jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcbiAgICAgICAgOiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjY3Jvc3MgbW9kdWxlcy5cbiAqIEBuYW1lIHJvb3RzXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUm9vdD59XG4gKiBAZXhhbXBsZVxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXG4gKlxuICogLy8gaW4gYW5vdGhlciBtb2R1bGU6XG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcbiAqXG4gKiAvLyBpbiBhbnkgc3Vic2VxdWVudCBtb2R1bGU6XG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xuICovXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTG9uZ0JpdHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXG4gKiBAY2xhc3NkZXNjIEhlbHBlciBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbyBMb3cgMzIgYml0cywgdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXG4gKi9cbmZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcbiAgICAvLyBnZW5lcmF0ZWQgY29udmVydGVyIGNvZGUgbWlnaHQgc3RpbGwgY2FsbCB0aGUgY3RvciB3aXRoIHNpZ25lZCAzMmJpdHMuIGtlcHQgZm9yIGNvbXBhdC5cblxuICAgIC8qKlxuICAgICAqIExvdyBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuXG4gICAgLyoqXG4gICAgICogSGlnaCBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaSA9IGhpID4+PiAwO1xufVxuXG4vKipcbiAqIFplcm8gYml0cy5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7dXRpbC5Mb25nQml0c31cbiAqL1xudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG56ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcblxuLyoqXG4gKiBaZXJvIGhhc2guXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcbiAgICAgICAgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcbiAgICAgICAgICAgIGhpID0gfnRoaXMuaGkgICAgID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5Njtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBsb25nLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xuICAgICAgICA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbn07XG5cbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXG4gKi9cbkxvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcbiAgICAsXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICApO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xuICAgIHRoaXMuaGkgID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZGVjb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5oaSAgPSAoIHRoaXMuaGkgPj4+IDEgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBMZW5ndGhcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgcGFydDAgPSAgdGhpcy5sbyxcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcbiAgICByZXR1cm4gcGFydDIgPT09IDBcbiAgICAgICAgID8gcGFydDEgPT09IDBcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4ID8gNSA6IDZcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5hbWU7IH0gfSk7XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuXG4vLyBleHRlbmRzIFdyaXRlclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbn1cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxuICAgICAqL1xuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcblxuICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgICB9O1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0MCkgLy8gcGxhaW4ganMgaXMgZmFzdGVyIGZvciBzaG9ydCBzdHJpbmdzIChwcm9iYWJseSBkdWUgdG8gcmVkdW5kYW50IGFzc2VydGlvbnMpXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAbmFtZSBCdWZmZXJXcml0ZXIjZmluaXNoXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cbmltcG9ydCB7QmFja2VuZCwgSW5mZXJlbmNlU2Vzc2lvbiwgU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQge1Nlc3Npb259IGZyb20gJy4vb25ueGpzL3Nlc3Npb24nO1xuaW1wb3J0IHtPbm54anNTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi9vbm54anMvc2Vzc2lvbi1oYW5kbGVyJztcblxuY2xhc3MgT25ueGpzQmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIGFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHBhdGhPckJ1ZmZlcjogc3RyaW5nfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8U2Vzc2lvbkhhbmRsZXI+IHtcbiAgICAvLyBOT1RFOiBTZXNzaW9uLkNvbmZpZyhmcm9tIG9ubnguanMpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyhmcm9tXG4gICAgLy8gb25ueHJ1bnRpbWUtY29tbW9uKS5cbiAgICAvLyAgICAgICBJbiBmdXR1cmUgd2Ugc2hvdWxkIHJlbW92ZSBTZXNzaW9uLkNvbmZpZyBhbmQgdXNlIEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMuXG4gICAgLy8gICAgICAgQ3VycmVudGx5IHdlIGFsbG93IHRoaXMgdG8gaGFwcGVuIHRvIG1ha2UgdGVzdCBydW5uZXIgd29yay5cbiAgICBjb25zdCBzZXNzaW9uID0gbmV3IFNlc3Npb24ob3B0aW9ucyBhcyB1bmtub3duIGFzIFNlc3Npb24uQ29uZmlnKTtcblxuICAgIC8vIHR5cGVzY3JpcHQgY2Fubm90IG1lcmdlIG1ldGhvZCBvdmVycmlkZSBjb3JyZWN0bHkgKHNvIGZhciBpbiA0LjIuMykuIG5lZWQgaWYtZWxzZSB0byBjYWxsIHRoZSBtZXRob2QuXG4gICAgaWYgKHR5cGVvZiBwYXRoT3JCdWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT25ueGpzU2Vzc2lvbkhhbmRsZXIoc2Vzc2lvbik7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG9ubnhqc0JhY2tlbmQgPSBuZXcgT25ueGpzQmFja2VuZCgpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7cmVhZEZpbGV9IGZyb20gJ2ZzJztcbmltcG9ydCB7QmFja2VuZCwgZW52LCBJbmZlcmVuY2VTZXNzaW9uLCBTZXNzaW9uSGFuZGxlcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7Y3B1c30gZnJvbSAnb3MnO1xuaW1wb3J0IHtwcm9taXNpZnl9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQge09ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi93YXNtL3Nlc3Npb24taGFuZGxlcic7XG5pbXBvcnQge2luaXRpYWxpemVXZWJBc3NlbWJseX0gZnJvbSAnLi93YXNtL3dhc20tZmFjdG9yeSc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhbGwgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5LlxuICpcbiAqIFRob3NlIGZsYWdzIGFyZSBhY2Nlc3NpYmxlIGZyb20gYG9ydC5lbnYud2FzbWAuIFVzZXJzIGFyZSBhbGxvdyB0byBzZXQgdGhvc2UgZmxhZ3MgYmVmb3JlIHRoZSBmaXJzdCBpbmZlcmVuY2Ugc2Vzc2lvblxuICogYmVpbmcgY3JlYXRlZCwgdG8gb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVGbGFncyA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5pbml0VGltZW91dCAhPT0gJ251bWJlcicgfHwgZW52Lndhc20uaW5pdFRpbWVvdXQgPCAwKSB7XG4gICAgZW52Lndhc20uaW5pdFRpbWVvdXQgPSAwO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5zaW1kICE9PSAnYm9vbGVhbicpIHtcbiAgICBlbnYud2FzbS5zaW1kID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20ubnVtVGhyZWFkcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIoZW52Lndhc20ubnVtVGhyZWFkcykgfHwgZW52Lndhc20ubnVtVGhyZWFkcyA8PSAwKSB7XG4gICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID0gdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBjcHVzKCkubGVuZ3RoIDogbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICB9XG59O1xuXG5jbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICBhc3luYyBpbml0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHBvcHVsYXRlIHdhc20gZmxhZ3NcbiAgICBpbml0aWFsaXplRmxhZ3MoKTtcblxuICAgIC8vIGluaXQgd2FzbVxuICAgIGF3YWl0IGluaXRpYWxpemVXZWJBc3NlbWJseSgpO1xuICB9XG4gIGNyZWF0ZVNlc3Npb25IYW5kbGVyKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyPjtcbiAgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXI+O1xuICBhc3luYyBjcmVhdGVTZXNzaW9uSGFuZGxlcihwYXRoT3JCdWZmZXI6IHN0cmluZ3xVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFNlc3Npb25IYW5kbGVyPiB7XG4gICAgbGV0IGJ1ZmZlcjogVWludDhBcnJheTtcbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIG5vZGVcbiAgICAgICAgYnVmZmVyID0gYXdhaXQgcHJvbWlzaWZ5KHJlYWRGaWxlKShwYXRoT3JCdWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHBhdGhPckJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBwYXRoT3JCdWZmZXI7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIoKTtcbiAgICBoYW5kbGVyLmxvYWRNb2RlbChidWZmZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFuZGxlcik7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdhc21CYWNrZW5kID0gbmV3IE9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kKCk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuZXhwb3J0ICogZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7cmVnaXN0ZXJCYWNrZW5kfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0IHtvbm54anNCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtb25ueGpzJztcbmltcG9ydCB7d2FzbUJhY2tlbmR9IGZyb20gJy4vYmFja2VuZC13YXNtJztcblxucmVnaXN0ZXJCYWNrZW5kKCd3ZWJnbCcsIG9ubnhqc0JhY2tlbmQsIDEpO1xucmVnaXN0ZXJCYWNrZW5kKCd3YXNtJywgd2FzbUJhY2tlbmQsIDIpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IHtvbm54fSBmcm9tICdvbm54LXByb3RvJztcbmltcG9ydCB7b25ueHJ1bnRpbWV9IGZyb20gJy4vb3J0LXNjaGVtYS9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IHtMb25nVXRpbH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEF0dHJpYnV0ZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0OiBudW1iZXI7XG4gICAgaW50OiBudW1iZXI7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgdGVuc29yOiBUZW5zb3I7XG4gICAgZmxvYXRzOiBudW1iZXJbXTtcbiAgICBpbnRzOiBudW1iZXJbXTtcbiAgICBzdHJpbmdzOiBzdHJpbmdbXTtcbiAgICB0ZW5zb3JzOiBUZW5zb3JbXTtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbnR5cGUgVmFsdWVUeXBlcyA9IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFtBdHRyaWJ1dGUuRGF0YVR5cGVdO1xuXG50eXBlIFZhbHVlID0gW1ZhbHVlVHlwZXMsIEF0dHJpYnV0ZS5EYXRhVHlwZV07XG5cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGVzOiBvbm54LklBdHRyaWJ1dGVQcm90b1tdfG9ydEZicy5BdHRyaWJ1dGVbXXxudWxsfHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgIT09IG51bGwgJiYgYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChhdHRyLm5hbWUsIFtBdHRyaWJ1dGUuZ2V0VmFsdWUoYXR0ciksIEF0dHJpYnV0ZS5nZXRUeXBlKGF0dHIpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChhdHRyLm5hbWUoKSEsIFtBdHRyaWJ1dGUuZ2V0VmFsdWUoYXR0ciksIEF0dHJpYnV0ZS5nZXRUeXBlKGF0dHIpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzLnNpemUgPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZWQgYXR0cmlidXRlIG5hbWVzJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCB0eXBlOiBBdHRyaWJ1dGUuRGF0YVR5cGUsIHZhbHVlOiBWYWx1ZVR5cGVzKTogdm9pZCB7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5zZXQoa2V5LCBbdmFsdWUsIHR5cGVdKTtcbiAgfVxuICBkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGdldEZsb2F0KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2Zsb2F0J10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnZmxvYXQnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0SW50KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2ludCddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2ludCcsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRTdHJpbmcoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnc3RyaW5nJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnc3RyaW5nJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFRlbnNvcihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWyd0ZW5zb3InXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICd0ZW5zb3InLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0RmxvYXRzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2Zsb2F0cyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2Zsb2F0cycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRJbnRzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2ludHMnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdpbnRzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFN0cmluZ3Moa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnc3RyaW5ncyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3N0cmluZ3MnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0VGVuc29ycyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWyd0ZW5zb3JzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAndGVuc29ycycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGdldDxWIGV4dGVuZHMgQXR0cmlidXRlLkRhdGFUeXBlTWFwW0F0dHJpYnV0ZS5EYXRhVHlwZV0+KFxuICAgICAga2V5OiBzdHJpbmcsIHR5cGU6IEF0dHJpYnV0ZS5EYXRhVHlwZSwgZGVmYXVsdFZhbHVlPzogVik6IFYge1xuICAgIGNvbnN0IHZhbHVlQW5kVHlwZSA9IHRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlQW5kVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUFuZFR5cGVbMV0gIT09IHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0eXBlfSBidXQgZ290ICR7dmFsdWVBbmRUeXBlWzFdfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVBbmRUeXBlWzBdIGFzIFY7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUeXBlKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvfG9ydEZicy5BdHRyaWJ1dGUpOiBBdHRyaWJ1dGUuRGF0YVR5cGUge1xuICAgIGNvbnN0IHR5cGUgPSBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IChhdHRyKS50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuICd0ZW5zb3InO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0cyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gJ2ludHMnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmdzJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiAndGVuc29ycyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0OiAke29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0eXBlXX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZShhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90b3xvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgY29uc3QgYXR0clR5cGUgPSBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IGF0dHIudHlwZSA6IChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpLnR5cGUoKTtcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSCB8fCBhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVOb0NoZWNrKGF0dHIpO1xuXG4gICAgLy8gY2FzdCBMT05HIHRvIG51bWJlclxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVCAmJiBMb25nVXRpbC5pc0xvbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHZhbHVlIGFzIExvbmcgfCBmbGF0YnVmZmVycy5Mb25nKTtcbiAgICB9XG5cbiAgICAvLyBjYXN0IExPTkdbXSB0byBudW1iZXJbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpIHtcbiAgICAgIGNvbnN0IGFyciA9ICh2YWx1ZSBhcyBBcnJheTxudW1iZXJ8TG9uZ3xmbGF0YnVmZmVycy5Mb25nPik7XG4gICAgICBjb25zdCBudW1iZXJWYWx1ZTogbnVtYmVyW10gPSBuZXcgQXJyYXk8bnVtYmVyPihhcnIubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWF5YmVMb25nID0gYXJyW2ldO1xuICAgICAgICBudW1iZXJWYWx1ZVtpXSA9IExvbmdVdGlsLmxvbmdUb051bWJlcihtYXliZUxvbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY2FzdCBvbm54LlRlbnNvclByb3RvIHRvIG9ubnhqcy5UZW5zb3JcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpIHtcbiAgICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IFRlbnNvci5mcm9tUHJvdG8odmFsdWUgYXMgb25ueC5JVGVuc29yUHJvdG8pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlIGFzIG9ydEZicy5UZW5zb3IpO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90b1tdIHRvIG9ubnhqcy5UZW5zb3JbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpIHtcbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICBjb25zdCB0ZW5zb3JQcm90b3MgPSB2YWx1ZSBhcyBvbm54LklUZW5zb3JQcm90b1tdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCh2YWx1ZSA9PiBUZW5zb3IuZnJvbVByb3RvKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnN0IHRlbnNvclByb3RvcyA9IHZhbHVlIGFzIG9ydEZicy5UZW5zb3JbXTtcbiAgICAgICAgcmV0dXJuIHRlbnNvclByb3Rvcy5tYXAodmFsdWUgPT4gVGVuc29yLmZyb21PcnRUZW5zb3IodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYXN0IFVpbnQ4QXJyYXkgdG8gc3RyaW5nXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HKSB7XG4gICAgICAvLyBzdHJpbmcgaW4gb25ueCBhdHRyaWJ1dGUgaXMgb2YgdWludDhhcnJheSB0eXBlLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gc3RyaW5nIGJlbG93LiBXaGlsZSBpbiBvcnQgZm9ybWF0LFxuICAgICAgLy8gc3RyaW5nIGF0dHJpYnV0ZXMgYXJlIHJldHVybmVkIGFzIHN0cmluZywgc28gbm8gY29udmVyc2lvbiBpcyBuZWVkZWQuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdXRmOFN0cmluZyA9IHZhbHVlIGFzIFVpbnQ4QXJyYXk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh1dGY4U3RyaW5nLmJ1ZmZlciwgdXRmOFN0cmluZy5ieXRlT2Zmc2V0LCB1dGY4U3RyaW5nLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FzdCBVaW50OEFycmF5W10gdG8gc3RyaW5nW11cbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTKSB7XG4gICAgICAvLyBzdHJpbmdzIGluIG9ubnggYXR0cmlidXRlIGlzIHJldHVybmVkIGFzIHVpbnQ4YXJyYXlbXSwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHN0cmluZ1tdIGJlbG93LiBXaGlsZSBpbiBvcnRcbiAgICAgIC8vIGZvcm1hdCBzdHJpbmdzIGF0dHJpYnV0ZXMgYXJlIHJldHVybmVkIGFzIHN0cmluZ1tdLCBzbyBubyBjb252ZXJzaW9uIGlzIG5lZWRlZC5cbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICBjb25zdCB1dGY4U3RyaW5ncyA9IHZhbHVlIGFzIFVpbnQ4QXJyYXlbXTtcbiAgICAgICAgcmV0dXJuIHV0ZjhTdHJpbmdzLm1hcChcbiAgICAgICAgICAgIHV0ZjhTdHJpbmcgPT4gQnVmZmVyLmZyb20odXRmOFN0cmluZy5idWZmZXIsIHV0ZjhTdHJpbmcuYnl0ZU9mZnNldCwgdXRmOFN0cmluZy5ieXRlTGVuZ3RoKS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgYXMgVmFsdWVUeXBlcztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVjayhhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90b3xvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIGF0dHIgaW5zdGFuY2VvZiAob25ueC5BdHRyaWJ1dGVQcm90bykgPyB0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGF0dHIpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ubnhGb3JtYXQoYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG8pIHtcbiAgICBzd2l0Y2ggKGF0dHIudHlwZSEpIHtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOlxuICAgICAgICByZXR1cm4gYXR0ci5mO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gYXR0ci5pO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gYXR0ci5zO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SOlxuICAgICAgICByZXR1cm4gYXR0ci50O1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEg6XG4gICAgICAgIHJldHVybiBhdHRyLmc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmZsb2F0cztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmludHM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkdTOlxuICAgICAgICByZXR1cm4gYXR0ci5zdHJpbmdzO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpcbiAgICAgICAgcmV0dXJuIGF0dHIudGVuc29ycztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpcbiAgICAgICAgcmV0dXJuIGF0dHIuZ3JhcGhzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbYXR0ci50eXBlIV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWVOb0NoZWNrRnJvbU9ydEZvcm1hdChhdHRyOiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgc3dpdGNoIChhdHRyLnR5cGUoKSkge1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZigpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5JTlQ6XG4gICAgICAgIHJldHVybiBhdHRyLmkoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gYXR0ci5zKCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuIGF0dHIudCgpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5HUkFQSDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZygpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5GTE9BVFM6XG4gICAgICAgIHJldHVybiBhdHRyLmZsb2F0c0FycmF5KCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLklOVFM6IHtcbiAgICAgICAgY29uc3QgaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuaW50c0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICBpbnRzLnB1c2goYXR0ci5pbnRzKGkpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludHM7XG4gICAgICB9XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6IHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuc3RyaW5nc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goYXR0ci5zdHJpbmdzKGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncztcbiAgICAgIH1cbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzoge1xuICAgICAgICBjb25zdCB0ZW5zb3JzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ci50ZW5zb3JzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgICAgIHRlbnNvcnMucHVzaChhdHRyLnRlbnNvcnMoaSkhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29ycztcbiAgICAgIH1cbiAgICAgIC8vIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuR1JBUEhTOlxuICAgICAgLy8gVE9ETzogU3ViZ3JhcGggbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAvLyBjb25zdCBncmFwaHMgPSBbXTtcbiAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ci5ncmFwaHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAvLyAgIGdyYXBocy5wdXNoKGF0dHIuZ3JhcGhzKGkpISk7XG4gICAgICAvLyB9XG4gICAgICAvLyByZXR1cm4gZ3JhcGhzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHtvcnRGYnMuQXR0cmlidXRlVHlwZVthdHRyLnR5cGUoKV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hdHRyaWJ1dGVzOiBNYXA8c3RyaW5nLCBWYWx1ZT47XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtXZWJHTEJhY2tlbmR9IGZyb20gJy4vYmFja2VuZHMvYmFja2VuZC13ZWJnbCc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4vb3BlcmF0b3JzJztcbmltcG9ydCB7T3BTZXR9IGZyb20gJy4vb3BzZXQnO1xuaW1wb3J0IHtTZXNzaW9ufSBmcm9tICcuL3Nlc3Npb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZUhhbmRsZXIge1xuICAvKipcbiAgICogZGlzcG9zZSB0aGUgaW5mZXJlbmNlIGhhbmRsZXIuIGl0IHdpbGwgYmUgY2FsbGVkIGFzIHRoZSBsYXN0IHN0ZXAgaW4gU2Vzc2lvbi5ydW4oKVxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIHRyYW5zZm9ybSB0aGUgZ3JhcGggYXQgaW5pdGlhbGl6YXRpb24gdGltZVxuICAgKiBAcGFyYW0gZ3JhcGhUcmFuc2Zvcm1lciB0aGUgZ3JhcGggdHJhbnNmb3JtZXIgdG8gbWFuaXB1bGF0ZSB0aGUgbW9kZWwgZ3JhcGhcbiAgICovXG4gIHRyYW5zZm9ybUdyYXBoPyhncmFwaFRyYW5zZm9ybWVyOiBHcmFwaC5UcmFuc2Zvcm1lcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBJbmZlcmVuY2VIYW5kbGVyIHRvIHVzZSBpbiBhIFNlc3Npb24ucnVuKCkgY2FsbFxuICAgKi9cbiAgY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpOiBJbmZlcmVuY2VIYW5kbGVyO1xuXG4gIC8qKlxuICAgKiBkaXNwb3NlIHRoZSBzZXNzaW9uIGhhbmRsZXIuIGl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSBzZXNzaW9uIGlzIGJlaW5nIGRpc3Bvc2VkIGV4cGxpY2l0bHlcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIG9wZXJhdG9yIGZyb20gdGhlIG5hbWUgYW5kIG9wc2V0IHZlcnNpb247IGJhY2tlbmQgc3BlY2lmaWNcbiAgICogQHBhcmFtIG5vZGUgdGhlIG5vZGUgdG8gcmVzb2x2ZVxuICAgKiBAcGFyYW0gb3BzZXRzIGEgbGlzdCBvZiBvcHNldHMgdGhhdCBleHBvcnRlZCBmcm9tIHRoZSBtb2RlbFxuICAgKiBAcGFyYW0gZ3JhcGggdGhlIGNvbXBsZXRlbHkgaW5pdGlhbGl6ZWQgZ3JhcGhcbiAgICovXG4gIHJlc29sdmUobm9kZTogR3JhcGguTm9kZSwgb3BzZXRzOiByZWFkb25seSBPcFNldFtdLCBncmFwaDogR3JhcGgpOiBPcGVyYXRvcjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgbGV0J3MgdGhlIHNlc3Npb25IYW5kbGVyIGtub3cgdGhhdCB0aGUgZ3JhcGggaW5pdGlhbGl6YXRpb24gaXMgY29tcGxldGVcbiAgICogQHBhcmFtIGdyYXBoIHRoZSBjb21wbGV0ZWx5IGluaXRpYWxpemVkIGdyYXBoXG4gICAqL1xuICBvbkdyYXBoSW5pdGlhbGl6ZWQ/KGdyYXBoOiBHcmFwaCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JyZXNwb25kaW5nIGJhY2tlbmRcbiAgICovXG4gIHJlYWRvbmx5IGJhY2tlbmQ6IEJhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIGEgcmVmZXJlbmNlIHRvIHRoZSBzZXNzaW9uIGNvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYWNrZW5kIHtcbiAgLyoqXG4gICAqIGluaXRpYWxpemUgdGhlIGJhY2tlbmQuIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSwgd2hlbiB0aGUgZmlyc3QgdGltZSB0aGVcbiAgICogYmFja2VuZCBpdCB0byBiZSB1c2VkXG4gICAqL1xuICBpbml0aWFsaXplKCk6IGJvb2xlYW58UHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogY3JlYXRlIGFuIGluc3RhbmNlIG9mIFNlc3Npb25IYW5kbGVyIHRvIHVzZSBpbiBhIFNlc3Npb24gb2JqZWN0J3MgbGlmZWN5Y2xlXG4gICAqL1xuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpOiBTZXNzaW9uSGFuZGxlcjtcblxuICAvKipcbiAgICogZGlzcG9zZSB0aGUgYmFja2VuZC4gY3VycmVudGx5IHRoaXMgd2lsbCBub3QgYmUgY2FsbGVkXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbi8vIGNhY2hlcyBhbGwgaW5pdGlhbGl6ZWQgYmFja2VuZCBpbnN0YW5jZXNcbmNvbnN0IGJhY2tlbmRzQ2FjaGU6IE1hcDxzdHJpbmcsIEJhY2tlbmQ+ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY29uc3QgYmFja2VuZDoge1tuYW1lOiBzdHJpbmddOiBCYWNrZW5kfSA9IHtcbiAgd2ViZ2w6IG5ldyBXZWJHTEJhY2tlbmQoKSxcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlZmVyZW5jZSB0byB0aGUgYmFja2VuZC4gSWYgYSBoaW50IGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGJhY2tlbmQgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJhY2tlbmQoaGludD86IHN0cmluZ3xyZWFkb25seSBzdHJpbmdbXSk6IFByb21pc2U8QmFja2VuZD4ge1xuICBpZiAoIWhpbnQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUJhY2tlbmQoWyd3ZWJnbCddKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoaW50cyA9IHR5cGVvZiBoaW50ID09PSAnc3RyaW5nJyA/IFtoaW50XSA6IGhpbnQ7XG5cbiAgICBmb3IgKGNvbnN0IGJhY2tlbmRIaW50IG9mIGhpbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IGJhY2tlbmRzQ2FjaGUuZ2V0KGJhY2tlbmRIaW50KTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCB0cnlMb2FkQmFja2VuZChiYWNrZW5kSGludCk7XG4gICAgICBpZiAoYmFja2VuZCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ25vIGF2YWlsYWJsZSBiYWNrZW5kIHRvIHVzZScpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cnlMb2FkQmFja2VuZChiYWNrZW5kSGludDogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kfHVuZGVmaW5lZD4ge1xuICBjb25zdCBiYWNrZW5kT2JqID0gYmFja2VuZDtcblxuICBpZiAodHlwZW9mIGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdICE9PSAndW5kZWZpbmVkJyAmJiBpc0JhY2tlbmQoYmFja2VuZE9ialtiYWNrZW5kSGludF0pKSB7XG4gICAgY29uc3QgYmFja2VuZCA9IGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdO1xuICAgIGxldCBpbml0ID0gYmFja2VuZC5pbml0aWFsaXplKCk7XG4gICAgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gaW5pdCkge1xuICAgICAgaW5pdCA9IGF3YWl0IGluaXQ7XG4gICAgfVxuICAgIGlmIChpbml0KSB7XG4gICAgICBiYWNrZW5kc0NhY2hlLnNldChiYWNrZW5kSGludCwgYmFja2VuZCk7XG4gICAgICByZXR1cm4gYmFja2VuZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0JhY2tlbmQob2JqOiB1bmtub3duKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IG8gPSBvYmogYXMgYW55O1xuXG4gIC8vIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBhIEJhY2tlbmQgaW5zdGFuY2VcbiAgaWYgKFxuICAgICAgJ2luaXRpYWxpemUnIGluIG8gJiYgdHlwZW9mIG8uaW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplKClcbiAgICAgICdjcmVhdGVTZXNzaW9uSGFuZGxlcicgaW4gbyAmJiB0eXBlb2Ygby5jcmVhdGVTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJiAgLy8gY3JlYXRlU2Vzc2lvbkhhbmRsZXIoKVxuICAgICAgJ2Rpc3Bvc2UnIGluIG8gJiYgdHlwZW9mIG8uZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NlKClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tlbmRUeXBlID0gQmFja2VuZDtcbmV4cG9ydCB0eXBlIFNlc3Npb25IYW5kbGVyVHlwZSA9IFJldHVyblR5cGU8QmFja2VuZFR5cGVbJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJ10+O1xuZXhwb3J0IHR5cGUgSW5mZXJlbmNlSGFuZGxlclR5cGUgPSBSZXR1cm5UeXBlPFNlc3Npb25IYW5kbGVyVHlwZVsnY3JlYXRlSW5mZXJlbmNlSGFuZGxlciddPjtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7QmFja2VuZCwgU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtTZXNzaW9ufSBmcm9tICcuLi9zZXNzaW9uJztcblxuaW1wb3J0IHtXZWJHTFNlc3Npb25IYW5kbGVyfSBmcm9tICcuL3dlYmdsL3Nlc3Npb24taGFuZGxlcic7XG5pbXBvcnQge1dlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC93ZWJnbC1jb250ZXh0JztcbmltcG9ydCB7Y3JlYXRlV2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsL3dlYmdsLWNvbnRleHQtZmFjdG9yeSc7XG5cbi8qKlxuICogV2ViR0xCYWNrZW5kIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgYWxsIFdlYkdMIG9wZWFydGlvbnNcbiAqIFdoZW4gaXQgc3RhcnRzIGl0IGNyZWF0ZWQgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dFxuICogYW5kIG90aGVyIG1haW4gZnJhbWV3b3JrIGNvbXBvbmVudHMgc3VjaCBhcyBQcm9ncmFtIGFuZCBUZXh0dXJlIE1hbmFnZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTEJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQ7XG5cbiAgZ2V0IGNvbnRleHRJZCgpOiAnd2ViZ2wnfCd3ZWJnbDInfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC5jb250ZXh0SWQ7XG4gIH1cbiAgc2V0IGNvbnRleHRJZCh2YWx1ZTogJ3dlYmdsJ3wnd2ViZ2wyJ3x1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wuY29udGV4dElkID0gdmFsdWU7XG4gIH1cblxuICBnZXQgbWF0bXVsTWF4QmF0Y2hTaXplKCk6IG51bWJlcnx1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplO1xuICB9XG4gIHNldCBtYXRtdWxNYXhCYXRjaFNpemUodmFsdWU6IG51bWJlcnx1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wubWF0bXVsTWF4QmF0Y2hTaXplID0gdmFsdWU7XG4gIH1cblxuICBnZXQgdGV4dHVyZUNhY2hlTW9kZSgpOiAnaW5pdGlhbGl6ZXJPbmx5J3wnZnVsbCd8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLnRleHR1cmVDYWNoZU1vZGU7XG4gIH1cbiAgc2V0IHRleHR1cmVDYWNoZU1vZGUodmFsdWU6ICdpbml0aWFsaXplck9ubHknfCdmdWxsJ3x1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wudGV4dHVyZUNhY2hlTW9kZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHBhY2soKTogYm9vbGVhbnx1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wucGFjaztcbiAgfVxuICBzZXQgcGFjayh2YWx1ZTogYm9vbGVhbnx1bmRlZmluZWQpIHtcbiAgICBlbnYud2ViZ2wucGFjayA9IHZhbHVlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5nbENvbnRleHQgPSBjcmVhdGVXZWJHTENvbnRleHQodGhpcy5jb250ZXh0SWQpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5tYXRtdWxNYXhCYXRjaFNpemUgPSAxNjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy50ZXh0dXJlQ2FjaGVNb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZU1vZGUgPSAnZnVsbCc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMucGFjayAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMucGFjayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBMb2dnZXIuc2V0V2l0aEVudihlbnYpO1xuXG4gICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAnV2ViR0xCYWNrZW5kJyxcbiAgICAgICAgICBgQ3JlYXRlZCBXZWJHTENvbnRleHQ6ICR7dHlwZW9mIHRoaXMuZ2xDb250ZXh0fSB3aXRoIG1hdG11bE1heEJhdGNoU2l6ZTogJHtcbiAgICAgICAgICAgICAgdGhpcy5tYXRtdWxNYXhCYXRjaFNpemV9OyB0ZXh0dXJlQ2FjaGVNb2RlOiAke3RoaXMudGV4dHVyZUNhY2hlTW9kZX07IHBhY2s6ICR7dGhpcy5wYWNrfS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIExvZ2dlci53YXJuaW5nKCdXZWJHTEJhY2tlbmQnLCBgVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0xCYWNrZW5kLiAke2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVNlc3Npb25IYW5kbGVyKGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dCk6IFNlc3Npb25IYW5kbGVyIHtcbiAgICByZXR1cm4gbmV3IFdlYkdMU2Vzc2lvbkhhbmRsZXIodGhpcywgY29udGV4dCk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmdsQ29udGV4dC5kaXNwb3NlKCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0FycmF5VXRpbCwgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtzcXVlZXplU2hhcGV9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHtUZXh0dXJlTGF5b3V0fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7Z2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7Z2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMsfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIGdldFNxdWVlemVkUGFyYW1zLCBzcXVlZXplSW5wdXRTaGFwZX0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciBkYXRhIHR5cGVzIGFuZCByb3V0aW5lcyBmb3IgbWFuaXB1bGF0aW5nXG4gKiBjb29yZGluYXRlcyBhbmQgbWFwcGluZyB0by9mcm9tIHRlbnNvciBpbmRpY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBDb29yZHNHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIHJldHVyblR5cGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBHbHNsQ29udGV4dCkge1xuICAgIHN1cGVyKGNvbnRleHQpO1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMub2Zmc2V0VG9Db29yZHMoKSxcbiAgICAgIC4uLnRoaXMuY29vcmRzVG9PZmZzZXQoKSxcbiAgICAgIC4uLnRoaXMudG9WZWMoKSxcbiAgICAgIC4uLnRoaXMudmFsdWVGcm9tKCksXG4gICAgICAvLyBUT0RPIHJldHVybiB0aGVzZSBvbmx5IHdoZW4gcGFja2luZyBpcyBlbmFibGVkLlxuICAgICAgLi4udGhpcy5nZXRDb21tb25VdGlsRnVuY3MoKSxcbiAgICAgIC4uLnRoaXMuZ2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cygpLFxuICAgICAgLi4udGhpcy5nZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKVxuICAgIH07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIG1hcCBmcm9tXG4gICAqIDJEIG5vcm1hbHppZWQgY29vcmRpbmF0ZXMgKHMsdCkgdG8gYSBmbGF0IG9mZnNldFxuICAgKi9cbiAgcHJvdGVjdGVkIG9mZnNldFRvQ29vcmRzKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBmdW5jTmFtZSA9ICdvZmZzZXRUb0Nvb3Jkcyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldFRvQ29vcmRzOiBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiAke2Z1bmNOYW1lfShpbnQgb2Zmc2V0LCBpbnQgd2lkdGgsIGludCBoZWlnaHQpIHtcbiAgICAgICAgaW50IHQgPSBvZmZzZXQgLyB3aWR0aDtcbiAgICAgICAgaW50IHMgPSBvZmZzZXQgLSB0KndpZHRoO1xuICAgICAgICB2ZWMyIGNvb3JkcyA9ICh2ZWMyKHMsdCkgKyB2ZWMyKDAuNSwwLjUpKSAvIHZlYzIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgICB9XG4gICAgICBgKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBtYXAgZnJvbVxuICAgKiAyRCBub3JtYWx6aWVkIGNvb3JkaW5hdGVzIChzLHQpIHRvIGEgZmxhdCBvZmZzZXRcbiAgICovXG4gIHByb3RlY3RlZCBjb29yZHNUb09mZnNldCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSAnY29vcmRzVG9PZmZzZXQnO1xuICAgIHJldHVybiB7XG4gICAgICBjb29yZHNUb09mZnNldDogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIGludCAke2Z1bmNOYW1lfSh2ZWMyIGNvb3JkcywgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGZsb2F0IHMgPSBjb29yZHMucyAqIGZsb2F0KHdpZHRoKTtcbiAgICAgICAgZmxvYXQgdCA9IGNvb3Jkcy50ICogZmxvYXQoaGVpZ2h0KTtcbiAgICAgICAgaW50IG9mZnNldCA9IGludCh0KSAqIHdpZHRoICsgaW50KHMpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb2RlIGZvciBvdXRwdXQgc2FtcGxlci5cbiAgICovXG5cbiAgcHJvdGVjdGVkIGdldE91dHB1dFNhbXBsaW5nU25pcHBldCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLm91dHB1dExheW91dDtcbiAgICBpZiAob3V0cHV0TGF5b3V0LmlzUGFja2VkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0TGF5b3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0TGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIHBhY2tlZCBvdXRwdXQgc2FtcGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dFNoYXBlID0gb3V0cHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0VGV4U2hhcGUgPSBbb3V0cHV0TGF5b3V0LndpZHRoLCBvdXRwdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgY29uc3QgZnVuY05hbWUgPSAnZ2V0T3V0cHV0Q29vcmRzJztcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZDFEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZDJEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgICB0aGlzLmdldE91dHB1dFBhY2tlZDNEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkTkRDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIC8vIFRPRE8gd2UgbmVlZCB0aGlzIHRvIHByb3Blcmx5IHJldHVybiBhIHBhY2tlZCB2ZWM0IGZyb20ga2VybmVscy5cbiAgICAvLyBSZXBsYWNlIGFsbCAne2dsc2wub3V0cHV0fSA9IHJlc3VsdCcgd2l0aCAnc2V0T3V0cHV0KHJlc3VsdCknIGluIGFsbCBrZXJuZWxzLlxuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJHQkFTb3VyY2UgPSBgXG4gICAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZhbDtcbiAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJHQkFGdW5jTmFtZSA9ICdmbG9hdFRleHR1cmVTZXRSR0JBJztcbiAgICByZXN1bHRbZmxvYXRUZXh0dXJlU2V0UkdCQUZ1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShmbG9hdFRleHR1cmVTZXRSR0JBU291cmNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb2RlIGZvciB1bnBhY2tlZCBvdXRwdXQgc2FtcGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRUZXhTaGFwZSA9IFtvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBjb25zdCBmdW5jTmFtZSA9ICdnZXRPdXRwdXRDb29yZHMnO1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQyRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKFxuICAgICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhcbiAgICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhcbiAgICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQgZGltZW5zaW9uYWxpdHk6ICR7b3V0U2hhcGUubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIC8vIFRPRE8gd2UgbmVlZCB0aGlzIHRvIHByb3Blcmx5IHJldHVybiBhIHBhY2tlZCB2ZWM0IGZyb20ga2VybmVscy5cbiAgICAvLyBSZXBsYWNlIGFsbCAne2dsc2wub3V0cHV0fSA9IHJlc3VsdCcgd2l0aCAnc2V0T3V0cHV0KHJlc3VsdCknIGluIGFsbCBrZXJuZWxzLlxuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJTb3VyY2UgPSBgXG4gICAgICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xuICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCh2YWwsIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgYDtcbiAgICBjb25zdCBmbG9hdFRleHR1cmVTZXRSRnVuY05hbWUgPSAnZmxvYXRUZXh0dXJlU2V0Uic7XG4gICAgcmVzdWx0W2Zsb2F0VGV4dHVyZVNldFJGdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoZmxvYXRUZXh0dXJlU2V0UlNvdXJjZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsYXIgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFNjYWxhckNvb3JkcygpOiBHbHNsTGliUm91dGluZSB7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAxRCBwYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFBhY2tlZDFEQ29vcmRzKHNoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgaWYgKHBhY2tlZFRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy55ICogJHtwYWNrZWRUZXhTaGFwZVsxXX0uMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChwYWNrZWRUZXhTaGFwZVsxXSA9PT0gMSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7cGFja2VkVGV4U2hhcGVbMF19LjApO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogMkQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGlmIChBcnJheVV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihUZXhDb29yZHMueHkgKiB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgLy8gdGV4ZWxzIG5lZWRlZCB0byBhY2NvbW1vZGF0ZSBhIGxvZ2ljYWwgcm93XG4gICAgY29uc3QgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG5cbiAgICAvKipcbiAgICAgKiBnZXRPdXRwdXRDb29yZHNcbiAgICAgKlxuICAgICAqIHJlc1RleFJDOiBUaGUgcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgdGV4ZWxzLiBJZiB5b3UgbW92ZSBvdmVyIG9uZVxuICAgICAqIHRleGVsIHRvIHRoZSByaWdodCBpbiB0aGUgcGFja2VkIHRleHR1cmUsIHlvdSBhcmUgbW92aW5nIG92ZXIgb25lIGNvbHVtblxuICAgICAqIChub3QgdHdvKS5cbiAgICAgKlxuICAgICAqIGluZGV4OiBUaGUgdGV4ZWwgaW5kZXhcbiAgICAgKi9cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG5cbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogM0QgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke3RleGVsc0luQmF0Y2h9O1xuICAgICAgICAgIGluZGV4IC09IGIgKiAke3RleGVsc0luQmF0Y2h9O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogTkQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWRORENvb3JkcyhzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gW3RleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXV07XG5cbiAgICBjb25zdCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBNYXRoLmNlaWwoc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0gLyAyKTtcbiAgICBjb25zdCB0ZXhlbHNJbkJhdGNoID0gdGV4ZWxzSW5Mb2dpY2FsUm93ICogTWF0aC5jZWlsKHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdIC8gMik7XG4gICAgbGV0IHRleGVsc0luQmF0Y2hOID0gdGV4ZWxzSW5CYXRjaDtcbiAgICBsZXQgYmF0Y2hlcyA9ICcnO1xuICAgIGxldCBjb29yZHMgPSAnYiwgciwgYyc7XG5cbiAgICBmb3IgKGxldCBiID0gMjsgYiA8IHNoYXBlLmxlbmd0aCAtIDE7IGIrKykge1xuICAgICAgdGV4ZWxzSW5CYXRjaE4gKj0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gYiAtIDFdO1xuICAgICAgYmF0Y2hlcyA9IGBcbiAgICAgIGludCBiJHtifSA9IGluZGV4IC8gJHt0ZXhlbHNJbkJhdGNoTn07XG4gICAgICBpbmRleCAtPSBiJHtifSAqICR7dGV4ZWxzSW5CYXRjaE59O1xuICAgIGAgKyBiYXRjaGVzO1xuICAgICAgY29vcmRzID0gYGIke2J9LCBgICsgY29vcmRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICBpdmVjJHtzaGFwZS5sZW5ndGh9IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAke2JhdGNoZXN9XG5cbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7dGV4ZWxzSW5CYXRjaH07XG4gICAgICAgIGluZGV4IC09IGIgKiAke3RleGVsc0luQmF0Y2h9O1xuXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcbiAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICByZXR1cm4gaXZlYyR7c2hhcGUubGVuZ3RofSgke2Nvb3Jkc30pO1xuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDFEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKHNoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMkQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkMkRDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgIGludCByID0gaW5kZXggLyAke3NoYXBlWzFdfTtcbiAgICAgICAgICBpbnQgYyA9IGluZGV4IC0gciAqICR7c2hhcGVbMV19O1xuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgM0Qgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkM0RDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJ107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9XG4gICAgICAgIHN0cmlkZXNcbiAgICAgICAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMiA9IGkgPT09IHN0cmlkZXMubGVuZ3RoIC0gMSA/XG4gICAgICAgICAgICAgICAgICBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2kgKyAxXX0gPSBpbmRleCAtICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWAgOlxuICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtsaW5lMX07ICR7bGluZTJ9O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgc291cmNlID0gYFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNEQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkNERDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6XG4gICAgICBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJywgJ2QyJ107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9XG4gICAgICAgIHN0cmlkZXNcbiAgICAgICAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMiA9IGkgPT09IHN0cmlkZXMubGVuZ3RoIC0gMSA/XG4gICAgICAgICAgICAgICAgICBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2kgKyAxXX0gPSBpbmRleCAtICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWAgOlxuICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtsaW5lMX07ICR7bGluZTJ9O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgc291cmNlID0gYFxuICAgICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgICR7Y29vcmRzRnJvbUluZGV4U25pcHBldH1cbiAgICAgICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA1RCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQ1RENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOlxuICAgICAgR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCcsICdkMicsICdkMyddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM1KHIsIGMsIGQsIGQyLCBkMyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDZEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbXG4gICAgbnVtYmVyLCBudW1iZXJcbiAgXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnLCAnZDQnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID1cbiAgICAgICAgc3RyaWRlc1xuICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUyID0gaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaSArIDFdfSA9IGluZGV4IC0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICBgaW5kZXggLT0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgIGl2ZWM2IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICR7Y29vcmRzRnJvbUluZGV4U25pcHBldH1cbiAgICAgICAgIHJldHVybiBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcbiAgICAgICB9XG4gICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb2RlIGZvciBjb21tb24gVVYgY29vcmRzIGNvbXB1dGF0aW9uIHV0aWxpdHkgZnVuY3Rpb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldENvbW1vblV0aWxGdW5jcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGxldCBmdW5jTmFtZSA9ICd1dkZyb21GbGF0JztcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICB2ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLyB0ZXhOdW1SO1xuICAgICAgaW50IHRleFIgPSBpbmRleCAtIHRleEMgKiB0ZXhOdW1SO1xuICAgICAgLy8gVE9ETzogc3dhcCB0ZXhSLCB0ZXhDIG9yZGVyIGluIGZvbGxvd2luZyBmdW5jdGlvbiBzbyByb3cgaXMgY29ycmVzcG9uZGluZyB0byB1IGFuZCBjb2x1bW4gaXMgY29ycmVzcG9uZGluZyB0b1xuICAgICAgLy8gICAgICAgdi5cbiAgICAgIHJldHVybiAodmVjMih0ZXhSLCB0ZXhDKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bVIsIHRleE51bUMpO1xuICAgIH1cbiAgICBgKTtcbiAgICBmdW5jTmFtZSA9ICdwYWNrZWRVVmZyb20xRCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICAgIGludCB0ZXhlbEluZGV4ID0gaW5kZXggLyAyO1xuICAgICAgICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcbiAgICAgICAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgICB9XG4gICAgICBgKTtcbiAgICBmdW5jTmFtZSA9ICdwYWNrZWRVVmZyb20yRCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tM0QnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXG4gICAgICAgICAgaW50IHRleGVsc0luQmF0Y2gsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCBiLFxuICAgICAgICAgIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gICAgICAgIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xuICAgICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAnc2FtcGxlVGV4dHVyZSc7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSh0ZXh0dXJlU2FtcGxlciwgdXYpLnI7XG4gICAgICAgIH1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgaW5wdXRzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKHNhbXBsZXJOYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV07XG4gICAgICBjb25zdCBmdW5jTmFtZSA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZShzYW1wbGVyTmFtZSk7XG4gICAgICBpZiAoaW5wdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgc2FtcGxlck5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgc2FtcGxlck5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0Q29vcmRGdW5jTmFtZSA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKHNhbXBsZXJOYW1lKTtcbiAgICAgIGlmIChpbnB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCA8PSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlucHV0TGF5b3V0LmlzUGFja2VkKSB7XG4gICAgICAgICAgcmVzdWx0W291dENvb3JkRnVuY05hbWVdID1cbiAgICAgICAgICAgICAgdGhpcy5nZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMob3V0Q29vcmRGdW5jTmFtZSwgaW5wdXRMYXlvdXQsIG91dHB1dExheW91dCwgc2FtcGxlck5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtvdXRDb29yZEZ1bmNOYW1lXSA9XG4gICAgICAgICAgICAgIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMob3V0Q29vcmRGdW5jTmFtZSwgaW5wdXRMYXlvdXQsIG91dHB1dExheW91dCwgc2FtcGxlck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3Igb3V0cHV0IGNvb3JkaW5hdGVzIG9mIHNhbXBsZXJzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKFxuICAgICAgZnVuY05hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG91dHB1dExheW91dDogVGV4dHVyZUxheW91dCwgbmFtZTogc3RyaW5nKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IGluU2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFNoYXBlID0gb3V0cHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgdGV4TmFtZSA9IG5hbWU7XG4gICAgY29uc3QgdGV4RnVuY1NuaXBwZXQgPSBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUodGV4TmFtZSk7XG5cbiAgICBjb25zdCBpblJhbmsgPSBpblNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBvdXRSYW5rID0gb3V0U2hhcGUubGVuZ3RoO1xuXG4gICAgY29uc3QgYnJvYWRjYXN0RGltcyA9IEJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhpblNoYXBlLCBvdXRTaGFwZSk7XG5cbiAgICBjb25zdCB0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUob3V0UmFuayk7XG4gICAgY29uc3QgcmFua0RpZmYgPSBvdXRSYW5rIC0gaW5SYW5rO1xuICAgIGxldCBjb29yZHNTbmlwcGV0OiBzdHJpbmc7XG4gICAgY29uc3QgZmllbGRzID0gWyd4JywgJ3knLCAneicsICd3JywgJ3UnLCAndiddO1xuXG4gICAgaWYgKGluUmFuayA9PT0gMCkge1xuICAgICAgY29vcmRzU25pcHBldCA9ICcnO1xuICAgIH0gZWxzZSBpZiAob3V0UmFuayA8IDIgJiYgYnJvYWRjYXN0RGltcy5sZW5ndGggPj0gMSkge1xuICAgICAgY29vcmRzU25pcHBldCA9ICdjb29yZHMgPSAwOyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSBicm9hZGNhc3REaW1zLm1hcChkID0+IGBjb29yZHMuJHtmaWVsZHNbZCArIHJhbmtEaWZmXX0gPSAwO2ApLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBsZXQgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgaWYgKG91dFJhbmsgPCAyICYmIGluUmFuayA+IDApIHtcbiAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSBpblNoYXBlLm1hcCgocywgaSkgPT4gYGNvb3Jkcy4ke2ZpZWxkc1tpICsgcmFua0RpZmZdfWApLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dCA9ICdyZXR1cm4gb3V0cHV0VmFsdWU7JztcbiAgICBjb25zdCBpblNpemUgPSBTaGFwZVV0aWwuc2l6ZShpblNoYXBlKTtcbiAgICBjb25zdCBpc0lucHV0U2NhbGFyID0gaW5TaXplID09PSAxO1xuICAgIGNvbnN0IG91dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRTaGFwZSk7XG4gICAgY29uc3QgaXNPdXRwdXRTY2FsYXIgPSBvdXRTaXplID09PSAxO1xuXG4gICAgaWYgKGluUmFuayA9PT0gMSAmJiAhaXNJbnB1dFNjYWxhciAmJiAhaXNPdXRwdXRTY2FsYXIpIHtcbiAgICAgIG91dHB1dCA9IGBcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHgsIG91dHB1dFZhbHVlLnl5KTtcbiAgICAgIGA7XG4gICAgfSBlbHNlIGlmIChpc0lucHV0U2NhbGFyICYmICFpc091dHB1dFNjYWxhcikge1xuICAgICAgaWYgKG91dFJhbmsgPT09IDEpIHtcbiAgICAgICAgb3V0cHV0ID0gYFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XG4gICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBgXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XG4gICAgICAgIGA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChicm9hZGNhc3REaW1zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgcm93cyA9IGluUmFuayAtIDI7XG4gICAgICBjb25zdCBjb2xzID0gaW5SYW5rIC0gMTtcblxuICAgICAgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihyb3dzKSA+IC0xICYmIGJyb2FkY2FzdERpbXMuaW5kZXhPZihjb2xzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTsnO1xuICAgICAgfSBlbHNlIGlmIChicm9hZGNhc3REaW1zLmluZGV4T2Yocm93cykgPiAtMSkge1xuICAgICAgICBvdXRwdXQgPSAncmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgJyArXG4gICAgICAgICAgICAnb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7JztcbiAgICAgIH0gZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgb3V0cHV0ID0gJ3JldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7JztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgdmVjNCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgJHt0eXBlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgJHtjb29yZHNTbmlwcGV0fVxuICAgICAgICB2ZWM0IG91dHB1dFZhbHVlID0gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgJHtvdXRwdXR9XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciB1bnBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgIGZ1bmNOYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG5hbWU6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBvdXRUZXhTaGFwZSA9IFtvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGluVGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgaW5SYW5rID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgb3V0UmFuayA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpblNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleEZ1bmNTbmlwcGV0ID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKG5hbWUpO1xuXG4gICAgaWYgKGluUmFuayA9PT0gb3V0UmFuayAmJiBBcnJheVV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCBUZXhDb29yZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dFJhbmspO1xuICAgIGNvbnN0IGJyb2FkY2FzdERpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpO1xuICAgIGNvbnN0IHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgICBsZXQgY29vcmRzU25pcHBldDogc3RyaW5nO1xuICAgIGNvbnN0IGZpZWxkcyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXTtcblxuICAgIGlmIChpblJhbmsgPT09IDApIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9IGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gYnJvYWRjYXN0RGltcy5tYXAoZCA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5tYXAoKHMsIGkpID0+IGBjb29yZHMuJHtmaWVsZHNbaSArIHJhbmtEaWZmXX1gKS5qb2luKCcsICcpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICR7dHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgJHtjb29yZHNTbmlwcGV0fVxuICAgICAgICAgIHJldHVybiAke3RleEZ1bmNTbmlwcGV0fSgke3VucGFja2VkQ29vcmRzU25pcHBldH0pO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLmdldE91dHB1dENvb3JkcyddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIHBhY2tlZCBvcGVyYXRpb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBzd2l0Y2ggKGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJTY2FsYXIoZnVuY05hbWUsIG5hbWUpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyMUQoZnVuY05hbWUsIG5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlck5EKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgdW5wYWNrZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgc3dpdGNoIChzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjNEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjREKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjVEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjZEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBUT0RPIHN1cHBvcnQgbW9yZSBkaW1lbnNpb25hbGl0aWVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGltZW5zaW9uICR7c2hhcGUubGVuZ3RofS1EYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhY2tlZCBzY2FsYXIgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICB2ZWM0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIGhhbGZDUik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgMUQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyMUQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVsxXSwgdGV4U2hhcGVbMF1dO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXG4gICAgICAke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0sIGluZGV4KTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7XG4gICAgfWA7XG4gICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5wYWNrZWRVVmZyb20xRCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgMkQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyMkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgY29uc3QgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuXG4gICAgaWYgKHRleFNoYXBlICE9IG51bGwgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgdmVjNCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke3RleE51bUN9LjAsICR7dGV4TnVtUn0uMCk7XG4gICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7XG4gICAgICB9YDtcblxuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShwYWNrZWRTYW1wbGVyKTtcbiAgICB9XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICBjb25zdCB2YWx1ZXNQZXJSb3cgPSBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcbiAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKCR7cGFja2VkVGV4U2hhcGVbMV19LCAke3BhY2tlZFRleFNoYXBlWzBdfSwgJHt2YWx1ZXNQZXJSb3d9LCByb3csIGNvbCk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMkQnXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDNEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjNEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gW3RleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXV07XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcblxuICAgIGlmIChzaGFwZVswXSA9PT0gMSkge1xuICAgICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IHNoYXBlLnNsaWNlKDEpO1xuICAgICAgY29uc3Qga2VwdERpbXMgPSBbMSwgMl07XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIHNxdWVlemVkU2hhcGUpO1xuICAgICAgY29uc3QgcGFyYW1zID0gWydiJywgJ3JvdycsICdjb2wnXTtcbiAgICAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG4gICAgICBjb25zdCBzYW1wbGVyUm91dGluZSA9IHRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpO1xuICAgICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGAke3NhbXBsZXJSb3V0aW5lLnJvdXRpbmVCb2R5fVxuICAgICAgdmVjNCAke2Z1bmNOYW1lfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgICAgfSBgO1xuICAgICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBzYW1wbGVyUm91dGluZS5kZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICBjb25zdCB0ZXhOdW1SID0gcGFja2VkVGV4U2hhcGVbMF07XG4gICAgY29uc3QgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzFdO1xuXG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlWzJdIC8gMik7XG4gICAgY29uc3QgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVsxXSAvIDIpO1xuXG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tM0QoXG4gICAgICAgICR7dGV4TnVtQ30sICR7dGV4TnVtUn0sICR7dGV4ZWxzSW5CYXRjaH0sICR7dmFsdWVzUGVyUm93fSwgYiwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTt9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTNEJ10pO1xuICB9XG4gIC8qXG4gICAqIFBhY2tlZCBORCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXJORChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IHRleE51bVIgPSBwYWNrZWRUZXhTaGFwZVsxXTtcbiAgICBjb25zdCB0ZXhOdW1DID0gcGFja2VkVGV4U2hhcGVbMF07XG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlW3JhbmsgLSAxXSAvIDIpO1xuICAgIGxldCB0ZXhlbHNJbkJhdGNoID0gdmFsdWVzUGVyUm93ICogTWF0aC5jZWlsKHNoYXBlW3JhbmsgLSAyXSAvIDIpO1xuICAgIGxldCBwYXJhbXMgPSAnaW50IGIsIGludCByb3csIGludCBjb2wnO1xuICAgIGxldCBpbmRleCA9IGBiICogJHt0ZXhlbHNJbkJhdGNofSArIChyb3cgLyAyKSAqICR7dmFsdWVzUGVyUm93fSArIChjb2wgLyAyKWA7XG4gICAgZm9yIChsZXQgYiA9IDI7IGIgPCByYW5rIC0gMTsgYisrKSB7XG4gICAgICBwYXJhbXMgPSBgaW50IGIke2J9LCBgICsgcGFyYW1zO1xuICAgICAgdGV4ZWxzSW5CYXRjaCAqPSBzaGFwZVtyYW5rIC0gYiAtIDFdO1xuICAgICAgaW5kZXggPSBgYiR7Yn0gKiAke3RleGVsc0luQmF0Y2h9ICsgYCArIGluZGV4O1xuICAgIH1cbiAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oJHtwYXJhbXN9KSB7XG4gICAgICBpbnQgaW5kZXggPSAke2luZGV4fTtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyAke3RleE51bUN9O1xuICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiAke3RleE51bUN9O1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1DfSwgJHt0ZXhOdW1SfSk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIHNjYWxhciBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IFt0ZXhOdW1SLCB0ZXhOdW1DXSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBpZiAodGV4TnVtUiA9PT0gMSAmJiB0ZXhOdW1DID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIG9mZnNldF8ke25hbWV9KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCAxRCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgdE51bVIgPSBpbnB1dExheW91dC53aWR0aDtcbiAgICBjb25zdCB0TnVtQyA9IGlucHV0TGF5b3V0LmhlaWdodDtcblxuICAgIGlmICh0TnVtQyA9PT0gMSAmJiB0TnVtUiA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG5cbiAgICBpZiAodE51bUMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHt0TnVtUn0uMCwgMC41KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cbiAgICBpZiAodE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke3ROdW1DfS4wKTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dE51bVJ9LCAke3ROdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMkQgc25pcHBldC5cbiAgICovXG5cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuXG4gICAgLy8gVE9ETzogbW9kaWZ5IHJvdy9jb2wgb3JkZXIgZm9yIG90aGVyIGRpbWVuc2lvbnMuXG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQuaGVpZ2h0LCBpbnB1dExheW91dC53aWR0aF07XG5cbiAgICBpZiAodGV4U2hhcGUgIT0gbnVsbCAmJiBBcnJheVV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzFdO1xuICAgICAgY29uc3QgdGV4TnVtQyA9IHRleFNoYXBlWzBdO1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICAgIHZlYzIgdXYgPSAodmVjMihyb3csIGNvbCkgKyBoYWxmQ1IpIC8gdmVjMigke3RleE51bVJ9LjAsICR7dGV4TnVtQ30uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG5cbiAgICBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnY29sJywgJ3JvdyddO1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KS5yb3V0aW5lQm9keX1cbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzFdO1xuICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVswXTtcbiAgICBpZiAodGV4TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtuYW1lfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSk7XG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtuYW1lfSksIHZlYzMoJHtzaGFwZVsxXX0sIDEsIDEpKTtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7dGV4TnVtUn0uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgICB9XG5cbiAgICBpZiAodGV4TnVtUiA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHtuYW1lfSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSk7XG4gICAgICAgICAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBvZmZzZXRfJHtuYW1lfSksIHZlYzMoJHtzaGFwZVsxXX0sIDEsIDEpKTtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyAke3RleE51bUN9LjAsIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSBjb2wgKiAke3NoYXBlWzFdfSArIHJvdztcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgM0Qgc25pcHBldC5cbiAgICovXG5cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjNEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICAgIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXTtcblxuICAgIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICBjb25zdCBzcXVlZXplZFNoYXBlID0gbmV3U2hhcGU7XG4gICAgaWYgKHNxdWVlemVkU2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIHNxdWVlemVkU2hhcGUpO1xuICAgICAgY29uc3QgcGFyYW1zID0gWydiYXRjaCcsICdjb2wnLCAncm93J107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgICAgY29uc3Qgcm91dGluZSA9IHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCk7XG4gICAgICAvLyBUT0RPOiByZXZpc2l0IHRoZSBsb2dpYyBoZXJlIHRvIG1ha2UgaXQgc2ltcGxlclxuICAgICAgY29uc3QgcmV2RGltcyA9IGtlcHREaW1zLnJldmVyc2UoKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3JvdXRpbmUucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGJhdGNoLCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIHJldkRpbXMpfSk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIHJvdXRpbmUuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXhOdW1SID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdGV4TnVtQyA9IGlucHV0TGF5b3V0LmhlaWdodDtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGRlcHRoLCBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXG4gICAgICAgICAgICBpbnQgaW5kZXggPSBkZXB0aCAqICR7c3RyaWRlMH0gKyBjb2wgKiAke3N0cmlkZTF9ICsgcm93O1xuICAgICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA0RCBzbmlwcGV0LlxuICAgKi9cblxuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyNEQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICAgIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcblxuICAgIC8vXG4gICAgLy8gVE9ETzogcmUtZW5hYmxlIHRoaXMgc2hvcnRjdXQgb25jZSB0aGUgaW5kZXggY2FsY3VsYXRpb24gYnVnIGlzIGZpeGVkLlxuICAgIC8vXG4gICAgLy8gY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIC8vIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAvLyAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgbmV3U2hhcGUpO1xuICAgIC8vICAgY29uc3QgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMiddO1xuICAgIC8vICAgLy8gRGVlcCBjb3B5IG9mIGlucHV0IHRleHR1cmUgbGF5b3V0LlxuICAgIC8vICAgY29uc3QgbmV3SW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0TGF5b3V0KSk7XG4gICAgLy8gICBuZXdJbnB1dExheW91dC51bnBhY2tlZFNoYXBlID0gbmV3SW5wdXRTaGFwZTtcbiAgICAvLyAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAvLyAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgLy8gICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XG4gICAgLy8gICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgYDtcbiAgICAvLyAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgLy8gICAgICAgc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCB0ZXhOdW1SID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdGV4TnVtQyA9IGlucHV0TGF5b3V0LmhlaWdodDtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7c3RyaWRlMH0gKyBjb2wgKiAke3N0cmlkZTF9ICtcbiAgICAgICAgICAgICAgZGVwdGgyICogJHtzdHJpZGUyfSArIGRlcHRoO1xuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDVEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyNUQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHNoYXBlWzRdO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgY29uc3QgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMicsICdkZXB0aDMnXTtcbiAgICAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XG4gICAgICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCddKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXhOdW1SID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdGV4TnVtQyA9IGlucHV0TGF5b3V0LmhlaWdodDtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7c3RyaWRlMH0gKyBjb2wgKiAke3N0cmlkZTF9ICsgZGVwdGggKiAke3N0cmlkZTJ9ICtcbiAgICAgICAgICBkZXB0aDMgKiAke3N0cmlkZTN9ICsgZGVwdGgyO1xuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy51dkZyb21GbGF0J10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDZEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyNkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgc3RyaWRlNCA9IHNoYXBlWzVdO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzaGFwZVs0XSAqIHN0cmlkZTQ7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHNoYXBlWzNdICogc3RyaWRlMztcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgICBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ3JvdycsICdjb2wnLCAnZGVwdGgnLCAnZGVwdGgyJywgJ2RlcHRoMycsICdkZXB0aDQnXTtcbiAgICAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAgICR7dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KS5yb3V0aW5lQm9keX1cbiAgICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xuICAgICAgICAgICAgICByZXR1cm4gJHtmdW5jTmFtZX0oJHtnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcbiAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7c3RyaWRlMH0gKyBjb2wgKiAke3N0cmlkZTF9ICsgZGVwdGggKiAke3N0cmlkZTJ9ICtcbiAgICAgICAgICAgIGRlcHRoMiAqICR7c3RyaWRlM30gKyBkZXB0aDMgKiAke3N0cmlkZTR9ICsgZGVwdGg0O1xuICAgICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICBzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gdG8gbWFwIGZyb20gdGhlIGdpdmVuIHRleHR1cmUgY29vcmRpYW50ZXMgKHMsdClcbiAgICogdG8gbG9naWNhbCBpbmRpY2VzIGZvciB0aGUgb3V0cHV0XG4gICAqIFRoZXJlIHdpbGwgb25seSBiZSBvbmUgc2luZ2xlIHZhcmlhdGlvbiBvZiB0aGlzXG4gICAqIEFsc28gc2VlIGNvb3Jkc1RvT2Zmc2V0IGFuZCBvZmZzZXRUb0luZGljZXMgZm9yIGlucHV0LXNwZWNpZmljIHZlcnNpb25zXG4gICAqL1xuICBwcm90ZWN0ZWQgdG9WZWMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dC5zaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgc3RyaWRlcyA9IG91dHB1dC5zdHJpZGVzO1xuICAgIGNvbnN0IHhTY2FsZSA9IG91dHB1dC53aWR0aDtcbiAgICBjb25zdCB5U2NhbGUgPSBvdXRwdXQuaGVpZ2h0O1xuXG4gICAgY29uc3Qgc3RyaWRlc0Jsb2NrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIGNbJHtpfV0gPSBvZmZzZXQgLyAke3N0cmlkZXNbaV19O2ApO1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgICBvZmZzZXQgLT0gY1ske2l9XSAqICR7c3RyaWRlc1tpXX07YCk7XG4gICAgfVxuICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgY1ske3JhbmsgLSAxfV0gPSBvZmZzZXQ7YCk7XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIHZvaWQgdG9WZWModmVjMiB0ZXhDb29yZHMsIG91dCBpbnQgY1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gY29vcmRzVG9PZmZzZXQodGV4Q29vcmRzLCAke3hTY2FsZX0sICR7eVNjYWxlfSk7XG4gICAgICAgICR7c3RyaWRlc0Jsb2NrLmpvaW4oJycpfVxuICAgICAgfVxuICAgICAgdm9pZCB0b1ZlYyhpbnQgb2Zmc2V0LCBvdXQgaW50IGNbJHtyYW5rfV0pIHtcbiAgICAgICAgJHtzdHJpZGVzQmxvY2suam9pbignJyl9XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4ge3RvVmVjOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSwgWydjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKX07XG4gIH1cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSB2YWx1ZSBnZXR0ZXIgZnVuY3Rpb25zIGdlbmVyYXRlZCBmb3IgZWFjaCBpbnB1dFxuICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGhhcmR3aXJlZCB0byB0aGUgbmFtZSBhbmQgZGltZW5zaW9ucyBvZiB0aGUgaW5wdXRcbiAgICogQW4gJ19UJyB2YXJpYXRpb24gaXMgYWxzbyBwcm9kdWNlZCB3aGljaCBhY2Nlc3NlcyB2YWx1ZXMgYXMgaWYgdGhlXG4gICAqIGlucHV0IHdhcyB0cmFuc3Bvc2VkXG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsdWVGcm9tKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGxheW91dCA9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IHNoYXBlID0gbGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoID4gMCA/IGxheW91dC51bnBhY2tlZFNoYXBlIDogbGF5b3V0LnNoYXBlO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKG5hbWUsIHJhbmssIGxheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodCwgZmFsc2UpLFxuICAgICAgICAgIFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2Z1bmNOYW1lfWAsICdjb29yZGluYXRlcy5vZmZzZXRUb0Nvb3JkcycsICdmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0J10pO1xuICAgICAgZnVuY05hbWUgPSBmdW5jTmFtZSArICdfVCc7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKG5hbWUsIHJhbmssIGxheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodCwgdHJ1ZSksXG4gICAgICAgICAgW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7ZnVuY05hbWV9YCwgJ2Nvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzJywgJ2ZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXQnXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgb25lIHZhbHVlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIG5hbWUgYW5kIHJhbmsgZ2l2ZW5cbiAgICogSWYgYSB0cmFuc3Bvc2UgaXMgc2V0IHByb3BlciBvZmZzZXRUb0Nvb3JkcyBtYXBwaW5nIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmFuayByYW5rIG9mIHRoZSBpbnB1dFxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIHdoZXRoZXIgb3Igbm90IHNob3VsZCBnZW5lcmF0ZSBhIHRyYW5zcG9zZSB2YXJpYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBnZXRWYWx1ZUZyb21TaW5nbGUodmFyTmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0cmFuc3Bvc2U6IGJvb2xlYW4pOlxuICAgICAgc3RyaW5nIHtcbiAgICBsZXQgbmFtZSA9IGBfJHt2YXJOYW1lfWA7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgbmFtZSA9IG5hbWUgKyAnX1QnO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiBgXG4gICAgICAgIGZsb2F0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHtuYW1lfShtKTtcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oJHt2YXJOYW1lfSwgY29vcmRzKSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBwYWNrZWQgdmFsdWUgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbmFtZSBhbmQgcmFuayBnaXZlblxuICAgKiBJZiBhIHRyYW5zcG9zZSBpcyBzZXQgcHJvcGVyIG9mZnNldFRvQ29vcmRzIG1hcHBpbmcgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSByYW5rIHJhbmsgb2YgdGhlIGlucHV0XG4gICAqIEBwYXJhbSB0cmFuc3Bvc2Ugd2hldGhlciBvciBub3Qgc2hvdWxkIGdlbmVyYXRlIGEgdHJhbnNwb3NlIHZhcmlhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFZhbHVlRnJvbSh2YXJOYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHRyYW5zcG9zZTogYm9vbGVhbik6XG4gICAgICBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gYF8ke3Zhck5hbWV9X1BhY2tgO1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJ19UJztcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gYFxuICAgICAgICB2ZWM0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0XyR7dmFyTmFtZX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke3Zhck5hbWV9LCBjb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Byb2dyYW1JbmZvfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmV4cG9ydCBlbnVtIEZ1bmN0aW9uVHlwZSB7XG4gIFZhbHVlQmFzZWQsXG4gIFBvc2l0aW9uYWxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgR2xzbEZ1bmN0aW9uPFQgZXh0ZW5kcyBGdW5jdGlvblR5cGU+IHtcbiAgYm9keTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IFQ7XG59XG5leHBvcnQgdHlwZSBHbHNsVmFsdWVGdW5jdGlvbiA9IEdsc2xGdW5jdGlvbjxGdW5jdGlvblR5cGUuVmFsdWVCYXNlZD47XG5leHBvcnQgaW50ZXJmYWNlIEdsc2xQb3NpdGlvbmFsRnVuY3Rpb24gZXh0ZW5kcyBHbHNsRnVuY3Rpb248RnVuY3Rpb25UeXBlLlBvc2l0aW9uYWw+IHtcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEdsc2xDb250ZXh0IHtcbiAgY29uc3RydWN0b3IocHVibGljIGdsQ29udGV4dDogV2ViR0xDb250ZXh0LCBwdWJsaWMgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvKSB7fVxufVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEdsc2xMaWIge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY29udGV4dDogR2xzbENvbnRleHQpIHt9XG4gIGFic3RyYWN0IGdldEZ1bmN0aW9ucygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfTtcbiAgYWJzdHJhY3QgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9O1xufVxuXG4vLyBhYnN0cmFjdGlvbiB0byByZXByZXNlbnQgYSBHTFNMIGxpYnJhcnkgcm91dGluZSBhbmQgaXQncyBkZXBlbmRlbmNpZXNcbmV4cG9ydCBjbGFzcyBHbHNsTGliUm91dGluZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByb3V0aW5lQm9keTogc3RyaW5nLCBwdWJsaWMgZGVwZW5kZW5jaWVzPzogc3RyaW5nW10pIHt9XG59XG5cbi8vIGFic3RyYWN0aW9uIHRvIHJlcHJlc2VudCBhIEdMU0wgbGlicmFyeSByb3V0aW5lIGFuZCBpdCdzIGRlcGVuZGVuY2llcyBBUyBHUkFQSCBOb2Rlc1xuLy8gdGhpcyBsZXZlbCBvZiBhYnN0cmFjdGlvbiBpcyB1c2VkIHRvIHRvcG9sb2dpY2FsbHkgc29ydCByb3V0aW5lcyBiZWZvcmUgZnJhZ21lbnQgc2hhZGUgaW5jbHVzaW9uXG5leHBvcnQgY2xhc3MgR2xzbExpYlJvdXRpbmVOb2RlIHtcbiAgZGVwZW5kZW5jaWVzOiBHbHNsTGliUm91dGluZU5vZGVbXTtcbiAgcm91dGluZUJvZHk6IHN0cmluZztcbiAgY29uc3RydWN0b3IocHVibGljIG5hbWU6IHN0cmluZywgcm91dGluZUJvZHk/OiBzdHJpbmcsIGRlcGVuZGVuY2llcz86IEdsc2xMaWJSb3V0aW5lTm9kZVtdKSB7XG4gICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJvdXRpbmVCb2R5KSB7XG4gICAgICB0aGlzLnJvdXRpbmVCb2R5ID0gcm91dGluZUJvZHk7XG4gICAgfVxuICB9XG4gIGFkZERlcGVuZGVuY3kobm9kZTogR2xzbExpYlJvdXRpbmVOb2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHRvcG9sb2dpY2FsbHkgc29ydCBHTFNMIGxpYnJhcnkgcm91dGluZXMgKGdyYXBoIG5vZGVzIGFic3RyYWN0aW9uKSBiZWZvcmUgc2hhZGVyIHNjcmlwdCBpbmNsdXNpb25cbmV4cG9ydCBjbGFzcyBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMge1xuICBzdGF0aWMgcmV0dXJuT3JkZXJlZE5vZGVzKG5vZGVzOiBHbHNsTGliUm91dGluZU5vZGVbXSk6IEdsc2xMaWJSb3V0aW5lTm9kZVtdIHtcbiAgICBpZiAoIW5vZGVzIHx8IG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG5cbiAgICBjb25zdCBjeWNsZUNoZWNrID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgY29uc3QgYWxyZWFkeVRyYXZlcnNlZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxHbHNsTGliUm91dGluZU5vZGU+KCk7XG5cbiAgICB0aGlzLmNyZWF0ZU9yZGVyZWROb2Rlcyhub2RlcywgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlT3JkZXJlZE5vZGVzKFxuICAgICAgZ3JhcGhOb2RlczogR2xzbExpYlJvdXRpbmVOb2RlW10sIGN5Y2xlQ2hlY2s6IFNldDxzdHJpbmc+LCBhbHJlYWR5VHJhdmVyc2VkOiBTZXQ8c3RyaW5nPixcbiAgICAgIHJlc3VsdDogR2xzbExpYlJvdXRpbmVOb2RlW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRoaXMuZGZzVHJhdmVyc2UoZ3JhcGhOb2Rlc1tpXSwgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBkZnNUcmF2ZXJzZShcbiAgICAgIHJvb3Q6IEdsc2xMaWJSb3V0aW5lTm9kZSwgY3ljbGVDaGVjazogU2V0PHN0cmluZz4sIGFscmVhZHlUcmF2ZXJzZWQ6IFNldDxzdHJpbmc+LCByZXN1bHQ6IEdsc2xMaWJSb3V0aW5lTm9kZVtdKSB7XG4gICAgLy8gaWYgdGhpcyByb290IGhhcyBhbHJlYWR5IGJlZW4gdHJhdmVyc2VkIHJldHVyblxuICAgIGlmICghcm9vdCB8fCBhbHJlYWR5VHJhdmVyc2VkLmhhcyhyb290Lm5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY3ljbGljIGRlcGVuZGVuY3kgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICBpZiAoY3ljbGVDaGVjay5oYXMocm9vdC5uYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDeWNsaWMgZGVwZW5kZW5jeSBkZXRlY3RlZC4gQ2FuXFwndCB0b3BvbG9naWNhbGx5IHNvcnQgcm91dGluZXMgbmVlZGVkIGZvciBzaGFkZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gaG9sZCB0aGlzIG5vZGUgdG8gZGV0ZWN0IGN5Y2xlcyBpZiBhbnlcbiAgICBjeWNsZUNoZWNrLmFkZChyb290Lm5hbWUpO1xuXG4gICAgLy8gdHJhdmVyc2UgY2hpbGRyZW4gaW4gYSBkZnMgZmFzaGlvblxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJvb3QuZGVwZW5kZW5jaWVzO1xuICAgIGlmIChkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuZGZzVHJhdmVyc2UoZGVwZW5kZW5jaWVzW2ldLCBjeWNsZUNoZWNrLCBhbHJlYWR5VHJhdmVyc2VkLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCB0byByZXN1bHQgaG9sZGVyXG4gICAgcmVzdWx0LnB1c2gocm9vdCk7XG5cbiAgICAvLyBtYXJrIHRoaXMgbm9kZSBhcyB0cmF2ZXJzZWQgc28gdGhhdCB3ZSBkb24ndCB0cmF2ZXJzZSBmcm9tIHRoaXMgYWdhaW5cbiAgICBhbHJlYWR5VHJhdmVyc2VkLmFkZChyb290Lm5hbWUpO1xuXG4gICAgLy8gcmVsZWFzZSB0aGUgaG9sZFxuICAgIGN5Y2xlQ2hlY2suZGVsZXRlKHJvb3QubmFtZSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZX0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGNvbnZlcnRpbmdcbiAqIGZsb2F0MzIgdG8vZnJvbSBVbnNpZ25lZCBieXRlIG9yIGZsb2F0IDE2XG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGluZ0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7Li4udGhpcy5lbmNvZGVGbG9hdDMyKCksIC4uLnRoaXMuZGVjb2RlRmxvYXQzMigpfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ30ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm90ZWN0ZWQgZW5jb2RlRmxvYXQzMigpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KGYsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgfVxuICAgICAgICBgKVxuICAgIH07XG4gIH1cbiAgcHJvdGVjdGVkIGRlY29kZUZsb2F0MzIoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICBkZWNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xuICAgICAgICByZXR1cm4gcmdiYS5yO1xuICAgICAgfVxuICAgICAgICBgKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHJvdXRpbmUgdG8gZW5jb2RlIGVuY29kZSBhIDMyYml0IGZsb2F0IHRvIGEgdmVjNCAob2YgdW5zaWduZWQgYnl0ZXMpXG4gICAqIEBjcmVkaXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNTk5NjIvaG93LWRvLWktY29udmVydC1hLXZlYzQtcmdiYS12YWx1ZS10by1hLWZsb2F0XG4gICAqL1xuICBwcm90ZWN0ZWQgZW5jb2RlVWludDgoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGVuZGlhbm5lc3MgPSBFbmNvZGluZ0dsc2xMaWIuaXNMaXR0bGVFbmRpYW4oKSA/ICdyZ2JhLnJnYmE9cmdiYS5hYmdyOycgOiAnJztcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xuICAgICAgICBoaWdocCBmbG9hdCBGID0gYWJzKGYpO1xuICAgICAgICBoaWdocCBmbG9hdCBTaWduID0gc3RlcCgwLjAsLWYpO1xuICAgICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xuICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IChleHAyKC0gRXhwb25lbnQpICogRik7XG4gICAgICAgIEV4cG9uZW50ID0gZmxvb3IobG9nMihGKSArIDEyNy4wKSArIGZsb29yKGxvZzIoTWFudGlzc2EpKTtcbiAgICAgICAgaGlnaHAgdmVjNCByZ2JhO1xuICAgICAgICByZ2JhWzBdID0gMTI4LjAgKiBTaWduICArIGZsb29yKEV4cG9uZW50KmV4cDIoLTEuMCkpO1xuICAgICAgICByZ2JhWzFdID0gMTI4LjAgKiBtb2QoRXhwb25lbnQsMi4wKSArIG1vZChmbG9vcihNYW50aXNzYSoxMjguMCksMTI4LjApO1xuICAgICAgICByZ2JhWzJdID0gZmxvb3IobW9kKGZsb29yKE1hbnRpc3NhKmV4cDIoMjMuMCAtOC4wKSksZXhwMig4LjApKSk7XG4gICAgICAgIHJnYmFbM10gPSBmbG9vcihleHAyKDIzLjApKm1vZChNYW50aXNzYSxleHAyKC0xNS4wKSkpO1xuICAgICAgICAke2VuZGlhbm5lc3N9XG4gICAgICAgIHJnYmEgPSByZ2JhIC8gMjU1LjA7IC8vIHZhbHVlcyBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQgdG8gWzAsMV1cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfVxuICAgICAgICBgKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIHJvdXRpbmUgdG8gZW5jb2RlIGEgdmVjNCBvZiB1bnNpZ25lZCBieXRlcyB0byBmbG9hdDMyXG4gICAqIEBjcmVkaXQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcwNTk5NjIvaG93LWRvLWktY29udmVydC1hLXZlYzQtcmdiYS12YWx1ZS10by1hLWZsb2F0XG4gICAqL1xuICBwcm90ZWN0ZWQgZGVjb2RlVWludDgoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGVuZGlhbm5lc3MgPSBFbmNvZGluZ0dsc2xMaWIuaXNMaXR0bGVFbmRpYW4oKSA/ICdyZ2JhLnJnYmE9cmdiYS5hYmdyOycgOiAnJztcbiAgICByZXR1cm4ge1xuICAgICAgZGVjb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgICBoaWdocCBmbG9hdCBkZWNvZGUoaGlnaHAgdmVjNCByZ2JhKSB7XG4gICAgICAgICAgcmdiYSA9IHJnYmEgKiAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgZGUtbm9ybWFsaXplZCBmcm9tIFswLDFdIHRvIFswLDI1NV1cbiAgICAgICAgICAke2VuZGlhbm5lc3N9XG4gICAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI4LjAscmdiYVswXSkqMi4wO1xuICAgICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbMF0sMTI4LjApICsgc3RlcCgxMjguMCxyZ2JhWzFdKSAtIDEyNy4wO1xuICAgICAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMV0sMTI4LjApKjY1NTM2LjAgKyByZ2JhWzJdKjI1Ni4wICtyZ2JhWzNdICsgZmxvYXQoMHg4MDAwMDApO1xuICAgICAgICAgIGhpZ2hwIGZsb2F0IFJlc3VsdCA9ICBTaWduICogZXhwMihFeHBvbmVudCkgKiAoTWFudGlzc2EgKiBleHAyKC0yMy4wICkpO1xuICAgICAgICAgIHJldHVybiBSZXN1bHQ7XG4gICAgICB9XG4gICAgICAgIGApXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgbWFjaGluZSBpcyBsaXR0bGUgZW5kaWFuIG9yIG5vdFxuICAgKiBAY3JlZGl0OiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Ub29UYWxsTmF0ZS80NzUwOTUzXG4gICAqL1xuICBzdGF0aWMgaXNMaXR0bGVFbmRpYW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICBjb25zdCBhID0gbmV3IFVpbnQzMkFycmF5KGIpO1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICBhWzBdID0gMHhkZWFkYmVlZjtcbiAgICBpZiAoY1swXSA9PT0gMHhlZikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjWzBdID09PSAweGRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBlbmRpYW5uZXNzJyk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZX0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi9nbHNsLXNvdXJjZSc7XG5cbi8qKlxuICogVGhpcyBHTFNMIGxpYnJhcnkgaGFuZGxlcyByb3V0aW5lcyBhcm91bmQgcmVhZGluZyBhIHRleGxldCBhbmQgd3JpdGluZyB0byBpdFxuICogUmVhZGluZyBhbmQgd3JpdGluZyBjb3VsZCBiZSBtb3JlIHRoYW4ganVzdCBkZWFsaW5nIHdpdGggb25lIGNoYW5uZWxcbiAqIEl0IG1heSByZXF1aXJlIGVuY29kaW5nL2RlY29kaW5nIHRvL2Zyb20gNCBjaGFubmVscyBpbnRvIG9uZVxuICovXG5leHBvcnQgY2xhc3MgRnJhZ0NvbG9yR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBHbHNsQ29udGV4dCkge1xuICAgIHN1cGVyKGNvbnRleHQpO1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgcmV0dXJuIHsuLi50aGlzLnNldEZyYWdDb2xvcigpLCAuLi50aGlzLmdldENvbG9yQXNGbG9hdCgpfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ30ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm90ZWN0ZWQgc2V0RnJhZ0NvbG9yKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBzZXRGcmFnQ29sb3I6IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgICBgXG4gICAgICAgIHZvaWQgc2V0RnJhZ0NvbG9yKGZsb2F0IHZhbHVlKSB7XG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IGVuY29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgICBbJ2VuY29kaW5nLmVuY29kZSddKVxuICAgIH07XG4gIH1cbiAgcHJvdGVjdGVkIGdldENvbG9yQXNGbG9hdCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbG9yQXNGbG9hdDogbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIGBcbiAgICAgICAgZmxvYXQgZ2V0Q29sb3JBc0Zsb2F0KHZlYzQgY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGUoY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgICAgWydlbmNvZGluZy5kZWNvZGUnXSlcbiAgICB9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY29uc3QgSU5MSU5FX0ZVTkNfREVGX1JFR0VYID0gL0BpbmxpbmVbXFxzXFxuXFxyXSsoXFx3KylbXFxzXFxuXFxyXSsoWzAtOWEtekEtWl9dKylcXHMqXFwoKFteKV0qKVxcKVxccyp7KChbXn1dfFtcXG5cXHJdKSopfS9nbTtcbmNvbnN0IEZVTkNfQ0FMTF9SRUdFWCA9ICcoXFxcXHcrKT9cXFxccysoW18wLTlhLXpBLVpdKylcXFxccys9XFxcXHMrX19GVU5DX19cXFxcKCguKilcXFxcKVxcXFxzKjsnO1xuLyoqXG4gKiBHTFNMIHByZXByb2Nlc3NvciByZXNwb25zaWJsZSBmb3IgcmVzb2x2aW5nIEBpbmxpbmUgZGlyZWN0aXZlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUlubGluZXMoc2NyaXB0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBpbmxpbmVEZWZzOiB7W25hbWU6IHN0cmluZ106IHtwYXJhbXM6IEFycmF5PHt0eXBlOiBzdHJpbmc7IG5hbWU6IHN0cmluZ318bnVsbD47IGJvZHk6IHN0cmluZ319ID0ge307XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IElOTElORV9GVU5DX0RFRl9SRUdFWC5leGVjKHNjcmlwdCkpICE9PSBudWxsKSB7XG4gICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbM11cbiAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgICAgICAgICAgICAgICAgLm1hcChzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBzLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnMgJiYgdG9rZW5zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiB0b2tlbnNbMF0sIG5hbWU6IHRva2Vuc1sxXX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdiAhPT0gbnVsbCk7XG4gICAgaW5saW5lRGVmc1ttYXRjaFsyXV0gPSB7cGFyYW1zLCBib2R5OiBtYXRjaFs0XX07XG4gIH1cbiAgZm9yIChjb25zdCBuYW1lIGluIGlubGluZURlZnMpIHtcbiAgICBjb25zdCByZWdleFN0cmluZyA9IEZVTkNfQ0FMTF9SRUdFWC5yZXBsYWNlKCdfX0ZVTkNfXycsIG5hbWUpO1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleFN0cmluZywgJ2dtJyk7XG4gICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoc2NyaXB0KSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gbWF0Y2hbMl07XG4gICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaFszXS5zcGxpdCgnLCcpO1xuICAgICAgY29uc3QgZGVjbExpbmUgPSAodHlwZSkgPyBgJHt0eXBlfSAke3ZhcmlhYmxlfTtgIDogJyc7XG4gICAgICBsZXQgbmV3Qm9keTogc3RyaW5nID0gaW5saW5lRGVmc1tuYW1lXS5ib2R5O1xuICAgICAgbGV0IHBhcmFtUmVkZWNMaW5lID0gJyc7XG4gICAgICBpbmxpbmVEZWZzW25hbWVdLnBhcmFtcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgcGFyYW1SZWRlY0xpbmUgKz0gYCR7di50eXBlfSAke3YubmFtZX0gPSAke3BhcmFtc1tpXX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBuZXdCb2R5ID0gYCR7cGFyYW1SZWRlY0xpbmV9XFxuICR7bmV3Qm9keX1gO1xuICAgICAgbmV3Qm9keSA9IG5ld0JvZHkucmVwbGFjZSgncmV0dXJuJywgYCR7dmFyaWFibGV9ID0gYCk7XG4gICAgICBjb25zdCByZXBsYWNlbWVudCA9IGBcbiAgICAgICR7ZGVjbExpbmV9XG4gICAgICB7XG4gICAgICAgICR7bmV3Qm9keX1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShtYXRjaFswXSwgcmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICBzY3JpcHQgPSBzY3JpcHQucmVwbGFjZShJTkxJTkVfRlVOQ19ERUZfUkVHRVgsICcnKTtcbiAgcmV0dXJuIHNjcmlwdDtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZU5vZGUsIFRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lc30gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7cmVwbGFjZUlubGluZXN9IGZyb20gJy4vZ2xzbC1mdW5jdGlvbi1pbmxpbmVyJztcbmltcG9ydCB7Z2xzbFJlZ2lzdHJ5fSBmcm9tICcuL2dsc2wtcmVnaXN0ZXJlZC1saWJzJztcbmltcG9ydCB7Z2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluLCBnZXRGcmFnU2hhZGVyUHJlYW1ibGV9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVmFyaWFibGVJbmZvfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByZXByb2Nlc3NvciBmb3IgdGhlIGFkZGl0aW9ucyB0byB0aGUgR0xTTCBsYW5ndWFnZVxuICogSXQgZGVhbHMgd2l0aDpcbiAqICBAaW5jbHVkZSBkaXJlY3RpdmVzXG4gKiAgQGlubGluZVxuICogIExvb3AgdW5yb2xsaW5nIChub3QgaW1wbGVtZW50ZWQpXG4gKiAgTWFjcm8gcmVzb2x1dGlvbiAobm90IGltcGxlbWVudGVkKVxuICovXG5leHBvcnQgY2xhc3MgR2xzbFByZXByb2Nlc3NvciB7XG4gIHJlYWRvbmx5IGNvbnRleHQ6IEdsc2xDb250ZXh0O1xuICByZWFkb25seSBsaWJzOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJ9ID0ge307XG4gIHJlYWRvbmx5IGdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoOiB7W3JvdXRpbmVOYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZU5vZGV9ID0ge307XG5cbiAgY29uc3RydWN0b3IoZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbykge1xuICAgIHRoaXMuY29udGV4dCA9IG5ldyBHbHNsQ29udGV4dChnbENvbnRleHQsIHByb2dyYW1JbmZvKTtcblxuICAgIC8vIGNvbnN0cnVjdCBHbHNsTGlic1xuICAgIE9iamVjdC5rZXlzKGdsc2xSZWdpc3RyeSkuZm9yRWFjaCgobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBsaWIgPSBuZXcgZ2xzbFJlZ2lzdHJ5W25hbWVdKHRoaXMuY29udGV4dCk7XG4gICAgICB0aGlzLmxpYnNbbmFtZV0gPSBsaWI7XG4gICAgfSk7XG5cbiAgICAvLyBjb25zdHJ1Y3QgR2xzbFJvdXRpbmVEZXBlbmRlbmN5R3JhcGhcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoO1xuICAgIGZvciAoY29uc3QgbGliTmFtZSBpbiB0aGlzLmxpYnMpIHtcbiAgICAgIGNvbnN0IGxpYiA9IHRoaXMubGlic1tsaWJOYW1lXTtcbiAgICAgIGNvbnN0IHJvdXRpbmVzSW5MaWIgPSBsaWIuZ2V0RnVuY3Rpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IHJvdXRpbmUgaW4gcm91dGluZXNJbkxpYikge1xuICAgICAgICBjb25zdCBrZXkgPSBsaWJOYW1lICsgJy4nICsgcm91dGluZTtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlOiBHbHNsTGliUm91dGluZU5vZGU7XG4gICAgICAgIGlmIChtYXBba2V5XSkge1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gbWFwW2tleV07XG4gICAgICAgICAgY3VycmVudE5vZGUucm91dGluZUJvZHkgPSByb3V0aW5lc0luTGliW3JvdXRpbmVdLnJvdXRpbmVCb2R5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gbmV3IEdsc2xMaWJSb3V0aW5lTm9kZShrZXksIHJvdXRpbmVzSW5MaWJbcm91dGluZV0ucm91dGluZUJvZHkpO1xuICAgICAgICAgIG1hcFtrZXldID0gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gcm91dGluZXNJbkxpYltyb3V0aW5lXS5kZXBlbmRlbmNpZXM7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtYXBbZGVwZW5kZW5jaWVzW2ldXSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IEdsc2xMaWJSb3V0aW5lTm9kZShkZXBlbmRlbmNpZXNbaV0pO1xuICAgICAgICAgICAgICBtYXBbZGVwZW5kZW5jaWVzW2ldXSA9IG5vZGU7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlLmFkZERlcGVuZGVuY3kobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hZGREZXBlbmRlbmN5KG1hcFtkZXBlbmRlbmNpZXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmVwcm9jZXNzKCk6IHN0cmluZyB7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm87XG4gICAgbGV0IHNvdXJjZSA9IHByb2dyYW1JbmZvLnNoYWRlclNvdXJjZTtcblxuICAgIC8vIGFwcGVuZCBtYWluKCkgZnVuY3Rpb25cbiAgICBpZiAoIXRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5oYXNNYWluKSB7XG4gICAgICBzb3VyY2UgPSBgJHtzb3VyY2V9XG4gICAgICAke2dldERlZmF1bHRGcmFnU2hhZGVyTWFpbih0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24sIHByb2dyYW1JbmZvLm91dHB1dExheW91dC5zaGFwZS5sZW5ndGgpfWA7XG4gICAgfVxuICAgIC8vIHJlcGxhY2UgaW5saW5lc1xuICAgIHNvdXJjZSA9IHJlcGxhY2VJbmxpbmVzKHNvdXJjZSk7XG5cbiAgICAvLyBjb25jYXQgZmluYWwgc291cmNlIHN0cmluZ1xuICAgIHJldHVybiBgJHtnZXRGcmFnU2hhZGVyUHJlYW1ibGUodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKX1cbiAgICAke3RoaXMuZ2V0VW5pZm9ybXMocHJvZ3JhbUluZm8uc2FtcGxlcnMsIHByb2dyYW1JbmZvLnZhcmlhYmxlcyl9XG4gICAgJHt0aGlzLmdldEltcG9ydHMoc291cmNlKX1cbiAgICAke3NvdXJjZX1gO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEltcG9ydHMoc2NyaXB0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJvdXRpbmVzSW5jbHVkZWQgPSB0aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChzY3JpcHQpO1xuXG4gICAgaWYgKHJvdXRpbmVzSW5jbHVkZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IHJvdXRpbmVzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0aW5lc0luY2x1ZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocm91dGluZXNJbmNsdWRlZFtpXS5yb3V0aW5lQm9keSkge1xuICAgICAgICByb3V0aW5lcyArPSByb3V0aW5lc0luY2x1ZGVkW2ldLnJvdXRpbmVCb2R5ICsgJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke3JvdXRpbmVzSW5jbHVkZWRbaV0ubmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGluZXM7XG4gIH1cbiAgcHJpdmF0ZSBzZWxlY3RHbHNsTGliUm91dGluZXNUb0JlSW5jbHVkZWQoc2NyaXB0OiBzdHJpbmcpOiBHbHNsTGliUm91dGluZU5vZGVbXSB7XG4gICAgY29uc3Qgbm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdID0gW107XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoKS5mb3JFYWNoKGNsYXNzQW5kUm91dGluZSA9PiB7XG4gICAgICBjb25zdCByb3V0aW5lID0gY2xhc3NBbmRSb3V0aW5lLnNwbGl0KCcuJylbMV07XG4gICAgICBpZiAoc2NyaXB0LmluZGV4T2Yocm91dGluZSkgIT09IC0xKSB7XG4gICAgICAgIG5vZGVzLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtjbGFzc0FuZFJvdXRpbmVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRVbmlmb3JtcyhzYW1wbGVycz86IHN0cmluZ1tdLCB2YXJpYWJsZXM/OiBWYXJpYWJsZUluZm9bXSk6IHN0cmluZyB7XG4gICAgY29uc3QgdW5pZm9ybUxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChzYW1wbGVycykge1xuICAgICAgZm9yIChjb25zdCBzYW1wbGVyIG9mIHNhbXBsZXJzKSB7XG4gICAgICAgIHVuaWZvcm1MaW5lcy5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke3NhbXBsZXJ9O2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHZhcmlhYmxlcykge1xuICAgICAgICB1bmlmb3JtTGluZXMucHVzaChcbiAgICAgICAgICAgIGB1bmlmb3JtICR7dmFyaWFibGUudHlwZX0gJHt2YXJpYWJsZS5uYW1lfSR7dmFyaWFibGUuYXJyYXlMZW5ndGggPyBgWyR7dmFyaWFibGUuYXJyYXlMZW5ndGh9XWAgOiAnJ307YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTGluZXMuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Nvb3Jkc0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC1jb29yZGluYXRlLWxpYic7XG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGlifSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtFbmNvZGluZ0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC1lbmNvZGluZy1saWInO1xuaW1wb3J0IHtGcmFnQ29sb3JHbHNsTGlifSBmcm9tICcuL2dsc2wtZnJhZ2NvbG9yLWxpYic7XG5pbXBvcnQge1NoYXBlVXRpbHNHbHNsTGlifSBmcm9tICcuL2dsc2wtc2hhcGUtdXRpbHMtbGliJztcbmltcG9ydCB7VmVjR2xzbExpYn0gZnJvbSAnLi9nbHNsLXZlYy1saWInO1xuXG5leHBvcnQgY29uc3QgZ2xzbFJlZ2lzdHJ5OiB7W25hbWU6IHN0cmluZ106IG5ldyAoY29udGV4dDogR2xzbENvbnRleHQpID0+IEdsc2xMaWJ9ID0ge1xuICAnZW5jb2RpbmcnOiBFbmNvZGluZ0dsc2xMaWIsXG4gICdmcmFnY29sb3InOiBGcmFnQ29sb3JHbHNsTGliLFxuICAndmVjJzogVmVjR2xzbExpYixcbiAgJ3NoYXBlVXRpbHMnOiBTaGFwZVV0aWxzR2xzbExpYixcbiAgJ2Nvb3JkaW5hdGVzJzogQ29vcmRzR2xzbExpYixcbiAgLy8gICdhcnJheXMnOiBBcnJheUdsc2xTTGliXG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgZGF0YSB0eXBlcyBhbmQgcm91dGluZXMgZm9yIG1hbmlwdWxhdGluZ1xuICogY29vcmRpbmF0ZXMgYW5kIG1hcHBpbmcgdG8vZnJvbSB0ZW5zb3IgaW5kaWNlc1xuICovXG5leHBvcnQgY2xhc3MgU2hhcGVVdGlsc0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLmJjYXN0SW5kZXgoKSxcbiAgICAgIC4uLnRoaXMuYmNhc3RNYXRtdWxJbmRleCgpLFxuICAgICAgLi4udGhpcy5vZmZzZXRUb0luZGljZXMoKSxcbiAgICAgIC4uLnRoaXMuaW5kaWNlc1RvT2Zmc2V0KCksXG4gICAgICAuLi50aGlzLmluY3JlbWVudEluZGljZXMoKVxuICAgIH07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHByb3RlY3RlZCBiY2FzdEluZGV4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCBvdXRwdXRSYW5rID0gcHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgaWYgKHNoYXBlLmxlbmd0aCA8PSBvdXRwdXRSYW5rKSB7XG4gICAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRpbU9mZnNldCA9IG91dHB1dFJhbmsgLSByYW5rO1xuICAgICAgICBjb25zdCBmdW5jTmFtZSA9IGBiY2FzdEluZGljZXNfJHtuYW1lfWA7XG4gICAgICAgIGxldCBibG9jayA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2l9XSA9IGludCggbW9kKGZsb2F0KGJjYXN0ZWRJbmRpY2VzWyR7ZGltT2Zmc2V0ICsgaX1dKSwgJHtzaGFwZVtpXX0uMCkgKTtcbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmdW5jTmFtZX0gKGludCBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmt9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBiY2FzdE1hdG11bEluZGV4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCBvdXRwdXRSYW5rID0gcHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgaWYgKCEoc2hhcGUubGVuZ3RoIDwgMiB8fCBzaGFwZS5sZW5ndGggPiBvdXRwdXRSYW5rKSkge1xuICAgICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBvdXRwdXRSYW5rIC0gcmFuaztcbiAgICAgICAgY29uc3QgZnVuY05hbWUgPSBgYmNhc3RNYXRtdWxJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgKytpKSB7XG4gICAgICAgICAgYmxvY2sgKz0gYFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7aX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHtkaW1PZmZzZXQgKyBpfV0pLCAke3NoYXBlW2ldfS4wKSApO1xuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7cmFuayAtIDF9XSA9IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFuayAtIDF9XTtcbiAgICAgICAgICByZWFsSW5kaWNlc1ske3JhbmsgLSAyfV0gPSBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmsgLSAyfV07XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBpbmRpY2VzVG9PZmZzZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uc2FtcGxlcnMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0uc2hhcGU7XG4gICAgICBjb25zdCBzdHJpZGVzID0gcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLnN0cmlkZXM7XG4gICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGZ1bmNOYW1lID0gYGluZGljZXNUb09mZnNldF8ke25hbWV9YDtcbiAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoU2hhcGVVdGlsc0dsc2xMaWIuaW5kZXhUb09mZnNldFNpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcykpO1xuICAgICAgZnVuY05hbWUgPSBgaW5kaWNlc1RvT2Zmc2V0XyR7bmFtZX1fVGA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID1cbiAgICAgICAgICBuZXcgR2xzbExpYlJvdXRpbmUoU2hhcGVVdGlsc0dsc2xMaWIuaW5kZXhUb09mZnNldFNpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcy5zbGljZSgpLnJldmVyc2UoKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGluZGV4VG9PZmZzZXRTaW5nbGUobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdKTogc3RyaW5nIHtcbiAgICBsZXQgYmxvY2sgPSAnJztcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIG9mZnNldCArPSBpbmRpY2VzWyR7aX1dICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIGludCAke25hbWV9KGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYDtcbiAgfVxuICBwcm90ZWN0ZWQgb2Zmc2V0VG9JbmRpY2VzKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXS5zdHJpZGVzO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBvZmZzZXRUb0luZGljZXNfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLm9mZnNldFRvSW5kaWNlc1NpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcykpO1xuICAgICAgZnVuY05hbWUgPSBgb2Zmc2V0VG9JbmRpY2VzXyR7bmFtZX1fVGA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID1cbiAgICAgICAgICBuZXcgR2xzbExpYlJvdXRpbmUoU2hhcGVVdGlsc0dsc2xMaWIub2Zmc2V0VG9JbmRpY2VzU2luZ2xlKGZ1bmNOYW1lLCByYW5rLCBzdHJpZGVzLnNsaWNlKCkucmV2ZXJzZSgpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgb2Zmc2V0VG9JbmRpY2VzU2luZ2xlKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgY29uc3Qgc3RyaWRlc0Jsb2NrID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICBpbmRpY2VzWyR7aX1dID0gb2Zmc2V0IC8gJHtzdHJpZGVzW2ldfTtgKTtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgb2Zmc2V0IC09IGluZGljZXNbJHtpfV0gKiAke3N0cmlkZXNbaV19O2ApO1xuICAgIH1cbiAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICBpbmRpY2VzWyR7cmFuayAtIDF9XSA9IG9mZnNldDtgKTtcbiAgICByZXR1cm4gYFxuICAgICAgdm9pZCAke25hbWV9KGludCBvZmZzZXQsIG91dCBpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICAgIGA7XG4gIH1cbiAgcHJvdGVjdGVkIGluY3JlbWVudEluZGljZXMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uc2FtcGxlcnMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0uc2hhcGU7XG4gICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgZnVuY05hbWUgPSBgaW5jcmVtZW50SW5kaWNlc18ke25hbWV9YDtcbiAgICAgIGxldCBzaGFwZUluaXQgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIHNoYXBlSW5pdCArPSBgXG4gICAgICAgIHNoYXBlWyR7aX1dID0gJHtzaGFwZVtpXX07YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmdW5jTmFtZX0oaW50IGF4aXMsIG91dCBpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgIGludCBzaGFwZVske3Jhbmt9XTtcbiAgICAgICAgICAke3NoYXBlSW5pdH07XG4gICAgICAgICAgZm9yKGludCBpID0gJHtyYW5rfSAtMSA7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZihpID4gYXhpcykgY29udGludWU7XG4gICAgICAgICAgICBpbmRpY2VzW2ldICs9IDE7XG4gICAgICAgICAgICBpZihpbmRpY2VzW2ldIDwgc2hhcGVbaV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2VzW2ldID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogcmVwcmVzZW50IGEgdmVyc2lvbiBpcnJlbGV2YW50IGFic3RyYWN0aW9uIG9mIGZvciBHTFNMIHNvdXJjZSBjb2RlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2xzbCB7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYXR0cmlidXRlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZhcnlpbmdWZXJ0ZXg6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFyeWluZ0ZyYWc6IHN0cmluZztcbiAgcmVhZG9ubHkgdGV4dHVyZTJEOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nO1xuICByZWFkb25seSBvdXRwdXREZWNsYXJhdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBHTFNMX0VTXzJfMDogR2xzbCA9IHtcbiAgdmVyc2lvbjogJycsXG4gIGF0dHJpYnV0ZTogJ2F0dHJpYnV0ZScsXG4gIHZhcnlpbmdWZXJ0ZXg6ICd2YXJ5aW5nJyxcbiAgdmFyeWluZ0ZyYWc6ICd2YXJ5aW5nJyxcbiAgdGV4dHVyZTJEOiAndGV4dHVyZTJEJyxcbiAgb3V0cHV0OiAnZ2xfRnJhZ0NvbG9yJyxcbiAgb3V0cHV0RGVjbGFyYXRpb246ICcnLFxufTtcbmNvbnN0IEdMU0xfRVNfM18wOiBHbHNsID0ge1xuICB2ZXJzaW9uOiAnI3ZlcnNpb24gMzAwIGVzJyxcbiAgYXR0cmlidXRlOiAnaW4nLFxuICB2YXJ5aW5nVmVydGV4OiAnb3V0JyxcbiAgdmFyeWluZ0ZyYWc6ICdpbicsXG4gIHRleHR1cmUyRDogJ3RleHR1cmUnLFxuICBvdXRwdXQ6ICdvdXRwdXRDb2xvcicsXG4gIG91dHB1dERlY2xhcmF0aW9uOiAnb3V0IHZlYzQgb3V0cHV0Q29sb3I7Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbHNsKHZlcnNpb246IDF8Mikge1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMSA/IEdMU0xfRVNfMl8wIDogR0xTTF9FU18zXzA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UodmVyc2lvbjogMXwyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAke2dsc2wuYXR0cmlidXRlfSB2ZWMzIHBvc2l0aW9uO1xuICAgICAgJHtnbHNsLmF0dHJpYnV0ZX0gdmVjMiB0ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICR7Z2xzbC52YXJ5aW5nVmVydGV4fSB2ZWMyIFRleENvb3JkcztcblxuICAgICAgdm9pZCBtYWluKClcbiAgICAgIHtcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xuICAgICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnU2hhZGVyUHJlYW1ibGUodmVyc2lvbjogMXwyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAke2dsc2wudmFyeWluZ0ZyYWd9IHZlYzIgVGV4Q29vcmRzO1xuICAgICR7Z2xzbC5vdXRwdXREZWNsYXJhdGlvbn1cbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cbiAgICBzdHJ1Y3QgaXZlYzVcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgIH07XG5cbiAgICBzdHJ1Y3QgaXZlYzZcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgICAgaW50IHY7XG4gICAgfTtcblxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbiAgICB9XG5cbiAgICBgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKHZlcnNpb246IDF8Miwgb3V0cHV0U2hhcGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHZlcnNpb24pO1xuICByZXR1cm4gYFxuICB2b2lkIG1haW4oKSB7XG4gICAgaW50IGluZGljZXNbJHtvdXRwdXRTaGFwZUxlbmd0aH1dO1xuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XG4gICAgdmVjNCByZXN1bHQgPSB2ZWM0KHByb2Nlc3MoaW5kaWNlcykpO1xuICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICB9XG4gIGA7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciB2ZWMgcm91dGluZXNcbiAqIFZlYyBpcyBhbiB2YXJpYmxlIGxlbmd0aCBpbnQgYXJyYXkuIFRoZSBsZW5ndGggaXMgZml4ZWQgYXQgdGhlIHRpbWUgb2ZcbiAqIGdlbmVyYXRpbmcgdGhlIGxpYnJhcnkgZnVuY3Rpb25zIGZyb20gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG91dHB1dC5cbiAqL1xuZXhwb3J0IGNsYXNzIFZlY0dsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ30ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7Li4udGhpcy5iaW5hcnlWZWNGdW5jdGlvbnMoKSwgLi4udGhpcy5jb3B5VmVjKCksIC4uLnRoaXMuc2V0VmVjSXRlbSgpLCAuLi50aGlzLmdldFZlY0l0ZW0oKX07XG4gIH1cbiAgcHJvdGVjdGVkIGJpbmFyeVZlY0Z1bmN0aW9ucygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLm91dHB1dExheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBuYW1lT3A6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSA9IHthZGQ6ICcrPScsIHN1YjogJy09JywgbXVsOiAnKj0nLCBkaXY6ICcvPSd9O1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmFtZU9wKSB7XG4gICAgICBjb25zdCBmbmFtZSA9IGAke25hbWV9VmVjYDtcbiAgICAgIGxldCBhc3NpZ25tZW50QmxvY2sgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICAgIGFzc2lnbm1lbnRCbG9jayArPSBgXG4gICAgICAgICAgZGVzdFske2l9XSAke25hbWVPcFtuYW1lXX0gc3JjWyR7aX1dO1xuICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7Zm5hbWV9KGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAgICR7YXNzaWdubWVudEJsb2NrfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXN1bHRbZm5hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcHJvdGVjdGVkIGNvcHlWZWMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBhc3NpZ25tZW50QmxvY2sgKz0gYFxuICAgICAgICBkZXN0WyR7aX1dID0gc3JjWyR7aX1dO1xuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAke2Fzc2lnbm1lbnRCbG9ja31cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHtjb3B5VmVjOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFZlY0l0ZW0oKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGJsb2NrID0gYFxuICAgICAgICBpZihpbmRleCA8IDApXG4gICAgICAgICAgICBpbmRleCA9JHtyYW5rfSArIGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgIG1bMF0gPSB2YWx1ZTtcbiAgICAgICAgYDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmsgLSAxOyArK2kpIHtcbiAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtpfSlcbiAgICAgICAgICAgIG1bJHtpfV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGA7XG4gICAgfVxuICAgIGJsb2NrICs9IGBcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbVske3JhbmsgLSAxfV0gPSB2YWx1ZTtcbiAgICAgICAgYDtcbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCBzZXRWZWNJdGVtKG91dCBpbnQgbVske3Jhbmt9XSwgaW50IGluZGV4LCBpbnQgdmFsdWUpIHtcbiAgICAgICAgJHtibG9ja31cbiAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4ge3NldFZlY0l0ZW06IG5ldyBHbHNsTGliUm91dGluZShib2R5KX07XG4gIH1cbiAgcHJvdGVjdGVkIGdldFZlY0l0ZW0oKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGJsb2NrID0gYFxuICAgICAgICBpZihpbmRleCA8IDApXG4gICAgICAgICAgICBpbmRleCA9ICR7cmFua30gKyBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gbVswXTtcbiAgICAgIGA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7aX0pXG4gICAgICAgICAgICByZXR1cm4gbVske2l9XTtcbiAgICAgIGA7XG4gICAgfVxuICAgIGJsb2NrICs9IGBcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1bJHtyYW5rIC0gMX1dO1xuICAgICAgICBgO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICBpbnQgZ2V0VmVjSXRlbShpbnQgbVske3Jhbmt9XSwgaW50IGluZGV4KSB7XG4gICAgICAgICR7YmxvY2t9XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4ge2dldFZlY0l0ZW06IG5ldyBHbHNsTGliUm91dGluZShib2R5KX07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMUGFja30gZnJvbSAnLi9vcHMvcGFjayc7XG5cbmltcG9ydCB7V2ViR0xVaW50OEVuY29kZX0gZnJvbSAnLi9vcHMvdWludDgtZW5jb2RlJztcbmltcG9ydCB7V2ViR0xVbnBhY2t9IGZyb20gJy4vb3BzL3VucGFjayc7XG5pbXBvcnQge1dlYkdMU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7RW5jb2Rlcn0gZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQge1dpZHRoSGVpZ2h0UHJlZnN9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHtBcnRpZmFjdCwgUnVuRGF0YSwgVGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXQsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtnZXRQYWNrZWRTaGFwZX0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgcHJpdmF0ZSBwYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHByaXZhdGUgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHByaXZhdGUgcGFjazJ1bnBhY2tNYXA6IE1hcDxUZW5zb3IuSWQsIFRlbnNvci5JZD47XG4gIHByaXZhdGUgdW5wYWNrMnBhY2tNYXA6IE1hcDxUZW5zb3IuSWQsIFRlbnNvci5JZD47XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXNzaW9uOiBXZWJHTFNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuXG4gICAgdGhpcy5wYWNrMnVucGFja01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFjazJwYWNrTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgcnVuKG9wOiBXZWJHTE9wZXJhdG9yLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChvcCk7XG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBvcC5jcmVhdGVQcm9ncmFtSW5mbyh0aGlzLCBpbnB1dHMpO1xuICAgICAgaWYgKCFwcm9ncmFtSW5mby5uYW1lKSB7XG4gICAgICAgIHByb2dyYW1JbmZvLm5hbWUgPSBvcC5jb25zdHJ1Y3Rvcj8ubmFtZTtcbiAgICAgIH1cbiAgICAgIGFydGlmYWN0ID0gdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW1JbmZvKTtcbiAgICAgIHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChvcCwgYXJ0aWZhY3QpO1xuICAgIH1cbiAgICBjb25zdCBydW5EYXRhID0gb3AuY3JlYXRlUnVuRGF0YSh0aGlzLCBhcnRpZmFjdC5wcm9ncmFtSW5mbywgaW5wdXRzKTtcbiAgICB0aGlzLnJ1blByb2dyYW0oYXJ0aWZhY3QsIHJ1bkRhdGEpO1xuICAgIHJldHVybiBbcnVuRGF0YS5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3JdO1xuICB9XG5cbiAgY2hlY2tBbmRVcGRhdGVUZXh0dXJlRm9ybShhcnRpZmFjdDogQXJ0aWZhY3QsIHJ1bkRhdGE6IFJ1bkRhdGEpIHtcbiAgICAvLyBwYWNrL3VucGFjayBpbnB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bkRhdGEuaW5wdXRUZXh0dXJlRGF0YXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gcnVuRGF0YS5pbnB1dFRleHR1cmVEYXRhc1tpXTtcbiAgICAgIGlmIChpbnB1dC5pc1BhY2tlZCAmJiAhYXJ0aWZhY3QucHJvZ3JhbUluZm8uZXhwZWN0UGFja2VkSW5wdXRzKSB7XG4gICAgICAgIHJ1bkRhdGEuaW5wdXRUZXh0dXJlRGF0YXNbaV0gPSB0aGlzLnVucGFjayhpbnB1dCk7XG4gICAgICB9IGVsc2UgaWYgKCFpbnB1dC5pc1BhY2tlZCAmJiBhcnRpZmFjdC5wcm9ncmFtSW5mby5leHBlY3RQYWNrZWRJbnB1dHMpIHtcbiAgICAgICAgcnVuRGF0YS5pbnB1dFRleHR1cmVEYXRhc1tpXSA9IHRoaXMucGFjayhpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJ1blByb2dyYW0oYXJ0aWZhY3Q6IEFydGlmYWN0LCBydW5EYXRhOiBSdW5EYXRhKSB7XG4gICAgdGhpcy5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKGFydGlmYWN0LCBydW5EYXRhKTtcblxuICAgIC8vIG91dHB1dCBzaG91bGQgbWF0Y2hcbiAgICBpZiAoISFydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhLmlzUGFja2VkICE9PSAhIWFydGlmYWN0LnByb2dyYW1JbmZvLmV4cGVjdFBhY2tlZE91dHB1dHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBydW5EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlRGF0YSBvYmplY3QgZnJvbSBhIHRlbnNvci5cbiAgICogVXNhZ2UgPSBFbmNvZGVyLlVzYWdlLlVwbG9hZE9ubHkuXG4gICAqIElmIGEgcmVsYXRlZCB0ZXh0dXJlIGRhdGEgaXMgZm91bmQgaW4gY2FjaGUsIHJldHVybnMgaXQ7XG4gICAqIE90aGVyd2lzZTpcbiAgICogICBDcmVhdGVzIGEgbmV3IHRleHR1cmUgbGF5b3V0IGlmIG5vdCBwcm92aWRlZDtcbiAgICogICBDcmVhdGVzIFdlYkdMVGV4dHVyZSB3aXRoIHRoZSBsYXlvdXQ7XG4gICAqICAgVXBsb2FkIHRlbnNvciBkYXRhIHRvIHRoZSB0ZXh0dXJlO1xuICAgKiAgIENyZWF0ZXMgYSB0ZXh0dXJlIGRhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3Igd2l0aCBkYXRhIHRvIHVwbG9hZFxuICAgKi9cbiAgZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0ZW5zb3I6IFRlbnNvciwgbGF5b3V0PzogVGV4dHVyZUxheW91dCwgaXNQYWNrZWQgPSBmYWxzZSkge1xuICAgIGxldCB0ZCA9IHRoaXMuZ2V0VGV4dHVyZURhdGEodGVuc29yLmRhdGFJZCwgaXNQYWNrZWQpO1xuICAgIGlmICghdGQpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdJbmZlcmVuY2VIYW5kbGVyJywgYENyZWF0aW5nIG5ldyBUZXh0dXJlRGF0YSBmb3IgZGltczogWyR7dGVuc29yLmRpbXN9XWApO1xuICAgICAgaWYgKCFsYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0ID0gdGhpcy5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHRlbnNvci5kaW1zLnNsaWNlKCkpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgZmluZCB0aGUgdGV4dHVyZSBkYXRhIHdpdGggc3BlY2lmaWMgcGFjayBtb2RlIGluIHRoZSBjYWNoZSwgdHJ5IHdpdGggdGhlIGRpZmZlcmVudFxuICAgICAgLy8gcGFjayBtb2RlIHRvIHNlZSBpZiB0aGUgdGVuc29yIGlzIGNhY2hlZCB1c2luZyB0aGF0IHBhY2sgbW9kZS4gSWYgc3VjY2VlZCwgd2UgY2FuIHJldHVybiB0aGlzXG4gICAgICAvLyB0ZW5zb3IgZGF0YSBhbmQgbGF0ZXIgYXBwbHkgYSBwYWNrL3VucGFjayBvcCBvbiB0aGlzIHRleHR1cmUsIG5vIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG9uZSBoZXJlLlxuICAgICAgdGQgPSB0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsICFpc1BhY2tlZCk7XG4gICAgICBpZiAoIXRkKSB7XG4gICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZUxheW91dCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHRlbnNvciwgMSwgZmFsc2UsIFtdLCB0cnVlKTtcbiAgICAgICAgICBjb25zdCB1bnBhY2tlZFRleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShcbiAgICAgICAgICAgICAgdW5wYWNrZWRUZXh0dXJlTGF5b3V0LCB0ZW5zb3IudHlwZSwgdGVuc29yLm51bWJlckRhdGEsIHRlbnNvciwgRW5jb2Rlci5Vc2FnZS5VcGxvYWRPbmx5KTtcbiAgICAgICAgICB0ZCA9IHRoaXMucGFjayh1bnBhY2tlZFRleHR1cmVEYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZCA9IHRoaXMuY3JlYXRlVGV4dHVyZURhdGEobGF5b3V0LCB0ZW5zb3IudHlwZSwgdGVuc29yLm51bWJlckRhdGEsIHRlbnNvciwgRW5jb2Rlci5Vc2FnZS5VcGxvYWRPbmx5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnSW5mZXJlbmNlSGFuZGxlcicsIGBSZXRyaWV2aW5nIFRleHR1cmVEYXRhIGZyb20gY2FjaGU6IFske3RlbnNvci5kaW1zfV1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRleHR1cmVEYXRhIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIHR5cGUgYW5kIHRleHR1cmUgbGF5b3V0LlxuICAgKiBVc2FnZSA9IEVuY29kZXIuVXNhZ2UuRGVmYXVsdC5cbiAgICogQHBhcmFtIGRhdGFUeXBlIHRoZSB0ZW5zb3IgZGF0YSB0eXBlXG4gICAqL1xuICBjcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQobGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlKTogVGV4dHVyZURhdGEge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGxheW91dCwgZGF0YVR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRleHR1cmVEYXRhIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gZGF0YSBhbmQgYmluZCB0byB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBVc2FnZSA9IEVuY29kZXIuVXNhZ2UuVXBsb2FkT25seS5cbiAgICogTk9URTogdGhpcyBmdW5jdGlvbiBpcyBhIGhhY2sgZm9yIENvbnYgaW1wbGVtZW50YXRpb24uIHNob3VsZCByZW1vdmUgdGhpcyBmdW5jdGlvbiwgYWZ0ZXIgcmV3cml0aW5nIENvbnZcbiAgICogaW1wbGVtZW50YXRpb24gYnkgR3JhcGguVHJhbnNmb3JtZXJcbiAgICogQHBhcmFtIGRhdGFUeXBlIHRoZSB0ZW5zb3IgZGF0YSB0eXBlXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBhY3R1YWwgZGF0YSB0byB1cGxvYWRcbiAgICogQHBhcmFtIHRlbnNvciB0aGUgdGVuc29yIHRvIGJpbmQuIHRlbnNvcidzIGRhdGEgaXMgaWdub3JlZC5cbiAgICovXG4gIGNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dEJpbmRUZW5zb3IoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IFRlbnNvci5OdW1iZXJUeXBlLCB0ZW5zb3I6IFRlbnNvcik6IFRleHR1cmVEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShsYXlvdXQsIGRhdGFUeXBlLCBkYXRhLCB0ZW5zb3IsIEVuY29kZXIuVXNhZ2UuVXBsb2FkT25seSk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVRleHR1cmVEYXRhKFxuICAgICAgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBkYXRhPzogVGVuc29yLk51bWJlclR5cGUsIHRlbnNvcj86IFRlbnNvcixcbiAgICAgIHVzYWdlPzogRW5jb2Rlci5Vc2FnZSk6IFRleHR1cmVEYXRhIHtcbiAgICBMb2dnZXIudmVyYm9zZSgnSW5mZXJlbmNlSGFuZGxlcicsIGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KGxheW91dCl9XWApO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY3JlYXRlVGV4dHVyZUZyb21MYXlvdXQoZGF0YVR5cGUsIGxheW91dCwgZGF0YSwgdXNhZ2UpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUobGF5b3V0LCBkYXRhVHlwZSwgdGV4dHVyZSwgdGVuc29yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlRGF0YSBvYmplY3QsIHVzaW5nIHRoZSBnaXZlbiB0ZXh0dXJlLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNyZWF0ZSBuZXcgdGV4dHVyZS4gVXN1YWxseSB1c2VkIGluIHNjZW5hcmlvcyB1c2luZyB0ZXh0dXJlIHNoYXJpbmcuIChlZy4gUmVzaGFwZSlcbiAgICogQHBhcmFtIGRhdGFUeXBlIHRoZSB0ZW5zb3IgZGF0YSB0eXBlXG4gICAqIEBwYXJhbSB0ZXh0dXJlIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IHRvIHNoYXJlXG4gICAqIEBwYXJhbSB0ZW5zb3JJZCB0aGUgdGVuc29yIElEIG9mIHRoZSBzaGFyZWQgdGVuc29yIGRhdGFcbiAgICovXG4gIGNyZWF0ZVNoYXJlZFRleHR1cmVEYXRhKFxuICAgICAgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHRlbnNvcklkPzogVGVuc29yLklkKTogVGV4dHVyZURhdGEge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUobGF5b3V0LCBkYXRhVHlwZSwgdGV4dHVyZSwgdW5kZWZpbmVkLCB0ZW5zb3JJZCk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgdGVuc29yPzogVGVuc29yLCB0ZW5zb3JJZD86IFRlbnNvci5JZCkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSA9IHtcbiAgICAgIC4uLmxheW91dCxcbiAgICAgIHRlbnNvcjogdGVuc29yIHx8XG4gICAgICAgICAgbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAgIGxheW91dC51bnBhY2tlZFNoYXBlLCBkYXRhVHlwZSwgKF9pZDogVGVuc29yLklkKSA9PiB0aGlzLnJlYWRUZXh0dXJlKHRleHR1cmVEYXRhKSwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB0ZW5zb3JJZCksXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnNldFRleHR1cmVEYXRhKHRleHR1cmVEYXRhLnRlbnNvci5kYXRhSWQsIHRleHR1cmVEYXRhLCBsYXlvdXQuaXNQYWNrZWQpO1xuICAgIHJldHVybiB0ZXh0dXJlRGF0YTtcbiAgfVxuXG4gIGdldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIGlzUGFja2VkID0gZmFsc2UpOiBUZXh0dXJlRGF0YXx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0ZW5zb3JJZCkgP1xuICAgICAgICB0aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEodGVuc29ySWQsIGlzUGFja2VkKSA6XG4gICAgICAgIGlzUGFja2VkID8gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCkgOiB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpO1xuICB9XG4gIHNldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIHRkOiBUZXh0dXJlRGF0YSwgaXNQYWNrZWQgPSBmYWxzZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0ZW5zb3JJZCkpIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5zZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZCwgdGQsIGlzUGFja2VkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKGlzUGFja2VkID8gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlIDogdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUpLnNldCh0ZW5zb3JJZCwgdGQpO1xuICAgIH1cbiAgfVxuICBpc1RleHR1cmVMYXlvdXRDYWNoZWQodGVuc29yOiBUZW5zb3IsIGlzUGFja2VkID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIGlzUGFja2VkKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZUxheW91dCBvYmplY3QgZnJvbSBhIHRlbnNvci4gSWYgYSByZWxhdGVkIHRleHR1cmUgZGF0YSBpcyBmb3VuZCwgcmV0dXJucyB0aGUgY2FjaGVkIHRleHR1cmUgbGF5b3V0LlxuICAgKi9cbiAgZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KFxuICAgICAgdGVuc29yOiBUZW5zb3IsIGNoYW5uZWxzOiAxfDQgPSAxLCBpc1BhY2tlZCA9IGZhbHNlLCB1bnBhY2tlZFNoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICByZXZlcnNlV0ggPSBmYWxzZSk6IFRleHR1cmVMYXlvdXQge1xuICAgIGNvbnN0IHRkID0gdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCBpc1BhY2tlZCk7XG4gICAgaWYgKHRkKSB7XG4gICAgICByZXR1cm4gdGQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoXG4gICAgICAgIGNoYW5uZWxzID09PSAxIHx8IGlzUGFja2VkID8gdGVuc29yLmRpbXMgOiBnZXRQYWNrZWRTaGFwZSh0ZW5zb3IuZGltcyksIGNoYW5uZWxzLCB1bnBhY2tlZFNoYXBlLFxuICAgICAgICBpc1BhY2tlZCB8fCByZXZlcnNlV0ggPyB7aXNQYWNrZWQsIHJldmVyc2VXSH0gOiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRleHR1cmVMYXlvdXQgb2JqZWN0IGZyb20gc2hhcGUuXG4gICAqL1xuICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKFxuICAgICAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBjaGFubmVsczogMXw0ID0gMSwgdW5wYWNrZWRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogVGV4dHVyZUxheW91dCB7XG4gICAgY29uc3QgaXNQYWNrZWQgPSAhIShwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZCk7XG4gICAgY29uc3QgW3RleFdpZHRoLCB0ZXhIZWlnaHRdID1cbiAgICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LmNvbXB1dGVUZXh0dXJlV0goaXNQYWNrZWQgPyB1bnBhY2tlZFNoYXBlIHx8IHNoYXBlIDogc2hhcGUsIHByZWZzKTtcbiAgICBsZXQgW3dpZHRoLCBoZWlnaHRdID0gW3RleFdpZHRoLCB0ZXhIZWlnaHRdO1xuICAgIGlmIChwcmVmcyAmJiBwcmVmcy5yZXZlcnNlV0gpIHtcbiAgICAgIHdpZHRoID0gdGV4SGVpZ2h0O1xuICAgICAgaGVpZ2h0ID0gdGV4V2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgbGV0IGluZmVycmVkRGltcyA9IHNoYXBlLnNsaWNlKDApO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICBpbmZlcnJlZERpbXMgPSBbMV07XG4gICAgfVxuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgLy8gdW5wYWNrZWRTaGFwZSB3aWxsIHRha2UgYHNoYXBlYCBhbmQgbm90IGBpbmZlcnJlZERpbXNgIHNvIGFzIHRvIGNyZWF0ZSBhIHNjYWxhciBUZW5zb3IgaWYgbmVlZCBiZVxuICAgICAgdW5wYWNrZWRTaGFwZSA9IHNoYXBlO1xuICAgIH0gZWxzZSBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIGlmIChjaGFubmVscyAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2EgcGFja2VkIHRleHR1cmUgbXVzdCBiZSA0LWNoYW5uZWwnKTtcbiAgICAgIH1cbiAgICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgICAgIGlmIChyYW5rID4gMCkge1xuICAgICAgICBpbmZlcnJlZERpbXNbcmFuayAtIDFdID0gTWF0aC5jZWlsKGluZmVycmVkRGltc1tyYW5rIC0gMV0gLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyYW5rID4gMSkge1xuICAgICAgICBpbmZlcnJlZERpbXNbcmFuayAtIDJdID0gTWF0aC5jZWlsKGluZmVycmVkRGltc1tyYW5rIC0gMl0gLyAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF1bnBhY2tlZFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBjaGFubmVscyxcbiAgICAgIGlzUGFja2VkLFxuICAgICAgc2hhcGU6IGluZmVycmVkRGltcyxcbiAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhpbmZlcnJlZERpbXMpLFxuICAgICAgdW5wYWNrZWRTaGFwZSxcbiAgICAgIHJldmVyc2VkV0g6IChwcmVmcyAmJiBwcmVmcy5yZXZlcnNlV0gpXG4gICAgfTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJlYWRUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBpZiAodGV4dHVyZURhdGEuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUZXh0dXJlKHRoaXMudW5wYWNrKHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBvcCA9IG5ldyBXZWJHTFVpbnQ4RW5jb2RlKCk7XG4gICAgICBjb25zdCB1aW50OFREID0gb3AucnVuSW50ZXJuYWwodGhpcywgdGV4dHVyZURhdGEpO1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCh1aW50OFREKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIHBhY2soaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEge1xuICAgIGNvbnN0IGNhY2hlZElkID0gdGhpcy51bnBhY2sycGFja01hcC5nZXQoaW5wdXQudGVuc29yLmRhdGFJZCk7XG4gICAgaWYgKGNhY2hlZElkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldChjYWNoZWRJZCkhO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBgJHtpbnB1dC5zaGFwZX1gO1xuICAgIGxldCBvcCA9IHRoaXMuc2Vzc2lvbi5wYWNrT3BDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIW9wKSB7XG4gICAgICBvcCA9IG5ldyBXZWJHTFBhY2soKTtcbiAgICAgIHRoaXMuc2Vzc2lvbi5wYWNrT3BDYWNoZS5zZXQoa2V5LCBvcCk7XG4gICAgfVxuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChvcCk7XG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSBvcC5jcmVhdGVQcm9ncmFtSW5mbyh0aGlzLCBbaW5wdXQudGVuc29yXSk7XG4gICAgICBhcnRpZmFjdCA9IHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtSW5mbyk7XG4gICAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qob3AsIGFydGlmYWN0KTtcbiAgICB9XG4gICAgY29uc3QgcnVuRGF0YSA9IG9wLmNyZWF0ZVJ1bkRhdGEodGhpcywgYXJ0aWZhY3QucHJvZ3JhbUluZm8sIFtpbnB1dC50ZW5zb3JdKTtcbiAgICB0aGlzLnJ1blByb2dyYW0oYXJ0aWZhY3QsIHJ1bkRhdGEpO1xuICAgIHRoaXMudW5wYWNrMnBhY2tNYXAuc2V0KGlucHV0LnRlbnNvci5kYXRhSWQsIHJ1bkRhdGEub3V0cHV0VGV4dHVyZURhdGEudGVuc29yLmRhdGFJZCk7XG4gICAgcmV0dXJuIHJ1bkRhdGEub3V0cHV0VGV4dHVyZURhdGE7XG4gIH1cblxuICB1bnBhY2soaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEge1xuICAgIGNvbnN0IGNhY2hlZElkID0gdGhpcy5wYWNrMnVucGFja01hcC5nZXQoaW5wdXQudGVuc29yLmRhdGFJZCk7XG4gICAgaWYgKGNhY2hlZElkKSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KGNhY2hlZElkKSE7XG4gICAgfVxuICAgIC8vIEZvciB1bnBhY2tlZCBrZXJuZWwsIGNhY2hlIGl0IGJ5IHVzaW5nIGlucHV0J3MgdW5wYWNrZWRTaGFwZSBhcyBjYWNoZSBrZXkuXG4gICAgLy8gTm90ZSB0aGF0IHdlIG5lZWQgdG8gdXNlIGlucHV0LnVucGFja2VkU2hhcGUgaW5zdGVhZCBvZiBpbnB1dC5zaGFwZSBoZXJlLFxuICAgIC8vIGFzIHRoZSBzaGFwZSBpbmZlcnMgdGhlIHBhY2tlZCB0ZXh0dXJlIHNoYXBlLiBEaWZmZXJlbnQgdW5wYWNrZWRTaGFwZSBjYW4gaGF2ZSB0aGVcbiAgICAvLyBzYW1lIHBhY2tlZCB0ZXh0dXJlIHNoYXBlLiBGb3IgZXhhbXBsZSwgZm9yIHVucGFja2VkIHNoYXBlLCBib3RoIFsyLCAzXSBhbmRcbiAgICAvLyBbMiwgNF0gaGFzIHRoZSBzYW1lIHBhY2tlZCBzaGFwZSBbMSwgMl0sIGJ1dCB0aG9zZSB0d28gc2hhcGVzIHNob3VsZCBoYXZlIGRpZmZlcmVudFxuICAgIC8vIHVucGFjayBzaGFkZXJzLlxuICAgIGNvbnN0IGtleSA9IGAke2lucHV0LnVucGFja2VkU2hhcGV9YDtcbiAgICBsZXQgb3AgPSB0aGlzLnNlc3Npb24udW5wYWNrT3BDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIW9wKSB7XG4gICAgICBvcCA9IG5ldyBXZWJHTFVucGFjaygpO1xuICAgICAgdGhpcy5zZXNzaW9uLnVucGFja09wQ2FjaGUuc2V0KGtleSwgb3ApO1xuICAgIH1cbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qob3ApO1xuICAgIGlmICghYXJ0aWZhY3QpIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gb3AuY3JlYXRlUHJvZ3JhbUluZm8odGhpcywgW2lucHV0LnRlbnNvcl0pO1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8pO1xuICAgICAgdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KG9wLCBhcnRpZmFjdCk7XG4gICAgfVxuICAgIGNvbnN0IHJ1bkRhdGEgPSBvcC5jcmVhdGVSdW5EYXRhKHRoaXMsIGFydGlmYWN0LnByb2dyYW1JbmZvLCBbaW5wdXQudGVuc29yXSk7XG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBydW5EYXRhKTtcbiAgICB0aGlzLnBhY2sydW5wYWNrTWFwLnNldChpbnB1dC50ZW5zb3IuZGF0YUlkLCBydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvci5kYXRhSWQpO1xuICAgIHJldHVybiBydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtGTE9BVF9UWVBFUywgTlVNQkVSX1RZUEVTfSBmcm9tICcuLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtPcFNldH0gZnJvbSAnLi4vLi4vb3BzZXQnO1xuXG5pbXBvcnQge1dlYkdMQmF0Y2hOb3JtYWxpemF0aW9ufSBmcm9tICcuL29wcy9iYXRjaC1ub3JtYWxpemF0aW9uJztcbmltcG9ydCAqIGFzIGJpbmFyeU9wcyBmcm9tICcuL29wcy9iaW5hcnktb3AnO1xuaW1wb3J0IHtXZWJHTENsaXB9IGZyb20gJy4vb3BzL2NsaXAnO1xuaW1wb3J0IHtXZWJHTENvbmNhdH0gZnJvbSAnLi9vcHMvY29uY2F0JztcbmltcG9ydCB7V2ViR0xDb252fSBmcm9tICcuL29wcy9jb252JztcbmltcG9ydCB7V2ViR0xEZXB0aFRvU3BhY2V9IGZyb20gJy4vb3BzL2RlcHRoLXRvLXNwYWNlJztcbmltcG9ydCB7V2ViR0xEcm9wb3V0fSBmcm9tICcuL29wcy9kcm9wb3V0JztcbmltcG9ydCB7V2ViR0xFbHV9IGZyb20gJy4vb3BzL2VsdSc7XG5pbXBvcnQge1dlYkdMRmxhdHRlbn0gZnJvbSAnLi9vcHMvZmxhdHRlbic7XG5pbXBvcnQge1dlYkdMR2F0aGVyfSBmcm9tICcuL29wcy9nYXRoZXInO1xuaW1wb3J0IHtXZWJHTEdlbW19IGZyb20gJy4vb3BzL2dlbW0nO1xuaW1wb3J0IHtXZWJHTEltYWdlU2NhbGVyfSBmcm9tICcuL29wcy9pbWFnZS1zY2FsZXInO1xuaW1wb3J0IHtXZWJHTEluc3RhbmNlTm9ybWFsaXphdGlvbn0gZnJvbSAnLi9vcHMvaW5zdGFuY2Utbm9ybWFsaXphdGlvbic7XG5pbXBvcnQge1dlYkdMTGVha3lSZWx1fSBmcm9tICcuL29wcy9sZWFreS1yZWx1JztcbmltcG9ydCB7V2ViR0xNYXRNdWx9IGZyb20gJy4vb3BzL21hdG11bCc7XG5pbXBvcnQge1dlYkdMUGFkfSBmcm9tICcuL29wcy9wYWQnO1xuaW1wb3J0IHtXZWJHTEF2ZXJhZ2VQb29sLCBXZWJHTEdsb2JhbEF2ZXJhZ2VQb29sLCBXZWJHTEdsb2JhbE1heFBvb2wsIFdlYkdMTWF4UG9vbH0gZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQgKiBhcyByZWR1Y2VPcHMgZnJvbSAnLi9vcHMvcmVkdWNlJztcbmltcG9ydCB7V2ViR0xSZXNoYXBlfSBmcm9tICcuL29wcy9yZXNoYXBlJztcbmltcG9ydCB7V2ViR0xSZXNpemVQYWNrZWR9IGZyb20gJy4vb3BzL3Jlc2l6ZS1wYWNrZWQnO1xuaW1wb3J0IHtXZWJHTFNoYXBlfSBmcm9tICcuL29wcy9zaGFwZSc7XG5pbXBvcnQge1dlYkdMU2xpY2UsIFdlYkdMU2xpY2VWMTB9IGZyb20gJy4vb3BzL3NsaWNlJztcbmltcG9ydCB7V2ViR0xTb2Z0bWF4fSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7V2ViR0xTcGxpdH0gZnJvbSAnLi9vcHMvc3BsaXQnO1xuaW1wb3J0IHtXZWJHTFNxdWVlemV9IGZyb20gJy4vb3BzL3NxdWVlemUnO1xuaW1wb3J0IHtXZWJHTFN1bX0gZnJvbSAnLi9vcHMvc3VtJztcbmltcG9ydCB7V2ViR0xUaWxlfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7V2ViR0xUcmFuc3Bvc2V9IGZyb20gJy4vb3BzL3RyYW5zcG9zZSc7XG5pbXBvcnQgKiBhcyB1bmFyeU9wcyBmcm9tICcuL29wcy91bmFyeS1vcCc7XG5pbXBvcnQge1dlYkdMVW5zcXVlZXplfSBmcm9tICcuL29wcy91bnNxdWVlemUnO1xuaW1wb3J0IHtXZWJHTFVwc2FtcGxlfSBmcm9tICcuL29wcy91cHNhbXBsZSc7XG5cbmV4cG9ydCBjb25zdCBXRUJHTF9PUF9SRVNPTFZFX1JVTEVTOiByZWFkb25seSBPcFNldC5SZXNvbHZlUnVsZVtdID0gW1xuICBbJ0FicycsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKE5VTUJFUl9UWVBFUywgdW5hcnlPcHMuZ2xzbEFicygpKV0sXG4gIFsnQWNvcycsICcnLCAnNysnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsQWNvcygpKV0sXG4gIFsnQWRkJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChOVU1CRVJfVFlQRVMsIGJpbmFyeU9wcy5nbHNsQWRkKCkpXSxcbiAgWydBbmQnLCAnJywgJzcrJywgKCkgPT4gbmV3IGJpbmFyeU9wcy5XZWJHTEJpbmFyeU9wKFsnYm9vbCddLCBiaW5hcnlPcHMuZ2xzbEFuZCgpKV0sXG4gIFsnQXNpbicsICcnLCAnNysnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsQXNpbigpKV0sXG4gIFsnQXRhbicsICcnLCAnNysnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsQXRhbigpKV0sXG4gIFsnQXZlcmFnZVBvb2wnLCAnJywgJzctMTAnLCAoKSA9PiBuZXcgV2ViR0xBdmVyYWdlUG9vbCgpXSwgIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIEF2ZXJhZ2VQb29sLTEwXG4gIFsnQmF0Y2hOb3JtYWxpemF0aW9uJywgJycsICc3KycsICgpID0+IG5ldyBXZWJHTEJhdGNoTm9ybWFsaXphdGlvbigpXSxcbiAgWydDZWlsJywgJycsICc2KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xDZWlsKCkpXSxcbiAgWydDbGlwJywgJycsICc2LTEwJywgKCkgPT4gbmV3IFdlYkdMQ2xpcCgpXSxcbiAgWydDb25jYXQnLCAnJywgJzQrJywgKCkgPT4gbmV3IFdlYkdMQ29uY2F0KCldLFxuICBbJ0NvbnYnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMQ29udigpXSxcbiAgWydDb3MnLCAnJywgJzcrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbENvcygpKV0sXG4gIFsnRGl2JywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChOVU1CRVJfVFlQRVMsIGJpbmFyeU9wcy5nbHNsRGl2KCkpXSxcbiAgWydEcm9wb3V0JywgJycsICc3KycsICgpID0+IG5ldyBXZWJHTERyb3BvdXQoKV0sXG4gIFsnRGVwdGhUb1NwYWNlJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTERlcHRoVG9TcGFjZSgpXSxcbiAgWydFcXVhbCcsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoTlVNQkVSX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbEVxdWFsKCksIHVuZGVmaW5lZCwgJ2Jvb2wnKV0sXG4gIFsnRWx1JywgJycsICc2KycsICgpID0+IG5ldyBXZWJHTEVsdSgpXSxcbiAgWydFeHAnLCAnJywgJzYrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbEV4cCgpKV0sXG4gIFsnRmxhdHRlbicsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xGbGF0dGVuKCldLFxuICBbJ0Zsb29yJywgJycsICc2KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xGbG9vcigpKV0sXG4gIFsnR2F0aGVyJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTEdhdGhlcigpXSxcbiAgWydHZW1tJywgJycsICc3LTEwJywgKCkgPT4gbmV3IFdlYkdMR2VtbShmYWxzZSldLFxuICBbJ0dlbW0nLCAnJywgJzExKycsICgpID0+IG5ldyBXZWJHTEdlbW0odHJ1ZSldLFxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTEdsb2JhbEF2ZXJhZ2VQb29sKCldLFxuICBbJ0dsb2JhbE1heFBvb2wnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMR2xvYmFsTWF4UG9vbCgpXSxcbiAgWydHcmVhdGVyJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChOVU1CRVJfVFlQRVMsIGJpbmFyeU9wcy5nbHNsR3JlYXRlcigpLCB1bmRlZmluZWQsICdib29sJyldLFxuICBbJ0lkZW50aXR5JywgJycsICcxKycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoTlVNQkVSX1RZUEVTLCB1bmFyeU9wcy5nbHNsSWRlbnRpdHkoKSldLFxuICBbJ0ltYWdlU2NhbGVyJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTEltYWdlU2NhbGVyKCldLFxuICBbJ0luc3RhbmNlTm9ybWFsaXphdGlvbicsICcnLCAnNisnLCAoKSA9PiBuZXcgV2ViR0xJbnN0YW5jZU5vcm1hbGl6YXRpb24oKV0sXG4gIFsnTGVha3lSZWx1JywgJycsICc2KycsICgpID0+IG5ldyBXZWJHTExlYWt5UmVsdSgpXSxcbiAgWydMZXNzJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChOVU1CRVJfVFlQRVMsIGJpbmFyeU9wcy5nbHNsTGVzcygpLCB1bmRlZmluZWQsICdib29sJyldLFxuICBbJ0xvZycsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsTG9nKCkpXSxcbiAgWydNYXRNdWwnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMTWF0TXVsKCldLFxuICBbJ01heFBvb2wnLCAnJywgJzEtOScsICgpID0+IG5ldyBXZWJHTE1heFBvb2woKV0sICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBNYXhQb29sLTggYW5kIE1heFBvb2wtMTBcbiAgWydNdWwnLCAnJywgJzcrJywgKCkgPT4gbmV3IGJpbmFyeU9wcy5XZWJHTEJpbmFyeU9wKE5VTUJFUl9UWVBFUywgYmluYXJ5T3BzLmdsc2xNdWwoKSldLFxuICBbJ05lZycsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKE5VTUJFUl9UWVBFUywgdW5hcnlPcHMuZ2xzbE5lZygpKV0sXG4gIFsnTm90JywgJycsICcxKycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoWydib29sJ10sIHVuYXJ5T3BzLmdsc2xOb3QoKSldLFxuICBbJ09yJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChbJ2Jvb2wnXSwgYmluYXJ5T3BzLmdsc2xPcigpKV0sXG4gIFsnUGFkJywgJycsICcyLTEwJywgKCkgPT4gbmV3IFdlYkdMUGFkKCldLFxuICBbJ1BvdycsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoRkxPQVRfVFlQRVMsIGJpbmFyeU9wcy5nbHNsUG93KCkpXSxcbiAgWydQUmVsdScsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoRkxPQVRfVFlQRVMsIGJpbmFyeU9wcy5nbHNsUFJlbHUoKSldLFxuICBbJ1JlZHVjZUxvZ1N1bScsICcnLCAnMSsnLCAoKSA9PiBuZXcgcmVkdWNlT3BzLldlYkdMUmVkdWNlTG9nU3VtKCldLFxuICBbJ1JlZHVjZU1heCcsICcnLCAnMSsnLCAoKSA9PiBuZXcgcmVkdWNlT3BzLldlYkdMUmVkdWNlTWF4KCldLFxuICBbJ1JlZHVjZU1lYW4nLCAnJywgJzErJywgKCkgPT4gbmV3IHJlZHVjZU9wcy5XZWJHTFJlZHVjZU1lYW4oKV0sXG4gIFsnUmVkdWNlTWluJywgJycsICcxKycsICgpID0+IG5ldyByZWR1Y2VPcHMuV2ViR0xSZWR1Y2VNaW4oKV0sXG4gIFsnUmVkdWNlUHJvZCcsICcnLCAnMSsnLCAoKSA9PiBuZXcgcmVkdWNlT3BzLldlYkdMUmVkdWNlUHJvZCgpXSxcbiAgWydSZWR1Y2VTdW0nLCAnJywgJzErJywgKCkgPT4gbmV3IHJlZHVjZU9wcy5XZWJHTFJlZHVjZVN1bSgpXSxcbiAgWydSZWR1Y2VTdW1TcXVhcmUnLCAnJywgJzErJywgKCkgPT4gbmV3IHJlZHVjZU9wcy5XZWJHTFJlZHVjZVN1bVNxdWFyZSgpXSxcbiAgWydSZWx1JywgJycsICc2KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xSZWx1KCkpXSxcbiAgWydSZXNoYXBlJywgJycsICc1KycsICgpID0+IG5ldyBXZWJHTFJlc2hhcGUoKV0sXG4gIFsnUmVzaXplJywgJycsICcxMCcsICgpID0+IG5ldyBXZWJHTFJlc2l6ZVBhY2tlZCgxMCldLFxuICBbJ1Jlc2l6ZScsICcnLCAnMTErJywgKCkgPT4gbmV3IFdlYkdMUmVzaXplUGFja2VkKDExKV0sXG4gIFsnU2hhcGUnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMU2hhcGUoKV0sXG4gIFsnU2lnbW9pZCcsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsU2lnbW9pZCgpKV0sXG4gIFsnU2luJywgJycsICc3KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xTaW4oKSldLFxuICBbJ1NsaWNlJywgJycsICcxMCsnLCAoKSA9PiBuZXcgV2ViR0xTbGljZVYxMCgpXSwgIC8vIFRPRE86IHN1cHBvcnQgJ3N0ZXBzJyBmb3IgU2xpY2UtMTBcbiAgWydTbGljZScsICcnLCAnMS05JywgKCkgPT4gbmV3IFdlYkdMU2xpY2UoKV0sXG4gIFsnU29mdG1heCcsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xTb2Z0bWF4KCldLFxuICAvLyAnU3BsaXQnIG9wZXJhdG9yIGhhcyBhbiBvcHRpb25hbCBhdHRyaWJ1dGUgJ3NwbGl0J1xuICAvLyB0aGlzIGF0dHJpYnV0ZSBkZXRlcm1pbmVzIGhvdyB0aGUgc3BlY2lmaWVkIGF4aXMgb2YgaW5wdXQgZGF0YVxuICAvLyBpcyBzcGxpdC4gV2hlbiB0aGUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHdlIG5lZWQgdGhlIGNvdW50IG9mIG51bWJlciBvZiBvdXRwdXRzXG4gIC8vIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB0aGUgJ3NwbGl0JyBhdHRyaWJ1dGUgZnJvbSB0aGUgcnVudGltZSBpbnB1dCB0byB0aGUgT3BlcmF0b3JcbiAgWydTcGxpdCcsICcnLCAnMisnLCAobm9kZSkgPT4gbmV3IFdlYkdMU3BsaXQobm9kZS5vdXRwdXRzLmxlbmd0aCldLFxuICBbJ1NxcnQnLCAnJywgJzYrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbFNxcnQoKSldLFxuICBbJ1NxdWVlemUnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMU3F1ZWV6ZSgpXSxcbiAgWydTdWInLCAnJywgJzcrJywgKCkgPT4gbmV3IGJpbmFyeU9wcy5XZWJHTEJpbmFyeU9wKE5VTUJFUl9UWVBFUywgYmluYXJ5T3BzLmdsc2xTdWIoKSldLFxuICBbJ1N1bScsICcnLCAnNisnLCAoKSA9PiBuZXcgV2ViR0xTdW0oKV0sICAvLyBUT0RPOiBzdXBwb3J0IG11bHRpZGlyZWN0aW9uYWwgYnJvYWRjYXN0IGZvciBTdW0tOFxuICBbJ1RhbicsICcnLCAnNysnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsVGFuKCkpXSxcbiAgWydUYW5oJywgJycsICc2KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xUYW5oKCkpXSxcbiAgWydUaWxlJywgJycsICc2KycsICgpID0+IG5ldyBXZWJHTFRpbGUoKV0sXG4gIFsnVHJhbnNwb3NlJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTFRyYW5zcG9zZSgpXSxcbiAgWydVcHNhbXBsZScsICcnLCAnNy04JywgKCkgPT4gbmV3IFdlYkdMVXBzYW1wbGUoNyldLFxuICBbJ1Vwc2FtcGxlJywgJycsICc5JywgKCkgPT4gbmV3IFdlYkdMVXBzYW1wbGUoOSldLFxuICBbJ1Vuc3F1ZWV6ZScsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xVbnNxdWVlemUoKV0sXG4gIFsnWG9yJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChbJ2Jvb2wnXSwgYmluYXJ5T3BzLmdsc2xYb3IoKSldLFxuXTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0JhdGNoTm9ybWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEJhdGNoTm9ybWFsaXphdGlvbiBleHRlbmRzIEJhdGNoTm9ybWFsaXphdGlvbiB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlucHV0TGF5b3V0cyA9IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgc2NhbGUgPSBpbnB1dExheW91dHNbMV07XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgdmVjMiBwb3NpdGlvbiA9IG9mZnNldFRvQ29vcmRzKGluZGljZXNbMV0sICR7c2NhbGUud2lkdGh9LCAke3NjYWxlLmhlaWdodH0pO1xuICAgICAgICBmbG9hdCBzY2FsZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShTY2FsZSwgcG9zaXRpb24pKTtcbiAgICAgICAgZmxvYXQgbWVhbiA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShNZWFuLCBwb3NpdGlvbikpO1xuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShWYXJpYW5jZSwgcG9zaXRpb24pKTtcbiAgICAgICAgZmxvYXQgYiA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShCLCBwb3NpdGlvbikpO1xuXG4gICAgICAgIHJldHVybiBzY2FsZSAqICggKF9BKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZmxvYXQoJHt0aGlzLmVwc2lsb259KSkgKSArIGI7XG4gICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnQScsICdTY2FsZScsICdCJywgJ01lYW4nLCAnVmFyaWFuY2UnXSxcbiAgICAgIHNoYWRlclNvdXJjZVxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1swXSldO1xuICAgIGlucHV0cy5zbGljZSgxKS5mb3JFYWNoKHQgPT4gaW5wdXRURHMucHVzaChoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCkpKTtcbiAgICBjb25zdCBvdXRwdXRURCA9IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpO1xuICAgIHJldHVybiB7aW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLCBvdXRwdXRUZXh0dXJlRGF0YTogb3V0cHV0VEQsIHVuaWZvcm1EYXRhOiB7fX07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0JpbmFyeU9wfSBmcm9tICcuLi8uLi8uLi9vcHMvYmluYXJ5LW9wJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtGdW5jdGlvblR5cGUsIEdsc2xWYWx1ZUZ1bmN0aW9ufSBmcm9tICcuLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMQmluYXJ5T3AgZXh0ZW5kcyBCaW5hcnlPcCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBwcml2YXRlIHVzZVBhY2tlZFRleHR1cmU/OiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgdHlwZUNvbnN0cmFpbnQ6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdLCBwcm90ZWN0ZWQgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLCBvcFR5cGU/OiBzdHJpbmcsXG4gICAgICByZXN1bHRUeXBlPzogVGVuc29yLkRhdGFUeXBlKSB7XG4gICAgc3VwZXIodHlwZUNvbnN0cmFpbnQsIG9wVHlwZSwgcmVzdWx0VHlwZSk7XG4gIH1cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcyk7XG5cbiAgICAvLyBUT0RPIGZpeCBiY2FzdCBpbiBwYWNrZWQgbW9kZS5cbiAgICBpZiAodGhpcy51c2VQYWNrZWRUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXNlUGFja2VkVGV4dHVyZSA9ICFpc0Jyb2FkY2FzdCAmJiBoYW5kbGVyLnNlc3Npb24ucGFjaztcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dExheW91dHMgPSB0aGlzLnVzZVBhY2tlZFRleHR1cmUgP1xuICAgICAgICBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCwgNCwgdHJ1ZSwgdC5kaW1zLCB0cnVlKSkgOlxuICAgICAgICBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpO1xuICAgIGNvbnN0IG91cHV0TGF5b3V0ID0gdGhpcy51c2VQYWNrZWRUZXh0dXJlID9cbiAgICAgICAgaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKGlucHV0c1swXS5kaW1zLCA0LCBpbnB1dHNbMF0uZGltcywge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KSA6XG4gICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dHNbMF0uZGltcyk7XG5cbiAgICBpZiAoaXNCcm9hZGNhc3QpIHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBmYWxzZSk7XG4gICAgICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGFSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAwID8gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGJSYW5rID0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAwID8gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGFCY2FzdCA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/ICdiY2FzdEluZGljZXNfQShpbmRpY2VzLCBhaW5kaWNlcyk7JyA6ICdhaW5kaWNlc1swXSA9IDA7JztcbiAgICAgIGNvbnN0IGJCY2FzdCA9IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMCA/ICdiY2FzdEluZGljZXNfQihpbmRpY2VzLCBiaW5kaWNlcyk7JyA6ICdiaW5kaWNlc1swXSA9IDA7JztcblxuICAgICAgLy8gVE9ETzogZm9yIHBhY2tlZCB0ZW5zb3JzLCB3ZSBuZWVkIHRvIGltcGxlbWVudCBsb2dpYyB0byBjYWN1bGF0ZSB0ZXh0Q29vcmRzIGZvciBicm9hZGNhc3QgdGVuc29yXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke3RoaXMuZ2xzbEZ1bmMuYm9keX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtvdXRwdXRSYW5rfV0pIHtcbiAgICAgICAgaW50IGFpbmRpY2VzWyR7YVJhbmt9XTtcbiAgICAgICAgaW50IGJpbmRpY2VzWyR7YlJhbmt9XTtcbiAgICAgICAgJHthQmNhc3R9XG4gICAgICAgICR7YkJjYXN0fVxuICAgICAgICByZXR1cm4gJHt0aGlzLmdsc2xGdW5jLm5hbWV9KF9BKGFpbmRpY2VzKSwgX0IoYmluZGljZXMpKTtcbiAgICB9YDtcbiAgICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMudXNlUGFja2VkVGV4dHVyZSA/XG4gICAgICAgICAgaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlLCA0LCBvdXRwdXRTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KSA6XG4gICAgICAgICAgaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRMYXlvdXRzLFxuICAgICAgICBvdXRwdXRMYXlvdXQsXG4gICAgICAgIHNhbXBsZXJzOiBbJ0EnLCAnQiddLFxuICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICAgIGV4cGVjdFBhY2tlZElucHV0czogdGhpcy51c2VQYWNrZWRUZXh0dXJlLFxuICAgICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0aGlzLnVzZVBhY2tlZFRleHR1cmVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgJHt0aGlzLmdsc2xGdW5jLmJvZHl9XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCB2MSA9ICR7Z2xzbC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XG4gICAgICB2ZWM0IHYyID0gJHtnbHNsLnRleHR1cmUyRH0oQiwgVGV4Q29vcmRzKTtcbiAgICAgIHZlYzQgcmVzdWx0ID0gJHt0aGlzLmdsc2xGdW5jLm5hbWV9KHYxLCB2Mik7XG4gICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICB9XG4gICAgYDtcblxuICAgIGlmICh0aGlzLnVzZVBhY2tlZFRleHR1cmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc01haW46IHRydWUsXG4gICAgICAgIGlucHV0TGF5b3V0cyxcbiAgICAgICAgb3V0cHV0TGF5b3V0OiBvdXB1dExheW91dCxcbiAgICAgICAgc2FtcGxlcnM6IFsnQScsICdCJ10sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgZXhwZWN0UGFja2VkSW5wdXRzOiB0cnVlLFxuICAgICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgICBpbnB1dExheW91dHMsXG4gICAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKGlucHV0c1swXS5kaW1zKSxcbiAgICAgICAgc2FtcGxlcnM6IFsnQScsICdCJ10sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IHRoaXMudXNlUGFja2VkVGV4dHVyZSA/XG4gICAgICAgIGlucHV0cy5tYXAoKHQpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0LCAxLCBmYWxzZSwgW10sIHRydWUpKSkgOlxuICAgICAgICBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChcbiAgICAgICAgICBwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIHRoaXMucmVzdWx0VHlwZSA/IHRoaXMucmVzdWx0VHlwZSA6IGlucHV0c1swXS50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBZGQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2FkZF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSArIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgKyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRGl2KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdkaXZfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgLyBiO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHYxIC8gdjI7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE11bCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbXVsXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhICogYjtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAqIHYyO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTdWIoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3N1Yl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLSB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRXF1YWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2VxdWFsXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdChhID09IGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoZXF1YWwodjEsIHYyKSk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEdyZWF0ZXIoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2dyZWF0ZXJfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPiBiKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KCB2MS5yID4gdjIuciAsXG4gICAgICB2MS5nID4gdjIuZyxcbiAgICAgIHYxLmIgPiB2Mi5iLFxuICAgICAgdjEuYSA+IHYyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTGVzcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbGVzc18nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoYSA8IGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPCB2Mi5yICxcbiAgICAgICAgICAgICAgICB2MS5nIDwgdjIuZyxcbiAgICAgICAgICAgICAgICB2MS5iIDwgdjIuYixcbiAgICAgICAgICAgICAgICB2MS5hIDwgdjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBbmQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2FuZF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgJiYgYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgJiYgYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyAmJiBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgJiYgYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hICYmIGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsT3IoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ29yXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSB8fCBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciB8fCBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nIHx8IGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiB8fCBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgfHwgYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xYb3IoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3hvcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgXl4gYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgXl4gYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyBeXiBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgXl4gYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hIF5eIGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsUG93KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluQmluYXJ5KCdwb3cnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsUFJlbHUoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3ByZWx1Xyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhIDwgMC4wID8gYSAqIGI6IGE7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNChcbiAgICAgIHYxLnIgPCAwLjAgPyB2MS5yICogdjIucjogdjEucixcbiAgICAgIHYxLmcgPCAwLjAgPyB2MS5nICogdjIuZzogdjEuZyxcbiAgICAgIHYxLmIgPCAwLjAgPyB2MS5iICogdjIuYjogdjEuYixcbiAgICAgIHYxLmEgPCAwLjAgPyB2MS5hICogdjIuYTogdjEuYVxuICAgICAgKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cblxuZnVuY3Rpb24gZ2xzbEJ1aWx0aW5CaW5hcnkoZm5hbWU6IHN0cmluZyk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9IGAke2ZuYW1lfV9gO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gJHtmbmFtZX0oYSwgYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gJHtmbmFtZX0odjEsIHYyKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0NsaXB9IGZyb20gJy4uLy4uLy4uL29wcy9jbGlwJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xDbGlwIGV4dGVuZHMgQ2xpcCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGNvbnN0IGZsb2F0IG1pbiA9IGZsb2F0KCR7dGhpcy5taW59KTtcbiAgICAgIGNvbnN0IGZsb2F0IG1heCA9IGZsb2F0KCR7dGhpcy5tYXh9KTtcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgdiA9ICR7Z2xzbC50ZXh0dXJlMkR9KEEsIFRleENvb3JkcykucjtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KGNsYW1wKHYsIG1pbiwgbWF4KSk7XG4gICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0pXSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0NvbmNhdH0gZnJvbSAnLi4vLi4vLi4vb3BzL2NvbmNhdCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRDaGFubmVscywgdW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFBhY2tlZENvbmNhdCBleHRlbmRzIENvbmNhdCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBpZiAodGhpcy5heGlzID49IGlucHV0U2hhcGUubGVuZ3RoIHx8IHRoaXMuYXhpcyA8ICgtMSAqIGlucHV0U2hhcGUubGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzIDwgMCkge1xuICAgICAgdGhpcy5heGlzID0gaW5wdXRTaGFwZS5sZW5ndGggKyB0aGlzLmF4aXM7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvciB3aGlsZSB3ZSBkbyB0aGF0XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhTlNoYXBlID0gaW5wdXRzW2ldLmRpbXMuc2xpY2UoKTtcbiAgICAgIGZvciAobGV0IGF4aXNJbmRleCA9IDA7IGF4aXNJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyBheGlzSW5kZXgrKykge1xuICAgICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICAgIGlmIChheGlzSW5kZXggPT09IHRoaXMuYXhpcykge1xuICAgICAgICAgIG91dHB1dFNoYXBlW3RoaXMuYXhpc10gKz0gZGF0YU5TaGFwZVtheGlzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRTaGFwZVtheGlzSW5kZXhdICE9PSBkYXRhTlNoYXBlW2F4aXNJbmRleF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGNvb3JkcyA9IGdldENoYW5uZWxzKCdjb29yZHMnLCByYW5rKTtcbiAgICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuXG4gICAgY29uc3Qgc2hhcGVzID0gaW5wdXRzLm1hcChpID0+IGkuZGltcyk7XG4gICAgY29uc3QgYWxsR2xDaGFubmVscyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXTtcbiAgICBjb25zdCBjaGFubmVscyA9IGFsbEdsQ2hhbm5lbHMuc2xpY2UoMCwgcmFuayk7XG4gICAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBuZXcgQXJyYXkoc2hhcGVzLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IHNhbXBsZXJzID0gaW5wdXRzLm1hcCgodiwgaSkgPT4gYFgke2l9YCk7XG5cbiAgICBvZmZzZXRzWzBdID0gc2hhcGVzWzBdW3RoaXMuYXhpc107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvZmZzZXRzW2ldID0gb2Zmc2V0c1tpIC0gMV0gKyBzaGFwZXNbaV1bdGhpcy5heGlzXTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbdGhpcy5heGlzXTtcbiAgICBjb25zdCBsYXN0Q2hhbm5lbHMgPSBjaGFubmVscy5zbGljZSgtMik7XG4gICAgY29uc3QgYWxsQ2hhbm5lbHMgPSBjaGFubmVscy5qb2luKCk7XG5cbiAgICBsZXQgZ2V0VmFsdWVTbmlwcGV0ID0gYGlmICgke2NoYW5uZWx9IDwgJHtvZmZzZXRzWzBdfSkge1xuICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgZ2V0WDAoJHthbGxDaGFubmVsc30pLCB2ZWMyKCR7bGFzdENoYW5uZWxzLmpvaW4oKX0pKTtcbiAgICAgIH1gO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2hpZnQgPSBvZmZzZXRzW2kgLSAxXTtcbiAgICAgIGdldFZhbHVlU25pcHBldCArPSBgXG4gICAgICAgICAgaWYgKCR7Y2hhbm5lbH0gPCAke29mZnNldHNbaV19ICAmJiAke2NoYW5uZWx9ID49ICR7b2Zmc2V0c1tpIC0gMV19KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgICAgZ2V0WCR7aX0oJHt0aGlzLmdldFNoaWZ0ZWRDaGFubmVsc1NuaXBwZXQoY2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KX0pLFxuICAgICAgICAgICAgICB2ZWMyKCR7dGhpcy5nZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGxhc3RDaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSkpO1xuICAgICAgICAgIH1gO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgZ2V0WCR7bGFzdEluZGV4fSgke3RoaXMuZ2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChjaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSksXG4gICAgICAgICAgICB2ZWMyKCR7dGhpcy5nZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGxhc3RDaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSkpO2A7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICAgICAgZmxvYXQgZ2V0VmFsdWUoJHtjaGFubmVscy5tYXAoeCA9PiAnaW50ICcgKyB4KX0pIHtcbiAgICAgICAgICAke2dldFZhbHVlU25pcHBldH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAke2R0eXBlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDFdfTtcbiAgICAgICAgICBjb29yZHMuJHthbGxHbENoYW5uZWxzW3JhbmsgLSAxXX0gPSBjb29yZHMuJHthbGxHbENoYW5uZWxzW3JhbmsgLSAyXX07XG4gICAgICAgICAgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tyYW5rIC0gMl19ID0gbGFzdERpbTtcblxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Nvb3Jkc30pLCAwLiwgMC4sIDAuKTtcblxuICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19ICsgMTtcbiAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDFdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDFdfSkge1xuICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAyXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMl19ICsgMTtcbiAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDJdfSkge1xuICAgICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19IC0gMTtcbiAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDJdfSAmJlxuICAgICAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19IDwgJHtvdXRwdXRTaGFwZVtyYW5rIC0gMV19KSB7XG4gICAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBgO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQsIDQsIHRydWUsIHQuZGltcywgdHJ1ZSkpLFxuICAgICAgb3V0cHV0TGF5b3V0OlxuICAgICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSwgNCwgb3V0cHV0U2hhcGUsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSksXG4gICAgICBzYW1wbGVycyxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLCB0cnVlKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBzbmlwcGV0IHRvIHNoaWZ0IGEgZ2l2ZW4gY2hhbm5lbCBpbiBhIGxpc3Qgb2YgY2hhbm5lbHMgYnkgc2hpZnRcbiAgICpcbiAgICogaS5lOiByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBmb3JtICd4LCB5LVtzaGlmdF0sIHonIHdoZXJlIGFueSBvbmUgY2hhbm5lbCBjYW5cbiAgICogaGF2ZSB0aGUgc2hpZnQgYXBwbGllZC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGNoYW5uZWxzOiBzdHJpbmdbXSwgY2hhbm5lbDogc3RyaW5nLCBzaGlmdDogbnVtYmVyKSB7XG4gICAgY29uc3QgY2hhbm5lbElkeCA9IGNoYW5uZWxzLmluZGV4T2YoY2hhbm5lbCk7XG4gICAgY29uc3QgcmVzID0gY2hhbm5lbHMubWFwKChjLCBpZHgpID0+IHtcbiAgICAgIGlmIChpZHggPT09IGNoYW5uZWxJZHgpIHtcbiAgICAgICAgcmV0dXJuIGAke2N9IC0gJHtzaGlmdH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcy5qb2luKCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlJztcbmltcG9ydCB7Q29uY2F0fSBmcm9tICcuLi8uLi8uLi9vcHMvY29uY2F0JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtXZWJHTFBhY2tlZENvbmNhdH0gZnJvbSAnLi9jb25jYXQtcGFja2VkJztcblxuLy8gV2UgcHJvdmlkZSBhIHdyYXBwZXIgY2xhc3Mgc28gdGhhdCB0aGUga2VybmVsIGNhbiBzd2l0Y2ggYmV0d2VlbiBwYWNrZWQgYW5kIHVucGFja2VkIGRlcGVuZGluZyBvbiB0aGUgaW5wdXRzIG9uIHRoZVxuLy8gZmx5LlxuZXhwb3J0IGNsYXNzIFdlYkdMQ29uY2F0IGV4dGVuZHMgQ29uY2F0IGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHVucGFja2VkSW1wbDogV2ViR0xVbnBhY2tlZENvbmNhdDtcbiAgcGFja2VkSW1wbDogV2ViR0xQYWNrZWRDb25jYXQ7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51bnBhY2tlZEltcGwgPSBuZXcgV2ViR0xVbnBhY2tlZENvbmNhdCgpO1xuICAgIHRoaXMucGFja2VkSW1wbCA9IG5ldyBXZWJHTFBhY2tlZENvbmNhdCgpO1xuICB9XG5cbiAgLy8gTm8gbmVlZCB0byBjYWxsIHN1cGVyIHNpbmNlIHRoaXMgY2xhc3Mgb25seSBzZXJ2ZXMgYXMgYSB3cmFwcGVyLlxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMudW5wYWNrZWRJbXBsLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG4gICAgdGhpcy5wYWNrZWRJbXBsLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG4gIH1cblxuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGlmIChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucGFjayAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcy5wYWNrZWRJbXBsLCBpbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcy51bnBhY2tlZEltcGwsIGlucHV0cyk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGlmIChoYW5kbGVyLnNlc3Npb24ucGFjayAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRJbXBsLmNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja2VkSW1wbC5jcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgaWYgKGhhbmRsZXIuc2Vzc2lvbi5wYWNrICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tlZEltcGwuY3JlYXRlUnVuRGF0YShoYW5kbGVyLCBwcm9ncmFtSW5mbywgaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRJbXBsLmNyZWF0ZVJ1bkRhdGEoaGFuZGxlciwgcHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gICAgfVxuICB9XG59XG5leHBvcnQgY2xhc3MgV2ViR0xVbnBhY2tlZENvbmNhdCBleHRlbmRzIENvbmNhdCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBpZiAodGhpcy5heGlzID49IGlucHV0U2hhcGUubGVuZ3RoIHx8IHRoaXMuYXhpcyA8ICgtMSAqIGlucHV0U2hhcGUubGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzIDwgMCkge1xuICAgICAgdGhpcy5heGlzID0gaW5wdXRTaGFwZS5sZW5ndGggKyB0aGlzLmF4aXM7XG4gICAgfVxuICAgIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvciB3aGlsZSB3ZSBkbyB0aGF0XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhTlNoYXBlID0gaW5wdXRzW2ldLmRpbXMuc2xpY2UoKTtcbiAgICAgIGZvciAobGV0IGF4aXNJbmRleCA9IDA7IGF4aXNJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyBheGlzSW5kZXgrKykge1xuICAgICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICAgIGlmIChheGlzSW5kZXggPT09IHRoaXMuYXhpcykge1xuICAgICAgICAgIG91dHB1dFNoYXBlW3RoaXMuYXhpc10gKz0gZGF0YU5TaGFwZVtheGlzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSBhbGwgbm9uLWNhbmNhdGVuYXRlZCBheGVzIG1hdGNoIGVhY2ggb3RoZXJcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRTaGFwZVtheGlzSW5kZXhdICE9PSBkYXRhTlNoYXBlW2F4aXNJbmRleF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSAnJztcbiAgICAvLyBpbiBtb3N0IGNhc2VzIGxpbmVhciBzZWFyY2ggaXMgc3VmZmljaWVudCwgYXMgaW4gbW9zdCBzY2VuYXJpb3MsIG9ubHkgMiB0ZW5zb3JzIGFyZSBjb25jYXRlbmF0ZWRcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA8IDUpIHtcbiAgICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSB0aGlzLmdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNMaW5lYXJTZWFyY2goaW5wdXRzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSB0aGlzLmdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNCaW5hcnlTZWFyY2goaW5wdXRzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kID0gdGhpcy5mZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2QoaW5wdXRzLmxlbmd0aCwgcmFuayk7XG4gICAgY29uc3QgZ2V0VmFsdWVGcm9tQXJyYXlJbmRleE1ldGhvZCA9IHRoaXMuZ2V0VmFsdWVGcm9tQXJyYXlJbmRleE1ldGhvZChpbnB1dHMubGVuZ3RoKTtcbiAgICBjb25zdCBzYW1wbGVycyA9IGlucHV0cy5tYXAoKHYsIGkpID0+IGBYJHtpfWApO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7ZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kfVxuICAgICAgJHtnZXRWYWx1ZUZyb21BcnJheUluZGV4TWV0aG9kfVxuICAgICAgJHtnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTWV0aG9kfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHt0aGlzLmF4aXN9XSk7XG5cbiAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcbiAgICAgICAgICBpbmRpY2VzWyR7dGhpcy5heGlzfV0gPSBpbmRpY2VzWyR7XG4gICAgICAgIHRoaXMuYXhpc31dIC0gaW50KGdldFZhbHVlRnJvbUFycmF5SW5kZXgoc2l6ZUluQ29uY2F0QXhpcywgdGV4dHVyZUluZGV4LWludCgxKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xuICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQpKSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzLFxuICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdzaXplSW5Db25jYXRBeGlzJywgdHlwZTogJ2ludCcsIGFycmF5TGVuZ3RoOiBpbnB1dHMubGVuZ3RofV0sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpcyA9IG5ldyBBcnJheTxudW1iZXI+KHByb2dyYW1JbmZvLmlucHV0TGF5b3V0cy5sZW5ndGgpO1xuICAgIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9ncmFtSW5mby5pbnB1dExheW91dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHByZXZpb3VzU3VtICs9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXS5zaGFwZVt0aGlzLmF4aXNdO1xuICAgICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtRGF0YSA9IHtzaXplSW5Db25jYXRBeGlzfTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGFcbiAgICB9O1xuICB9XG4gIHByaXZhdGUgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0xpbmVhclNlYXJjaChudW1iZXJPZlRlbnNvcnM6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBpbnQgZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMoaW50IGluZGV4KSB7XG4gICAgICBmb3IoaW50IGk9MDsgaTwke251bWJlck9mVGVuc29yc307IGkrKykge1xuICAgICAgICAgIGlmKGluZGV4IDwgaW50KHNpemVJbkNvbmNhdEF4aXNbaV0pKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9YDtcbiAgfVxuXG4gIC8vIFRPRE86IEltcGxlbWVudCBCaW5hcnlTZWFyY2ggaW4gR0xTTFxuICBwcml2YXRlIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNCaW5hcnlTZWFyY2gobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNMaW5lYXJTZWFyY2gobnVtYmVyT2ZUZW5zb3JzKTtcbiAgfVxuXG4gIHByaXZhdGUgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kKG51bWJlck9mVGVuc29yczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpIHtcbiAgICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0ZW5zb3JSYW5rfV0pIHtgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVGVuc29yczsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgICAgYGVsc2UgeyByZXR1cm4gX1gke2l9KGluZGljZXMpOyB9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBlbHNlIGlmICh0ZXh0dXJlSW5kZXggPT0gJHtpfSkgeyByZXR1cm4gX1gke2l9KGluZGljZXMpOyB9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAnXFx0JyArXG4gICAgICAgICd9Jyk7XG4gICAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VmFsdWVGcm9tQXJyYXlJbmRleE1ldGhvZChhcnJheVJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgY29kZUxpbmVzOiBzdHJpbmdbXSA9IFtgaW50IGdldFZhbHVlRnJvbUFycmF5SW5kZXgoaW50IGFyclske2FycmF5UmFua31dLCBpbnQgaW5kZXgpIHtgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5UmFuazsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBpZiAoaW5kZXggPT0gJHtpfSkgeyByZXR1cm4gYXJyWyR7aX1dOyB9YCk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGFycmF5UmFuayAtIDEpIHtcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgICBgZWxzZSB7IHJldHVybiBhcnJbJHtpfV07IH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgICAgYGVsc2UgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuIGFyclske2l9XTsgfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgJ1xcdCcgK1xuICAgICAgICAnfScpO1xuXG4gICAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtDb252fSBmcm9tICcuLi8uLi8uLi9vcHMvY29udic7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7YXNzZXJ0LCBQb29sQ29udlV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1dlYkdMQ29udn0gZnJvbSAnLi9jb252JztcbmltcG9ydCB7V2ViR0xJbTJDb2xQYWNrZWR9IGZyb20gJy4vaW0yY29sLXBhY2snO1xuaW1wb3J0IHtXZWJHTE1hdE11bFBhY2tlZH0gZnJvbSAnLi9tYXRtdWwtcGFjayc7XG5pbXBvcnQge1dlYkdMUmVzaGFwZVBhY2tlZH0gZnJvbSAnLi9yZXNoYXBlLXBhY2tlZCc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTENvbnZQYWNrZWQgZXh0ZW5kcyBDb252IHtcbiAgcHJvdGVjdGVkIGFydGlmYWN0czogQXJ0aWZhY3RbXTtcbiAgcHJvdGVjdGVkIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mb1tdO1xuICBwcm90ZWN0ZWQgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuXG4gIHByaXZhdGUga2VybmVsUmVzaGFwZSA9IG5ldyBXZWJHTFJlc2hhcGVQYWNrZWQoKTtcbiAgcHJpdmF0ZSBpbTJjb2w6IFdlYkdMSW0yQ29sUGFja2VkO1xuICBwcml2YXRlIG1hdG11bCA9IG5ldyBXZWJHTE1hdE11bFBhY2tlZCgpO1xuICBwcml2YXRlIG91dHB1dFJlc2hhcGUgPSBuZXcgV2ViR0xSZXNoYXBlUGFja2VkKCk7XG5cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBwcm9ncmFtTWFuYWdlciA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlcjtcbiAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgICBpZiAodGhpcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwga3NoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMua2VybmVsU2hhcGUucHVzaChrc2hhcGVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgICBpbnB1dHNbMF0uZGltcywgdGhpcy5zdHJpZGVzLCB0aGlzLmRpbGF0aW9ucywgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5wYWRzLCB0aGlzLmF1dG9QYWQpO1xuICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAnQ29udicsXG4gICAgICAgIGBhdXRwUGFkOiR7dGhpcy5hdXRvUGFkfSwgZGlsYXRpb25zOiR7dGhpcy5kaWxhdGlvbnN9LCBncm91cDoke3RoaXMuZ3JvdXB9LCBrZXJuZWxTaGFwZToke1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxTaGFwZX0sIHBhZHM6JHt0aGlzLnBhZHN9LCBzdHJpZGVzOiR7dGhpcy5zdHJpZGVzfWApO1xuXG4gICAgaWYgKCF0aGlzLm91dHB1dFNoYXBlKSB7XG4gICAgICB0aGlzLm91dHB1dFNoYXBlID0gV2ViR0xDb252LmNhbGNPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgdGhpcy5kaWxhdGlvbnMsIHRoaXMucGFkcywgdGhpcy5zdHJpZGVzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW0yY29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaW0yY29sID0gbmV3IFdlYkdMSW0yQ29sUGFja2VkKHRoaXMub3V0cHV0U2hhcGUsIGtzaGFwZSwgdGhpcy5kaWxhdGlvbnMsIHRoaXMucGFkcywgdGhpcy5zdHJpZGVzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZhdGlvbikge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUodW5kZWZpbmVkKTtcbiAgICAgIGF0dHJpYnV0ZXMuc2V0KCdfX2ludGVybmFsX2FjdGl2YXRpb24nLCAnc3RyaW5nJywgKHRoaXMuYWN0aXZhdGlvbikpO1xuICAgICAgdGhpcy5tYXRtdWwuaW5pdGlhbGl6ZShhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgLy8gc2hhcGUgZm9yIGtlcm5lbCByZXNoYXBlXG4gICAgY29uc3Qgc2hhcGUgPVxuICAgICAgICBuZXcgVGVuc29yKFsyXSwgJ2ludDMyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG5ldyBJbnQzMkFycmF5KFtrc2hhcGVbMF0sIGtzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXV0pKTtcbiAgICBpZiAoIXRoaXMuYXJ0aWZhY3RzKSB7XG4gICAgICB0aGlzLmFydGlmYWN0cyA9IFtdO1xuICAgICAgdGhpcy5wcm9ncmFtSW5mbyA9IFtdO1xuICAgICAgdGhpcy5wcm9ncmFtSW5mb1swXSA9IHRoaXMuaW0yY29sLmNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIFtpbnB1dHNbMF0sIGlucHV0c1sxXV0pO1xuICAgICAgdGhpcy5hcnRpZmFjdHNbMF0gPSBwcm9ncmFtTWFuYWdlci5idWlsZCh0aGlzLnByb2dyYW1JbmZvWzBdKTtcblxuICAgICAgdGhpcy5wcm9ncmFtSW5mb1sxXSA9IHRoaXMua2VybmVsUmVzaGFwZS5jcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzFdLCBzaGFwZV0pO1xuICAgICAgdGhpcy5hcnRpZmFjdHNbMV0gPSBwcm9ncmFtTWFuYWdlci5idWlsZCh0aGlzLnByb2dyYW1JbmZvWzFdKTtcbiAgICB9XG5cbiAgICAvLyBydW4gaW0yY29sXG4gICAgY29uc3QgcnVuRGF0YUltMmNvbCA9IHRoaXMuaW0yY29sLmNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlciwgdGhpcy5wcm9ncmFtSW5mb1swXSwgW2lucHV0c1swXSwgaW5wdXRzWzFdXSk7XG4gICAgaW5mZXJlbmNlSGFuZGxlci5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKHRoaXMuYXJ0aWZhY3RzWzBdLCBydW5EYXRhSW0yY29sKTtcbiAgICBwcm9ncmFtTWFuYWdlci5ydW4odGhpcy5hcnRpZmFjdHNbMF0sIHJ1bkRhdGFJbTJjb2wpO1xuICAgIGNvbnN0IGltMmNvbE91dHB1dCA9IHJ1bkRhdGFJbTJjb2wub3V0cHV0VGV4dHVyZURhdGEudGVuc29yO1xuXG4gICAgLy8gcmVzaGFwZSBrZXJuZWxcbiAgICBjb25zdCBydW5EYXRhS2VybmVsUmVzaGFwZSA9XG4gICAgICAgIHRoaXMua2VybmVsUmVzaGFwZS5jcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXIsIHRoaXMucHJvZ3JhbUluZm9bMV0sIFtpbnB1dHNbMV0sIHNoYXBlXSk7XG4gICAgaW5mZXJlbmNlSGFuZGxlci5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKHRoaXMuYXJ0aWZhY3RzWzFdLCBydW5EYXRhS2VybmVsUmVzaGFwZSk7XG4gICAgcHJvZ3JhbU1hbmFnZXIucnVuKHRoaXMuYXJ0aWZhY3RzWzFdLCBydW5EYXRhS2VybmVsUmVzaGFwZSk7XG4gICAgY29uc3Qga2VybmVsUmVzaGFwZWQgPSBydW5EYXRhS2VybmVsUmVzaGFwZS5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3I7XG5cbiAgICAvLyBydW4gbWF0bXVsXG4gICAgY29uc3QgaGFzQmlhcyA9IChpbnB1dHMubGVuZ3RoID09PSAzKTtcbiAgICBhc3NlcnQodGhpcy5hcnRpZmFjdHMubGVuZ3RoID4gMSwgKCkgPT4gJ2V4cGVjdCBhdCBsZWFzdCAyIGFydGlmYWN0cyBjcmVhdGVkJyk7XG4gICAgaWYgKHRoaXMuYXJ0aWZhY3RzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5wcm9ncmFtSW5mb1syXSA9IHRoaXMubWF0bXVsLmNyZWF0ZVByb2dyYW1JbmZvKFxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIGhhc0JpYXMgPyBba2VybmVsUmVzaGFwZWQsIGltMmNvbE91dHB1dCwgaW5wdXRzWzJdXSA6IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0XSk7XG4gICAgICB0aGlzLmFydGlmYWN0c1syXSA9IHByb2dyYW1NYW5hZ2VyLmJ1aWxkKHRoaXMucHJvZ3JhbUluZm9bMl0pO1xuICAgIH1cbiAgICBjb25zdCBydW5EYXRhTWF0bXVsID0gdGhpcy5tYXRtdWwuY3JlYXRlUnVuRGF0YShcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgdGhpcy5wcm9ncmFtSW5mb1syXSxcbiAgICAgICAgaGFzQmlhcyA/IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0LCBpbnB1dHNbMl1dIDogW2tlcm5lbFJlc2hhcGVkLCBpbTJjb2xPdXRwdXRdKTtcbiAgICBpbmZlcmVuY2VIYW5kbGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZUZvcm0odGhpcy5hcnRpZmFjdHNbMl0sIHJ1bkRhdGFNYXRtdWwpO1xuICAgIHByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLmFydGlmYWN0c1syXSwgcnVuRGF0YU1hdG11bCk7XG4gICAgY29uc3QgbWF0bXVsT3V0cHV0ID0gcnVuRGF0YU1hdG11bC5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3I7XG5cbiAgICAvLyByZXNoYXBlIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dFNoYXBlVGVuc29yID0gbmV3IFRlbnNvcihcbiAgICAgICAgW3RoaXMub3V0cHV0U2hhcGUubGVuZ3RoXSwgJ2ludDMyJywgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgIG5ldyBJbnQzMkFycmF5KFt0aGlzLm91dHB1dFNoYXBlWzBdLCB0aGlzLm91dHB1dFNoYXBlWzFdLCB0aGlzLm91dHB1dFNoYXBlWzJdLCB0aGlzLm91dHB1dFNoYXBlWzNdXSkpO1xuXG4gICAgYXNzZXJ0KHRoaXMuYXJ0aWZhY3RzLmxlbmd0aCA+IDIsICgpID0+ICdleHBlY3QgYXQgbGVhc3QgMyBhcnRpZmFjdHMgY3JlYXRlZCcpO1xuICAgIGlmICh0aGlzLmFydGlmYWN0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHRoaXMucHJvZ3JhbUluZm9bM10gPSB0aGlzLm91dHB1dFJlc2hhcGUuY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgW21hdG11bE91dHB1dCwgb3V0cHV0U2hhcGVUZW5zb3JdKTtcbiAgICAgIHRoaXMuYXJ0aWZhY3RzWzNdID0gcHJvZ3JhbU1hbmFnZXIuYnVpbGQodGhpcy5wcm9ncmFtSW5mb1szXSk7XG4gICAgfVxuICAgIGNvbnN0IHJ1bkRhdGFPdXRwdXRSZXNoYXBlID1cbiAgICAgICAgdGhpcy5vdXRwdXRSZXNoYXBlLmNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlciwgdGhpcy5wcm9ncmFtSW5mb1szXSwgW21hdG11bE91dHB1dCwgb3V0cHV0U2hhcGVUZW5zb3JdKTtcbiAgICBpbmZlcmVuY2VIYW5kbGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZUZvcm0odGhpcy5hcnRpZmFjdHNbM10sIHJ1bkRhdGFPdXRwdXRSZXNoYXBlKTtcbiAgICBwcm9ncmFtTWFuYWdlci5ydW4odGhpcy5hcnRpZmFjdHNbM10sIHJ1bkRhdGFPdXRwdXRSZXNoYXBlKTtcbiAgICByZXR1cm4gW3J1bkRhdGFPdXRwdXRSZXNoYXBlLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvcl07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7Q29udn0gZnJvbSAnLi4vLi4vLi4vb3BzL2NvbnYnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1Bvb2xDb252VXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUnVuRGF0YSwgVGV4dHVyZUxheW91dCwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4uL3dlYmdsLWNvbnRleHQnO1xuXG5pbXBvcnQge1dlYkdMQ29udlBhY2tlZH0gZnJvbSAnLi9jb252LXBhY2snO1xuaW1wb3J0IHtnZXRBY3RpY2F0aW9uU25pcHBldH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMQ29udiBleHRlbmRzIENvbnYge1xuICB1bnBhY2tlZEdyb3VwZWRDb252SW1wbDogV2ViR0xVbnBhY2tlZEdyb3VwZWRDb252O1xuICB1bnBhY2tlZENvbnZJbXBsOiBXZWJHTFVucGFja2VkQ29udjtcbiAgcGFja2VkQ29udkltcGw6IFdlYkdMQ29udlBhY2tlZDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5wYWNrZWRHcm91cGVkQ29udkltcGwgPSBuZXcgV2ViR0xVbnBhY2tlZEdyb3VwZWRDb252KCk7XG4gICAgdGhpcy51bnBhY2tlZENvbnZJbXBsID0gbmV3IFdlYkdMVW5wYWNrZWRDb252KCk7XG4gICAgdGhpcy5wYWNrZWRDb252SW1wbCA9IG5ldyBXZWJHTENvbnZQYWNrZWQoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZShhdHRyaWJ1dGVzKTtcbiAgICB0aGlzLnVucGFja2VkR3JvdXBlZENvbnZJbXBsLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG4gICAgdGhpcy51bnBhY2tlZENvbnZJbXBsLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG4gICAgdGhpcy5wYWNrZWRDb252SW1wbC5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBwYWNrTW9kZSA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuICAgIGlmICh0aGlzLmdyb3VwID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRHcm91cGVkQ29udkltcGwucnVuKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cyk7XG4gICAgfSBlbHNlIGlmIChwYWNrTW9kZSAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDQgJiYgaW5wdXRzWzBdLmRpbXNbMF0gPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tlZENvbnZJbXBsLnJ1bihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tlZENvbnZJbXBsLnJ1bihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBjYWxjT3V0cHV0U2hhcGUoXG4gICAgICBpbnB1dFNoYXBlOiBudW1iZXJbXSwga2VybmVsU2hhcGU6IG51bWJlcltdLCBkaWxhdGlvbnM6IG51bWJlcltdLCBhZGp1c3RQYWRzOiBudW1iZXJbXSxcbiAgICAgIHN0cmlkZXM6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDIpO1xuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRTcGF0aWFsU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbMF07XG4gICAgY29uc3Qga2VybmVsU3BhdGlhbFNoYXBlID0ga2VybmVsU2hhcGUuc2xpY2UoMik7XG4gICAgY29uc3QgZGlsYXRlZEtlcm5lbFNoYXBlID0ga2VybmVsU3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArICh2IC0gMSkgKiAoZGlsYXRpb25zW2ldIC0gMSkpO1xuICAgIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZCA9IGlucHV0U3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArIGFkanVzdFBhZHNbaV0gKyBhZGp1c3RQYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICAgIGNvbnN0IG91dHB1dFNwYXRpYWxTaGFwZSA9XG4gICAgICAgIGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZC5tYXAoKHYsIGkpID0+IE1hdGguZmxvb3IoKHYgLSBkaWxhdGVkS2VybmVsU2hhcGVbaV0gKyBzdHJpZGVzW2ldKSAvIHN0cmlkZXNbaV0pKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dENoYW5uZWxzXS5jb25jYXQoLi4ub3V0cHV0U3BhdGlhbFNoYXBlKTtcbiAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMVW5wYWNrZWRHcm91cGVkQ29udiBleHRlbmRzIENvbnYgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuXG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGdldEJpYXMob3V0cHV0X2NoYW5uZWwpOycgOiAnJztcbiAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVswXSAvIHRoaXMuZ3JvdXA7XG4gICAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgICBpZiAodGhpcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgd1NoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMua2VybmVsU2hhcGUucHVzaCh3U2hhcGVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgICBpbnB1dHNbMF0uZGltcywgdGhpcy5zdHJpZGVzLCB0aGlzLmRpbGF0aW9ucywgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5wYWRzLCB0aGlzLmF1dG9QYWQpO1xuICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAnQ29udicsXG4gICAgICAgIGBhdXRwUGFkOiR7dGhpcy5hdXRvUGFkfSwgZGlsYXRpb25zOiR7dGhpcy5kaWxhdGlvbnN9LCBncm91cDoke3RoaXMuZ3JvdXB9LCBrZXJuZWxTaGFwZToke1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxTaGFwZX0sIHBhZHM6JHt0aGlzLnBhZHN9LCBzdHJpZGVzOiR7dGhpcy5zdHJpZGVzfWApO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gV2ViR0xDb252LmNhbGNPdXRwdXRTaGFwZSh4U2hhcGUsIHdTaGFwZSwgdGhpcy5kaWxhdGlvbnMsIHRoaXMucGFkcywgdGhpcy5zdHJpZGVzKTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBjb25zdCB7YWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb259ID0gZ2V0QWN0aWNhdGlvblNuaXBwZXQodGhpcy5hY3RpdmF0aW9uKTtcblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoJHt0aGlzLnN0cmlkZXNbMF19LCAke3RoaXMuc3RyaWRlc1sxXX0pO1xuICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3RoaXMucGFkc1swXX0sICR7dGhpcy5wYWRzWzFdfSk7XG4gICAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xuICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnp3ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICBpbnQgZ3JvdXBfaWQgPSBvdXRwdXRfY2hhbm5lbCAvICR7b3V0cHV0Q2hhbm5lbHNQZXJHcm91cH07XG5cbiAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xuICAgICAgZm9yIChpbnQgd0luQ2hhbm5lbCA9IDA7IHdJbkNoYW5uZWwgPCAke3dTaGFwZVsxXX07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHt3U2hhcGVbMV19ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yIChpbnQgd0hlaWdodCA9IDA7IHdIZWlnaHQgPCAke3dTaGFwZVsyXX07IHdIZWlnaHQrKykge1xuICAgICAgICAgIGludCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHt0aGlzLmRpbGF0aW9uc1swXX07XG5cbiAgICAgICAgICBpZiAoeEhlaWdodCA8IDAgfHwgeEhlaWdodCA+PSAke3hTaGFwZVsyXX0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdXaWR0aCA9IDA7IHdXaWR0aCA8ICR7d1NoYXBlWzNdfTsgd1dpZHRoKyspIHtcbiAgICAgICAgICAgIGludCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqICR7dGhpcy5kaWxhdGlvbnNbMV19O1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7eFNoYXBlWzNdfSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGlucHV0X2NoYW5uZWwsIHhXaWR0aCwgeEhlaWdodCk7XG4gICAgICAgICAgICBmbG9hdCB3VmFsID0gZ2V0VyhvdXRwdXRfY2hhbm5lbCwgd0luQ2hhbm5lbCwgd1dpZHRoLCB3SGVpZ2h0KTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwqd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCh2YWx1ZSwgLjAsIC4wLCAuMCk7XG4gICAgfVxuYDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IGhhc0JpYXMgPyBbJ1gnLCAnVycsICdCaWFzJ10gOiBbJ1gnLCAnVyddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVucGFja2VkQ29udiBleHRlbmRzIENvbnYge1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGNvbnN0IHByb2dyYW1NYW5hZ2VyID0gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyO1xuICAgIGlmICghdGhpcy5hcnRpZmFjdHMpIHtcbiAgICAgIHRoaXMuYXJ0aWZhY3RzID0gW107XG4gICAgICBjb25zdCBwcm9ncmFtSW5mb3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1JbmZvQXJyYXkoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUluZm9zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFydGlmYWN0ID0gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW1JbmZvc1tpXSk7XG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzLnB1c2goYXJ0aWZhY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBydW5EYXRhQXJyYXkgPSB0aGlzLmNyZWF0ZVJ1bkRhdGFBcnJheShpbmZlcmVuY2VIYW5kbGVyLCB0aGlzLmFydGlmYWN0cy5tYXAoYSA9PiBhLnByb2dyYW1JbmZvKSwgaW5wdXRzKTtcbiAgICBpbmZlcmVuY2VIYW5kbGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZUZvcm0odGhpcy5hcnRpZmFjdHNbMF0sIHJ1bkRhdGFBcnJheVswXSk7XG4gICAgcHJvZ3JhbU1hbmFnZXIucnVuKHRoaXMuYXJ0aWZhY3RzWzBdLCBydW5EYXRhQXJyYXlbMF0pO1xuICAgIHByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLmFydGlmYWN0c1sxXSwgcnVuRGF0YUFycmF5WzFdKTtcbiAgICByZXR1cm4gW3J1bkRhdGFBcnJheVsxXS5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3JdO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvQXJyYXkoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm9bXSB7XG4gICAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICAgIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gICAgaWYgKHRoaXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCB3RGltcyA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB3RGltcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmtlcm5lbFNoYXBlLnB1c2god0RpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgICBpbnB1dHNbMF0uZGltcywgdGhpcy5zdHJpZGVzLCB0aGlzLmRpbGF0aW9ucywgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5wYWRzLCB0aGlzLmF1dG9QYWQpO1xuICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAnQ29udicsXG4gICAgICAgIGBhdXRwUGFkOiR7dGhpcy5hdXRvUGFkfSwgZGlsYXRpb25zOiR7dGhpcy5kaWxhdGlvbnN9LCBncm91cDoke3RoaXMuZ3JvdXB9LCBrZXJuZWxTaGFwZToke1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxTaGFwZX0sIHBhZHM6JHt0aGlzLnBhZHN9LCBzdHJpZGVzOiR7dGhpcy5zdHJpZGVzfWApO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gV2ViR0xDb252LmNhbGNPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgdGhpcy5kaWxhdGlvbnMsIHRoaXMucGFkcywgdGhpcy5zdHJpZGVzKTtcbiAgICBjb25zdCBpbTJjb2xQcm9ncmFtSW5mbyA9IHRoaXMuY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgZG90UHJvZHVjdFByb2dyYW1JbmZvID1cbiAgICAgICAgdGhpcy5jcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW0yY29sUHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dHMsIG91dHB1dFNoYXBlKTtcbiAgICByZXR1cm4gW2ltMmNvbFByb2dyYW1JbmZvLCBkb3RQcm9kdWN0UHJvZ3JhbUluZm9dO1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGFBcnJheShpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvczogUHJvZ3JhbUluZm9bXSwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgICBSdW5EYXRhW10ge1xuICAgIGNvbnN0IGsgPSBpbnB1dHNbMV07XG4gICAgY29uc3QgYiA9IGlucHV0cy5sZW5ndGggPj0gMyA/IGlucHV0c1syXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQga1REID0gaW5mZXJlbmNlSGFuZGxlci5nZXRUZXh0dXJlRGF0YShrLmRhdGFJZCk7XG4gICAgaWYgKCFrVEQpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdDb252JywgJ0RpZCBub3QgZmluZCB0aGUgYWRqdXN0ZWRLZXJuZWwgdGV4dHVyZSBpbiB0aGUgY2FjaGUuIENyZWF0aW5nIHJldy4nKTtcbiAgICAgIGNvbnN0IG5ld0tlcm5lbERhdGEgPVxuICAgICAgICAgIFdlYkdMVW5wYWNrZWRDb252LnByZXBLZXJuZWxGb3JEb3RQcm9kdWN0KGsuZGltcy5zbGljZSgpLCB0aGlzLmdyb3VwLCA0LCBrLmZsb2F0RGF0YSBhcyBGbG9hdDMyQXJyYXkpO1xuICAgICAgLy8gaGFjazogc2hvdWxkIHVzZSBncmFwaCB0cmFuc2Zvcm1lciB0byByZXdyaXRlIGluaXRpYWxpemVyIEtcbiAgICAgIGtURCA9IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0QmluZFRlbnNvcihcbiAgICAgICAgICBwcm9ncmFtSW5mb3NbMV0uaW5wdXRMYXlvdXRzWzFdLCBrLnR5cGUsIG5ld0tlcm5lbERhdGEsIGspO1xuICAgIH1cbiAgICBjb25zdCBydW50RGF0YUltMkNvbCA9IHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBbaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSldLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvc1swXS5vdXRwdXRMYXlvdXQsIGlucHV0c1swXS50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gICAgY29uc3QgaW5wdXRURHMgPSBbcnVudERhdGFJbTJDb2wub3V0cHV0VGV4dHVyZURhdGEsIGtURF07XG4gICAgaWYgKGIpIHtcbiAgICAgIGlucHV0VERzLnB1c2goaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGIpKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0VEQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mb3NbMV0ub3V0cHV0TGF5b3V0LCBpbnB1dHNbMF0udHlwZSk7XG4gICAgY29uc3QgcnVuRGF0YURvdFByb2R1Y3QgPSB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogb3V0cHV0VEQsXG4gICAgICB1bmlmb3JtRGF0YToge30sXG4gICAgICBkcmF3OiAoZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsIGFydGlmYWN0OiBBcnRpZmFjdCkgPT4ge1xuICAgICAgICBjb25zdCBnbCA9IGdsQ29udGV4dC5nbDtcbiAgICAgICAgY29uc3Qgc2hhcmVkRGltID0gYXJ0aWZhY3QucHJvZ3JhbUluZm8ucGFyYW1zIS5zaGFyZWREaW0gYXMgbnVtYmVyO1xuICAgICAgICBjb25zdCBzaGFyZWREaW1SZWFkU2l6ZSA9IGFydGlmYWN0LnByb2dyYW1JbmZvLnBhcmFtcyEuc2hhcmVkRGltUmVhZFNpemUgYXMgbnVtYmVyO1xuICAgICAgICBjb25zdCBzaGFyZWREaW1PZmZzZXRMb2NhdGlvbiA9IGFydGlmYWN0LnVuaWZvcm1Mb2NhdGlvbnMuZmluZChsID0+IGwubmFtZSA9PT0gJ3NoYXJlZERpbU9mZnNldCcpIS5sb2NhdGlvbjtcbiAgICAgICAgbGV0IGJsZW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2hhcmVkRGltOyBrICs9IHNoYXJlZERpbVJlYWRTaXplKSB7XG4gICAgICAgICAgTG9nZ2VyLnZlcmJvc2UoJ01hdE11bDJEJywgYGsgPSAke2t9LCBzaGFyZWREaW06ICR7c2hhcmVkRGltfSwgcmVhZFNpemUgPSAke3NoYXJlZERpbVJlYWRTaXplfWApO1xuICAgICAgICAgIGlmIChrID09PSBzaGFyZWREaW1SZWFkU2l6ZSkge1xuICAgICAgICAgICAgYmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsQ29udGV4dC5jaGVja0Vycm9yKCk7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcbiAgICAgICAgICAgIGdsQ29udGV4dC5jaGVja0Vycm9yKCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuICAgICAgICAgICAgZ2xDb250ZXh0LmNoZWNrRXJyb3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnbC51bmlmb3JtMWkoc2hhcmVkRGltT2Zmc2V0TG9jYXRpb24sIGspO1xuICAgICAgICAgIGdsQ29udGV4dC5jaGVja0Vycm9yKCk7XG4gICAgICAgICAgZ2xDb250ZXh0LmRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChibGVuZCkge1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgIGdsQ29udGV4dC5jaGVja0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBbcnVudERhdGFJbTJDb2wsIHJ1bkRhdGFEb3RQcm9kdWN0XTtcbiAgfVxuICBjcmVhdGVJbTJDb2xQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSk6XG4gICAgICBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuXG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpbTJjb2xEaW1zID0gV2ViR0xVbnBhY2tlZENvbnYuY2FsY0ltMkNvbERpbXMoeHNoYXBlLCBrc2hhcGUsIG91dHB1dFNoYXBlLCA0KTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoXG4gICAgICAgIGltMmNvbERpbXMsIDQsIFtpbTJjb2xEaW1zWzBdLCBpbTJjb2xEaW1zWzFdLCBpbTJjb2xEaW1zWzJdLCBpbTJjb2xEaW1zWzNdICogNF0sIHticmVha0F4aXM6IDN9KTtcblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGNvbnN0IGludCBYQyA9ICR7eHNoYXBlWzFdfTtcbiAgICAgIGNvbnN0IGludCBYSCA9ICR7eHNoYXBlWzJdfTtcbiAgICAgIGNvbnN0IGludCBYVyA9ICR7eHNoYXBlWzNdfTtcbiAgICAgIGNvbnN0IGludCBLSCA9ICR7dGhpcy5rZXJuZWxTaGFwZVswXX07XG4gICAgICBjb25zdCBpbnQgS1cgPSAke3RoaXMua2VybmVsU2hhcGVbMV19O1xuICAgICAgY29uc3QgaW50IGRpbGF0aW9uSCA9ICR7dGhpcy5kaWxhdGlvbnNbMF19O1xuICAgICAgY29uc3QgaW50IGRpbGF0aW9uVyA9ICR7dGhpcy5kaWxhdGlvbnNbMV19O1xuICAgICAgY29uc3QgaW50IHN0cmlkZUggPSAke3RoaXMuc3RyaWRlc1swXX07XG4gICAgICBjb25zdCBpbnQgc3RyaWRlVyA9ICR7dGhpcy5zdHJpZGVzWzFdfTtcbiAgICAgIGNvbnN0IGludCBwYWRIID0gJHt0aGlzLnBhZHNbMF19O1xuICAgICAgY29uc3QgaW50IHBhZFcgPSAke3RoaXMucGFkc1sxXX07XG4gICAgICBjb25zdCBpbnQgS0hLVyA9IEtIKktXO1xuICAgICAgY29uc3QgaW50IFhDS0hLVyA9IFhDICogS0hLVztcbiAgICAgIGNvbnN0IGludCBvdXRwdXRDaGFubmVscyA9IDQ7XG4gICAgICB2ZWM0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IGIgID0gaW5kaWNlc1swXTsgLy8gYmF0Y2ggc2l6ZVxuICAgICAgICBpbnQgb2ggPSBpbmRpY2VzWzFdICogc3RyaWRlSCAtIHBhZEg7IC8vb3V0cHV0IGhlaWdodFxuICAgICAgICBpbnQgb3cgPSBpbmRpY2VzWzJdICogc3RyaWRlVyAtIHBhZFc7IC8vb3V0cHV0IHdpZHRoXG4gICAgICAgIGludCBwID0gaW5kaWNlc1szXSAqIG91dHB1dENoYW5uZWxzOyAvL3BhdGNoXG4gICAgICAgIHZlYzQgdmFsdWUgPSB2ZWM0KDAuMCk7XG4gICAgICAgIGZvcihpbnQgaT0wOyBpIDwgb3V0cHV0Q2hhbm5lbHM7ICsraSkge1xuICAgICAgICAgIGlmKHAgPCBYQ0tIS1cpIHtcbiAgICAgICAgICAgIGludCBwYXRjaEMgPSBwIC8gS0hLVztcbiAgICAgICAgICAgIGludCBwYXRjaEggPSAocCAtIHBhdGNoQypLSEtXKSAvIEtXO1xuICAgICAgICAgICAgaW50IHBhdGNoVyA9IChwIC0gcGF0Y2hDKktIS1cpIC0gcGF0Y2hIICogS1c7XG4gICAgICAgICAgICBpbnQgeGgyID0gb2ggKyBwYXRjaEggKiBkaWxhdGlvbkg7XG4gICAgICAgICAgICBpbnQgeHcyID0gb3cgKyBwYXRjaFcgKiBkaWxhdGlvblc7XG4gICAgICAgICAgICBpbnQgeFske3hzaGFwZS5sZW5ndGh9XTtcbiAgICAgICAgICAgIHhbMF0gPSBiO1xuICAgICAgICAgICAgeFsxXSA9IHBhdGNoQztcbiAgICAgICAgICAgIHhbMl0gPSB4aDI7XG4gICAgICAgICAgICB4WzNdID0geHcyO1xuICAgICAgICAgICAgaWYoeGgyID49IDAgJiZcbiAgICAgICAgICAgICAgICB4aDIgPCBYSCAmJlxuICAgICAgICAgICAgICAgIHh3MiA+PSAwICYmXG4gICAgICAgICAgICAgICAgeHcyIDwgWFcpIHtcbiAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfWCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKytwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdJbTJDb2wnLFxuICAgICAgaW5wdXRMYXlvdXRzOiBbaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHhzaGFwZSldLFxuICAgICAgb3V0cHV0TGF5b3V0LFxuICAgICAgc2FtcGxlcnM6IFsnWCddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvKFxuICAgICAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbTJjb2xMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGlucHV0czogVGVuc29yW10sXG4gICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGFkanVzdGVkS2VybmVsU2hhcGUgPSBba3NoYXBlWzBdLCBNYXRoLmNlaWwoKHhzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXSkgLyA0KV07XG4gICAgY29uc3Qga0xheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShcbiAgICAgICAgYWRqdXN0ZWRLZXJuZWxTaGFwZSwgNCwgW2FkanVzdGVkS2VybmVsU2hhcGVbMF0sIGFkanVzdGVkS2VybmVsU2hhcGVbMV0gKiA0XSwge2JyZWFrQXhpczogMX0pO1xuXG4gICAgbGV0IGJMYXlvdXQ6IFRleHR1cmVMYXlvdXR8dW5kZWZpbmVkO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBpbnB1dExheW91dHMgPSBbaW0yY29sTGF5b3V0LCBrTGF5b3V0XTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgYkxheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dHNbMl0uZGltcy5zbGljZSgpKTtcbiAgICAgIGlucHV0TGF5b3V0cy5wdXNoKGJMYXlvdXQpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGluaXRWYWx1ZSA9IChpbnB1dHMubGVuZ3RoIDwgMykgPyAnMC4wJyA6ICdfQihiKSc7XG4gICAgY29uc3Qgc2hhcmVkRGltID0gaW0yY29sTGF5b3V0LnNoYXBlWzNdO1xuICAgIGNvbnN0IGJsZW5kRW5hYmxlZCA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0JsZW5kU3VwcG9ydGVkICYmICF0aGlzLmFjdGl2YXRpb247XG4gICAgY29uc3Qgc2hhcmVkRGltUmVhZFNpemUgPSBibGVuZEVuYWJsZWQgJiYgaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQubWF0bXVsTWF4QmF0Y2hTaXplID9cbiAgICAgICAgdGhpcy5jYWxjU2hhcmVkRGltUmVhZFNpemUoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQubWF0bXVsTWF4QmF0Y2hTaXplLCBzaGFyZWREaW0pIDpcbiAgICAgICAgc2hhcmVkRGltO1xuICAgIGNvbnN0IHNhbXBsZXJzID0gWydJbTJDb2wnLCAnSyddO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBzYW1wbGVycy5wdXNoKCdCJyk7XG4gICAgfVxuXG4gICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGljYXRpb25TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbik7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgIGludCBiWzFdO1xuICAgICAgYlswXSA9IGluZGljZXNbMV07XG4gICAgICBpbnQgaW0yY29sWyR7aW0yY29sTGF5b3V0LnNoYXBlLmxlbmd0aH1dO1xuICAgICAgaW0yY29sWzBdID0gaW5kaWNlc1swXTtcbiAgICAgIGltMmNvbFsxXSA9IGluZGljZXNbMl07XG4gICAgICBpbTJjb2xbMl0gPSBpbmRpY2VzWzNdO1xuICAgICAgaW50IGltMmNvbE9mZnNldCA9IGltMmNvbFswXSAqICR7aW0yY29sTGF5b3V0LnN0cmlkZXNbMF19ICsgaW0yY29sWzFdICogJHtcbiAgICAgICAgaW0yY29sTGF5b3V0LnN0cmlkZXNbMV19ICsgaW0yY29sWzJdICogJHtpbTJjb2xMYXlvdXQuc3RyaWRlc1syXX0gKyBzaGFyZWREaW1PZmZzZXQ7XG4gICAgICBpbnQga2VybmVsT2Zmc2V0ID0gaW5kaWNlc1sxXSAqICR7a0xheW91dC5zdHJpZGVzWzBdfSArIHNoYXJlZERpbU9mZnNldDtcbiAgICAgIGZsb2F0IHZhbHVlID0gc2hhcmVkRGltT2Zmc2V0ID09IDAgPyAke2luaXRWYWx1ZX0gOiAwLjA7XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c2hhcmVkRGltUmVhZFNpemV9OyArK2kpIHtcbiAgICAgICAgdmVjMiBpbTJjb2xDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbTJjb2xPZmZzZXQsICR7aW0yY29sTGF5b3V0LndpZHRofSwgJHtpbTJjb2xMYXlvdXQuaGVpZ2h0fSk7XG4gICAgICAgIHZlYzIga2VybmVsQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoa2VybmVsT2Zmc2V0LCAke2tMYXlvdXQud2lkdGh9LCAke2tMYXlvdXQuaGVpZ2h0fSk7XG4gICAgICAgIHZhbHVlICs9IGRvdCgke2dsc2wudGV4dHVyZTJEfShJbTJDb2wsIGltMmNvbENvb3JkcyksICR7Z2xzbC50ZXh0dXJlMkR9KEssIGtlcm5lbENvb3JkcykpO1xuICAgICAgICArK2ltMmNvbE9mZnNldDtcbiAgICAgICAgKytrZXJuZWxPZmZzZXQ7XG4gICAgICB9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ2RvdFByb2R1Y3QnLFxuICAgICAgaW5wdXRMYXlvdXRzOiBpbnB1dHMubGVuZ3RoID09PSAzID8gW2ltMmNvbExheW91dCwga0xheW91dCwgYkxheW91dCFdIDogW2ltMmNvbExheW91dCwga0xheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQsXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBzYW1wbGVycyxcbiAgICAgIHZhcmlhYmxlczogW3tuYW1lOiAnc2hhcmVkRGltT2Zmc2V0JywgdHlwZTogJ2ludCd9XSxcbiAgICAgIHBhcmFtczoge3NoYXJlZERpbSwgc2hhcmVkRGltUmVhZFNpemV9XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcHJlcEtlcm5lbEZvckRvdFByb2R1Y3Qoc2hhcGU6IG51bWJlcltdLCBncm91cDogbnVtYmVyLCBjaGFubmVsczogbnVtYmVyLCBrZXJuZWw6IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKGdyb3VwID09PSAxICYmIChjaGFubmVscyA9PT0gMSB8fCAoc2hhcGVbMl0gKiBzaGFwZVszXSkgJSBjaGFubmVscyA9PT0gMCkpIHtcbiAgICAgIHJldHVybiBrZXJuZWw7XG4gICAgfVxuICAgIGNvbnN0IG51bUZlYXR1cmVNYXBzID0gc2hhcGVbMF07XG4gICAgY29uc3Qgb2xkUm93U2l6ZSA9IHNoYXBlWzFdICogc2hhcGVbMl0gKiBzaGFwZVszXTtcbiAgICBjb25zdCBuZXdSb3dTaXplID0gTWF0aC5jZWlsKG9sZFJvd1NpemUgKiBncm91cCAvIGNoYW5uZWxzKSAqIGNoYW5uZWxzO1xuICAgIGNvbnN0IG5ld1NpemUgPSBudW1GZWF0dXJlTWFwcyAqIG5ld1Jvd1NpemU7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShuZXdTaXplKTtcbiAgICBmb3IgKGxldCBmID0gMDsgZiA8IG51bUZlYXR1cmVNYXBzOyArK2YpIHtcbiAgICAgIGNvbnN0IG9sZE9mZnNldCA9IGYgKiBvbGRSb3dTaXplO1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gZiAqIG5ld1Jvd1NpemUgKyBmICUgZ3JvdXAgKiBvbGRSb3dTaXplO1xuICAgICAgYnVmZmVyLnNldChrZXJuZWwuc3ViYXJyYXkob2xkT2Zmc2V0LCBvbGRPZmZzZXQgKyBvbGRSb3dTaXplKSwgbmV3T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuICBzdGF0aWMgY2FsY0ltMkNvbERpbXMoaW5wdXRTaGFwZTogbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IG51bWJlcltdLCBjaGFubmVscyA9IDEpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG91dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM10sXG4gICAgICBNYXRoLmNlaWwoaW5wdXRTaGFwZVsxXSAqIGtlcm5lbFNoYXBlWzJdICoga2VybmVsU2hhcGVbM10gLyBjaGFubmVscylcbiAgICBdO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNhbGNTaGFyZWREaW1SZWFkU2l6ZShwcmVmZXJyZWRCYXRjaFNpemU6IG51bWJlciwgc2hhcmVkRGltOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChwcmVmZXJyZWRCYXRjaFNpemUgPD0gMCB8fCBzaGFyZWREaW0gPCBwcmVmZXJyZWRCYXRjaFNpemUgfHwgc2hhcmVkRGltICUgcHJlZmVycmVkQmF0Y2hTaXplICE9PSAwKSB7XG4gICAgICByZXR1cm4gc2hhcmVkRGltO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZmVycmVkQmF0Y2hTaXplO1xuICB9XG4gIHByb3RlY3RlZCBjYWxjQmxvY2tTaXplKG91dHB1dExheW91dDogVGV4dHVyZUxheW91dCk6IFtudW1iZXIsIG51bWJlcl18dW5kZWZpbmVkIHtcbiAgICBjb25zdCBwcmVmZXJyZWRSb3dDb3VudCA9IDY0O1xuICAgIGNvbnN0IHByZWZlcnJlZENvbENvdW50ID0gNjQ7XG4gICAgaWYgKG91dHB1dExheW91dC5oZWlnaHQgPCBwcmVmZXJyZWRSb3dDb3VudCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIFtwcmVmZXJyZWRDb2xDb3VudCwgcHJlZmVycmVkUm93Q291bnRdO1xuICB9XG4gIHByb3RlY3RlZCBhcnRpZmFjdHM6IEFydGlmYWN0W107XG4gIHByb3RlY3RlZCByZWFkU2l6ZSA9IDg7XG4gIHByb3RlY3RlZCBibG9ja1NpemUgPSA2NDtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlJztcbmltcG9ydCB7RGVwdGhUb1NwYWNlfSBmcm9tICcuLi8uLi8uLi9vcHMvZGVwdGgtdG8tc3BhY2UnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtBcnRpZmFjdCwgUHJvZ3JhbUluZm8sIFJ1bkRhdGF9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL3Jlc2hhcGUnO1xuaW1wb3J0IHtXZWJHTFRyYW5zcG9zZX0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xEZXB0aFRvU3BhY2UgZXh0ZW5kcyBEZXB0aFRvU3BhY2Uge1xuICBwcm90ZWN0ZWQgdHJhbnNwb3NlUHJvZ3JhbUluZm86IFByb2dyYW1JbmZvO1xuXG4gIHByb3RlY3RlZCB0cmFuc3Bvc2VBcnRpZmFjdDogQXJ0aWZhY3Q7XG5cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBwcm9ncmFtTWFuYWdlciA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlcjtcbiAgICBjb25zdCB0cmFuc3Bvc2VQZXJtID0gdGhpcy5tb2RlID09PSAnRENSJyA/IFswLCAzLCA0LCAxLCA1LCAyXSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgICBjb25zdCBmaXJzdFJlc2hhcGVTaGFwZSA9IHRoaXMubW9kZSA9PT0gJ0RDUicgP1xuICAgICAgICBbXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMF0sIHRoaXMuYmxvY2tzaXplLCB0aGlzLmJsb2Nrc2l6ZSwgaW5wdXRzWzBdLmRpbXNbMV0gLyB0aGlzLmJsb2Nrc2l6ZVNxciwgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbM11cbiAgICAgICAgXSA6XG4gICAgICAgIFtcbiAgICAgICAgICBpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzBdLmRpbXNbMV0gLyB0aGlzLmJsb2Nrc2l6ZVNxciwgdGhpcy5ibG9ja3NpemUsIHRoaXMuYmxvY2tzaXplLCBpbnB1dHNbMF0uZGltc1syXSxcbiAgICAgICAgICBpbnB1dHNbMF0uZGltc1szXVxuICAgICAgICBdO1xuXG4gICAgY29uc3QgdHJhbnNwb3NlID0gbmV3IFdlYkdMVHJhbnNwb3NlKCk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUodW5kZWZpbmVkKTtcbiAgICBhdHRyaWJ1dGVzLnNldCgncGVybScsICdpbnRzJywgdHJhbnNwb3NlUGVybSk7XG4gICAgdHJhbnNwb3NlLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG5cbiAgICAvLyBGaXJzdCByZXNoYXBlXG5cbiAgICBjb25zdCBmaXJzdFJlc2hhcGVkVGVuc29yID0gcmVzaGFwZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGZpcnN0UmVzaGFwZVNoYXBlKTtcblxuICAgIC8vIHRyYW5zcG9zZVxuICAgIGlmICghdGhpcy50cmFuc3Bvc2VQcm9ncmFtSW5mbykge1xuICAgICAgdGhpcy50cmFuc3Bvc2VQcm9ncmFtSW5mbyA9IHRyYW5zcG9zZS5jcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBbZmlyc3RSZXNoYXBlZFRlbnNvcl0pO1xuICAgICAgdGhpcy50cmFuc3Bvc2VBcnRpZmFjdCA9IHByb2dyYW1NYW5hZ2VyLmJ1aWxkKHRoaXMudHJhbnNwb3NlUHJvZ3JhbUluZm8pO1xuICAgIH1cbiAgICBjb25zdCBydW5EYXRhVHJhbnNwb3NlID1cbiAgICAgICAgdHJhbnNwb3NlLmNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlciwgdGhpcy50cmFuc3Bvc2VQcm9ncmFtSW5mbywgW2ZpcnN0UmVzaGFwZWRUZW5zb3JdKTtcbiAgICBpbmZlcmVuY2VIYW5kbGVyLmNoZWNrQW5kVXBkYXRlVGV4dHVyZUZvcm0odGhpcy50cmFuc3Bvc2VBcnRpZmFjdCwgcnVuRGF0YVRyYW5zcG9zZSk7XG4gICAgcHJvZ3JhbU1hbmFnZXIucnVuKHRoaXMudHJhbnNwb3NlQXJ0aWZhY3QsIHJ1bkRhdGFUcmFuc3Bvc2UpO1xuICAgIGNvbnN0IHRyYW5zcG9zZU91dHB1dCA9IHJ1bkRhdGFUcmFuc3Bvc2Uub3V0cHV0VGV4dHVyZURhdGEudGVuc29yO1xuXG4gICAgLy8gU2Vjb25kIHJlc2hhcGVcbiAgICBjb25zdCByZXN1bHQgPSByZXNoYXBlKGluZmVyZW5jZUhhbmRsZXIsIHRyYW5zcG9zZU91dHB1dCwgW1xuICAgICAgaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1swXS5kaW1zWzFdIC8gdGhpcy5ibG9ja3NpemVTcXIsIGlucHV0c1swXS5kaW1zWzJdICogdGhpcy5ibG9ja3NpemUsXG4gICAgICBpbnB1dHNbMF0uZGltc1szXSAqIHRoaXMuYmxvY2tzaXplXG4gICAgXSk7XG4gICAgcmV0dXJuIFtyZXN1bHRdO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldE91dFNoYXBlKGlucHV0OiBUZW5zb3IpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgICBjb25zdCBpbnB1dERlcHRoID0gaW5wdXQuZGltc1sxXTtcbiAgICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0LmRpbXNbMl07XG4gICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0LmRpbXNbM107XG4gICAgaWYgKGlucHV0RGVwdGggJSAodGhpcy5ibG9ja3NpemVTcXIpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRlcHRoIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHNxdWFyZWQgYmxvY2tzaXplLicpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IGlucHV0RGVwdGggLyB0aGlzLmJsb2Nrc2l6ZVNxcjtcbiAgICBjb25zdCBvdXRwdXRIZWlnaHQgPSBpbnB1dEhlaWdodCAqIHRoaXMuYmxvY2tzaXplO1xuICAgIGNvbnN0IG91dHB1dFdpZHRoID0gaW5wdXRXaWR0aCAqIHRoaXMuYmxvY2tzaXplO1xuICAgIHJldHVybiBbYmF0Y2hTaXplLCBvdXRwdXREZXB0aCwgb3V0cHV0SGVpZ2h0LCBvdXRwdXRXaWR0aF07XG4gIH1cblxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn0iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEcm9wb3V0fSBmcm9tICcuLi8uLi8uLi9vcHMvZHJvcG91dCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTERyb3BvdXQgZXh0ZW5kcyBEcm9wb3V0IGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgaWYgKHRoaXMudGVzdE1vZGUpIHtcbiAgICAgIHJldHVybiBbaW5wdXRzWzBdXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gdGVzdCBtb2RlIERyb3BvdXQgaXMgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIF9pbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9uIHRlc3QgbW9kZSBEcm9wb3V0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIF9wcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIF9pbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gdGVzdCBtb2RlIERyb3BvdXQgaXMgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbHV9IGZyb20gJy4uLy4uLy4uL29wcy9lbHUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEVsdSBleHRlbmRzIEVsdSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgdiA9ICR7Z2xzbC50ZXh0dXJlMkR9KEEsIFRleENvb3JkcykucjtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHYgPj0gMC4wID8gdjogKGV4cCh2KSAtIDEuMCkgKiAke3RoaXMuYWxwaGEudG9FeHBvbmVudGlhbCgpfSk7IC8qIGZsb2F0IG51bWJlciBmb3JtYXQgKi9cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSldLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnQSddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RmxhdHRlbn0gZnJvbSAnLi4vLi4vLi4vb3BzL2ZsYXR0ZW4nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vcmVzaGFwZSc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEZsYXR0ZW4gZXh0ZW5kcyBGbGF0dGVuIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gU2hhcGVVdGlsLmZsYXR0ZW5TaGFwZShpbnB1dHNbMF0uZGltcywgdGhpcy5heGlzKTtcblxuICAgIHJldHVybiBbcmVzaGFwZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIG91dHB1dERpbXMpXTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7Z2xzbFJlbHUsIGdsc2xTaWdtb2lkfSBmcm9tICcuL3VuYXJ5LW9wJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGljYXRpb25TbmlwcGV0KGFjdGl2YXRpb246IHN0cmluZykge1xuICBsZXQgYWN0aXZhdGlvbkZ1bmN0aW9uID0gJyc7XG4gIGxldCBhY3RpdmF0aW9uTmFtZSA9ICcnO1xuICBzd2l0Y2ggKGFjdGl2YXRpb24pIHtcbiAgICBjYXNlICdSZWx1JzpcbiAgICAgIGFjdGl2YXRpb25OYW1lID0gZ2xzbFJlbHUoKS5uYW1lO1xuICAgICAgYWN0aXZhdGlvbkZ1bmN0aW9uID0gZ2xzbFJlbHUoKS5ib2R5O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICBhY3RpdmF0aW9uTmFtZSA9IGdsc2xTaWdtb2lkKCkubmFtZTtcbiAgICAgIGFjdGl2YXRpb25GdW5jdGlvbiA9IGdsc2xTaWdtb2lkKCkuYm9keTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUT0RPOiBhZGRpbmcgb3RoZXIgYWN0aXZhdGlvbnMgdGhhdCBjYW4gYmUgZnVzZWQuXG4gICAgICBhY3RpdmF0aW9uTmFtZSA9ICcnO1xuICAgICAgYWN0aXZhdGlvbkZ1bmN0aW9uID0gJyc7XG4gIH1cbiAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gYWN0aXZhdGlvbiA/IGBcbiAgdmFsdWUgPSAke2FjdGl2YXRpb25OYW1lfSh2YWx1ZSk7YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcbiAgcmV0dXJuIHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn07XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHYXRoZXJ9IGZyb20gJy4uLy4uLy4uL29wcy9nYXRoZXInO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xHYXRoZXIgZXh0ZW5kcyBHYXRoZXIgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuXG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBpbmRleERhdGFTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGggKyBpbmRleERhdGFTaGFwZS5sZW5ndGggLSAxKTtcblxuICAgIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyh0aGlzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCBpbmRleENvcHlPcHM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gb3V0cHV0U2hhcGUgaXMgZGl2aWRlZCBpbnRvIHRocmVlIHBhcnRzOiBBLCBCLCBDXG4gICAgICAvLyB8MCAgICAgICAgYXhpc3wgIGF4aXMgKyBpbmRleERhdGFTaGFwZS5sZW5ndGggfCAgICAgICAgICBlbmR8XG4gICAgICAvLyB8ICAgICBBICAgICAgIHwgICAgICAgICAgICAgQiAgICAgICAgICAgICAgICAgfCAgICAgIEMgICAgICB8XG4gICAgICAvL1xuICAgICAgLy8gaW5wdXRJZHg6IFtBLCBpbnB1dHNbMV1bQl0sIENdXG4gICAgICBpZiAoaSA8IGF4aXMpIHsgIC8vIEFcbiAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbnB1dFNoYXBlW2ldO1xuICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5wdXRJZHhbJHtpfV0gPSBvdXRwdXRJZHhbJHtpfV07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA8IGF4aXMgKyBpbmRleERhdGFTaGFwZS5sZW5ndGgpIHsgIC8vIEJcbiAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGluZGV4RGF0YVNoYXBlW2kgLSBheGlzXTtcbiAgICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5kZXhEYXRhSWR4WyR7aSAtIGF4aXN9XSA9IG91dHB1dElkeFske2l9XTtgKTtcbiAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ1xuICAgICAgICAgIG91dHB1dFNoYXBlW2ldID0gaW5wdXRTaGFwZVtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMV07ICAvLyBza2lwIDEgZm9yIGF4aXNcbiAgICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5wdXRJZHhbJHtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3JhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGggfHwgMTtcbiAgICBjb25zdCBpcmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGlEcmFuayA9IGluZGV4RGF0YVNoYXBlLmxlbmd0aCB8fCAxO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske29yYW5rfV0pIHtcbiAgICAgICAgaW50IGlucHV0SWR4WyR7aXJhbmt9XTtcbiAgICAgICAgaW50IGluZGV4RGF0YUlkeFske2lEcmFua31dO1xuICAgICAgICBpbmRleERhdGFJZHhbMF0gPSAwO1xuICAgICAgICAke2luZGV4Q29weU9wcy5qb2luKCdcXG4gICAgICAgICcpfVxuICAgICAgICBpbnQgaWR4ID0gaW50KF9CKGluZGV4RGF0YUlkeCkpO1xuICAgICAgICBpbnB1dElkeFske2F4aXN9XSA9IGlkeCA8IDAgPyBpZHggKyAke2lucHV0U2hhcGVbYXhpc119IDogaWR4O1xuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xuICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQpKSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnLCAnQiddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHZW1tfSBmcm9tICcuLi8uLi8uLi9vcHMvZ2VtbSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7R2VtbVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMR2VtbSBleHRlbmRzIEdlbW0gaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IFtNLCBOXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgICAgICBhU2hhcGUsIHRoaXMudHJhbnNBLCBiU2hhcGUsIHRoaXMudHJhbnNCLCBpbnB1dHMubGVuZ3RoID09PSAzID8gaW5wdXRzWzJdLmRpbXMgOiB1bmRlZmluZWQpO1xuICAgIGNvbnN0IG9TaGFwZSA9IFtNLCBOXTtcbiAgICBpZiAoIW9TaGFwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gICAgfVxuICAgIGxldCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGxldCBsaW5lID0gJyc7XG4gICAgaWYgKHRoaXMudHJhbnNBKSB7XG4gICAgICBzaGFyZWREaW0gPSBhU2hhcGVbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLnRyYW5zQSAmJiB0aGlzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBfQV9UKGEpICogX0JfVChiKTsnO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc0EgJiYgIXRoaXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTsnO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMudHJhbnNBICYmIHRoaXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BKGEpICogX0JfVChiKTsnO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMudHJhbnNBICYmICF0aGlzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CKGIpOyc7XG4gICAgfVxuICAgIGNvbnN0IHJhbmsgPSBvU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGRlY2xhcmVDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGBpbnQgY1ske2lucHV0c1syXS5kaW1zLmxlbmd0aH1dO2AgOiAnJztcbiAgICBjb25zdCBicm9hZGNhc3RDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICdiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTsnIDogJyc7XG4gICAgY29uc3QgY2FsY3VsYXRlQyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyAndmFsdWUgKz0gYmV0YSAqIF9DKGMpOycgOiAnJztcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IGFbJHtyYW5rfV07XG4gICAgICAgICAgaW50IGJbJHtyYW5rfV07XG4gICAgICAgICAgJHtkZWNsYXJlQ31cblxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYSk7XG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBiKTtcbiAgICAgICAgICAke2Jyb2FkY2FzdEN9XG5cbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICBmb3IgKGludCBrPTA7IGs8JHtzaGFyZWREaW19OyArK2spIHtcbiAgICAgICAgICAgICAgYVske3JhbmsgLSAxfV0gPSBrO1xuICAgICAgICAgICAgICBiWyR7cmFuayAtIDJ9XSA9IGs7XG4gICAgICAgICAgICAgICR7bGluZX1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICogYWxwaGE7XG4gICAgICAgICAgJHtjYWxjdWxhdGVDfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1gO1xuICAgIGNvbnN0IGlucHV0TGF5b3V0cyA9IGlucHV0cy5tYXAodCA9PiBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0cyxcbiAgICAgIG91dHB1dExheW91dDogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG9TaGFwZSksXG4gICAgICBzYW1wbGVyczogaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFsnQScsICdCJywgJ0MnXSA6IFsnQScsICdCJ10sXG4gICAgICB2YXJpYWJsZXM6IFt7bmFtZTogJ2FscGhhJywgdHlwZTogJ2Zsb2F0J30sIHtuYW1lOiAnYmV0YScsIHR5cGU6ICdmbG9hdCd9XSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YTogeydhbHBoYSc6IHRoaXMuYWxwaGEsICdiZXRhJzogdGhpcy5iZXRhfVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7dW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEltMkNvbFBhY2tlZCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBwcm90ZWN0ZWQgY29udk91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIGtlcm5lbFNoYXBlOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIGRpbGF0aW9uczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBwYWRzOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIHN0cmlkZXM6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgY29udk91dHB1dFNoYXBlOiBudW1iZXJbXSwga2VybmVsU2hhcGU6IG51bWJlcltdLCBkaWxhdGlvbnM6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10pIHtcbiAgICB0aGlzLmNvbnZPdXRwdXRTaGFwZSA9IGNvbnZPdXRwdXRTaGFwZTtcbiAgICB0aGlzLmtlcm5lbFNoYXBlID0ga2VybmVsU2hhcGU7XG4gICAgdGhpcy5kaWxhdGlvbnMgPSBkaWxhdGlvbnM7XG4gICAgdGhpcy5wYWRzID0gcGFkcztcbiAgICB0aGlzLnN0cmlkZXMgPSBzdHJpZGVzO1xuICB9XG5cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW0yQ29sIGtlcm5lbCBzaG91bGQgaGF2ZSB0d28gaW5wdXQgdGVuc29ycycpO1xuICAgIH1cblxuICAgIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qgd3NoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCByb3dEaW0gPSAyO1xuICAgIGNvbnN0IGNvbERpbSA9IDM7XG4gICAgY29uc3QgcmFuayA9IHRoaXMuY29udk91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpbTJjb2xTaGFwZSA9IFt3c2hhcGVbMV0gKiB3c2hhcGVbMl0gKiB3c2hhcGVbM10sIHRoaXMuY29udk91dHB1dFNoYXBlWzJdICogdGhpcy5jb252T3V0cHV0U2hhcGVbM11dO1xuICAgIGNvbnN0IGtlcm5lbFNpemUgPSB3c2hhcGVbMl0gKiB3c2hhcGVbM107XG4gICAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGxldCB1bnJvbGxlZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPD0gMTsgY29sKyspIHtcbiAgICAgICAgdW5yb2xsZWQgKz0gYFxuICAgICAgICAgIGJsb2NrSW5kZXggPSByYy54ICsgJHtjb2x9O1xuICAgICAgICAgIHBvcyA9IHJjLnkgKyAke3Jvd307XG5cbiAgICAgICAgICBpZihibG9ja0luZGV4IDwgJHtpbTJjb2xTaGFwZVsxXX0gJiYgcG9zIDwgJHtpbTJjb2xTaGFwZVswXX0pIHtcbiAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke3RoaXMuY29udk91dHB1dFNoYXBlW3JhbmsgLSAxXX0pKSAqICR7dGhpcy5zdHJpZGVzWzBdfSAtICR7dGhpcy5wYWRzWzBdfTtcbiAgICAgICAgICAgIGQwID0gb2Zmc2V0WSArICR7dGhpcy5kaWxhdGlvbnNbMF19ICogKGltb2QocG9zLCAke2tlcm5lbFNpemV9KSAvICR7d3NoYXBlWzJdfSk7XG5cbiAgICAgICAgICAgIGlmKGQwIDwgJHt4c2hhcGVbcm93RGltXX0gJiYgZDAgPj0gMCkge1xuICAgICAgICAgICAgICBvZmZzZXRYID0gaW1vZChibG9ja0luZGV4LCAke3RoaXMuY29udk91dHB1dFNoYXBlW3JhbmsgLSAxXX0pICogJHt0aGlzLnN0cmlkZXNbMV19IC0gJHt0aGlzLnBhZHNbMV19O1xuICAgICAgICAgICAgICBkMSA9IG9mZnNldFggKyAke3RoaXMuZGlsYXRpb25zWzFdfSAqIGltb2QoaW1vZChwb3MsICR7a2VybmVsU2l6ZX0pLCAke3dzaGFwZVsyXX0pO1xuXG4gICAgICAgICAgICAgIGlmKGQxIDwgJHt4c2hhcGVbY29sRGltXX0gJiYgZDEgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgY2ggPSBpbnQoZmxvYXQocG9zKS8gJHtrZXJuZWxTaXplfS4pO1xuICAgICAgICAgICAgICAgICAgaW5uZXJEaW1zID0gdmVjMihkMCwgZDEpO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0WyR7cm93ICogMiArIGNvbH1dID0gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcbiAgICAgICAgICAgICAgICAgICAgaW50KGlubmVyRGltcy55KSksIGlubmVyRGltcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgJHt1bnBhY2tDaGFubmVsfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XG4gICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XG4gICAgICAgIHZlYzIgaW5uZXJEaW1zO1xuICAgICAgICAke3Vucm9sbGVkfVxuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICB9XG4gICAgICAgICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ1dlYkdMSW0yQ29sUGFja2VkJyxcbiAgICAgIGlucHV0TGF5b3V0czogW2luZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgNCwgdHJ1ZSwgeHNoYXBlLCB0cnVlKV0sXG4gICAgICBvdXRwdXRMYXlvdXQ6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKGltMmNvbFNoYXBlLCA0LCBpbTJjb2xTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID1cbiAgICAgICAgaW5wdXRzLm1hcCgodCkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQsIDEsIGZhbHNlLCBbXSwgdHJ1ZSkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW1hZ2VTY2FsZXJ9IGZyb20gJy4uLy4uLy4uL29wcy9pbWFnZS1zY2FsZXInO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xJbWFnZVNjYWxlciBleHRlbmRzIEltYWdlU2NhbGVyIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGdldEJpYXNNZXRob2QgPSB0aGlzLmNyZWF0ZUdldEJpYXNNZXRob2QodGhpcy5iaWFzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtnZXRCaWFzTWV0aG9kfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICByZXR1cm4gX1goaW5kaWNlcykgKiBzY2FsZSArIGdldEJpYXMoYmlhcywgaW5kaWNlc1sxXSk7XG4gICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKV0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydYJ10sXG4gICAgICB2YXJpYWJsZXM6IFt7bmFtZTogJ2JpYXMnLCB0eXBlOiAnZmxvYXQnLCBhcnJheUxlbmd0aDogdGhpcy5iaWFzLmxlbmd0aH0sIHtuYW1lOiAnc2NhbGUnLCB0eXBlOiAnZmxvYXQnfV0sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7J2JpYXMnOiB0aGlzLmJpYXMsICdzY2FsZSc6IHRoaXMuc2NhbGV9XG4gICAgfTtcbiAgfVxuICBwcml2YXRlIGNyZWF0ZUdldEJpYXNNZXRob2QobnVtQ2hhbm5lbHM6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgY29kZUxpbmVzOiBzdHJpbmdbXSA9IFtgZmxvYXQgZ2V0QmlhcyhmbG9hdCBiaWFzWyR7bnVtQ2hhbm5lbHN9XSwgaW50IGNoYW5uZWwpIHtgXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNoYW5uZWxzOyArK2kpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgICAgYGlmIChjaGFubmVsID09ICR7aX0pIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtQ2hhbm5lbHMgLSAxKSB7XG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgICAgYGVsc2UgeyByZXR1cm4gYmlhc1ske2l9XTsgfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgICBgZWxzZSBpZiAoY2hhbm5lbCA9PSAke2l9KSB7IHJldHVybiBiaWFzWyR7aX1dOyB9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAnXFx0JyArXG4gICAgICAgICd9Jyk7XG4gICAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5zdGFuY2VOb3JtYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcHMvaW5zdGFuY2Utbm9ybWFsaXphdGlvbic7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlTGF5b3V0fSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEluc3RhbmNlTm9ybWFsaXphdGlvbiBleHRlbmRzIEluc3RhbmNlTm9ybWFsaXphdGlvbiB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgaWYgKCF0aGlzLmFydGlmYWN0cykge1xuICAgICAgdGhpcy5hcnRpZmFjdHMgPSBbXTtcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvcyA9IHRoaXMuY3JlYXRlUHJvZ3JhbUluZm9zKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cyk7XG4gICAgICBwcm9ncmFtSW5mb3MuZm9yRWFjaCgocHJvZ3JhbUluZm8pID0+IHtcbiAgICAgICAgY29uc3QgYXJ0aWZhY3QgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8pO1xuICAgICAgICB0aGlzLmFydGlmYWN0cy5wdXNoKGFydGlmYWN0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJ1bkRhdGFzID0gdGhpcy5jcmVhdGVSdW5EYXRhcyhpbmZlcmVuY2VIYW5kbGVyLCB0aGlzLmFydGlmYWN0cy5tYXAoYSA9PiBhLnByb2dyYW1JbmZvKSwgaW5wdXRzKTtcbiAgICBydW5EYXRhcy5mb3JFYWNoKCh2LCBpKSA9PiBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKHRoaXMuYXJ0aWZhY3RzW2ldLCB2KSk7XG4gICAgcmV0dXJuIFtydW5EYXRhc1sxXS5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3JdO1xuICB9XG5cbiAgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIXN1cGVyLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgLy8gY3VycmVudGx5IHdlYmdsIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydCA0LUQgaW5wdXQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjcmVhdGVNZWFuQW5kVmFyaWFuY2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHhMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgeERpbXMgPSB4TGF5b3V0LnNoYXBlO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB4RGltc1sxXTtcbiAgICBjb25zdCBjaGFubmVsU2l6ZSA9IHhEaW1zWzJdICogeERpbXNbM107XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbeERpbXNbMF0sIGNoYW5uZWxdO1xuICAgIGNvbnN0IG91dHB1dFVucGFja2VkU2hhcGUgPSBbeERpbXNbMF0sIGNoYW5uZWwgKiA0XTtcblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICB2ZWM0IHByb2Nlc3MoaW50WzJdIGluZGljZXMpIHtcbiAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcbiAgICAgIGludCBhWzRdO1xuICAgICAgYVswXSA9IGluZGljZXNbMF07XG4gICAgICBhWzFdID0gaW5kaWNlc1sxXTtcbiAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XG4gICAgICBmb3IoaW50IGEyPTA7IGEyPCR7eERpbXNbMl19OyBhMisrKSB7XG4gICAgICAgIGFbMl0gPSBhMjtcbiAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke3hEaW1zWzNdfTsgYTMrKykge1xuICAgICAgICAgIGFbM10gPSBhMztcbiAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgdGVtcCArPSB4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbG9hdCBtZWFuID0gdGVtcCAvIGZsb2F0KCR7Y2hhbm5lbFNpemV9KTtcbiAgICAgIHRlbXAgPSAwLjA7XG4gICAgICBmb3IoaW50IGEyPTA7IGEyPCR7eERpbXNbMl19OyBhMisrKSB7XG4gICAgICAgIGFbMl0gPSBhMjtcbiAgICAgICAgZm9yKGludCBhMz0wOyBhMzwke3hEaW1zWzNdfTsgYTMrKykge1xuICAgICAgICAgIGFbM10gPSBhMztcbiAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgdGVtcCArPSAoeCAtIG1lYW4pICogKHggLSBtZWFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdi5yID0gbWVhbjtcbiAgICAgIHYuZyA9IHRlbXAgLyBmbG9hdCgke2NoYW5uZWxTaXplfSk7XG5cbiAgICAgIHJldHVybiB2O1xuICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFt4TGF5b3V0XSxcbiAgICAgIG91dHB1dExheW91dDogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlLCA0LCBvdXRwdXRVbnBhY2tlZFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ1gnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIG5hbWU6ICdNZWFuQW5kVmFyaWFuY2UnLFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVDb21wdXRPdXRwdXRQcm9ncmFtSW5mbyhcbiAgICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgeExheW91dDogVGV4dHVyZUxheW91dCwgc2NhbGVMYXlvdXQ6IFRleHR1cmVMYXlvdXQsXG4gICAgICBiTGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBtZWFuQW5kVmFyaWFuY2VMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICB2ZWM0IGdldF9NZWFuQW5kVmFyaWFuY2UoaW50WzJdIG12KSB7XG4gICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0X01lYW5BbmRWYXJpYW5jZShtdik7XG4gICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHttZWFuQW5kVmFyaWFuY2VMYXlvdXQud2lkdGh9LCAke21lYW5BbmRWYXJpYW5jZUxheW91dC5oZWlnaHR9KTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfShNZWFuQW5kVmFyaWFuY2UsIGNvb3Jkcyk7XG4gICAgfVxuXG4gICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xuXG4gICAgICAgICAgaW50IG12WzJdO1xuICAgICAgICAgIG12WzBdID0gaW5kaWNlc1swXTtcbiAgICAgICAgICBtdlsxXSA9IGluZGljZXNbMV07XG4gICAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xuICAgICAgICAgIGZsb2F0IG1lYW4gPSBtZWFuX2FuZF92YXJpYW5jZS5yO1xuICAgICAgICAgIGZsb2F0IHZhcmlhbmNlID0gbWVhbl9hbmRfdmFyaWFuY2UuZztcblxuICAgICAgICAgIGludCBzYlsxXTtcbiAgICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XG4gICAgICAgICAgZmxvYXQgc2NhbGUgPSBfU2NhbGUoc2IpO1xuICAgICAgICAgIGZsb2F0IGIgPSBfQihzYik7XG5cbiAgICAgICAgICByZXR1cm4gc2NhbGUgKiAoX1goaW5kaWNlcykgLSBtZWFuKSAvIHNxcnQodmFyaWFuY2UgKyBlcHNpbG9uKSArIGI7XG4gICAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFt4TGF5b3V0LCBtZWFuQW5kVmFyaWFuY2VMYXlvdXQsIHNjYWxlTGF5b3V0LCBiTGF5b3V0XSxcbiAgICAgIG91dHB1dExheW91dDogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHhMYXlvdXQuc2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnWCcsICdNZWFuQW5kVmFyaWFuY2UnLCAnU2NhbGUnLCAnQiddLFxuICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2Zsb2F0J31dLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgbmFtZTogJ0NvbXB1dE91dHB1dCcsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mb3MoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm9bXSB7XG4gICAgY29uc3QgeExheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSk7XG4gICAgY29uc3Qgc2NhbGVMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMV0pO1xuICAgIGNvbnN0IGJMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMl0pO1xuICAgIGNvbnN0IG1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvID0gdGhpcy5jcmVhdGVNZWFuQW5kVmFyaWFuY2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCB4TGF5b3V0KTtcbiAgICBjb25zdCBjb21wdXRlT3V0cHV0UHJvZ3JhbUluZm8gPSB0aGlzLmNyZWF0ZUNvbXB1dE91dHB1dFByb2dyYW1JbmZvKFxuICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLCB4TGF5b3V0LCBzY2FsZUxheW91dCwgYkxheW91dCwgbWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0KTtcblxuICAgIGNvbnN0IHByb2dyYW1JbmZvczogUHJvZ3JhbUluZm9bXSA9IFttZWFuQW5kVmFyaWFuY2VQcm9ncmFtSW5mbywgY29tcHV0ZU91dHB1dFByb2dyYW1JbmZvXTtcbiAgICByZXR1cm4gcHJvZ3JhbUluZm9zO1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGFzKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm9zOiBQcm9ncmFtSW5mb1tdLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YVtdIHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS50eXBlO1xuICAgIGNvbnN0IGlucHV0VEQgPSBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mb3NbMF0uaW5wdXRMYXlvdXRzWzBdKTtcbiAgICBjb25zdCBzY2FsZVREID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1sxXSwgcHJvZ3JhbUluZm9zWzFdLmlucHV0TGF5b3V0c1syXSk7XG4gICAgY29uc3QgYlREID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1syXSwgcHJvZ3JhbUluZm9zWzFdLmlucHV0TGF5b3V0c1szXSk7XG4gICAgY29uc3QgcnVuRGF0YXM6IFJ1bkRhdGFbXSA9IFtdO1xuICAgIHJ1bkRhdGFzLnB1c2goe1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IFtpbnB1dFREXSxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mb3NbMF0ub3V0cHV0TGF5b3V0LCBkYXRhVHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9KTtcbiAgICBydW5EYXRhcy5wdXNoKHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBbaW5wdXRURCwgcnVuRGF0YXNbMF0ub3V0cHV0VGV4dHVyZURhdGEsIHNjYWxlVEQsIGJURF0sXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm9zWzFdLm91dHB1dExheW91dCwgZGF0YVR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHsnZXBzaWxvbic6IHRoaXMuZXBzaWxvbn1cbiAgICB9KTtcbiAgICByZXR1cm4gcnVuRGF0YXM7XG4gIH1cbiAgcHJvdGVjdGVkIGFydGlmYWN0czogQXJ0aWZhY3RbXTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xlYWt5UmVsdX0gZnJvbSAnLi4vLi4vLi4vb3BzL2xlYWt5LXJlbHUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTExlYWt5UmVsdSBleHRlbmRzIExlYWt5UmVsdSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgdiA9ICR7Z2xzbC50ZXh0dXJlMkR9KEEsIFRleENvb3JkcykucjtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHYgPCAwLjAgPyB2ICogZmxvYXQoJHt0aGlzLmFscGhhfSkgOiB2KTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBpbnB1dExheW91dHM6IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0pXSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TWF0TXVsfSBmcm9tICcuLi8uLi8uLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRBY3RpY2F0aW9uU25pcHBldH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMTWF0TXVsUGFja2VkIGV4dGVuZHMgTWF0TXVsIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFTaGFwZSwgYlNoYXBlLCB0cnVlKTtcblxuICAgIGlmICghb3V0cHV0U2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNoYXJlZERpbSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc2hhcmVkRGltSW5kZXggPSBNYXRoLmNlaWwoc2hhcmVkRGltIC8gMik7XG4gICAgY29uc3QgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGJSYW5rID0gYlNoYXBlLmxlbmd0aDtcblxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3Qgb3V0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBhbGxHbENoYW5uZWxzID0gWyd4JywgJ3knLCAneicsICd3JywgJ3UnLCAndiddO1xuXG4gICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGljYXRpb25TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7Y29vcmRzRGF0YVR5cGV9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBsYXN0RGltID0gcmMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAxXX07XG4gICAgICAgIHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMV19ID0gcmMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAyXX07XG4gICAgICAgIHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19ID0gbGFzdERpbTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW1JbmRleH07IGkrKykge1xuICAgICAgICAgIHZlYzQgYSA9IGdldEEoJHtnZXRBKGFsbEdsQ2hhbm5lbHMsIGFSYW5rKX0pO1xuICAgICAgICAgIHZlYzQgYiA9IGdldEIoJHtnZXRCKGFsbEdsQ2hhbm5lbHMsIGJSYW5rKX0pO1xuICAgICAgICAgIHJlc3VsdCArPSAoYS5ycmJiICogYi5yZ3JnKTtcbiAgICAgICAgICByZXN1bHQgKz0gKGEuZ2dhYSAqIGIuYmFiYSk7XG4gICAgICAgIH1cbiAgICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdXZWJHTE1hdE11bFBhY2tlZCcsXG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQsIDQsIHRydWUsIGlucHV0c1tpXS5kaW1zLCB0cnVlKSksXG4gICAgICBvdXRwdXRMYXlvdXQ6XG4gICAgICAgICAgaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlLCA0LCBvdXRwdXRTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KSxcbiAgICAgIHNhbXBsZXJzOiBoYXNCaWFzID8gWydBJywgJ0InLCAnQmlhcyddIDogWydBJywgJ0InXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID1cbiAgICAgICAgaW5wdXRzLm1hcCgodCkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQsIDEsIGZhbHNlLCBbXSwgdHJ1ZSkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBKGFsbEdsQ2hhbm5lbHM6IHN0cmluZ1tdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgcmVzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7IGkrKykge1xuICAgIHJlcyArPSBgcmMuJHthbGxHbENoYW5uZWxzW2ldfSwgYDtcbiAgfVxuICByZXMgKz0gYHJjLiR7YWxsR2xDaGFubmVsc1tyYW5rIC0gMl19LCBgICtcbiAgICAgICdpKjInO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRCKGFsbEdsQ2hhbm5lbHM6IHN0cmluZ1tdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgcmVzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7IGkrKykge1xuICAgIHJlcyArPSBgcmMuJHthbGxHbENoYW5uZWxzW2ldfSwgYDtcbiAgfVxuICByZXMgKz0gJ2kqMiwgJyArXG4gICAgICBgcmMuJHthbGxHbENoYW5uZWxzW3JhbmsgLSAxXX1gO1xuICByZXR1cm4gcmVzO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TWF0TXVsfSBmcm9tICcuLi8uLi8uLi9vcHMvbWF0bXVsJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7V2ViR0xNYXRNdWxQYWNrZWR9IGZyb20gJy4vbWF0bXVsLXBhY2snO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xNYXRNdWwgZXh0ZW5kcyBNYXRNdWwgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcHJpdmF0ZSB1c2VQYWNrZWRUZXh0dXJlPzogYm9vbGVhbjtcblxuICBwYWNrZWRJbXBsOiBXZWJHTE1hdE11bFBhY2tlZDtcbiAgdW5wYWNrZWRJbXBsOiBXZWJHTFVucGFja2VkTWF0TXVsO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucGFja2VkSW1wbCA9IG5ldyBXZWJHTE1hdE11bFBhY2tlZCgpO1xuICAgIHRoaXMudW5wYWNrZWRJbXBsID0gbmV3IFdlYkdMVW5wYWNrZWRNYXRNdWwoKTtcbiAgfVxuXG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgaWYgKHRoaXMudXNlUGFja2VkVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcbiAgICAgIHRoaXMudXNlUGFja2VkVGV4dHVyZSA9ICFpc0Jyb2FkY2FzdCAmJiBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucGFjaztcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VQYWNrZWRUZXh0dXJlKSB7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcy5wYWNrZWRJbXBsLCBpbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcy51bnBhY2tlZEltcGwsIGlucHV0cyk7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGlmICh0aGlzLnVzZVBhY2tlZFRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgICB0aGlzLnVzZVBhY2tlZFRleHR1cmUgPSAhaXNCcm9hZGNhc3QgJiYgaGFuZGxlci5zZXNzaW9uLnBhY2s7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXNlUGFja2VkVGV4dHVyZSAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRJbXBsLmNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja2VkSW1wbC5jcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBpZiAodGhpcy51c2VQYWNrZWRUZXh0dXJlICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tlZEltcGwuY3JlYXRlUnVuRGF0YShoYW5kbGVyLCBwcm9ncmFtSW5mbywgaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRJbXBsLmNyZWF0ZVJ1bkRhdGEoaGFuZGxlciwgcHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVucGFja2VkTWF0TXVsIGV4dGVuZHMgTWF0TXVsIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYVNoYXBlLCBiU2hhcGUsIHRydWUpO1xuICAgIGlmICghb3V0cHV0U2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgYXJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGJyYW5rID0gYlNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgYVske2FyYW5rfV07XG4gICAgICAgICAgaW50IGJbJHticmFua31dO1xuICAgICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xuICAgICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19CKGluZGljZXMsIGIpO1xuXG4gICAgICAgICAgZmxvYXQgdmFsdWU7XG4gICAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7c2hhcmVkRGltfTsgKytrKSB7XG4gICAgICAgICAgICAgIGFbJHthcmFuayAtIDF9XSA9IGs7XG4gICAgICAgICAgICAgIGJbJHticmFuayAtIDJ9XSA9IGs7XG4gICAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSksXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJywgJ0InXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRDb29yZHNEYXRhVHlwZX0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQge2dldENoYW5uZWxzfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xQYWNrIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2sga2VybmVsIHNob3VsZCBoYXZlIGlucHV0IHRlbnNvciBjb3VudCB0byAxLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcblxuICAgIGNvbnN0IG91dHB1dExheW91dCA9XG4gICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dFNoYXBlLCA0LCBpbnB1dFNoYXBlLCB7aXNQYWNrZWQ6IHRydWUsIHJldmVyc2VXSDogdHJ1ZX0pO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gb3V0cHV0TGF5b3V0LnNoYXBlO1xuICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dFJhbmspO1xuICAgIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgb3V0cHV0UmFuayk7XG4gICAgY29uc3Qgc2V0dXAgPSBnZXRTZXR1cChvdXRwdXRSYW5rLCBjaGFubmVscywgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDJdLCBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV0pO1xuXG4gICAgbGV0IHJldmVyc2VkSW5wdXRXSDtcbiAgICBpZiAoaW5wdXRSYW5rID09PSAwKSB7XG4gICAgICByZXZlcnNlZElucHV0V0ggPSBbMSwgMV07XG4gICAgfSBlbHNlIGlmIChpbnB1dFJhbmsgPT09IDEpIHtcbiAgICAgIHJldmVyc2VkSW5wdXRXSCA9IFtpbnB1dFNoYXBlWzBdLCAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV2ZXJzZWRJbnB1dFdIID0gW2lucHV0U2hhcGVbb3V0cHV0UmFuayAtIDFdLCBpbnB1dFNoYXBlW291dHB1dFJhbmsgLSAyXV07XG4gICAgfVxuICAgIGNvbnN0IG91dE9mQm91bmRzQ29uZGl0aW9uID0gZ2V0T3V0T2ZCb3VuZHNDb25kaXRpb24ob3V0cHV0UmFuaywgcmV2ZXJzZWRJbnB1dFdILCBjaGFubmVscyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gZ2V0T3V0cHV0KGlucHV0U2hhcGUsIGNoYW5uZWxzKTtcblxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgaWYoJHtvdXRPZkJvdW5kc0NvbmRpdGlvbn0pIHtcbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCgwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHtzZXR1cH1cblxuICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KCR7b3V0cHV0fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBgO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdXZWJHTFBhY2snLFxuICAgICAgaW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdLCAxLCBmYWxzZSwgW10sIHRydWUpXSxcbiAgICAgIG91dHB1dExheW91dCxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IGZhbHNlLFxuICAgICAgZXhwZWN0UGFja2VkT3V0cHV0czogdHJ1ZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIGNoZWNrIG91dHB1dCBjb29yZGluYXRlIGxvY2F0aW9uIGFuZCByZXR1cm4gZmFsc2UgaWYgaXQgaXMgb3V0c2lkZSBpbnB1dCdzIHdpZHRoL2hlaWdodCBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBnZXRPdXRPZkJvdW5kc0NvbmRpdGlvbihyYW5rOiBudW1iZXIsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZGltczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBgcmMgPiAke3NoYXBlWzBdfWA7XG4gIH1cblxuICBsZXQgY29uZCA9ICcnO1xuICBmb3IgKGxldCBpID0gcmFuayAtIDI7IGkgPCByYW5rOyBpKyspIHtcbiAgICBjb25kICs9IGAke2RpbXNbaV19ID49ICR7c2hhcGVbaSAtIHJhbmsgKyAyXX1gO1xuICAgIGlmIChpIDwgcmFuayAtIDEpIHtcbiAgICAgIGNvbmQgKz0gJ3x8JztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZDtcbn1cblxuLyoqXG4gKiBjb2RlIHNuaXBwZXQgdG8gc2FtcGxlIGlucHV0IHRleHR1cmUgd2l0aCBvdXRwdXQgY29vcmRpYW50ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0cHV0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZGltczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gIGlmIChyYW5rID09PSAwKSB7XG4gICAgcmV0dXJuICdnZXRBKCksIDAsIDAsIDAnO1xuICB9XG5cbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gYGdldEEocmMpLFxuICAgICAgICAgICAgcmMgKyAxID49ICR7c2hhcGVbMF19ID8gMC4gOiBnZXRBKHJjICsgMSksXG4gICAgICAgICAgICAwLCAwYDtcbiAgfVxuXG4gIGNvbnN0IGNvb3JkMDAgPSAnciwgYyc7XG4gIGNvbnN0IGNvb3JkMDEgPSAnciwgY3AxJztcbiAgY29uc3QgY29vcmQxMCA9ICdycDEsIGMnO1xuICBjb25zdCBjb29yZDExID0gJ3JwMSwgY3AxJztcbiAgbGV0IEQgPSAnJztcbiAgaWYgKHJhbmsgPiAyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgKytpKSB7XG4gICAgICBEID0gRCArIGAke2RpbXNbaV19LGA7XG4gICAgfVxuICB9XG4gIHJldHVybiBgZ2V0QSgke0R9JHtjb29yZDAwfSksXG4gICAgICAgICAgckVkZ2UgPyAwLiA6IGdldEEoJHtEfSR7Y29vcmQxMH0pLFxuICAgICAgICAgIGNFZGdlID8gMC4gOiBnZXRBKCR7RH0ke2Nvb3JkMDF9KSxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QSgke0R9JHtjb29yZDExfSlgO1xufVxuXG4vKipcbiAqIGNvZGUgc25pcHBldCB0byBzZXR1cCA0IGNvb3JkaW5hdGVzIGFuZCBlZGdlIGNvbmRpdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0U2V0dXAocmFuazogbnVtYmVyLCBkaW1zOiBzdHJpbmdbXSwgcm93czogbnVtYmVyLCBjb2xzOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMCB8fCByYW5rID09PSAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8vIHJhbmsgPj0gMiBmb3Igd2lkdGgraGVpZ2h0IHBhY2suXG4gIGVsc2Uge1xuICAgIGNvbnN0IHNldHVwID0gYFxuICAgIGludCByID0gJHtkaW1zW3JhbmsgLSAyXX07XG4gICAgaW50IGMgPSAke2RpbXNbcmFuayAtIDFdfTtcbiAgICBpbnQgcnAxID0gJHtkaW1zW3JhbmsgLSAyXX0gKyAxO1xuICAgIGludCBjcDEgPSAke2RpbXNbcmFuayAtIDFdfSArIDE7XG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSAke2NvbHN9O1xuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gJHtyb3dzfTtcbiAgICBgO1xuICAgIHJldHVybiBzZXR1cDtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWNDaGFubmVscyhuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKS5tYXAoZCA9PiBgJHtuYW1lfS4ke2R9YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFubmVscyhuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gW25hbWVdO1xuICB9XG4gIHJldHVybiBnZXRWZWNDaGFubmVscyhuYW1lLCByYW5rKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVucGFja0Zyb21DaGFubmVsKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIGludCBkaW0pIHtcbiAgICAgIGludCBtb2RDb29yZCA9IGltb2QoZGltLCAyKTtcbiAgICAgIHJldHVybiBtb2RDb29yZCA9PSAwID8gZnJhZy5yIDogZnJhZy5nO1xuICAgIH1cblxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xuICAgICAgdmVjMiBtb2RDb29yZCA9IG1vZChpbm5lckRpbXMsIDIuKTtcbiAgICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLmIgOiBmcmFnLmEpO1xuICAgIH1cbiAgYDtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1BhZH0gZnJvbSAnLi4vLi4vLi4vb3BzL3BhZCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbCwgR2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFRleHR1cmVMYXlvdXQsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMUGFkIGV4dGVuZHMgUGFkIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnBhZFNoYXBlKGlucHV0c1swXS5kaW1zLnNsaWNlKCksIHRoaXMucGFkcyk7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBhbGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKTtcbiAgICBjb25zdCBwYWRGdW5jdGlvbiA9IGdldFBhZEZ1bmN0aW9uKFxuICAgICAgICBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSwgJ0EnLCBhbGF5b3V0LCB0aGlzLm1vZGUsIHRoaXMucGFkcywgdGhpcy52YWx1ZSk7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtwYWRGdW5jdGlvbn1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgICByZXR1cm4gcGFkQShpbmRpY2VzKTtcbiAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFthbGF5b3V0XSxcbiAgICAgIG91dHB1dExheW91dDogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFkRnVuY3Rpb24oXG4gICAgZ2xzbDogR2xzbCwgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCwgbW9kZTogc3RyaW5nLCBwYWRzOiBudW1iZXJbXSwgdmFsdWU6IG51bWJlcik6IHN0cmluZyB7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2NvbnN0YW50JzpcbiAgICAgIHJldHVybiBnZXRQYWRDb25zdGFudChcbiAgICAgICAgICBnbHNsLCBuYW1lLCBpbnB1dExheW91dC5zaGFwZSwgaW5wdXRMYXlvdXQuc3RyaWRlcywgaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodCwgcGFkcywgdmFsdWUpO1xuICAgIGNhc2UgJ3JlZmxlY3QnOlxuICAgICAgcmV0dXJuIGdldFBhZFJlZmxlY3QoXG4gICAgICAgICAgZ2xzbCwgbmFtZSwgaW5wdXRMYXlvdXQuc2hhcGUsIGlucHV0TGF5b3V0LnN0cmlkZXMsIGlucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHQsIHBhZHMpO1xuICAgIGNhc2UgJ2VkZ2UnOlxuICAgICAgcmV0dXJuIGdldFBhZEVkZ2UoXG4gICAgICAgICAgZ2xzbCwgbmFtZSwgaW5wdXRMYXlvdXQuc2hhcGUsIGlucHV0TGF5b3V0LnN0cmlkZXMsIGlucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHQsIHBhZHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYWRDb25zdGFudChcbiAgICBnbHNsOiBHbHNsLCBuYW1lOiBzdHJpbmcsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLFxuICAgIHBhZHM6IG51bWJlcltdLCB2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgIGsgPSBtWyR7aX1dIC0gJHtwYWRzW2ldfTtcbiAgICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgICAgaWYgKGsgPj0gJHtzaGFwZVtpXX0pIHJldHVybiBjb25zdGFudDtcbiAgICAgICAgICBvZmZzZXQgKz0gayAqICR7c3RyaWRlc1tpXX07XG4gICAgICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgICBmbG9hdCBwYWQke25hbWV9KGludCBtWyR7cmFua31dKSB7XG4gICAgICAgICAgY29uc3QgZmxvYXQgY29uc3RhbnQgPSBmbG9hdCgke3ZhbHVlfSk7XG4gICAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIGNvb3JkcykpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBgO1xufVxuZnVuY3Rpb24gZ2V0UGFkUmVmbGVjdChcbiAgICBnbHNsOiBHbHNsLCBuYW1lOiBzdHJpbmcsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLFxuICAgIHBhZHM6IG51bWJlcltdKSB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgIGsgPSBtWyR7aX1dIC0gJHtwYWRzW2ldfTtcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW50IF8ybl8xID0gJHsyICogKHNoYXBlW2ldIC0gMSl9O1xuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xuICAgICAgICAgIGlmKGsgPj0gJHtzaGFwZVtpXX0pIHsgayA9IF8ybl8xIC0gazsgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgICAgZmxvYXQgcGFkJHtuYW1lfShpbnQgbVske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xufVxuZnVuY3Rpb24gZ2V0UGFkRWRnZShcbiAgICBnbHNsOiBHbHNsLCBuYW1lOiBzdHJpbmcsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLFxuICAgIHBhZHM6IG51bWJlcltdKSB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICBrID0gbVske2l9XSAtICR7cGFkc1tpXX07XG4gICAgICBpZiAoayA8IDApICBrID0gMDtcbiAgICAgIGlmIChrID49ICR7c2hhcGVbaV19KSBrID0gJHtzaGFwZVtpXSAtIDF9O1xuICAgICAgb2Zmc2V0ICs9IGsgKiAke3N0cmlkZXNbaV19O1xuICAgICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIGZsb2F0IHBhZCR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgaW50IGsgPSAwO1xuICAgICAgJHtibG9ja31cbiAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3dpZHRofSwgJHtoZWlnaHR9KTtcbiAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIGNvb3JkcykpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBgO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXZlcmFnZVBvb2wsIEdsb2JhbEF2ZXJhZ2VQb29sLCBHbG9iYWxNYXhQb29sLCBNYXhQb29sfSBmcm9tICcuLi8uLi8uLi9vcHMvcG9vbCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7UG9vbENvbnZVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFRleHR1cmVMYXlvdXQsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMR2xvYmFsQXZlcmFnZVBvb2wgZXh0ZW5kcyBHbG9iYWxBdmVyYWdlUG9vbCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICByZXR1cm4gY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyhcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCB0cnVlLCB0aGlzLmtlcm5lbFNoYXBlLCB0aGlzLmF1dG9QYWQsIHRoaXMuc3RyaWRlcywgdGhpcy5wYWRzLCB0aGlzLmNvdW50SW5jbHVkZVBhZCk7XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2luZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1swXSldO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTpcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMQXZlcmFnZVBvb2wgZXh0ZW5kcyBBdmVyYWdlUG9vbCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICByZXR1cm4gY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyhcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBmYWxzZSwgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5hdXRvUGFkLCB0aGlzLnN0cmlkZXMsIHRoaXMucGFkcywgdGhpcy5jb3VudEluY2x1ZGVQYWQpO1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKFxuICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwga2VybmVsU2hhcGU6IG51bWJlcltdID0gW10sXG4gICAgYXV0b1BhZCA9ICcnLCBzdHJpZGVzOiBudW1iZXJbXSA9IFtdLCBwYWRzOiBudW1iZXJbXSA9IFtdLCBjb3VudEluY2x1ZGVQYWQ6IGJvb2xlYW4pOiBQcm9ncmFtSW5mbyB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZSwga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9XG4gICAgICBQb29sQ29udlV0aWwuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlLCBzdHJpZGVzLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XG4gIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShrZXJuZWxTaGFwZSk7XG4gIGNvbnN0IG9wMSA9ICd2YWx1ZSArPSBfWCh4KTsnO1xuICBsZXQgb3AyID0gJyc7XG4gIGlmIChjb3VudEluY2x1ZGVQYWQpIHtcbiAgICBvcDIgKz0gYHZhbHVlIC89IGZsb2F0KCR7a2VybmVsU2l6ZX0pO2A7XG4gIH0gZWxzZSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSBmbG9hdCgke2tlcm5lbFNpemV9IC0gcGFkKTtgO1xuICB9XG4gIGNvbnN0IGlucHV0TGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKTtcbiAgY29uc3QgcG9vbGluZ0NvZGUgPSBnZW5lcmF0ZVBvb2xpbmdDb2RlKGlucHV0TGF5b3V0LCBrZXJuZWxTaGFwZSwgcGFkcywgc3RyaWRlcywgb3AxLCBvcDIsICcwLjAnKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtwb29saW5nQ29kZX1cbiAgICBgO1xuICByZXR1cm4ge1xuICAgIGlucHV0TGF5b3V0czogW2lucHV0TGF5b3V0XSxcbiAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgc2FtcGxlcnM6IFsnWCddLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMR2xvYmFsTWF4UG9vbCBleHRlbmRzIEdsb2JhbE1heFBvb2wgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgcmV0dXJuIGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyhcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCB0cnVlLCB0aGlzLmtlcm5lbFNoYXBlLCB0aGlzLmF1dG9QYWQsIHRoaXMuc3RyaWRlcywgdGhpcy5wYWRzKTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSldO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTpcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMTWF4UG9vbCBleHRlbmRzIE1heFBvb2wgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgcmV0dXJuIGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyhcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBmYWxzZSwgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5hdXRvUGFkLCB0aGlzLnN0cmlkZXMsIHRoaXMucGFkcyk7XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2luZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oXG4gICAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBrZXJuZWxTaGFwZTogbnVtYmVyW10gPSBbXSxcbiAgICBhdXRvUGFkID0gJycsIHN0cmlkZXM6IG51bWJlcltdID0gW10sIHBhZHM6IG51bWJlcltdID0gW10pOiBQcm9ncmFtSW5mbyB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZSwga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9XG4gICAgICBQb29sQ29udlV0aWwuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlLCBzdHJpZGVzLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XG4gIGNvbnN0IG9wMSA9IGBcbiAgICAgICAgICAgICAgdmFsdWUgPSBtYXgoX1goeCksIHZhbHVlKTtcbiAgICAgIGA7XG4gIGNvbnN0IG9wMiA9ICcnO1xuICBjb25zdCBpbnB1dExheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dFNoYXBlKTtcbiAgY29uc3QgcG9vbGluZ0NvZGUgPSBnZW5lcmF0ZVBvb2xpbmdDb2RlKGlucHV0TGF5b3V0LCBrZXJuZWxTaGFwZSwgcGFkcywgc3RyaWRlcywgb3AxLCBvcDIsICctMWU1Jyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAke3Bvb2xpbmdDb2RlfVxuICBgO1xuICByZXR1cm4ge1xuICAgIGlucHV0TGF5b3V0czogW2lucHV0TGF5b3V0XSxcbiAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgc2FtcGxlcnM6IFsnWCddLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUG9vbGluZ0NvZGUoXG4gICAgeDogVGV4dHVyZUxheW91dCwga2VybmVsU2hhcGU6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sIG9wMTogc3RyaW5nLCBvcDI6IHN0cmluZyxcbiAgICBzdGFydFZhbDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaW5wdXREaW1zID0geC5zaGFwZTtcbiAgY29uc3QgcmFuayA9IHguc2hhcGUubGVuZ3RoO1xuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoIDw9IDIpIHtcbiAgICBjb25zdCBrdyA9IGtlcm5lbFNoYXBlW2tlcm5lbFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHN3ID0gc3RyaWRlc1tzdHJpZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnQgPSBwYWRzW3BhZHMubGVuZ3RoIC8gMiAtIDFdO1xuICAgIGNvbnN0IHB3RW5kID0gcGFkc1twYWRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRpbVcgPSBpbnB1dERpbXNbcmFuayAtIDFdO1xuICAgIGxldCBjb2RlVyA9ICcnO1xuICAgIGxldCBjb2RlSCA9ICcnO1xuICAgIGxldCBjb2RlSEVuZCA9ICcnO1xuICAgIGlmIChwd1N0YXJ0ICsgcHdFbmQgIT09IDApIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMV0gPCAwIHx8IHhbJHtyYW5rfSAtIDFdID49ICR7ZGltV30pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVXID0gYFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBraCA9IGtlcm5lbFNoYXBlW2tlcm5lbFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3Qgc2ggPSBzdHJpZGVzW3N0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBwaFN0YXJ0ID0gcGFkc1twYWRzLmxlbmd0aCAvIDIgLSAyXTtcbiAgICAgIGNvbnN0IHBoRW5kID0gcGFkc1twYWRzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgZGltSCA9IGlucHV0RGltc1tyYW5rIC0gMl07XG4gICAgICBpZiAocGhTdGFydCArIHBoRW5kICE9PSAwKSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7a2h9OyBqKyspIHtcbiAgICAgICAgICAgICAgICB4WyR7cmFua30gLSAyXSA9IGluZGljZXNbJHtyYW5rfSAtIDJdICogJHtzaH0gLSAke3BoU3RhcnR9ICsgajtcbiAgICAgICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMl0gPCAwIHx8IHhbJHtyYW5rfSAtIDJdID49ICR7ZGltSH0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCs9ICR7a3d9O1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtraH07IGorKykge1xuICAgICAgICAgICAgICAgICAgeFske3Jhbmt9IC0gMl0gPSBpbmRpY2VzWyR7cmFua30gLSAyXSAqICR7c2h9IC0gJHtwaFN0YXJ0fSArIGo7XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIGNvZGVIRW5kID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgIH1cblxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgICAgICBpbnQgeFske3Jhbmt9XTtcbiAgICAgICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcblxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7c3RhcnRWYWx9O1xuICAgICAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtjb2RlSH1cbiAgICAgICAgICAgICAgJHtjb2RlV31cbiAgICAgICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO1xuICAgIHJldHVybiBwb29saW5nQ29kZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBrZXJuZWxTaXplID0gU2hhcGVVdGlsLnNpemUoa2VybmVsU2hhcGUpO1xuICAgIGNvbnN0IGtlcm5lbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoa2VybmVsU2hhcGUpO1xuICAgIGNvbnN0IHN0cmlkZXNSYW5rID0ga2VybmVsU3RyaWRlcy5sZW5ndGg7XG4gICAgY29uc3QgcGFkc1JhbmsgPSBwYWRzLmxlbmd0aDtcbiAgICBjb25zdCBvZmZzZXRUb0luZGljZXNGdW5jdGlvbiA9IG9mZnNldFRvSW5kaWNlcyhzdHJpZGVzUmFuayk7XG4gICAgY29uc3QgY29weUlucHV0RGltcyA9IGNvcHlBcnJheShpbnB1dERpbXMsICdpbnB1dERpbXMnKTtcbiAgICBjb25zdCBjb3B5UGFkcyA9IGNvcHlBcnJheShwYWRzLCAncGFkcycpO1xuICAgIGNvbnN0IGNvcHlLZXJuZWxTdHJpZGVzID0gY29weUFycmF5KGtlcm5lbFN0cmlkZXMsICdrZXJuZWxTdHJpZGVzJyk7XG4gICAgY29uc3QgY29weVN0cmlkZXMgPSBjb3B5QXJyYXkoc3RyaWRlcywgJ3N0cmlkZXMnKTtcbiAgICBjb25zdCBoYXNQYWRzID0gcGFkcy5yZWR1Y2UoKHN1bSwgY3VyKSA9PiBzdW0gKyBjdXIpO1xuICAgIGxldCBwYWRDb2RlID0gJyc7XG4gICAgaWYgKGhhc1BhZHMpIHtcbiAgICAgIHBhZENvZGUgPSBgXG4gICAgICAgICAgICAgICAgaWYgKHhbal0gPj0gaW5wdXREaW1zW2pdIHx8IHhbal0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtvcDF9YDtcbiAgICB9XG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgICAgICAke29mZnNldFRvSW5kaWNlc0Z1bmN0aW9ufVxuICAgICAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgICAgICAgIGludCB4WyR7cmFua31dO1xuICAgICAgICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XG4gICAgICAgICAgICAgICAgaW50IG9mZnNldFske3N0cmlkZXNSYW5rfV07XG4gICAgICAgICAgICAgICAgaW50IHBhZHNbJHtwYWRzUmFua31dO1xuICAgICAgICAgICAgICAgIGludCBpbnB1dERpbXNbJHtyYW5rfV07XG4gICAgICAgICAgICAgICAgaW50IGtlcm5lbFN0cmlkZXNbJHtzdHJpZGVzUmFua31dO1xuICAgICAgICAgICAgICAgIGludCBzdHJpZGVzWyR7c3RyaWRlc1Jhbmt9XTtcbiAgICAgICAgICAgICAgICAke2NvcHlQYWRzfVxuICAgICAgICAgICAgICAgICR7Y29weUlucHV0RGltc31cbiAgICAgICAgICAgICAgICAke2NvcHlTdHJpZGVzfVxuICAgICAgICAgICAgICAgICR7Y29weUtlcm5lbFN0cmlkZXN9XG5cbiAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7c3RhcnRWYWx9O1xuICAgICAgICAgICAgICAgIGludCBwYWQgPSAwO1xuICAgICAgICAgICAgICAgIGJvb2wgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7a2VybmVsU2l6ZX07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9ICR7cmFua30gLSAke3N0cmlkZXNSYW5rfTsgaiA8ICR7cmFua307IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgIHhbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHtyYW5rfSArICR7c3RyaWRlc1Jhbmt9XVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRbaiAtICR7cmFua30gKyAke3N0cmlkZXNSYW5rfV0gLSBwYWRzW2ogLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAke3BhZENvZGV9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR7b3AyfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgcmV0dXJuIHBvb2xpbmdDb2RlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyYXk6IHJlYWRvbmx5IG51bWJlcltdLCBhcnJheU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgJHthcnJheU5hbWV9WyR7aX1dID0gJHthcnJheVtpXX07XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYmxvY2s7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvZmZzZXRUb0luZGljZXMocmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICB2b2lkIG9mZnNldFRvSW5kaWNlcyhpbnQgb2Zmc2V0LCBpbnRbJHtyYW5rfV0gc3RyaWRlcywgb3V0IGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgICBpZiAoJHtyYW5rfSA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtyYW5rfSAtIDE7ICsraSkge1xuICAgICAgICBpbmRpY2VzW2ldID0gb2Zmc2V0IC8gc3RyaWRlc1tpXTtcbiAgICAgICAgb2Zmc2V0IC09IGluZGljZXNbaV0gKiBzdHJpZGVzW2ldO1xuICAgICAgfVxuICAgICAgaW5kaWNlc1ske3Jhbmt9IC0gMV0gPSBvZmZzZXQ7XG4gICAgfWA7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtSZWR1Y2VCYXNlfSBmcm9tICcuLi8uLi8uLi9vcHMvcmVkdWNlLW9wJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuYWJzdHJhY3QgY2xhc3MgV2ViR0xHZW5lcmljUmVkdWNlIGV4dGVuZHMgUmVkdWNlQmFzZSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBnZXRPcHMoaW5wdXRzOiBUZW5zb3JbXSwgYXhlczogbnVtYmVyW10pOiBzdHJpbmdbXTtcblxuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBpUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCB8fCAxO1xuXG4gICAgY29uc3QgaWR4Q29weSA9IFtdOyAgLy8gY29weSBvdXRwdXQgaW5kZXhlcyB0byBpbnB1dCBpbmRleGVzXG5cbiAgICBjb25zdCBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXModGhpcy5heGVzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IG9wcyA9IHRoaXMuZ2V0T3BzKGlucHV0cywgYXhlcyk7ICAvLyBbaW5pdCBvcHMsIHJlZHVjZSBvcHMsIGZpbmFsIG9wc11cbiAgICBsZXQgcmVkdWNlT3BzID0gb3BzWzFdO1xuXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dHNbMF0uZGltcy5sZW5ndGg7IGsrKykge1xuICAgICAgLy8gaWYgdGhpcyBheGlzIGlzIHJlZHVjZWRcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5rZWVwRGltcykge1xuICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goMSk7XG4gICAgICAgIH0gIC8vIGVsc2UgeyByZW1vdmUgdGhlIGF4aXMgZnJvbSBvdXRwdXRTaGFwZTsgfVxuXG4gICAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZC10aCBheGlzXG4gICAgICAgIHJlZHVjZU9wcyA9IGBcbiAgICAgICAgZm9yKGludCBqJHtrfSA9IDA7IGoke2t9IDwgJHtpbnB1dHNbMF0uZGltc1trXX07IGoke2t9KyspIHtcbiAgICAgICAgICBpbnB1dElkeFske2t9XSA9IGoke2t9O1xuICAgICAgICAgICR7cmVkdWNlT3BzfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHhDb3B5LnB1c2goYGlucHV0SWR4WyR7a31dID0gb3V0cHV0SWR4WyR7b3V0cHV0U2hhcGUubGVuZ3RofV07YCk7XG5cbiAgICAgICAgb3V0cHV0U2hhcGUucHVzaChpbnB1dHNbMF0uZGltc1trXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb1JhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGggfHwgMTtcblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske29SYW5rfV0pIHtcbiAgICAgICAgZmxvYXQgdmFsdWU7ICAgICAgICAgICAgICAgICAvLyBmaW5hbCByZXN1bHRcbiAgICAgICAgaW50IGlucHV0SWR4WyR7aVJhbmt9XTsgICAgICAvLyBhZGRyZXNzaW5nIGlucHV0IGRhdGFcbiAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxuICAgICAgICAke29wc1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICR7cmVkdWNlT3BzfVxuICAgICAgICAke29wc1syXX0gICAgICAgLy8gZmluYWwgY29tcHV0YXRpb24gZm9yIHJlZHVjZSBtZWFuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1gO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQpKSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xSZWR1Y2VTdW0gZXh0ZW5kcyBXZWJHTEdlbmVyaWNSZWR1Y2Uge1xuICBnZXRPcHMoX2lucHV0czogVGVuc29yW10pOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVkdWNlTWVhbiBleHRlbmRzIFdlYkdMR2VuZXJpY1JlZHVjZSB7XG4gIGdldE9wcyhpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdIHtcbiAgICBsZXQgc2l6ZSA9IDEuMDtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2l6ZSAqPSBpbnB1dHNbMF0uZGltc1trXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWyd2YWx1ZSA9IDAuMDsnLCAndmFsdWUgKz0gX0EoaW5wdXRJZHgpOycsIGB2YWx1ZSAvPSAke3NpemV9LjtgXTsgIC8vIGVuc3VyZSByZWFsIG51bWJlciB3aXRoIGAuYFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFJlZHVjZU1heCBleHRlbmRzIFdlYkdMR2VuZXJpY1JlZHVjZSB7XG4gIGdldE9wcyhpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dHNbMF0uZGltcy5sZW5ndGg7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRJZHhbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYCR7aWR4WmVyby5qb2luKCdcXG4nKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLCAndmFsdWUgPSBtYXgodmFsdWUsIF9BKGlucHV0SWR4KSk7JywgJyddO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFJlZHVjZU1pbiBleHRlbmRzIFdlYkdMR2VuZXJpY1JlZHVjZSB7XG4gIGdldE9wcyhpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dHNbMF0uZGltcy5sZW5ndGg7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRJZHhbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYCR7aWR4WmVyby5qb2luKCdcXG4nKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLCAndmFsdWUgPSBtaW4odmFsdWUsIF9BKGlucHV0SWR4KSk7JywgJyddO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFJlZHVjZVByb2QgZXh0ZW5kcyBXZWJHTEdlbmVyaWNSZWR1Y2Uge1xuICBnZXRPcHMoX2lucHV0czogVGVuc29yW10pOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsndmFsdWUgPSAxLjA7JywgJ3ZhbHVlICo9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVkdWNlTG9nU3VtIGV4dGVuZHMgV2ViR0xHZW5lcmljUmVkdWNlIHtcbiAgZ2V0T3BzKF9pbnB1dHM6IFRlbnNvcltdKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbJ3ZhbHVlID0gMC4wOycsICd2YWx1ZSArPSBfQShpbnB1dElkeCk7JywgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xSZWR1Y2VTdW1TcXVhcmUgZXh0ZW5kcyBXZWJHTEdlbmVyaWNSZWR1Y2Uge1xuICBnZXRPcHMoX2lucHV0czogVGVuc29yW10pOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsnZmxvYXQgdDsgdmFsdWUgPSAwLjA7JywgJ3QgPSBfQShpbnB1dElkeCk7IHZhbHVlICs9IHQgKiB0OycsICcnXTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7UmVzaGFwZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3Jlc2hhcGUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtUZXh0dXJlTGF5b3V0fSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge3VucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xSZXNoYXBlUGFja2VkIGV4dGVuZHMgUmVzaGFwZSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNpemUga2VybmVsIHNob3VsZCBoYXZlIGlucHV0IHRlbnNvciBjb3VudCB0byAyLicpO1xuICAgIH1cblxuICAgIC8vIEZvciBwYWNrZWQgcmVzaGFwZSwgd2UgbmVlZCB0byByZS1hcnJhbmdlIHRleGVsIGRhdGEgZm9yIG91dHB1dCBzaGFwZS5cbiAgICAvLyBPdXIgcGFjayBpcyBkZXNpZ25lZCB0byBwYWNrIGEgMngyIHRpbGUgaW4gbGFzdCBoIGFuZCB3IGRpbWVuc2lvbiwgc29cbiAgICAvLyBmb3IgdGhlIHJlc2hhcGVkIG5ldyB0ZW5zb3IsIHdlIGp1c3QgbmVlZCB0byByZS1hcnJhbmdlIHRoZSBsYXN0IGggYW5kXG4gICAgLy8gdyBkaW1lbnNpb24uIEZvciBhbnkgc2hhcGUgdGhhdCBpcyBub3QgaW4gM0QsIGkuZS4gW2JhdGNoLCBXLCBIXSwgd2VcbiAgICAvLyBmaXJzdCBjb252ZXJ0IGl0IHRvIDNEIGJ5IGNvbGxhcHNpbmcgb3RoZXIgZGltZW5zaW9uIHRvIGJhdGNoIGRpbSwgdGhlblxuICAgIC8vIHByb2Nlc3Mgd2l0aCB0aGUgbGFzdCB0d28gZGltZW5zaW9ucy5cbiAgICAvLyBOb3RlOiB3ZSBvbmx5IG5lZWQgdGhlIHNoYXBlIHRlbnNvciB0byBjYWxjdWxhdGUgb3V0cHV0IHNoYXBlLCBzbyB0aGVcbiAgICAvLyBjb250ZW50IGluIHNoYXBlIHRlbnNvciBpcyBuZXZlciB1cGxvYWRlZCB0byBHUFUuIEl0IGlzIGFsd2F5cyBrZXB0IGluIENQVS5cbiAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGUgYWxnb3JpdGhtIC0tIGluIHNvbWUgY2FzZXMsIGlmIHRoZSBsYXN0IHR3byBkaW1zIGFyZVxuICAgIC8vIHRoZSBzYW1lIGJldHdlZW4gaW5wdXQgc2hhcGUgYW5kIG91dHB1dCBzaGFwZSwgdGhlIHBhY2tlZCByZXNoYXBlIGNhbiBiZVxuICAgIC8vIHRyZWF0ZWQgYXMgbm8tb3AuXG4gICAgLy8gVE9ETzogdGhlIGltcGxlbWVudGF0aW9uIGlzIGEgYml0IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGUgZmFjdCB0ZW5zb3Igc2hhcGUgaXNcbiAgICAvLyBpbW11dGFibGUgb25jZSB0aGUgdGVuc29yIGlzIGNyZWF0ZWQsIHBsdXMgdGhlIHRlbnNvciBzaGFwZSBoYXMgYSAxLXRvLTFcbiAgICAvLyBtYXBwaW5nIHdpdGggdGV4dHVyZSBsYXlvdXQuIEluIHRoZSBmdXR1cmUsIHdlIG1heSBjb25zaWRlciByZWxheGluZyB0aGlzXG4gICAgLy8gYXNzdW1wdGlvbi5cblxuICAgIGNvbnN0IG9yaWdpbklucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICB0aGlzLmlucHV0U2hhcGUzRCA9IHByb2Nlc3NEaW1zM0QoaW5wdXRzWzBdLmRpbXMpO1xuICAgIGxldCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dDtcbiAgICBpbnB1dExheW91dCA9IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgNCwgdHJ1ZSwgb3JpZ2luSW5wdXRTaGFwZSwgdHJ1ZSk7XG4gICAgaWYgKG9yaWdpbklucHV0U2hhcGUubGVuZ3RoICE9PSAzKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbElucHV0TGF5b3V0ID0gaW5wdXRMYXlvdXQ7XG4gICAgICAvLyBpZiBvcmlnaW5TaGFwZSBpcyBub3QgYSAzRCBzaGFwZSwgY3JlYXRlIHRleHR1cmUgbGF5b3V0IGZyb20gdGhlIHByb2Nlc3NlZCBzaGFwZS5cbiAgICAgIGlucHV0TGF5b3V0ID0gaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKFxuICAgICAgICAgIHRoaXMuaW5wdXRTaGFwZTNELCA0LCB0aGlzLmlucHV0U2hhcGUzRCwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KTtcbiAgICAgIC8vIGlmIHRoZSBwcm9jZXNzZWQgaW5wdXQgc2hhcGUgcHJvZHVjZXMgdGV4dHVyZSBsYXlvdXQgZGlmZmVybnQgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIG9uZSwgdGhlIHJ1biBkYXRhIGhhcyB0byB1c2UgdGhlIHByb2Nlc3NlZCAoM0QpIGlucHV0IHNoYXBlIGxhdGVyLlxuICAgICAgdGhpcy5uZWVkU3F1ZWV6ZUlucHV0RGF0YSA9XG4gICAgICAgICAgKGlucHV0TGF5b3V0LmhlaWdodCAhPT0gb3JpZ2luYWxJbnB1dExheW91dC5oZWlnaHQpIHx8IChpbnB1dExheW91dC53aWR0aCAhPT0gb3JpZ2luYWxJbnB1dExheW91dC53aWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5jYWxjdWxhdGVSZXNoYXBlZERpbXMob3JpZ2luSW5wdXRTaGFwZSwgaW5wdXRzWzFdLmludGVnZXJEYXRhKTtcbiAgICBjb25zdCBzcXVlZXplZE91dHB1dFNoYXBlID0gcHJvY2Vzc0RpbXMzRCh0aGlzLm91dHB1dFNoYXBlKTtcblxuICAgIHRoaXMub3V0cHV0TGF5b3V0ID0gaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKFxuICAgICAgICBzcXVlZXplZE91dHB1dFNoYXBlLCA0LCBzcXVlZXplZE91dHB1dFNoYXBlLCB7aXNQYWNrZWQ6IHRydWUsIHJldmVyc2VXSDogdHJ1ZX0pO1xuXG4gICAgbGV0IG1haW5Mb29wID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGxldCBvdXRwdXRDb29yZHMgPSAnJztcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IHJjOyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KTsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnksIHJjLnorMSk7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnorMSk7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAke291dHB1dENvb3Jkc31cbiAgICAgICAgJHtpID4gMCA/ICdpZihvdXRwdXRDb29yZHMueSA8IHJvd3MgJiYgb3V0cHV0Q29vcmRzLnogPCBjb2xzKXsnIDogJyd9XG4gICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gZ2V0RmxhdHRlbmVkSW5kZXgob3V0cHV0Q29vcmRzKTtcblxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0dGVuZWRJbmRleCk7XG4gICAgICAgICAgdmVjMiBpbm5lckRpbXMgPSB2ZWMyKGZsb2F0KGlucHV0UkMueSksZmxvYXQoaW5wdXRSQy56KSk7XG5cbiAgICAgICAgICByZXN1bHRbJHtpfV0gPSBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlubmVyRGltcyk7XG5cbiAgICAgICAgJHtpID4gMCA/ICd9JyA6ICcnfVxuICAgICAgYDtcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtnZXRSZXNoYXBlZElucHV0Q29vcmRzKHRoaXMuaW5wdXRTaGFwZTNEKX1cbiAgICAgICR7Z2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc3F1ZWV6ZWRPdXRwdXRTaGFwZSl9XG4gICAgICAke3VucGFja0Zyb21DaGFubmVsKCl9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcblxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XG4gICAgICAgIGludCByb3dzID0gJHtzcXVlZXplZE91dHB1dFNoYXBlWzJdfTtcbiAgICAgICAgaW50IGNvbHMgPSAke3NxdWVlemVkT3V0cHV0U2hhcGVbMV19O1xuXG4gICAgICAgICR7bWFpbkxvb3B9XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ1dlYkdMUmVzaGFwZVBhY2tlZCcsXG4gICAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IHRoaXMub3V0cHV0TGF5b3V0LFxuICAgICAgc2FtcGxlcnM6IFsnQSddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgIGV4cGVjdFBhY2tlZElucHV0czogdHJ1ZSxcbiAgICAgIGV4cGVjdFBhY2tlZE91dHB1dHM6IHRydWUsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgbGV0IGlucHV0VERzOiBbVGV4dHVyZURhdGFdO1xuICAgIGNvbnN0IG9yaWdpbmFsSW5wdXRMYXlvdXQgPSBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDEsIGZhbHNlLCBbXSwgZmFsc2UpO1xuICAgIGNvbnN0IG9yaWdpbmFsSW5wdXRURCA9IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIG9yaWdpbmFsSW5wdXRMYXlvdXQsIGZhbHNlKTtcblxuICAgIGlmICh0aGlzLm5lZWRTcXVlZXplSW5wdXREYXRhKSB7XG4gICAgICBjb25zdCBzcXVlZXplZElucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0ge1xuICAgICAgICBjaGFubmVsczogMSxcbiAgICAgICAgaGVpZ2h0OiBvcmlnaW5hbElucHV0TGF5b3V0LmhlaWdodCxcbiAgICAgICAgd2lkdGg6IG9yaWdpbmFsSW5wdXRMYXlvdXQud2lkdGgsXG4gICAgICAgIHNoYXBlOiB0aGlzLmlucHV0U2hhcGUzRCxcbiAgICAgICAgc3RyaWRlczogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHRoaXMuaW5wdXRTaGFwZTNEKSxcbiAgICAgICAgdW5wYWNrZWRTaGFwZTogdGhpcy5pbnB1dFNoYXBlM0QsXG4gICAgICB9O1xuICAgICAgY29uc3Qgc3F1ZWV6ZWRJbnB1dFREID1cbiAgICAgICAgICBoYW5kbGVyLmNyZWF0ZVNoYXJlZFRleHR1cmVEYXRhKHNxdWVlemVkSW5wdXRMYXlvdXQsIGlucHV0c1swXS50eXBlLCBvcmlnaW5hbElucHV0VEQudGV4dHVyZSk7XG4gICAgICBpbnB1dFREcyA9IFtzcXVlZXplZElucHV0VERdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0VERzID0gW29yaWdpbmFsSW5wdXRURF07XG4gICAgfVxuICAgIGxldCBvdXRwdXRMYXlvdXQgPSB0aGlzLm91dHB1dExheW91dDtcbiAgICAvLyBVc2Ugb3JpZ2luYWwgb3V0cHV0IHNoYXBlIGZvciBydW5EYXRhIG91dHB1dCBsYXlvdXQuXG4gICAgb3V0cHV0TGF5b3V0LnNoYXBlID0gdGhpcy5vdXRwdXRTaGFwZTtcbiAgICBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IHRoaXMub3V0cHV0U2hhcGU7XG4gICAgaWYgKG91dHB1dExheW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvdXRwdXRMYXlvdXQgPSBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoXG4gICAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSwgNCwgdGhpcy5vdXRwdXRTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHJ1biBkYXRhIGZvciByZXNoYXBlLiBIZXJlLCB3ZSB1c2UgdGhlIG9yaWdpbmFsIGNhbGN1bGF0ZSBvdXRwdXRMYXlvdXQgdG8gY3JlYXRlIHRoZSByZWFsIG91dHB1dCBsYXlvdXQuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChvdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbiAgcHJvdGVjdGVkIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcHJpdmF0ZSBpbnB1dFNoYXBlM0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgcHJpdmF0ZSBuZWVkU3F1ZWV6ZUlucHV0RGF0YSA9IGZhbHNlO1xuICBwcml2YXRlIG91dHB1dExheW91dDogVGV4dHVyZUxheW91dDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0RpbXMzRChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgbnVtYmVyW118VGVuc29yLkludGVnZXJUeXBlKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbMSwgMSwgMV07XG4gIH1cbiAgLy8gVE9ETzogc3F1ZWV6ZSBvdGhlciBzaGFwZXMgdG8gMkQgY2FzZVxuICBjb25zdCBiYXRjaERpbXMgPSBzaGFwZS5sZW5ndGggPj0gMyA/IHNoYXBlLnNsaWNlKDAsIHNoYXBlLmxlbmd0aCAtIDIpIDogWzFdO1xuICBsZXQgYmF0Y2ggPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoRGltcy5sZW5ndGg7ICsraSkge1xuICAgIGJhdGNoICo9IGJhdGNoRGltc1tpXTtcbiAgfVxuICByZXR1cm4gW2JhdGNoLCBzaGFwZS5sZW5ndGggPiAxID8gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gOiAxLCBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXV07XG59XG5mdW5jdGlvbiBnZXRSZXNoYXBlZElucHV0Q29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBzdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlKTtcbiAgY29uc3QgY29vcmRzID0gWydiJywgJ3InLCAnYyddO1xuICBjb25zdCBpbmRleCA9ICdpbmRleCc7XG4gIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPSBzdHJpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNbaV19ID0gJHtpbmRleH0gLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNbaSArIDFdfSA9ICR7aW5kZXh9IC0gJHtjb29yZHNbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gIHJldHVybiBgXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XG4gICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XG4gICAgfVxuICBgO1xufVxuXG5mdW5jdGlvbiBnZXRGbGF0dGVuZWRJbmRleEZyb20zRChzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG5cbiAgcmV0dXJuIGBcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xuICAgIC8vIHJldmVyc2UgeSwgeiBvcmRlclxuICAgIHJldHVybiBjb29yZHMueCAqICR7c3RyaWRlc1swXX0gKyBjb29yZHMueiAqICR7c3RyaWRlc1sxXX0gKyBjb29yZHMueTtcbiAgfVxuYDtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Jlc2hhcGV9IGZyb20gJy4uLy4uLy4uL29wcy9yZXNoYXBlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7VGV4dHVyZUxheW91dH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRQYWNrZWRTaGFwZX0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtXZWJHTFJlc2hhcGVQYWNrZWR9IGZyb20gJy4vcmVzaGFwZS1wYWNrZWQnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xSZXNoYXBlIGV4dGVuZHMgUmVzaGFwZSB7XG4gIHBhY2tlZEltcGw6IFdlYkdMUmVzaGFwZVBhY2tlZDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhY2tlZEltcGwgPSBuZXcgV2ViR0xSZXNoYXBlUGFja2VkKCk7XG4gIH1cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLnBhY2tlZEltcGwsIGlucHV0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc2hhcGVkRGltcyA9IFNoYXBlVXRpbC5jYWxjdWxhdGVSZXNoYXBlZERpbXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gICAgICBjb25zdCByZXNoYXBlZFRlbnNvciA9IHJlc2hhcGUoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCByZXNoYXBlZERpbXMpO1xuICAgICAgcmV0dXJuIFtyZXNoYXBlZFRlbnNvcl07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNoYXBlKFxuICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gIGNvbnN0IGlucHV0VEQgPSBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXQpO1xuICBsZXQgcGFja2VkU2hhcGUgPSByZXNoYXBlZERpbXM7XG4gIGlmIChpbnB1dFRELmNoYW5uZWxzID09PSA0KSB7XG4gICAgcGFja2VkU2hhcGUgPSBnZXRQYWNrZWRTaGFwZShyZXNoYXBlZERpbXMpO1xuICB9XG4gIGNvbnN0IG5ld1RleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSB7XG4gICAgY2hhbm5lbHM6IGlucHV0VEQuY2hhbm5lbHMsXG4gICAgaGVpZ2h0OiBpbnB1dFRELmhlaWdodCxcbiAgICB3aWR0aDogaW5wdXRURC53aWR0aCxcbiAgICAvLyBoYW5kbGUgcmVzaGFwaW5nIGludG8gc2NhbGFyIFRlbnNvcnNcbiAgICBzaGFwZTogcGFja2VkU2hhcGUubGVuZ3RoICE9PSAwID8gcGFja2VkU2hhcGUgOiBbMV0sXG4gICAgc3RyaWRlczogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHBhY2tlZFNoYXBlKSxcbiAgICB1bnBhY2tlZFNoYXBlOiByZXNoYXBlZERpbXMsXG4gIH07XG5cbiAgY29uc3QgbmV3VGV4dHVyZURhdGEgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVNoYXJlZFRleHR1cmVEYXRhKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gIHJldHVybiBuZXdUZXh0dXJlRGF0YS50ZW5zb3I7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtVcHNhbXBsZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3Vwc2FtcGxlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsLCBHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtBcnRpZmFjdCwgUHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFRleHR1cmVMYXlvdXQsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHt1bnBhY2tGcm9tQ2hhbm5lbH0gZnJvbSAnLi9wYWNraW5nLXV0aWxzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVzaXplUGFja2VkIGV4dGVuZHMgVXBzYW1wbGUgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaW5wdXRMYXlvdXQgPSBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDQsIHRydWUsIGlucHV0c1swXS5kaW1zLCB0cnVlKTtcblxuICAgIGNvbnN0IFtyb2ksIHNjYWxlcywgb3V0cHV0U2hhcGVdID0gdGhpcy5wcmVwYXJlSW5wdXRzKGlucHV0cyk7XG5cbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPVxuICAgICAgICBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUsIDQsIG91dHB1dFNoYXBlLCB7aXNQYWNrZWQ6IHRydWUsIHJldmVyc2VXSDogdHJ1ZX0pO1xuXG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiBjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyhcbiAgICAgICAgZ2xzbCwgdGhpcy5tb2RlLCBpbnB1dExheW91dCwgb3V0cHV0TGF5b3V0LCBzY2FsZXMsIHJvaSwgdGhpcy51c2VFeHRyYXBvbGF0aW9uLCB0aGlzLmV4dHJhcG9sYXRpb25WYWx1ZSxcbiAgICAgICAgdGhpcy5jdWJpY0NvZWZmaWNpZW50QSwgdGhpcy5leGNsdWRlT3V0c2lkZSwgdGhpcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSk7XG4gIH1cblxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURCA9XG4gICAgICAgIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgMSwgZmFsc2UsIFtdLCB0cnVlKSk7XG4gICAgY29uc3Qgb3V0cHV0VEQgPSBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VEQudGVuc29yLnR5cGUpO1xuICAgIHJldHVybiB7aW5wdXRUZXh0dXJlRGF0YXM6IFtpbnB1dFREXSwgb3V0cHV0VGV4dHVyZURhdGE6IG91dHB1dFRELCB1bmlmb3JtRGF0YToge319O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFydGlmYWN0czogQXJ0aWZhY3RbXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzaXplUHJvZ3JhbUluZm8oXG4gICAgZ2xzbDogR2xzbCwgbW9kZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCwgb3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHJvaTogcmVhZG9ubHkgbnVtYmVyW10sIGV4dHJhcG9sYXRpb25FbmFibGVkOiBib29sZWFuLCBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlciwgY3ViaWNDb2VmZmljaWVudEE6IG51bWJlcixcbiAgICBleGNsdWRlT3V0c2lkZTogYm9vbGVhbiwgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6IHN0cmluZyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgaXNTYW1lID0gc2NhbGVzLmV2ZXJ5KHMgPT4gcyA9PT0gMSkgJiYgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgIT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnO1xuICBpZiAoaXNTYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogW2lucHV0TGF5b3V0XSxcbiAgICAgIG91dHB1dExheW91dCxcbiAgICAgIHNhbXBsZXJzOiBbJ1gnXSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBzaGFkZXJTb3VyY2U6IGB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IHYgPSAke2dsc2wudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xuICAgICAgJHtnbHNsLm91dHB1dH0gPSB2O1xuICAgIH1gXG4gICAgfTtcbiAgfVxuICBjb25zdCBvdXRwdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICBjb25zdCBkaW0gPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGlmIChkaW0gPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBiZSBhdCBsZWFzdCAyLCBidXQgZ290ICR7ZGltfWApO1xuICB9XG5cbiAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbZGltIC0gMl07XG4gIGNvbnN0IG91dHB1dFdpZHRoID0gb3V0cHV0U2hhcGVbZGltIC0gMV07XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gIGlmIChkaW0gIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgZGltZW5zaW9uIHNob3VsZCBtYXRjaCBpbnB1dCAke2lucHV0U2hhcGUubGVuZ3RofSwgYnV0IGdvdCAke2RpbX1gKTtcbiAgfVxuICBjb25zdCBpbnB1dEhlaWdodCA9IGlucHV0U2hhcGVbZGltIC0gMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dFNoYXBlW2RpbSAtIDFdO1xuXG4gIGNvbnN0IHNjYWxlc0hlaWdodCA9IHNjYWxlc1tkaW0gLSAyXTtcbiAgY29uc3Qgc2NhbGVzV2lkdGggPSBzY2FsZXNbZGltIC0gMV07XG5cbiAgbGV0IGdldFNvdXJjZUZyYWNJbmRleCA9ICcnO1xuXG4gIGlmIChtb2RlICE9PSAnbGluZWFyJykge1xuICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgbW9kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IG1vZGU6ICcke21vZGV9J2ApO1xuICB9XG4gIHN3aXRjaCAoY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpIHtcbiAgICBjYXNlICdhc3ltbWV0cmljJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKXtcbiAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xuICAgICAgICB9XG4gICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2hhbGZfcGl4ZWwnOlxuICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpe1xuICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcbiAgICAgICAgfVxuICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKXtcbiAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7b3V0cHV0V2lkdGh9LjAgLSAxLjAsICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wLCAke291dHB1dFdpZHRofS4wIC0gMS4wLCAke1xuICAgICAgICAgIG91dHB1dEhlaWdodH0uMCAtIDEuMCk7XG4gICAgICAgICAgdmVjNCBvcmlnaW5hbCA9IHZlYzQoJHtpbnB1dFdpZHRofS4wIC0gMS4wLCAke2lucHV0SGVpZ2h0fS4wIC0gMS4wLCAke2lucHV0V2lkdGh9LjAgLSAxLjAsICR7XG4gICAgICAgICAgaW5wdXRIZWlnaHR9LjAgLSAxLjApO1xuICAgICAgICAgIHZlYzQgbmV3X3NjYWxlID0gb3JpZ2luYWwgLyByZXNpemVkO1xuICAgICAgICAgIHJldHVybiB2ZWM0KGNvb3JkcykgKiBuZXdfc2NhbGU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVE9ETzpzdXBwb3J0aW5nIG90aGVyIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogJyR7Y29vcmRpbmF0ZVRyYW5zZm9ybU1vZGV9J2ApO1xuICB9XG5cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShkaW0pO1xuICBjb25zdCB1bnBhY2tDaGFubmVsID0gdW5wYWNrRnJvbUNoYW5uZWwoKTtcbiAgY29uc3Qgc2hhZGVyID0gYFxuICAgICAgICBjb25zdCB2ZWMyIGlucHV0V0ggPSB2ZWMyKCR7aW5wdXRIZWlnaHR9LjAsICR7aW5wdXRXaWR0aH0uMCk7XG4gICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNCgke3NjYWxlc0hlaWdodH0uMCwgJHtzY2FsZXNXaWR0aH0uMCwgJHtzY2FsZXNIZWlnaHR9LjAsICR7c2NhbGVzV2lkdGh9LjApO1xuICAgICAgICAke3VucGFja0NoYW5uZWx9XG4gICAgICAgICR7Z2V0U291cmNlRnJhY0luZGV4fVxuICAgICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IHgxMCwgaW50IHIsIGludCBjLCBpbnQgZCkge1xuICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoeDEwLCByLCBjLCBkKSwgdmVjMihjLCBkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICR7Y29vcmRzRGF0YVR5cGV9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgICBpbnQgYmF0Y2ggPSByY1swXTtcbiAgICAgICAgICBpbnQgZGVwdGggPSByY1sxXTtcblxuICAgICAgICAgIC8vIHJldHJpZXZlIHRoZSA0IGNvb3JkaW5hdGVzIHRoYXQgaXMgdXNlZCBpbiB0aGUgNCBwYWNrZWQgb3V0cHV0IHZhbHVlcy5cbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBpdmVjNChyYy53eiwgcmMudyArIDEsIHJjLnogKyAxKTtcblxuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgc291cmNlIGluZGV4IGluIGZyYWN0aW9uXG4gICAgICAgICAgdmVjNCBzb3VyY2VGcmFjID0gZ2V0U291cmNlRnJhY0luZGV4KGNvb3Jkcyk7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZCBvZiB0aGUgNCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHBhY2tlZCBpbnRvIG9uZSB0ZXhlbC5cbiAgICAgICAgICBpdmVjNCB4MDAgPSBpdmVjNChtYXgoc291cmNlRnJhYy54eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54eSkpKTtcbiAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcbiAgICAgICAgICBpdmVjNCB4MTAgPSBpdmVjNChtYXgoc291cmNlRnJhYy56eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56eSkpKTtcbiAgICAgICAgICBpdmVjNCB4MTEgPSBpdmVjNChtYXgoc291cmNlRnJhYy56dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56dykpKTtcblxuICAgICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IHJjLncgPCAke291dHB1dEhlaWdodCAtIDF9O1xuICAgICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IHJjLnogPCAke291dHB1dFdpZHRoIC0gMX07XG5cbiAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXG4gICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLnkpLFxuICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEueSlcbiAgICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLnkpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XG4gICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEueSkgOiAwLjApO1xuXG4gICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtcmlnaHQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXG4gICAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXG4gICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxuICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudylcbiAgICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueCwgeDEwLncpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XG4gICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEudykgOiAwLjApO1xuXG4gICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyBib3R0b20tbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICB2ZWM0IGJvdHRvbUxlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC55KSxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLnkpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KVxuICAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLnkpIDogMC4wKTtcblxuICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgIHZlYzQgYm90dG9tUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLnosIHgwMC53KSxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLncpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC53KVxuICAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLncpIDogMC4wKTtcblxuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJwb2xhdGlvbiBmcmFjdGlvbiBvbiB1IGFuZCB2IGRpcmVjdGlvblxuICAgICAgICAgIHZlYzQgZnJhYyA9IHZlYzQoc291cmNlRnJhYykgLSBmbG9vcihzb3VyY2VGcmFjKTtcbiAgICAgICAgICB2ZWM0IGNsYW1wRnJhYyA9IGNsYW1wKGZyYWMsIHZlYzQoMC4wKSwgdmVjNCgxLjApKTtcblxuICAgICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XG4gICAgICAgICAgdmVjNCBib3R0b20gPSBtaXgoYm90dG9tTGVmdCwgYm90dG9tUmlnaHQsIGNsYW1wRnJhYy55d3l3KTtcbiAgICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBjbGFtcEZyYWMueHh6eik7XG5cbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICBgO1xuICByZXR1cm4ge1xuICAgIGlucHV0TGF5b3V0czogW2lucHV0TGF5b3V0XSxcbiAgICBvdXRwdXRMYXlvdXQsXG4gICAgc2FtcGxlcnM6IFsnQSddLFxuICAgIHNoYWRlclNvdXJjZTogc2hhZGVyLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgZXhwZWN0UGFja2VkSW5wdXRzOiB0cnVlLFxuICAgIGV4cGVjdFBhY2tlZE91dHB1dHM6IHRydWUsXG4gIH07XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3NoYXBlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuXG5leHBvcnQgY2xhc3MgV2ViR0xTaGFwZSBleHRlbmRzIFNoYXBlIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gW25ldyBUZW5zb3IoW2lucHV0c1swXS5kaW1zLmxlbmd0aF0sICdpbnQzMicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuZXcgSW50MzJBcnJheShpbnB1dHNbMF0uZGltcykpXTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2xpY2UsIFNsaWNlVjEwfSBmcm9tICcuLi8uLi8uLi9vcHMvc2xpY2UnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTbGljZSBleHRlbmRzIFNsaWNlIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cblxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgcmV0dXJuIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0c1swXSwgdGhpcy5zdGFydHMsIHRoaXMuZW5kcywgdGhpcy5heGVzKTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlciwgcHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMU2xpY2VWMTAgZXh0ZW5kcyBTbGljZVYxMCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG5cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGlmICghaGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzFdLmRhdGFJZCkgfHwgIWhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpIHx8XG4gICAgICAgIChpbnB1dHMubGVuZ3RoID49IDQgJiYgIWhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1szXS5kYXRhSWQpKSB8fFxuICAgICAgICAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmICFoYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbNF0uZGF0YUlkKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmIGlucHV0c1s0XS5pbnRlZ2VyRGF0YS5zb21lKChpOiBudW1iZXIpID0+IGkgIT09IDEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub24tMSBzdGVwcyBpcyBub3Qgc3VwcG9ydGVkIGZvciBTbGljZScpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydHMgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gICAgY29uc3QgZW5kcyA9IEFycmF5LmZyb20oaW5wdXRzWzJdLmludGVnZXJEYXRhKTtcbiAgICBjb25zdCBheGVzID0gaW5wdXRzLmxlbmd0aCA+PSA0ID8gQXJyYXkuZnJvbShpbnB1dHNbM10uaW50ZWdlckRhdGEpIDogW107XG5cbiAgICByZXR1cm4gY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXRzWzBdLCBzdGFydHMsIGVuZHMsIGF4ZXMpO1xuICB9XG5cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIHJldHVybiBjcmVhdGVSdW5EYXRhKGhhbmRsZXIsIHByb2dyYW1JbmZvLCBpbnB1dHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1JbmZvKFxuICAgIGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgeDogVGVuc29yLCBzdGFydHM6IHJlYWRvbmx5IG51bWJlcltdLCBlbmRzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBheGVzOiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvIHtcbiAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgYXhlcyA9IHguZGltcy5zbGljZSgwKS5tYXAoKHZhbCwgaW5kKSA9PiBpbmQpO1xuICB9XG4gIGF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhheGVzLCB4LmRpbXMubGVuZ3RoKTtcbiAgc3RhcnRzID0gc3RhcnRzLm1hcCgoc3RhcnQsIGluZCkgPT4ge1xuICAgIGlmIChzdGFydCA+IHguZGltc1theGVzW2luZF1dIC0gMSkge1xuICAgICAgcmV0dXJuIHguZGltc1theGVzW2luZF1dO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoc3RhcnQsIHguZGltc1theGVzW2luZF1dKTtcbiAgfSk7XG4gIGVuZHMgPSBlbmRzLm1hcCgoZW5kLCBpbmQpID0+IHtcbiAgICBpZiAoZW5kID4geC5kaW1zW2F4ZXNbaW5kXV0gLSAxKSB7XG4gICAgICByZXR1cm4geC5kaW1zW2F4ZXNbaW5kXV07XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhlbmQsIHguZGltc1theGVzW2luZF1dKTtcbiAgfSk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4LmRpbXMuc2xpY2UoKTtcblxuICBjb25zdCBzbGljZU9wczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0U2hhcGVbYXhlc1tpXV0gPSBlbmRzW2ldIC0gc3RhcnRzW2ldO1xuICAgIGlmIChzdGFydHNbaV0gPiAwKSB7XG4gICAgICBzbGljZU9wcy5wdXNoKGBvdXRwdXRJZHhbJHtheGVzW2ldfV0gKz0gJHtzdGFydHNbaV19O2ApO1xuICAgIH0gIC8vIGVsc2UgeyBzbGljZU9wcy5wdXNoKGBvdXRwdXRJZHhbJHtheGVzW2ldfV0gKz0gMDtgKTsgfVxuICB9XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgICR7c2xpY2VPcHMuam9pbignXFxuICAgICAgJyl9XG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgaW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoeCldLFxuICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICBzYW1wbGVyczogWydBJ10sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gIGNvbnN0IGlucHV0VERzID0gW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1swXSldO1xuICByZXR1cm4ge1xuICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgdW5pZm9ybURhdGE6IHt9XG4gIH07XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTb2Z0bWF4fSBmcm9tICcuLi8uLi8uLi9vcHMvc29mdG1heCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlTGF5b3V0fSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFNvZnRtYXggZXh0ZW5kcyBTb2Z0bWF4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGlmICghdGhpcy5hcnRpZmFjdHMpIHtcbiAgICAgIHRoaXMuYXJ0aWZhY3RzID0gW107XG4gICAgICBjb25zdCBwcm9ncmFtSW5mb3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1JbmZvcyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICAgICAgcHJvZ3JhbUluZm9zLmZvckVhY2goKHBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGFydGlmYWN0ID0gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHBpKTtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMucHVzaChhcnRpZmFjdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBydW5EYXRhcyA9IHRoaXMuY3JlYXRlUnVuRGF0YXMoaW5mZXJlbmNlSGFuZGxlciwgdGhpcy5hcnRpZmFjdHMubWFwKGEgPT4gYS5wcm9ncmFtSW5mbyksIGlucHV0cyk7XG4gICAgcnVuRGF0YXMuZm9yRWFjaCgodiwgaSkgPT4gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLmFydGlmYWN0c1tpXSwgdikpO1xuICAgIC8vIHJldHVybiBvbmx5IHRoZSBsYXN0IG91dHB1dFxuICAgIHJldHVybiBbcnVuRGF0YXNbcnVuRGF0YXMubGVuZ3RoIC0gMV0ub3V0cHV0VGV4dHVyZURhdGEudGVuc29yXTtcbiAgfVxuICBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8oXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIE46IG51bWJlciwgRDogbnVtYmVyLFxuICAgICAgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3c6IFRleHR1cmVMYXlvdXQsIG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93OiBUZXh0dXJlTGF5b3V0KTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgaW5wdXRMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IGlucHV0TGF5b3V0LmhlaWdodDtcblxuICAgIGlmIChOIDwgMSB8fCBEIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgIH1cblxuICAgIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5zaGFwZS5sZW5ndGggIT09IDEgfHwgbm9ybWFsaXphdGlvblBlckxvZ2ljYWxSb3cuc2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbmFsaXR5IG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgMScpO1xuICAgIH1cblxuICAgIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5zaGFwZVswXSAhPT0gTiB8fCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvdy5zaGFwZVswXSAhPT0gTikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcblxuICAgICAgLy8gZ2V0IG9mZnNldCBvZiBjdXJyZW50IGxvZ2ljYWwgdGVuc29yIGluZGV4IGZyb20gdGhlIDItRCB0ZXh0dXJlIGNvb3JkaW5hdGVzIChUZXhDb29yZHMpXG4gICAgICBpbnQgb2Zmc2V0ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pO1xuXG4gICAgICAvL2RldGVybWluZSB0aGUgbG9naWNhbCByb3cgZm9yIHRoaXMgaW5kZXhcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcbiAgICAgIGxvZ2ljYWxfcm93X2luZGV4WzBdID0gb2Zmc2V0IC8gJHtEfTtcblxuICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSBfTm9ybShsb2dpY2FsX3Jvd19pbmRleCk7XG5cbiAgICAgIC8vIGF2b2lkIHBvc3NpYmxlIGRpdmlzaW9uIGJ5IDBcbiAgICAgIC8vIGlmIG5vcm1fZmFjb3IgaXMgMCwgYWxsIGVsZW1lbnRzIGFyZSB6ZXJvXG4gICAgICAvLyBpZiBzbywgcmV0dXJuIDBcbiAgICAgIGlmKG5vcm1fZmFjdG9yID09IDAuMClcbiAgICAgICAgcmV0dXJuIDAuMDtcblxuICAgICAgcmV0dXJuIGV4cChfQShpbmRpY2VzKSAtIF9NYXgobG9naWNhbF9yb3dfaW5kZXgpKSAvIG5vcm1fZmFjdG9yO1xuICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dCwgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3csIG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93XSxcbiAgICAgIG91dHB1dExheW91dDogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnLCAnTWF4JywgJ05vcm0nXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIG5hbWU6ICdTb2Z0TWF4JyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgbm9ybWFsaXphdGlvbiBmYWN0b3IgZm9yIGVhY2ggb2YgdGhlICdOJyByb3dzXG4gICAqL1xuICBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCB4OiBUZW5zb3IsIE46IG51bWJlciwgRDogbnVtYmVyLCBtYXhFbGVtZW50UGVyTG9naWNhbFJvdzogVGV4dHVyZUxheW91dCxcbiAgICAgIG91dHB1dFNoYXBlOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCB4bGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHguZGltcy5zbGljZSgpKTtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHRleHR1cmVXaWR0aCA9IHhsYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IHhsYXlvdXQuaGVpZ2h0O1xuXG4gICAgaWYgKE4gPCAxIHx8IEQgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dFNoYXBlWzBdICE9PSBOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93LnNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgICB9XG5cbiAgICBpZiAobWF4RWxlbWVudFBlckxvZ2ljYWxSb3cuc2hhcGVbMF0gIT09IE4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuXG4gICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7RH07XG5cbiAgICAgIGZsb2F0IG5vcm1fZmFjdG9yID0gMC4wO1xuICAgICAgZmxvYXQgbWF4ID0gX01heChpbmRpY2VzKTtcbiAgICAgIGZvcihpbnQgaT0wOyBpPCR7RH07ICsraSlcbiAgICAgIHtcbiAgICAgICAgbm9ybV9mYWN0b3IgKz0gZXhwKGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLCAke1xuICAgICAgICB0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KSkpIC0gbWF4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vcm1fZmFjdG9yO1xuICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFt4bGF5b3V0LCBtYXhFbGVtZW50UGVyTG9naWNhbFJvd10sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJywgJ01heCddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgbmFtZTogJ0NvbXB1dFNjYWxlJyxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIG1heGltdW0gdmFsdWUgb2YgZWFjaCBvZiB0aGUgJ04nIHJvd3NcbiAgICovXG4gIGNyZWF0ZUNvbXB1dGVNYXhQcm9ncmFtSW5mbyhcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgeDogVGVuc29yLCBOOiBudW1iZXIsIEQ6IG51bWJlciwgb3V0cHV0U2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IHhsYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoeC5kaW1zLnNsaWNlKCkpO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgdGV4dHVyZVdpZHRoID0geGxheW91dC53aWR0aDtcbiAgICBjb25zdCB0ZXh0dXJlSGVpZ2h0ID0geGxheW91dC5oZWlnaHQ7XG5cbiAgICBpZiAoTiA8IDEgfHwgRCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIDEnKTtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0U2hhcGVbMF0gIT09IE4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhcGUgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG5cbiAgICAgICAgICBpbnQgbG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ID0gaW5kaWNlc1swXSAqICR7RH07XG5cbiAgICAgICAgICBmbG9hdCBtYXggPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0LCAke3RleHR1cmVXaWR0aH0sICR7XG4gICAgICAgIHRleHR1cmVIZWlnaHR9ICkpKTtcbiAgICAgICAgICBmb3IoaW50IGk9MTsgaTwke0R9OyArK2kpXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmxvYXQgY3VycmVudCA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLCAke1xuICAgICAgICB0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KSkpO1xuICAgICAgICAgICAgaWYoY3VycmVudCA+IG1heClcbiAgICAgICAgICAgICAgbWF4ID0gY3VycmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbeGxheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBuYW1lOiAnQ29tcHV0ZU1heCcsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mb3MoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm9bXSB7XG4gICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHRoaXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IE4gPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuICAgIGNvbnN0IEQgPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgYXhpcyk7XG4gICAgY29uc3QgY29tcHV0ZU1heFByb2dyYW1JbmZvID0gdGhpcy5jcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBOLCBELCBbTl0pO1xuICAgIGNvbnN0IGNvbXB1dGVTY2FsZVByb2dyYW1JbmZvID1cbiAgICAgICAgdGhpcy5jcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgTiwgRCwgY29tcHV0ZU1heFByb2dyYW1JbmZvLm91dHB1dExheW91dCwgW05dKTtcbiAgICBjb25zdCBzb2Z0TWF4UHJvZ3JhbUluZm8gPSB0aGlzLmNyZWF0ZVNvZnRNYXhQcm9ncmFtSW5mbyhcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBOLCBELCBjb21wdXRlTWF4UHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBjb21wdXRlU2NhbGVQcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQpO1xuXG4gICAgY29uc3QgcHJvZ3JhbUluZm9zOiBQcm9ncmFtSW5mb1tdID0gW2NvbXB1dGVNYXhQcm9ncmFtSW5mbywgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8sIHNvZnRNYXhQcm9ncmFtSW5mb107XG4gICAgcmV0dXJuIHByb2dyYW1JbmZvcztcbiAgfVxuICBjcmVhdGVSdW5EYXRhcyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvczogUHJvZ3JhbUluZm9bXSwgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGFbXSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZTtcbiAgICBjb25zdCBpbnB1dFREID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm9zWzBdLmlucHV0TGF5b3V0c1swXSk7XG4gICAgY29uc3QgcnVuRGF0YXM6IFJ1bkRhdGFbXSA9IFtdO1xuICAgIHJ1bkRhdGFzLnB1c2goe1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IFtpbnB1dFREXSxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mb3NbMF0ub3V0cHV0TGF5b3V0LCBkYXRhVHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb2dyYW1JbmZvcy5sZW5ndGg7ICsraSkge1xuICAgICAgcnVuRGF0YXMucHVzaCh7XG4gICAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBbLi4ucnVuRGF0YXNbaSAtIDFdLmlucHV0VGV4dHVyZURhdGFzLCBydW5EYXRhc1tpIC0gMV0ub3V0cHV0VGV4dHVyZURhdGFdLFxuICAgICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm9zW2ldLm91dHB1dExheW91dCwgZGF0YVR5cGUpLFxuICAgICAgICB1bmlmb3JtRGF0YToge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcnVuRGF0YXM7XG4gIH1cbiAgcHJvdGVjdGVkIGFydGlmYWN0czogQXJ0aWZhY3RbXTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1NwbGl0fSBmcm9tICcuLi8uLi8uLi9vcHMvc3BsaXQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbCwgU3BsaXRVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUnVuRGF0YX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTcGxpdCBleHRlbmRzIFNwbGl0IHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBpZiAoIXRoaXMuYXJ0aWZhY3RzKSB7XG4gICAgICB0aGlzLmFydGlmYWN0cyA9IFtdO1xuICAgICAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHRoaXMuYXhpcywgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5nZXRQcm9ncmFtQ291bnQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBheGlzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBheGlzLCBpKTtcbiAgICAgICAgY29uc3QgYXJ0aWZhY3QgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8pO1xuICAgICAgICB0aGlzLmFydGlmYWN0cy5wdXNoKGFydGlmYWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0czogVGVuc29yW10gPSBbXTtcblxuICAgIHRoaXMuYXJ0aWZhY3RzLmZvckVhY2goYXJ0aWZhY3QgPT4ge1xuICAgICAgY29uc3QgcnVuZGF0YSA9IHRoaXMuY3JlYXRlUnVuRGF0YShpbmZlcmVuY2VIYW5kbGVyLCBhcnRpZmFjdC5wcm9ncmFtSW5mbywgaW5wdXRzKTtcbiAgICAgIGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5ydW4oYXJ0aWZhY3QsIHJ1bmRhdGEpO1xuICAgICAgcmVzdWx0cy5wdXNoKHJ1bmRhdGEub3V0cHV0VGV4dHVyZURhdGEudGVuc29yKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBnZXRQcm9ncmFtQ291bnQoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IFssIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4aXMsIHRoaXMuc3BsaXQsIHRoaXMubnVtT3V0cHV0cyk7XG4gICAgcmV0dXJuIG9mZnNldHMubGVuZ3RoO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvciwgYXhpczogbnVtYmVyLCBpbmRleDogbnVtYmVyKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IFtzaGFwZXMsIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXQuZGltcywgYXhpcywgdGhpcy5zcGxpdCwgdGhpcy5udW1PdXRwdXRzKTtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2luZGV4XTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHNoYXBlc1tpbmRleF07XG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGluZGljZXNbJHtheGlzfV0gKz0gJHtvZmZzZXR9O1xuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XG4gICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ1dlYkdMU3BsaXQnLFxuICAgICAgaW5wdXRMYXlvdXRzOiBbaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXQpXSxcbiAgICAgIG91dHB1dExheW91dDogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBhcnRpZmFjdHM6IEFydGlmYWN0W107XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTcXVlZXplfSBmcm9tICcuLi8uLi8uLi9vcHMvc3F1ZWV6ZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vcmVzaGFwZSc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFNxdWVlemUgZXh0ZW5kcyBTcXVlZXplIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gU2hhcGVVdGlsLnNxdWVlemVTaGFwZShpbnB1dHNbMF0uZGltcywgdGhpcy5heGVzKTtcbiAgICByZXR1cm4gW3Jlc2hhcGUoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBvdXRwdXREaW1zKV07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1N1bX0gZnJvbSAnLi4vLi4vLi4vb3BzL3N1bSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMU3VtIGV4dGVuZHMgU3VtIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qgc3VtTGluZSA9IGlucHV0cy5tYXAoKHYsIGkpID0+IGAke2dsc2wudGV4dHVyZTJEfShYJHtpfSxUZXhDb29yZHMpYCkuam9pbignICsgJyk7XG4gICAgY29uc3Qgc2FtcGxlcnMgPSBpbnB1dHMubWFwKCh2LCBpKSA9PiBgWCR7aX1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnMsXG4gICAgICBzaGFkZXJTb3VyY2U6IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke3N1bUxpbmV9O1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1gLFxuICAgICAgaGFzTWFpbjogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUaWxlfSBmcm9tICcuLi8uLi8uLi9vcHMvdGlsZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFRpbGUgZXh0ZW5kcyBUaWxlIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cblxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGgpOyAgLy8gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcblxuICAgIGNvbnN0IHRpbGVPcHM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaV0gKiBpbnB1dHNbMV0ubnVtYmVyRGF0YVtpXTtcbiAgICAgIHRpbGVPcHMucHVzaChgaW5wdXRJZHhbJHtpfV0gPSBpbnQobW9kKGZsb2F0KG91dHB1dElkeFske2l9XSksICR7aW5wdXRTaGFwZVtpXX0uKSk7YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICBpbnQgaW5wdXRJZHhbJHtyYW5rfV07XG4gICAgICAke3RpbGVPcHMuam9pbignXFxuJyl9XG4gICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xuICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSksXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RyYW5zcG9zZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3RyYW5zcG9zZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7RnVuY3Rpb25UeXBlLCBHbHNsUG9zaXRpb25hbEZ1bmN0aW9ufSBmcm9tICcuLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFRyYW5zcG9zZSBleHRlbmRzIFRyYW5zcG9zZSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGdldE91dHB1dFNoYXBlKGlucHV0U2hhcGVzOiBBcnJheTxyZWFkb25seSBudW1iZXJbXT4pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcGVybSA9IHRoaXMuZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGVzWzBdKTtcbiAgICByZXR1cm4gU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShpbnB1dFNoYXBlc1swXSwgcGVybSk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlucHV0U2hhcGVzID0gaW5wdXRzLm1hcCh0ID0+IHQuZGltcy5zbGljZSgpKTtcbiAgICBjb25zdCBwZXJtID0gdGhpcy5nZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZXNbMF0pO1xuICAgIGNvbnN0IHVucGFja2VkT3V0cHV0U2hhcGUgPSB0aGlzLmdldE91dHB1dFNoYXBlKGlucHV0U2hhcGVzKTtcbiAgICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgIC8vIEEgZGltcz1bJHtpbnB1dHNbMF0uZGltcy50b1N0cmluZygpfV1cbiAgICAvLyBvdXQgRGltcz1bJHt1bnBhY2tlZE91dHB1dFNoYXBlLnRvU3RyaW5nKCl9XVxuICAgIC8vIGJhc2VkIG9uIHBlcm09WyR7cGVybS50b1N0cmluZygpfV1cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke3RoaXMuZ2V0UGVybUZ1bmN0aW9uQm9keSgncGVybScsIHBlcm0sIHJhbmspfVxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgYVske3Jhbmt9XTtcbiAgICAgICAgcGVybShhLCBpbmRpY2VzKTtcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xuICAgICAgfWA7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHVucGFja2VkT3V0cHV0U2hhcGUsIDEsIHVucGFja2VkT3V0cHV0U2hhcGUpO1xuICAgIHJldHVybiB7aW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKV0sIG91dHB1dExheW91dCwgc2FtcGxlcnM6IFsnQSddLCBzaGFkZXJTb3VyY2V9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxuICBnZXRQb3NpdGlvbmFsRnVuY3Rpb24oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dFNoYXBlOiBudW1iZXJbXSwgbmFtZT86IHN0cmluZyk6IEdsc2xQb3NpdGlvbmFsRnVuY3Rpb24ge1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gdGhpcy5nZXRPdXRwdXRTaGFwZShbaW5wdXRTaGFwZV0pO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgbmFtZSA9ICdwZXJtJztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBib2R5OiB0aGlzLmdldFBlcm1GdW5jdGlvbkJvZHkobmFtZSwgdGhpcy5nZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZSksIG91dHB1dFNoYXBlLmxlbmd0aCksXG4gICAgICB0eXBlOiBGdW5jdGlvblR5cGUuUG9zaXRpb25hbCxcbiAgICAgIGlucHV0U2hhcGUsXG4gICAgICBvdXRwdXRTaGFwZVxuICAgIH07XG4gIH1cbiAgcHJvdGVjdGVkIGdldEFkanVzdGVkUGVybShpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBsZXQgcGVybSA9IHRoaXMucGVybTtcbiAgICBpZiAocGVybSAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgIHBlcm0gPSBbLi4uKGlucHV0U2hhcGUua2V5cygpKV0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGVybTtcbiAgfVxuICBwcm90ZWN0ZWQgZ2V0UGVybUZ1bmN0aW9uQm9keShuYW1lOiBzdHJpbmcsIHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJldmVyc2VGdW5jID0gW107XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChgdm9pZCAke25hbWV9KG91dCBpbnQgYVske3Jhbmt9XSwgaW50IHNyY1ske3Jhbmt9XSkge2ApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICByZXZlcnNlRnVuYy5wdXNoKGBcXHRhWyR7cGVybVtpXX1dPXNyY1ske2l9XTtgKTtcbiAgICB9XG4gICAgcmV2ZXJzZUZ1bmMucHVzaCgnXFx0fScpO1xuICAgIHJldHVybiByZXZlcnNlRnVuYy5qb2luKCdcXG4nKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7VGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXR9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMVWludDhFbmNvZGUge1xuICBydW5JbnRlcm5hbChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZXh0dXJlRGF0YSk6IFRleHR1cmVEYXRhIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneS5jb21wdXRlVGV4dHVyZVdIKGlucHV0LnNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGNoYW5uZWxzOiA0LFxuICAgICAgc2hhcGU6IG91dHB1dFNoYXBlLFxuICAgICAgc3RyaWRlczogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKG91dHB1dFNoYXBlKSxcbiAgICAgIHVucGFja2VkU2hhcGU6IG91dHB1dFNoYXBlXG4gICAgfTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgc3BlY2lhbCBzY3JpcHQuIFVzZSBncmFwaCB0cmFuc2Zvcm1lciBpbnN0ZWFkLlxuICAgIC8qKlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtY29yZS9ibG9iL21hc3Rlci9zcmMva2VybmVscy93ZWJnbC9lbmNvZGVfZmxvYXRfZ3B1LnRzXG4gICAgICovXG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcbiAgICAgIGNvbnN0IGZsb2F0IEZMT0FUX01JTiA9IDEuMTc1NDk0MzVlLTM4O1xuXG4gICAgICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xuICAgICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGhpZ2hwIHZlYzQgZW5jb2RlQXNVaW50OChoaWdocCBmbG9hdCB2KSB7XG4gICAgICAgIGlmIChpc05hTih2KSkge1xuICAgICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgIH1cblxuICAgICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcblxuICAgICAgICBpZihhdiA8IEZMT0FUX01JTikge1xuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XG4gICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcbiAgICAgICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XG4gICAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XG4gICAgICAgIH1cblxuICAgICAgICBoaWdocCB2ZWM0IGMgPSB2ZWM0KDAsMCwwLDApO1xuXG4gICAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XG4gICAgICAgIGhpZ2hwIGZsb2F0IG0gPSBleHAyKGZyYWN0KGxvZzIoYXYpKSkgLSAxLjA7XG5cbiAgICAgICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XG4gICAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xuICAgICAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xuICAgICAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xuICAgICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XG5cbiAgICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XG4gICAgICAgIGNbM10gPSBmbG9vcihlYmlhcyAvIDIuMCk7XG4gICAgICAgIGViaWFzIC09IGNbM10gKiAyLjA7XG4gICAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XG5cbiAgICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XG5cbiAgICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcbiAgICAgIH1cblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7Z2xzbC50ZXh0dXJlMkR9KFgsVGV4Q29vcmRzKS5yO1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xuICAgICAgfWA7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPVxuICAgICAgICB7bmFtZTogJ1VpbnQ4RW5jb2RlJywgaW5wdXRMYXlvdXRzOiBbaW5wdXRdLCBvdXRwdXRMYXlvdXQsIHNhbXBsZXJzOiBbJ1gnXSwgc2hhZGVyU291cmNlLCBoYXNNYWluOiB0cnVlfTtcbiAgICBjb25zdCBhcnRpZmFjdCA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtSW5mbyk7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmdldEVuY29kZXIoJ2J5dGUnLCA0KTtcbiAgICBjb25zdCB0ZXh0dXJlID1cbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHQsIGVuY29kZXIpO1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEYXRhID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVTaGFyZWRUZXh0dXJlRGF0YShvdXRwdXRMYXlvdXQsICd1aW50OCcsIHRleHR1cmUpO1xuICAgIGNvbnN0IHJ1bkRhdGEgPSB7aW5wdXRUZXh0dXJlRGF0YXM6IFtpbnB1dF0sIG91dHB1dFRleHR1cmVEYXRhLCB1bmlmb3JtRGF0YToge319O1xuXG4gICAgaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bihhcnRpZmFjdCwgcnVuRGF0YSk7XG4gICAgcmV0dXJuIHJ1bkRhdGEub3V0cHV0VGV4dHVyZURhdGE7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1VuYXJ5T3B9IGZyb20gJy4uLy4uLy4uL29wcy91bmFyeS1vcCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7RnVuY3Rpb25UeXBlLCBHbHNsVmFsdWVGdW5jdGlvbn0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVuYXJ5T3AgZXh0ZW5kcyBVbmFyeU9wIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB0eXBlQ29uc3RyYWludDogcmVhZG9ubHkgVGVuc29yLkRhdGFUeXBlW10sIHByb3RlY3RlZCBnbHNsRnVuYzogR2xzbFZhbHVlRnVuY3Rpb24pIHtcbiAgICBzdXBlcih0eXBlQ29uc3RyYWludCk7XG4gIH1cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGlucHV0TGF5b3V0ID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgP1xuICAgICAgICBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDQsIHRydWUsIGlucHV0c1swXS5kaW1zLCB0cnVlKSA6XG4gICAgICAgIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSk7XG5cbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSBoYW5kbGVyLnNlc3Npb24ucGFjayA/XG4gICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSwgNCwgb3V0cHV0U2hhcGUsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSkgOlxuICAgICAgICBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke3RoaXMuZ2xzbEZ1bmMuYm9keX1cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCB2ID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgICAgdiA9ICR7dGhpcy5nbHNsRnVuYy5uYW1lfSh2KTtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2O1xuICAgICAgfVxuICAgICAgYDtcblxuICAgIGlmIChoYW5kbGVyLnNlc3Npb24ucGFjaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRMYXlvdXRzOiBbaW5wdXRMYXlvdXRdLFxuICAgICAgICBvdXRwdXRMYXlvdXQsXG4gICAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRydWUsXG4gICAgICAgIGV4cGVjdFBhY2tlZE91dHB1dHM6IHRydWVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7aW5wdXRMYXlvdXRzOiBbaW5wdXRMYXlvdXRdLCBvdXRwdXRMYXlvdXQsIHNhbXBsZXJzOiBbJ0EnXSwgc2hhZGVyU291cmNlLCBoYXNNYWluOiB0cnVlfTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VEQgPSBoYW5kbGVyLnNlc3Npb24ucGFjayA/XG4gICAgICAgIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgMSwgZmFsc2UsIFtdLCB0cnVlKSkgOlxuICAgICAgICBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IFtpbnB1dFREXSxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VEQudGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFicygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhYnMnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQWNvcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhY29zJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFzaW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYXNpbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBdGFuKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2F0YW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQ2VpbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdjZWlsJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbENvcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdjb3MnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRXhwKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2V4cCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xGbG9vcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdmbG9vcicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xJZGVudGl0eSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnaW5kZW50aXR5Xyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSkge1xuICAgIHJldHVybiBhO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTG9nKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2xvZycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xOZWcoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ25lZ18nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEpIHtcbiAgICByZXR1cm4gLWE7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdikge1xuICAgIHJldHVybiAtdjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTm90KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdub3RfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGZsb2F0KCAhIGJvb2woYSkgKTtcbiAgfVxuICBib29sICR7bmFtZX0oYm9vbCBhKSB7XG4gICAgcmV0dXJuICFhO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdmVjNCghYm9vbCh2LngpLCAhYm9vbCh2LnkpLCAhYm9vbCh2LnopLCAhYm9vbCh2LncpKTtcbiAgfVxuICBidmVjNCAke25hbWV9KGJ2ZWM0IHYpIHtcbiAgICByZXR1cm4gYnZlYzQoIXYueCwgIXYueSwgIXYueiwgIXYudyk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNpbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdzaW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncmVsdV8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEpIHtcbiAgICByZXR1cm4gbWF4KCBhLCAwLjAgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2KSB7XG4gICAgcmV0dXJuIG1heCggdiwgMC4wICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNpZ21vaWQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3NpZ21vaWRfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhKSB7XG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLWEpKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2KSB7XG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLXYpKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsU3FydCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdzcXJ0Jyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFRhbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCd0YW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsVGFuaCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAndGFuaF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEpIHtcbiAgICBhID0gY2xhbXAoYSwgLTEwLiwgMTAuKTtcbiAgICBhID0gZXhwKDIuKmEpO1xuICAgIHJldHVybiAoYSAtIDEuKSAvIChhICsgMS4pO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYpIHtcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcbiAgICB2ID0gZXhwKDIuKnYpO1xuICAgIHJldHVybiAodiAtIDEuKSAvICh2ICsgMS4pO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZnVuY3Rpb24gZ2xzbEJ1aWx0aW5VbmFyeShmbmFtZTogc3RyaW5nKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gYCR7Zm5hbWV9X2A7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSkge1xuICAgIHJldHVybiAke2ZuYW1lfShhKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2KSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KHYpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRDb29yZHNEYXRhVHlwZX0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtnZXRDaGFubmVscywgdW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVucGFjayBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrIGtlcm5lbCBzaG91bGQgaGF2ZSBpbnB1dCB0ZW5zb3IgY291bnQgdG8gMS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dFRleHR1cmUgPSBoYW5kbGVyLmdldFRleHR1cmVEYXRhKGlucHV0c1swXS5kYXRhSWQsIHRydWUpO1xuICAgIGlmICghaW5wdXRUZXh0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhY2tlZCBpbnB1dCB0ZXh0dXJlIG11c3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dExheW91dCA9IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgNCwgdHJ1ZSk7XG4gICAgY29uc3QgaXNTY2FsYXIgPSAoaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGggPT09IDApO1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dFRleHR1cmUudW5wYWNrZWRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBvdXRwdXRMYXlvdXQuc2hhcGU7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICAgIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgcmFuayk7XG4gICAgY29uc3QgaW5uZXJEaW1zID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICAgIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gICAgY29uc3Qgc291cmNlQ29vcmRzID0gaXNTY2FsYXIgPyAnJyA6IGdldFNvdXJjZUNvb3JkcyhyYW5rLCBjaGFubmVscyk7XG4gICAgY29uc3QgY29vcmRzID0gcmFuayA8PSAxID8gJ3JjJyA6IGB2ZWMyKCR7aW5uZXJEaW1zLmpvaW4oJywnKX0pYDtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAvLyBTYW1wbGUgdGhlIHRleHR1cmUgd2l0aCB0aGUgY29vcmRzIHRvIGdldCB0aGUgcmdiYSBjaGFubmVsIHZhbHVlLlxuICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoJHtzb3VyY2VDb29yZHN9KTtcblxuICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7Y29vcmRzfSksIDAsIDAsIDApO1xuICAgIH1cbiAgYDtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnV2ViR0xVbnBhY2snLFxuICAgICAgaW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdLCA0LCB0cnVlLCBpbnB1dHNbMF0uZGltcywgdHJ1ZSldLFxuICAgICAgb3V0cHV0TGF5b3V0LFxuICAgICAgc2FtcGxlcnM6IFsnQSddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgIGV4cGVjdFBhY2tlZElucHV0czogdHJ1ZSxcbiAgICAgIGV4cGVjdFBhY2tlZE91dHB1dHM6IGZhbHNlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1swXSwgdHJ1ZSldO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMocmFuazogbnVtYmVyLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuICdyYyc7XG4gIH1cblxuICBsZXQgY29vcmRzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29vcmRzICs9IGRpbXNbaV07XG4gICAgaWYgKGkgPCByYW5rIC0gMSkge1xuICAgICAgY29vcmRzICs9ICcsJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Vuc3F1ZWV6ZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3Vuc3F1ZWV6ZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vcmVzaGFwZSc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVuc3F1ZWV6ZSBleHRlbmRzIFVuc3F1ZWV6ZSB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFNoYXBlVXRpbC51bnNxdWVlemVTaGFwZShpbnB1dHNbMF0uZGltcywgdGhpcy5heGVzKTtcbiAgICByZXR1cm4gW3Jlc2hhcGUoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBvdXRwdXREaW1zKV07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Vwc2FtcGxlfSBmcm9tICcuLi8uLi8uLi9vcHMvdXBzYW1wbGUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVwc2FtcGxlIGV4dGVuZHMgVXBzYW1wbGUgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaW5wdXRMYXlvdXQgPSBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0pO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMubWFwKChkaW0sIGkpID0+IE1hdGguZmxvb3IoZGltICogdGhpcy5zY2FsZXNbaV0pKTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGRpbSA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcblxuICAgIGNvbnN0IG91dHB1dFBpdGNoZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pO1xuICAgIGNvbnN0IGlucHV0UGl0Y2hlcyA9IG5ldyBBcnJheTxudW1iZXI+KGRpbSk7XG4gICAgbGV0IHByZWNhbGN1bGF0ZWRQaXRjaGVzID0gYFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7ZGltfV07XG4gICAgICBpbnQgaW5wdXRfcGl0Y2hlc1ske2RpbX1dO1xuICAgICAgYDtcbiAgICBmb3IgKGxldCBkID0gZGltIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIG91dHB1dFBpdGNoZXNbZF0gPSAoZCA9PT0gZGltIC0gMSkgPyAxIDogb3V0cHV0UGl0Y2hlc1tkICsgMV0gKiBvdXRwdXRTaGFwZVtkICsgMV07XG4gICAgICBpbnB1dFBpdGNoZXNbZF0gPSAoZCA9PT0gZGltIC0gMSkgPyAxIDogaW5wdXRQaXRjaGVzW2QgKyAxXSAqIGlucHV0c1swXS5kaW1zW2QgKyAxXTtcblxuICAgICAgcHJlY2FsY3VsYXRlZFBpdGNoZXMgKz0gYFxuICAgICAgb3V0cHV0X3BpdGNoZXNbJHtkfV0gPSAke291dHB1dFBpdGNoZXNbZF19O1xuICAgICAgaW5wdXRfcGl0Y2hlc1ske2R9XSA9ICR7aW5wdXRQaXRjaGVzW2RdfTtcbiAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IGdldElucHV0RmxvYXRGdW5jdGlvbiA9IGBcbiAgICBmbG9hdCBnZXRJbnB1dEZsb2F0KGludCBpbmRleCkge1xuICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbmRleCwgJHtpbnB1dExheW91dC53aWR0aH0sICR7aW5wdXRMYXlvdXQuaGVpZ2h0fSk7XG4gICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShYLCBjb29yZHMpKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYDtcblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IHRoaXMubW9kZSA9PT0gJ25lYXJlc3QnID9cbiAgICAgICAgLy8gbmVhcmVzdFxuICAgICAgICBgXG4gICAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtkaW19XSkge1xuICAgICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke291dHB1dExheW91dC53aWR0aH0sICR7b3V0cHV0TGF5b3V0LmhlaWdodH0pO1xuXG4gICAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgICAgaW50IGQsIG07XG4gICAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7ZGltfTsgKytkaW0pIHtcbiAgICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcbiAgICAgICAgICBtID0gb3V0cHV0X2luZGV4IC0gZCAqIG91dHB1dF9waXRjaGVzW2RpbV07XG4gICAgICAgICAgb3V0cHV0X2luZGV4ID0gbTtcblxuICAgICAgICAgIGlmIChzY2FsZXNbZGltXSAhPSAxICYmIGQgPiAwKSB7XG4gICAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XG4gICAgICAgICAgICBtID0gZCAtIGQyICogc2NhbGVzW2RpbV07XG4gICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0X2luZGV4ICs9IGlucHV0X3BpdGNoZXNbZGltXSAqIGQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICB9YCA6XG4gICAgICAgIGRpbSA9PT0gNCA/XG4gICAgICAgIC8vIGJpbGluZWFyIDREXG4gICAgICAgICAgICBgXG4gICAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbNF0pIHtcbiAgICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRMYXlvdXQud2lkdGh9LCAke291dHB1dExheW91dC5oZWlnaHR9KTtcblxuICAgICAgICAke3ByZWNhbGN1bGF0ZWRQaXRjaGVzfVxuXG4gICAgICAgIGludCBtO1xuICAgICAgICBpbnQgaW5kZXhfb2ZfZGltMCwgaW5kZXhfb2ZfZGltMSwgaW5kZXhfb2ZfZGltMiwgaW5kZXhfb2ZfZGltMztcbiAgICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgICBpbmRleF9vZl9kaW0xID0gbSAvIG91dHB1dF9waXRjaGVzWzFdO1xuICAgICAgICBtID0gbSAtIGluZGV4X29mX2RpbTEgKiBvdXRwdXRfcGl0Y2hlc1sxXTtcbiAgICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcbiAgICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0yICogb3V0cHV0X3BpdGNoZXNbMl07XG4gICAgICAgIGluZGV4X29mX2RpbTMgPSBtO1xuXG4gICAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0yLCBpbmRleF9vZl9pbnB1dF9kaW0zLCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xuICAgICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTIgLSBpbmRleF9vZl9pbnB1dF9kaW0yICogc2NhbGVzWzJdO1xuICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0zID0gaW5kZXhfb2ZfZGltMyAvIHNjYWxlc1szXTtcbiAgICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcblxuICAgICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XG5cbiAgICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgICAgYm9vbCBlbmRfb2ZfZGltMiA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMiA9PSAoJHtpbnB1dHNbMF0uZGltc1syXX0gLSAxKSkge1xuICAgICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMlxuICAgICAgICAgIHgwMSA9IHgwMDtcbiAgICAgICAgICBlbmRfb2ZfZGltMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTMgPT0gKGlucHV0X3BpdGNoZXNbMl0gLSAxKSkge1xuICAgICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gM1xuICAgICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgICB4MTEgPSB4MDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICAgIHgxMSA9IGVuZF9vZl9kaW0yID8geDEwIDogZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xuICAgICAgICBmbG9hdCB5MSA9IHgxMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MTEgLSB4MTApIC8gZmxvYXQoc2NhbGVzWzJdKTtcbiAgICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzNdKTtcbiAgICAgIH1gIDpcbiAgICAgICAgICAgIC8vIGJpbGluZWFyIDJEXG4gICAgICAgICAgICBgXG4gICAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbMl0pIHtcbiAgICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRMYXlvdXQud2lkdGh9LCAke291dHB1dExheW91dC5oZWlnaHR9KTtcblxuICAgICAgICAke3ByZWNhbGN1bGF0ZWRQaXRjaGVzfVxuXG4gICAgICAgIGludCBtO1xuICAgICAgICBpbnQgaW5kZXhfb2ZfZGltMCwgaW5kZXhfb2ZfZGltMTtcbiAgICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgICBpbmRleF9vZl9kaW0xID0gbTtcblxuICAgICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMCwgaW5kZXhfb2ZfaW5wdXRfZGltMSwgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcbiAgICAgICAgeV9vZmZzZXQgPSBpbmRleF9vZl9kaW0wIC0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIHNjYWxlc1swXTtcbiAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMSA9IGluZGV4X29mX2RpbTEgLyBzY2FsZXNbMV07XG4gICAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XG5cbiAgICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XG5cbiAgICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgICAgYm9vbCBlbmRfb2ZfZGltMCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMCA9PSAoJHtpbnB1dHNbMF0uZGltc1swXX0gLSAxKSkge1xuICAgICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMFxuICAgICAgICAgIHgwMSA9IHgwMDtcbiAgICAgICAgICBlbmRfb2ZfZGltMCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTEgPT0gKGlucHV0X3BpdGNoZXNbMF0gLSAxKSkge1xuICAgICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMVxuICAgICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgICB4MTEgPSB4MDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICAgIHgxMSA9IGVuZF9vZl9kaW0wID8geDEwIDogZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0gKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xuICAgICAgICBmbG9hdCB5MSA9IHgxMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MTEgLSB4MTApIC8gZmxvYXQoc2NhbGVzWzBdKTtcbiAgICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzFdKTtcbiAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQsXG4gICAgICBzYW1wbGVyczogWydYJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICB2YXJpYWJsZXM6IFt7bmFtZTogJ3NjYWxlcycsIHR5cGU6ICdpbnQnLCBhcnJheUxlbmd0aDogdGhpcy5zY2FsZXMubGVuZ3RofV1cbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHtzY2FsZXM6IHRoaXMuc2NhbGVzLm1hcCh4ID0+IE1hdGguY2VpbCh4KSl9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0IHtMb2dnZXIsIFByb2ZpbGVyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuaW1wb3J0IHtHbHNsUHJlcHJvY2Vzc29yfSBmcm9tICcuL2dsc2wtcHJlcHJvY2Vzc29yJztcbmltcG9ydCB7Z2V0VmVydGV4U2hhZGVyU291cmNlfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7VGV4dHVyZUxheW91dFN0cmF0ZWd5fSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlRGF0YSwgVW5pZm9ybURhdGEsIFZhcmlhYmxlSW5mb30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1dlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC1jb250ZXh0JztcblxuLyoqXG4gKiBQcm9ncmFtTWFuYWdlciBpcyB0aGUgbWFpbiBjbGFzcyBiZWhpbmQgcnVubmluZyBjb21wdXRhdGlvbnNcbiAqIEl0IGJ1aWxkcyBQcm9ncmFtSW5mbydzIGludG8gQXJ0aWZhY3RzXG4gKiBJdCBjb21waWxlcyBnaXZlbiBQcm9ncmFtSW5mbydzIGludG8gV2ViR0wgUHJvcmFtcyAoY2FjaGVkIGFzIEFydGlmYWN0cylcbiAqIFVzZXMgdGhlIGFydGlmYWN0IHRvIHJ1biB0aGUgY29tcHV0YXRpb24gYnkgY2FsbGluZyBEcmF3IG9uXG4gKiB0aGUgV2ViR0wgZHJhd2luZyBidWZmZXJcbiAqIFByb2dyYW1NYW5hZ2VyIGF1dG9tYXRpY2FsbHkgbWFwcyAoYmluZHMpIGlucHV0IHZhcmlhYmxlcyB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBMb2NhdGlvbidzIGluIHRoZSBiaW5hcnkgcHJvZ3JhbVxuICovXG5leHBvcnQgY2xhc3MgUHJvZ3JhbU1hbmFnZXIge1xuICByZXBvOiBNYXA8dW5rbm93biwgQXJ0aWZhY3Q+OyAgLy8gdGhpcyBzaG91bGQgYmUgcGVyLXNlc3Npb24gb2JqZWN0XG4gIHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXI7XG4gIGF0dHJpYnV0ZXNCb3VuZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+LCBwdWJsaWMgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsXG4gICAgICBwdWJsaWMgdGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kpIHtcbiAgICB0aGlzLnJlcG8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzQm91bmQgPSBmYWxzZTtcbiAgfVxuICBnZXRBcnRpZmFjdChrZXk6IHVua25vd24pOiBBcnRpZmFjdHx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihidWlsZEFydGlmYWN0OiBBcnRpZmFjdCwgcnVuRGF0YTogUnVuRGF0YSk6IHZvaWQge1xuICAgIHRoaXMucHJvZmlsZXIuZXZlbnQoJ29wJywgYFByb2dyYW1NYW5hZ2VyLnJ1biAke2J1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSA/PyAndW5rbm93biBrZXJuZWwnfWAsICgpID0+IHtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgICBjb25zdCBwcm9ncmFtID0gYnVpbGRBcnRpZmFjdC5wcm9ncmFtO1xuICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYmluZE91dHB1dChydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhKTtcbiAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZXNCb3VuZCkge1xuICAgICAgICAgIHRoaXMuYmluZEF0dHJpYnV0ZXMoYnVpbGRBcnRpZmFjdC5hdHRyaWJMb2NhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZFVuaWZvcm1zKGJ1aWxkQXJ0aWZhY3QudW5pZm9ybUxvY2F0aW9ucywgcnVuRGF0YS51bmlmb3JtRGF0YSwgcnVuRGF0YS5pbnB1dFRleHR1cmVEYXRhcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKCdQcm9ncmFtTWFuYWdlcicsIGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8uc2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdHbENvbnRleHQuZHJhdygpJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmRvRHJhdyhidWlsZEFydGlmYWN0LCBydW5EYXRhKTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMuZ2xDb250ZXh0KTtcbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZlcnRleFNoYWRlcikge1xuICAgICAgdGhpcy5nbENvbnRleHQuZGVsZXRlU2hhZGVyKHRoaXMudmVydGV4U2hhZGVyKTtcbiAgICB9XG4gICAgdGhpcy5yZXBvLmZvckVhY2goYSA9PiB0aGlzLmdsQ29udGV4dC5kZWxldGVQcm9ncmFtKGEucHJvZ3JhbSkpO1xuICB9XG4gIGJ1aWxkKHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbyk6IEFydGlmYWN0IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdQcm9ncmFtTWFuYWdlci5idWlsZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXByb2Nlc3NvciA9IG5ldyBHbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LCBwcm9ncmFtSW5mbyk7XG4gICAgICBjb25zdCBmcmFnU2NyaXB0ID0gcHJlcHJvY2Vzc29yLnByZXByb2Nlc3MoKTtcbiAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmNvbXBpbGUoZnJhZ1NjcmlwdCk7XG4gICAgICBjb25zdCBhcnRpZmFjdCA9IHtcbiAgICAgICAgcHJvZ3JhbUluZm8sXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhcbiAgICAgICAgICAgIHByb2dyYW0sIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLCBwcmVwcm9jZXNzb3IuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLFxuICAgICAgICBhdHRyaWJMb2NhdGlvbnM6IHRoaXMuZ2V0QXR0cmliTG9jYXRpb25zKHByb2dyYW0pXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGFydGlmYWN0O1xuICAgIH0pO1xuICB9XG4gIHByb3RlY3RlZCBkb0RyYXcoYXJ0aWZhY3Q6IEFydGlmYWN0LCBydW5EYXRhOiBSdW5EYXRhKTogdm9pZCB7XG4gICAgaWYgKHJ1bkRhdGEuZHJhdykge1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ1Byb2dyYW1NYW5hZ2VyJywgJ0N1c3RvbSBkcmF3IGZ1bmN0aW9uJyk7XG4gICAgICBydW5EYXRhLmRyYXcodGhpcy5nbENvbnRleHQsIGFydGlmYWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbENvbnRleHQuZHJhdygpO1xuICAgIH1cbiAgfVxuICBwcm90ZWN0ZWQgY29tcGlsZShmcmFnU2hhZGVyU2NyaXB0OiBzdHJpbmcpOiBXZWJHTFByb2dyYW0ge1xuICAgIGlmICghdGhpcy52ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdQcm9yZ3JhbU1hbmFnZXInLCAnQ29tcGlsaW5nIGFuZCBjYWNoaW5nIFZlcnRleCBzaGFkZXIgZm9yIHRoZSBmaXJzdCB0aW1lJyk7XG4gICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXJTY3JpcHQgPSBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UodGhpcy5nbENvbnRleHQudmVyc2lvbik7XG4gICAgICB0aGlzLnZlcnRleFNoYWRlciA9IHRoaXMuZ2xDb250ZXh0LmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyU2NyaXB0LCB0aGlzLmdsQ29udGV4dC5nbC5WRVJURVhfU0hBREVSKTtcbiAgICB9XG4gICAgaWYgKGVudi5kZWJ1Zykge1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ1Byb3JncmFtTWFuYWdlcicsIGBGcmFnU2hhZGVyOlxuJHtmcmFnU2hhZGVyU2NyaXB0fVxuYCk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdTaGFkZXIgPSB0aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKGZyYWdTaGFkZXJTY3JpcHQsIHRoaXMuZ2xDb250ZXh0LmdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsIGZyYWdTaGFkZXIpO1xuICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcihmcmFnU2hhZGVyKTtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuICBiaW5kT3V0cHV0KHRkOiBUZXh0dXJlRGF0YSk6IHZvaWQge1xuICAgIGNvbnN0IHdpZHRoID0gdGQud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGQuaGVpZ2h0O1xuICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAnUHJvcmdyYW1NYW5hZ2VyJyxcbiAgICAgICAgYEJpbmRpbmcgb3V0cHV0IHRleHR1cmUgdG8gRnJhbWVidWZmZXI6IHcvaD0ke3dpZHRofS8ke2hlaWdodH0sIHNoYXBlPSR7dGQuc2hhcGV9LCB0eXBlPSR7dGQudGVuc29yLnR5cGV9YCk7XG4gICAgdGhpcy5nbENvbnRleHQuYXR0YWNoRnJhbWVidWZmZXIodGQudGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgYmluZEF0dHJpYnV0ZXMoYXR0cmliTG9jYXRpb25zOiBBcnRpZmFjdC5BdHRyaWJMb2NhdGlvbnMpOiB2b2lkIHtcbiAgICBjb25zdCBwb3NpdGlvbkhhbmRsZSA9IGF0dHJpYkxvY2F0aW9ucy5wb3NpdGlvbjtcbiAgICBjb25zdCB0ZXh0dXJlQ29vcmRIYW5kbGUgPSBhdHRyaWJMb2NhdGlvbnMudGV4dHVyZUNvb3JkO1xuICAgIHRoaXMuZ2xDb250ZXh0LnNldFZlcnRleEF0dHJpYnV0ZXMocG9zaXRpb25IYW5kbGUsIHRleHR1cmVDb29yZEhhbmRsZSk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzQm91bmQgPSB0cnVlO1xuICB9XG4gIGJpbmRVbmlmb3Jtcyh1bmlmb3JtTG9jYXRpb25zOiBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zLCB1bmlmb3JtRGF0YTogVW5pZm9ybURhdGEsIHRleHR1cmVzOiBUZXh0dXJlRGF0YVtdKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICBsZXQgdGV4dHVyZVBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IHtuYW1lLCB0eXBlLCBsb2NhdGlvbiwgYXJyYXlMZW5ndGh9IG9mIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzYW1wbGVyMkQnOlxuICAgICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZXNbdGV4dHVyZVBvc2l0aW9uXSwgbG9jYXRpb24sIHRleHR1cmVQb3NpdGlvbik7XG4gICAgICAgICAgdGV4dHVyZVBvc2l0aW9uKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHVuaWZvcm1EYXRhW25hbWVdIGFzIG51bWJlcltdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB1bmlmb3JtRGF0YVtuYW1lXSBhcyBudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHVuaWZvcm1EYXRhW25hbWVdIGFzIG51bWJlcltdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bmlmb3JtRGF0YVtuYW1lXSBhcyBudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gbm90IGltcGxlbWVudGVkOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRUZXh0dXJlKHRkOiBUZXh0dXJlRGF0YSwgdW5pZm9ybUhhbmRsZTogV2ViR0xVbmlmb3JtTG9jYXRpb24sIHBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0ZC50ZXh0dXJlLCBwb3NpdGlvbiwgdW5pZm9ybUhhbmRsZSk7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb25zKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IEFydGlmYWN0LkF0dHJpYkxvY2F0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpLFxuICAgICAgdGV4dHVyZUNvb3JkOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd0ZXh0dXJlQ29vcmQnKVxuICAgIH07XG4gIH1cbiAgZ2V0VW5pZm9ybUxvY2F0aW9ucyhwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHNhbXBsZXJzPzogc3RyaW5nW10sIHZhcmlhYmxlcz86IFZhcmlhYmxlSW5mb1tdKTpcbiAgICAgIEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMge1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnM6IEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMgPSBbXTtcbiAgICBpZiAoc2FtcGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBvZiBzYW1wbGVycykge1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zLnB1c2goe25hbWU6IHNhbXBsZXIsIHR5cGU6ICdzYW1wbGVyMkQnLCBsb2NhdGlvbjogdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgc2FtcGxlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucy5wdXNoKHsuLi52YXJpYWJsZSwgbG9jYXRpb246IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHZhcmlhYmxlLm5hbWUpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTG9jYXRpb25zO1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtOiBXZWJHTFByb2dyYW0sIG5hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gJHtuYW1lfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiByZWZlcmVuY2U7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb246IG51bWJlciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVMb2NhdGlvbjtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7T3BTZXQsIHJlc29sdmVPcGVyYXRvcn0gZnJvbSAnLi4vLi4vb3BzZXQnO1xuaW1wb3J0IHtTZXNzaW9ufSBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ2wnO1xuXG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1dFQkdMX09QX1JFU09MVkVfUlVMRVN9IGZyb20gJy4vb3AtcmVzb2x2ZS1ydWxlcyc7XG5pbXBvcnQge1Byb2dyYW1NYW5hZ2VyfSBmcm9tICcuL3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge1ByZWZlckxvZ2ljYWxTdHJhdGVneSwgVGV4dHVyZUxheW91dFN0cmF0ZWd5fSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZU1hbmFnZXJ9IGZyb20gJy4vdGV4dHVyZS1tYW5hZ2VyJztcbmltcG9ydCB7VGV4dHVyZURhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTZXNzaW9uSGFuZGxlciBpbXBsZW1lbnRzIFNlc3Npb25IYW5kbGVyIHtcbiAgcHJvZ3JhbU1hbmFnZXI6IFByb2dyYW1NYW5hZ2VyO1xuICB0ZXh0dXJlTWFuYWdlcjogVGV4dHVyZU1hbmFnZXI7XG4gIGxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3k7XG4gIHBhY2tlZFRleHR1cmVEYXRhQ2FjaGU6IE1hcDxUZW5zb3IuSWQsIFRleHR1cmVEYXRhPjtcbiAgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHBhY2sydW5wYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICB1bnBhY2sycGFja01hcDogTWFwPFRlbnNvci5JZCwgVGVuc29yLklkPjtcbiAgaW5pdGlhbGl6ZXJzOiBTZXQ8VGVuc29yLklkPjtcbiAgcGFja09wQ2FjaGU6IE1hcDxzdHJpbmcsIFdlYkdMT3BlcmF0b3I+O1xuICB1bnBhY2tPcENhY2hlOiBNYXA8c3RyaW5nLCBXZWJHTE9wZXJhdG9yPjtcbiAgcGFjaz86IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhY2tlbmQ6IFdlYkdMQmFja2VuZCwgcHVibGljIHJlYWRvbmx5IGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dCkge1xuICAgIHRoaXMubGF5b3V0U3RyYXRlZ3kgPSBuZXcgUHJlZmVyTG9naWNhbFN0cmF0ZWd5KGJhY2tlbmQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlciwgYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3kpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoXG4gICAgICAgIGJhY2tlbmQuZ2xDb250ZXh0LCB0aGlzLmxheW91dFN0cmF0ZWd5LCB0aGlzLmNvbnRleHQucHJvZmlsZXIsXG4gICAgICAgIHtyZXVzZVRleHR1cmVzOiBiYWNrZW5kLnRleHR1cmVDYWNoZU1vZGUgPT09ICdmdWxsJ30pO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhY2tPcENhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrT3BDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhY2sgPSBiYWNrZW5kLnBhY2s7XG4gICAgdGhpcy5wYWNrMnVucGFja01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFjazJwYWNrTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gbmV3IFdlYkdMSW5mZXJlbmNlSGFuZGxlcih0aGlzKTtcbiAgfVxuICBvbkdyYXBoSW5pdGlhbGl6ZWQoZ3JhcGg6IEdyYXBoKTogdm9pZCB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gZ3JhcGguZ2V0VmFsdWVzKCkuZmlsdGVyKHYgPT4gdi5mcm9tID09PSAtMSAmJiB2LnRlbnNvcikubWFwKHYgPT4gdi50ZW5zb3IhLmRhdGFJZCk7XG4gICAgdGhpcy5pbml0aWFsaXplcnMgPSBuZXcgU2V0KGluaXRpYWxpemVycyk7XG4gIH1cbiAgaXNJbml0aWFsaXplcih0ZW5zb3JJZDogVGVuc29yLklkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXJzID8gdGhpcy5pbml0aWFsaXplcnMuaGFzKHRlbnNvcklkKSA6IGZhbHNlO1xuICB9XG4gIGFkZEluaXRpYWxpemVyKHRlbnNvcklkOiBUZW5zb3IuSWQpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRpYWxpemVycy5hZGQodGVuc29ySWQpO1xuICB9XG4gIGdldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIGlzUGFja2VkOiBib29sZWFuKTogVGV4dHVyZURhdGF8dW5kZWZpbmVkIHtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCk7XG4gICAgfVxuICB9XG4gIHNldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgaXNQYWNrZWQgPSBmYWxzZSk6IHZvaWQge1xuICAgIExvZ2dlci52ZXJib3NlKCdXZWJHTFNlc3Npb25IYW5kbGVyJywgJ1N0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlJyk7XG4gICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KHRlbnNvcklkLCB0ZXh0dXJlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0ZW5zb3JJZCwgdGV4dHVyZURhdGEpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKHRkID0+IHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQsIHRydWUpKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yIHtcbiAgICBjb25zdCBvcCA9IHJlc29sdmVPcGVyYXRvcihub2RlLCBvcHNldHMsIFdFQkdMX09QX1JFU09MVkVfUlVMRVMpO1xuICAgIG9wLmluaXRpYWxpemUobm9kZS5hdHRyaWJ1dGVzLCBub2RlLCBncmFwaCk7XG4gICAgcmV0dXJuIG9wO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRW5jb2RlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0OiBGbG9hdDMyQXJyYXk7XG4gICAgYnl0ZTogVWludDhBcnJheTtcbiAgICBpbnQ6IFVpbnQzMkFycmF5O1xuICB9XG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG4gIHR5cGUgRGF0YUFycmF5VHlwZSA9IERhdGFUeXBlTWFwW0RhdGFUeXBlXTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbiAgZXhwb3J0IGNvbnN0IGVudW0gVXNhZ2Uge1xuICAgIERlZmF1bHQgPSAwLFxuICAgIFVwbG9hZE9ubHksXG4gICAgRG93bmxvYWQ0Qnl0ZXNBc0Zsb2F0MzIsXG4gIH1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgbWFwcGluZyBkYXRhIHR5cGVzIHRvIHRleHR1cmUgdGV4bGV0c1xuICogRW5jb2RpbmcgbWVhbnMgaG93IGEgRmxvYXQzMiBpcyBtYXBwZWQgdG8gMSBvciA0IGNoYW5uZWxzIGZvciBlYWNoIHRleGxldFxuICogRGVjb2RpbmcgbWVhbnMgaG93IGEgdGV4bGV0J3MgY2hhbm5lbHMgYXJlIG1hcHBlZCB0byBhIHJlc3VsdGluZyBGbG9hdDMyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemU6IG51bWJlcjtcbiAgZW5jb2RlKHNyYzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCB0ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlO1xuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGU7XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZTtcbn1cbi8qKlxuICogV2ViR0wyIGRhdGEgZW5jb2RlclxuICogVXNlcyBSMzJGIGFzIHRoZSBmb3JtYXQgZm9yIHRleGxldFxuICovXG5leHBvcnQgY2xhc3MgUmVkRmxvYXQzMkRhdGFFbmNvZGVyIGltcGxlbWVudHMgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IoZ2w6IFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSkge1xuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLlIzMkY7XG4gICAgICB0aGlzLmZvcm1hdCA9IGdsLlJFRDtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxzID09PSA0KSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTMyRjtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5GTE9BVDtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHtjaGFubmVsc31gKTtcbiAgICB9XG4gIH1cbiAgZW5jb2RlKHNyYzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCB0ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBsZXQgcmVzdWx0OiBGbG9hdDMyQXJyYXk7XG4gICAgbGV0IHNvdXJjZTogRmxvYXQzMkFycmF5O1xuICAgIGlmIChzcmMuY29uc3RydWN0b3IgIT09IEZsb2F0MzJBcnJheSkge1xuICAgICAgTG9nZ2VyLndhcm5pbmcoJ0VuY29kZXInLCAnZGF0YSB3YXMgbm90IG9mIHR5cGUgRmxvYXQzMjsgY3JlYXRpbmcgbmV3IEZsb2F0MzJBcnJheScpO1xuICAgICAgc291cmNlID0gbmV3IEZsb2F0MzJBcnJheShzcmMpO1xuICAgIH1cbiAgICBpZiAodGV4dHVyZVNpemUgKiB0aGlzLmNoYW5uZWxTaXplID4gc3JjLmxlbmd0aCkge1xuICAgICAgTG9nZ2VyLndhcm5pbmcoJ0VuY29kZXInLCAnU291cmNlIGRhdGEgdG9vIHNtYWxsLiBBbGxvY2F0aW5nIGxhcmdlciBhcnJheScpO1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHRoaXMuYWxsb2NhdGUodGV4dHVyZVNpemUgKiB0aGlzLmNoYW5uZWxTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICBzb3VyY2UuZm9yRWFjaCgodiwgaSkgPT4gcmVzdWx0W2ldID0gdik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSA9IHNyYyBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICByZXN1bHQgPSBzb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShzaXplICogNCk7XG4gIH1cbiAgZGVjb2RlKGJ1ZmZlcjogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCBkYXRhU2l6ZTogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5jaGFubmVsU2l6ZSA9PT0gMSkge1xuICAgICAgY29uc3QgZmlsdGVyZWREYXRhID0gKGJ1ZmZlciBhcyBGbG9hdDMyQXJyYXkpLmZpbHRlcigodmFsdWUsIGluZGV4KSA9PiBpbmRleCAlIDQgPT09IDApLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgZGF0YVNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuLyoqXG4gKiBEYXRhIGVuY29kZXIgZm9yIFdlYkdMIDEgd2l0aCBzdXBwb3J0IGZvciBmbG9hdGluZyBwb2ludCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBSR0JBRmxvYXREYXRhRW5jb2RlciBpbXBsZW1lbnRzIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSwgdGV4dHVyZVR5cGU/OiBudW1iZXIpIHtcbiAgICBpZiAoY2hhbm5lbHMgIT09IDEgJiYgY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IHRleHR1cmVUeXBlIHx8IGdsLkZMT0FUO1xuICB9XG4gIGVuY29kZShzcmM6IEZsb2F0MzJBcnJheSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgbGV0IGRlc3QgPSBzcmM7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdFbmNvZGVyJywgJ0V4cGxvZGluZyBpbnRvIGEgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBkZXN0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgc3JjLmZvckVhY2goKHYsIGkpID0+IGRlc3RbaSAqIDRdID0gdik7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDQpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IChidWZmZXIgYXMgRmxvYXQzMkFycmF5KS5maWx0ZXIoKHZhbHVlLCBpbmRleCkgPT4gaW5kZXggJSA0ID09PSAwKS5zdWJhcnJheSgwLCBkYXRhU2l6ZSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVpbnQ4RGF0YUVuY29kZXIgaW1wbGVtZW50cyBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZSA9IDQ7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSkge1xuICAgIGlmIChjaGFubmVscyA9PT0gMSkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLkFMUEhBO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5BTFBIQTsgIC8vIG5vdCB0ZXN0ZWRcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbHMgPT09IDQpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5SR0JBO1xuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICB9XG4gIGVuY29kZShzcmM6IFVpbnQ4QXJyYXksIF90ZXh0dXJlU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKTtcbiAgfVxuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaXplICogdGhpcy5jaGFubmVsU2l6ZSk7XG4gIH1cbiAgZGVjb2RlKGJ1ZmZlcjogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCBkYXRhU2l6ZTogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgZGF0YVNpemUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXJyYXkgdHlwZTogJHtidWZmZXIuY29uc3RydWN0b3J9YCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vLi4vdXRpbCc7XG4vKiogTGF5b3V0IHByZWZlcmVuY2VzICovXG5leHBvcnQgaW50ZXJmYWNlIFdpZHRoSGVpZ2h0UHJlZnMge1xuICBicmVha0F4aXM/OiBudW1iZXI7XG4gIGlzUGFja2VkPzogYm9vbGVhbjtcbiAgcmV2ZXJzZVdIPzogYm9vbGVhbjtcbn1cbi8qKlxuICogVGV4dHVyZUxheW91dFN0cmF0ZWd5IGlzIGFuIGFic3RyYWN0aW9uIGZvciBkaWZmZXJlbnQgcGxhbnNcbiAqIGZvciBtYXBwaW5nIG4tZGltZW5zaW9uYWwgYXJyYXlzIHRvIDJEIHRleHR1cmVzIChhbmQgYmFjaylcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb21wdXRlVGV4dHVyZVdIKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXTtcbn1cblxuLyoqXG4gKiBUaGlzIHN0cmF0ZWd5IHRyeSB0byBmaW5kIHRoZSBtaW5pbWFsIG1heChXLEgpIHRoYXQgZnVsZmlsbHMgKFcgKiBIID09IHRvdGFsU2l6ZSlcbiAqL1xuZXhwb3J0IGNsYXNzIEFsd2F5c0tlZXBPcmlnaW5hbFNpemVTdHJhdGVneSBpbXBsZW1lbnRzIFRleHR1cmVMYXlvdXRTdHJhdGVneSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtYXhUZXh0dXJlU2l6ZTogbnVtYmVyKSB7fVxuICBjb21wdXRlVGV4dHVyZVdIKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgLy8gc2NhbGFyIHRlbnNvclxuICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbMSwgMV07XG4gICAgfVxuICAgIGNvbnN0IG1heFRleHR1cmVTaXplID0gdGhpcy5tYXhUZXh0dXJlU2l6ZTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMuYnJlYWtBeGlzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBkaW1zIGZpdFxuICAgICAgY29uc3Qgd3NpemUgPSBwcmVmcy5icmVha0F4aXMgPj0gc2hhcGUubGVuZ3RoID8gMSA6IHNoYXBlLnNsaWNlKHByZWZzLmJyZWFrQXhpcykucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBoc2l6ZSA9IHByZWZzLmJyZWFrQXhpcyA8PSAwID8gMSA6IHNoYXBlLnNsaWNlKDAsIHByZWZzLmJyZWFrQXhpcykucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBpZiAod3NpemUgPiBtYXhUZXh0dXJlU2l6ZSB8fCBoc2l6ZSA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgICAgIC8vIGlnbm9yZSBwcmVmZXJlbmNlc1xuICAgICAgICAvLyBjb250aW51ZSB3aXRoIGRlZmF1bHQgbGF5b3V0XG4gICAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgJ1RleHR1cmVMYXlvdXQnLFxuICAgICAgICAgICAgYEdpdmVuIHdpZHRoL2hlaWdodCBwcmVmZXJlbmNlcyB3ZXJlIHVuYXR0YWluYWJsZTogc2hhcGU6JHtzaGFwZX0sIGJyZWFrQXhpczoke3ByZWZzLmJyZWFrQXhpc31gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbd3NpemUsIGhzaXplXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdG90YWxTaXplID0gc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG5cbiAgICBsZXQgd2lkdGggPSBNYXRoLmZsb29yKE1hdGguc3FydCh0b3RhbFNpemUpKTtcblxuICAgIGZvciAoOyB3aWR0aCA8IG1heFRleHR1cmVTaXplICYmIHdpZHRoIDwgdG90YWxTaXplOyB3aWR0aCsrKSB7XG4gICAgICBpZiAodG90YWxTaXplICUgd2lkdGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpZHRoID49IG1heFRleHR1cmVTaXplIHx8IHRvdGFsU2l6ZSAlIHdpZHRoICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBkaW1lbnNpb25zIGFyZSBvdXRzaWRlIHRoaXMgR1BVJ3MgYm91bmRhcmllczogJHtzaGFwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFt3aWR0aCwgdG90YWxTaXplIC8gd2lkdGhdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcmVmZXJMb2dpY2FsU3RyYXRlZ3kgaW1wbGVtZW50cyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF4VGV4dHVyZVNpemU6IG51bWJlcikge31cbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IHdoID0gdGhpcy5jb21wdXRlVGV4dHVyZShzaGFwZSwgcHJlZnMpO1xuICAgIGlmIChwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZCkge1xuICAgICAgd2hbMF0gLz0gMjtcbiAgICAgIHdoWzFdIC89IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdoO1xuICB9XG5cbiAgY29tcHV0ZVRleHR1cmUoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCBpc1BhY2tlZCA9IHByZWZzICYmIHByZWZzLmlzUGFja2VkO1xuICAgIC8vIHNjYWxhciB0ZW5zb3JcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaXNQYWNrZWQgPyBbMiwgMl0gOiBbMSwgMV07XG4gICAgfVxuICAgIGxldCBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemU7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmJyZWFrQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGltcyBmaXRcbiAgICAgIGNvbnN0IHdzaXplID0gcHJlZnMuYnJlYWtBeGlzID49IHNoYXBlLmxlbmd0aCA/IDEgOiBzaGFwZS5zbGljZShwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgaHNpemUgPSBwcmVmcy5icmVha0F4aXMgPD0gMCA/IDEgOiBzaGFwZS5zbGljZSgwLCBwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgaWYgKHdzaXplID4gbWF4VGV4dHVyZVNpemUgfHwgaHNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAvLyBpZ25vcmUgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gY29udGludWUgd2l0aCBkZWZhdWx0IGxheW91dFxuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICdUZXh0dXJlTGF5b3V0JyxcbiAgICAgICAgICAgIGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7c2hhcGV9LCBicmVha0F4aXM6JHtwcmVmcy5icmVha0F4aXN9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3dzaXplLCBoc2l6ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsb2dTaGFwZSA9IHNoYXBlLnNsaWNlKDApO1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgbWF4VGV4dHVyZVNpemUgPSBtYXhUZXh0dXJlU2l6ZSAqIDI7XG5cbiAgICAgIC8vIFRoaXMgbG9naWMgZW5zdXJlcyB3ZSBhY2N1cmF0ZWx5IGNvdW50IHRoZSBudW1iZXIgb2YgcGFja2VkIHRleGVscyBuZWVkZWRcbiAgICAgIC8vIHRvIGFjY29tbW9kYXRlIHRoZSB0ZW5zb3IuIFdlIGNhbiBvbmx5IHBhY2sgdmFsdWVzIGluIHRoZSBzYW1lIHRleGVsIGlmXG4gICAgICAvLyB0aGV5IGFyZSBmcm9tIGFkamFjZW50IHBhaXJzIG9mIHJvd3MvY29scyB3aXRoaW4gdGhlIHNhbWUgYmF0Y2guIFNvIGlmIGFcbiAgICAgIC8vIHRlbnNvciBoYXMgMyByb3dzLCB3ZSBwcmV0ZW5kIGl0IGhhcyA0IHJvd3MgaW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhlXG4gICAgICAvLyBmYWN0IHRoYXQgdGhlIHRleGVscyBjb250YWluaW5nIHRoZSB0aGlyZCByb3cgYXJlIGhhbGYgZW1wdHkuXG4gICAgICBsb2dTaGFwZSA9IGxvZ1NoYXBlLm1hcChcbiAgICAgICAgICAoZCwgaSkgPT4gaSA+PSBsb2dTaGFwZS5sZW5ndGggLSAyID8gKGxvZ1NoYXBlW2ldICUgMiA9PT0gMCA/IGxvZ1NoYXBlW2ldIDogbG9nU2hhcGVbaV0gKyAxKSA6IGxvZ1NoYXBlW2ldKTtcblxuICAgICAgLy8gUGFja2VkIHRleHR1cmUgaGVpZ2h0IGlzIGF0IGxlYXN0IDIgKHRoZSBjaGFubmVsIGhlaWdodCBvZiBhIHNpbmdsZVxuICAgICAgLy8gdGV4ZWwpLlxuICAgICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBsb2dTaGFwZSA9IFsyLCBsb2dTaGFwZVswXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbG9naWNhbCBzaGFwZSBpcyAyLCB3ZSBkb24ndCBzcXVlZXplLCBzaW5jZSB3ZSB3YW50IHRvIG1hdGNoIHBoeXNpY2FsLlxuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnN0IHNxdWVlemVSZXN1bHQgPSBzcXVlZXplU2hhcGUobG9nU2hhcGUpO1xuICAgICAgbG9nU2hhcGUgPSBzcXVlZXplUmVzdWx0Lm5ld1NoYXBlO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSBzaXplRnJvbVNoYXBlKGxvZ1NoYXBlKTtcbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoIDw9IDEgJiYgc2l6ZSA8PSBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgcmV0dXJuIFsxLCBzaXplXTtcbiAgICB9IGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMiAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJiBsb2dTaGFwZVsxXSA8PSBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgcmV0dXJuIGxvZ1NoYXBlIGFzIFtudW1iZXIsIG51bWJlcl07XG4gICAgfSBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJiBsb2dTaGFwZVsyXSA8PSBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSAqIGxvZ1NoYXBlWzFdLCBsb2dTaGFwZVsyXV07XG4gICAgfSBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgbG9nU2hhcGUubGVuZ3RoID09PSA0ICYmIGxvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVszXSA8PSBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSAqIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0sIGxvZ1NoYXBlWzNdXTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBsb2dTaGFwZS5sZW5ndGggPT09IDQgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM11dO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgLy8gRm9yIHBhY2tlZCB0ZXh0dXJlcyBzaXplIGVxdWFscyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzIHJlcXVpcmVkIHRvXG4gICAgICAgIC8vIGFjY29tbW9kYXRlIHRoZSB0ZXh0dXJlIGRhdGEuIEhvd2V2ZXIgaW4gb3JkZXIgdG8gc3F1YXJpZnkgc3VjaCB0aGF0XG4gICAgICAgIC8vIGlubmVyIGRpbWVuc2lvbnMgc3RheSBldmVuLCB3ZSByZXdyaXRlIHNpemUgdG8gZXF1YWwgdGhlIG51bWJlciBvZlxuICAgICAgICAvLyB0ZXhlbHMuIFRoZW4gaW4gdGhlIHJldHVybiBzdGF0ZW1lbnQgd2UgcmVoeWRyYXRlIHRoZSBzcXVhcmlmaWVkXG4gICAgICAgIC8vIGRpbWVuc2lvbnMgdG8gY2hhbm5lbCB1bml0cy5cbiAgICAgICAgcmV0dXJuIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSAvIDQpLm1hcChkID0+IGQgKiAyKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVlZXplU2hhcGUoc2hhcGU6IG51bWJlcltdLCBheGlzPzogbnVtYmVyW10pOiB7bmV3U2hhcGU6IG51bWJlcltdOyBrZXB0RGltczogbnVtYmVyW119IHtcbiAgY29uc3QgbmV3U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGtlcHREaW1zOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpc0VtcHR5QXJyYXkgPSBheGlzICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShheGlzKSAmJiBheGlzLmxlbmd0aCA9PT0gMDtcbiAgY29uc3QgYXhlcyA9IChheGlzID09IG51bGwgfHwgaXNFbXB0eUFycmF5KSA/IG51bGwgOiBwYXJzZUF4aXNQYXJhbShheGlzLCBzaGFwZSkuc29ydCgpO1xuICBsZXQgaiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXhlcyAhPSBudWxsKSB7XG4gICAgICBpZiAoYXhlc1tqXSA9PT0gaSAmJiBzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNxdWVlemUgYXhpcyAke2l9IHNpbmNlIGl0cyBkaW0gJyR7c2hhcGVbaV19JyBpcyBub3QgMWApO1xuICAgICAgfVxuICAgICAgaWYgKChheGVzW2pdID09IG51bGwgfHwgYXhlc1tqXSA+IGkpICYmIHNoYXBlW2ldID09PSAxKSB7XG4gICAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgaWYgKGF4ZXNbal0gPD0gaSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFwZVtpXSAhPT0gMSkge1xuICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge25ld1NoYXBlLCBrZXB0RGltc307XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUF4aXNQYXJhbShheGlzOiBudW1iZXJ8bnVtYmVyW10sIHNoYXBlOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAvLyBOb3JtYWxpemUgaW5wdXRcbiAgYXhpcyA9IGF4aXMgPT0gbnVsbCA/IHNoYXBlLm1hcCgocywgaSkgPT4gaSkgOiAoW10gYXMgbnVtYmVyW10pLmNvbmNhdChheGlzKTtcblxuICAvLyBDaGVjayBmb3IgdmFsaWQgcmFuZ2VcbiAgYXNzZXJ0KFxuICAgICAgYXhpcy5ldmVyeShheCA9PiBheCA+PSAtcmFuayAmJiBheCA8IHJhbmspLFxuICAgICAgKCkgPT4gYEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtyYW5rfSwgJHtyYW5rfSkgYnV0IGAgK1xuICAgICAgICAgIGBnb3QgYXhpcyAke2F4aXN9YCk7XG5cbiAgLy8gQ2hlY2sgZm9yIG9ubHkgaW50ZWdlcnNcbiAgYXNzZXJ0KFxuICAgICAgYXhpcy5ldmVyeShpc0ludCksXG4gICAgICAoKSA9PiAnQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0ICcgK1xuICAgICAgICAgIGBnb3QgYXhpcyAke2F4aXN9YCk7XG5cbiAgLy8gSGFuZGxlIG5lZ2F0aXZlIGF4aXMuXG4gIHJldHVybiBheGlzLm1hcChhID0+IGEgPCAwID8gcmFuayArIGEgOiBhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ludChhOiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGU6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFNjYWxhci5cbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgc2l6ZSA9IHNoYXBlWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dzQ29scyhzaGFwZTogbnVtYmVyW10pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IEVycm9yKCdDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuJyk7XG4gIH1cblxuICByZXR1cm4gW3NoYXBlLmxlbmd0aCA+IDEgPyBzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSA6IDEsIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpO1xuICByZXR1cm4gW3dpZHRoLCBNYXRoLmNlaWwoc2l6ZSAvIHdpZHRoKV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmF0Y2hEaW0oc2hhcGU6IG51bWJlcltdLCBkaW1zVG9Ta2lwID0gMik6IG51bWJlciB7XG4gIHJldHVybiBzaXplRnJvbVNoYXBlKHNoYXBlLnNsaWNlKDAsIHNoYXBlLmxlbmd0aCAtIGRpbXNUb1NraXApKTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlciwgUHJvZmlsZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5cbmltcG9ydCB7RW5jb2Rlcn0gZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQge1RleHR1cmVMYXlvdXRTdHJhdGVneX0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQge1RleHR1cmVEYXRhLCBUZXh0dXJlTGF5b3V0fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRleHR1cmVNYW5hZ2VyQ29uZmlnIHtcbiAgcmV1c2VUZXh0dXJlcz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogVGV4dHVyZU1hbmFnZXIgaXMgdGhlIG1haW5seSByZXNwb25zaWJsZSBmb3IgY2FjaGluZyBUZXh0dXJlc1xuICogVGV4dHVyZXMgYXJlIGNhY2hlZCBpbiAyIGxldmVsczpcbiAqICAgMS4gdGhlIHRleHVyZXMgd2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBhIGRhdGFJZCAoZnJvbSBUZW5zb3IpXG4gKiAgICBDYWNoaW5nIHRoZXNlIGlzIGNydWNpYWwgdG8gcGVyZm9ybWFuY2UuIFRoZXNlIGFyZSBJbi11c2UgVGV4dHVyZXNcbiAqICAgMi4gdGV4dHVyZXMgd2hpY2ggYXJlIG5vdCBpbiB1c2UgYnkgYW55IGN1cnJlbnQgUHJvZ3JhbUluZm8vVGVuc29yXG4gKiAgICAgVGhlc2UgYXJlIGNhbGxlZCBGcmVlIFRleHR1cmVzXG4gKiBUZXh0dXJlTWFuYWdlciBpcyBhbHNvIHVzZWQgdG8gaGVscCBjcmVhdGluZyB0ZXh0dXJlcy4gRm9yIHRoaXMgaXRcbiAqIHVzZXMgV2ViR0xDb250ZXh0IGFuZCBUZXh0dXJlTGF5b3V0U3RyYXRlZ3lcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHR1cmVNYW5hZ2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBpblVzZVRleHR1cmVzOiBNYXA8c3RyaW5nLCBXZWJHTFRleHR1cmVbXT47XG4gIHByaXZhdGUgcmVhZG9ubHkgaWRsZVRleHR1cmVzOiBNYXA8c3RyaW5nLCBXZWJHTFRleHR1cmVbXT47XG4gIHByaXZhdGUgcmVhZG9ubHkgdGV4dHVyZUxvb2t1cDogTWFwPFdlYkdMVGV4dHVyZSwgc3RyaW5nPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCwgcHVibGljIGxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksIHB1YmxpYyBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+LFxuICAgICAgcHJpdmF0ZSBjb25maWc6IFRleHR1cmVNYW5hZ2VyQ29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5yZXVzZVRleHR1cmVzKSB7XG4gICAgICB0aGlzLmluVXNlVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLmlkbGVUZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMudGV4dHVyZUxvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlVGV4dHVyZUZyb21MYXlvdXQoXG4gICAgICBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGE/OiBUZW5zb3IuTnVtYmVyVHlwZSwgdXNhZ2U/OiBFbmNvZGVyLlVzYWdlKSB7XG4gICAgY29uc3QgdGV4dHVyZURhdGFUeXBlID0gdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKTtcblxuICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLmdsQ29udGV4dC5nZXRFbmNvZGVyKHRleHR1cmVEYXRhVHlwZSwgbGF5b3V0LmNoYW5uZWxzIHx8IDEsIHVzYWdlKTtcbiAgICBpZiAobGF5b3V0LmlzUGFja2VkICYmIHVzYWdlID09PSBFbmNvZGVyLlVzYWdlLlVwbG9hZE9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gbGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGxheW91dC5oZWlnaHQ7XG5cbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGxldCBpblVzZVRleHR1cmVzOiBXZWJHTFRleHR1cmVbXXx1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IGAke3dpZHRofXgke2hlaWdodH1fJHtlbmNvZGVyLmZvcm1hdH1fJHtlbmNvZGVyLmludGVybmFsRm9ybWF0fV8ke2VuY29kZXIudGV4dHVyZVR5cGV9YDtcbiAgICAgIGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIWluVXNlVGV4dHVyZXMpIHtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGtleSwgaW5Vc2VUZXh0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgaWYgKGlkbGVUZXh0dXJlcyAmJiBpZGxlVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gaWRsZVRleHR1cmVzLnBvcCgpITtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICBpZiAodXNhZ2UgPT09IEVuY29kZXIuVXNhZ2UuVXBsb2FkT25seSkge1xuICAgICAgICAgIHRoaXMuZ2xDb250ZXh0LnVwZGF0ZVRleHR1cmUodGV4dHVyZSwgd2lkdGgsIGhlaWdodCwgZW5jb2RlciwgdGhpcy50b1RleHR1cmVEYXRhKGRhdGFUeXBlLCBkYXRhKSEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgfVxuICAgIH1cblxuICAgIExvZ2dlci52ZXJib3NlKCdUZXh0dXJlTWFuYWdlcicsIGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7bGF5b3V0LndpZHRofXgke2xheW91dC5oZWlnaHR9YCk7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCBlbmNvZGVyLCB0aGlzLnRvVGV4dHVyZURhdGEoZGF0YVR5cGUsIGRhdGEpKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKSB7XG4gICAgICBpblVzZVRleHR1cmVzIS5wdXNoKHRleHR1cmUpO1xuICAgICAgdGhpcy50ZXh0dXJlTG9va3VwLnNldCh0ZXh0dXJlLCBrZXkhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbiAgcmVhZFRleHR1cmUodGQ6IFRleHR1cmVEYXRhLCBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBjaGFubmVscz86IG51bWJlcik6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBpZiAoIWNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscyA9IDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdiYWNrZW5kJywgJ1RleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YVNpemUgPSB0ZC5zaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKSAqIGNoYW5uZWxzITtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZShcbiAgICAgICAgICB0ZC50ZXh0dXJlLCB0ZC53aWR0aCwgdGQuaGVpZ2h0LCBkYXRhU2l6ZSwgdGhpcy50b0VuY29kZXJUeXBlKGRhdGFUeXBlKSwgY2hhbm5lbHMhKTtcbiAgICAgIHJldHVybiB0aGlzLnRvVGVuc29yRGF0YShkYXRhVHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgcmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQodGQ6IFRleHR1cmVEYXRhKTogRmxvYXQzMkFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gdGQuc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodGQudGV4dHVyZSwgdGQud2lkdGgsIHRkLmhlaWdodCwgZGF0YVNpemUgKiA0LCAnYnl0ZScsIDQpO1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YVNpemUpO1xuICAgIH0pO1xuICB9XG4gIHJlbGVhc2VUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgZGVsZXRlVGV4dHVyZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKSB7XG4gICAgICBrZXkgPSB0aGlzLnRleHR1cmVMb29rdXAuZ2V0KHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoZGVsZXRlVGV4dHVyZSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUxvb2t1cC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpblVzZVRleHR1cmVzID0gdGhpcy5pblVzZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgICBpZiAoaW5Vc2VUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5Vc2VUZXh0dXJlcy5pbmRleE9mKHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGluVXNlVGV4dHVyZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGxldCBpZGxlVGV4dHVyZXMgPSB0aGlzLmlkbGVUZXh0dXJlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghaWRsZVRleHR1cmVzKSB7XG4gICAgICAgICAgICAgIGlkbGVUZXh0dXJlcyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLmlkbGVUZXh0dXJlcy5zZXQoa2V5LCBpZGxlVGV4dHVyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRsZVRleHR1cmVzLnB1c2godGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFrZXkgfHwgZGVsZXRlVGV4dHVyZSkge1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3RleHR1cmVEYXRhLndpZHRofXgke3RleHR1cmVEYXRhLmhlaWdodH1gKTtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIHRvVGVuc29yRGF0YShkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBkYXRhOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUpOiBUZW5zb3IuTnVtYmVyVHlwZSB7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkgPyBkYXRhIDogSW50MTZBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkgPyBkYXRhIDogSW50MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50OEFycmF5ID8gZGF0YSA6IEludDhBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSA/IGRhdGEgOiBVaW50MTZBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/IGRhdGEgOiBVaW50MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGRhdGEgOiBVaW50OEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBkYXRhIDogRmxvYXQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyBkYXRhIDogRmxvYXQ2NEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIHRvVGV4dHVyZURhdGEoZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgZGF0YTogVGVuc29yLk51bWJlclR5cGV8dW5kZWZpbmVkKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlfHVuZGVmaW5lZCB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpID8gZGF0YSA6IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgLypcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIChkYXRhLmNvbnN0cnVjdG9yID09PSBVaW50MzJBcnJheSkgPyBkYXRhIGFzIFVpbnQzMkFycmF5IDogbmV3IFVpbnQzMkFycmF5KGRhdGEpO1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIChkYXRhLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSA/IGRhdGEgYXMgVWludDhBcnJheSA6IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIChkYXRhLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXkpID8gZGF0YSBhcyBGbG9hdDMyQXJyYXkgOiBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHtkYXRhVHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgICAqL1xuICB9XG4gIHRvRW5jb2RlclR5cGUoX2RhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUpOiBFbmNvZGVyLkRhdGFUeXBlIHtcbiAgICByZXR1cm4gJ2Zsb2F0JztcbiAgICAvLyBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgLy8gICBjYXNlICdpbnQxNic6XG4gICAgLy8gICBjYXNlICdpbnQzMic6XG4gICAgLy8gICBjYXNlICd1aW50MTYnOlxuICAgIC8vICAgY2FzZSAndWludDMyJzpcbiAgICAvLyAgICAgcmV0dXJuICdpbnQnO1xuICAgIC8vICAgY2FzZSAndWludDgnOlxuICAgIC8vICAgY2FzZSAnYm9vbCc6XG4gICAgLy8gICAgIHJldHVybiAnYnl0ZSc7XG4gICAgLy8gICBjYXNlICdmbG9hdDMyJzpcbiAgICAvLyAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgIC8vICAgICByZXR1cm4gJ2Zsb2F0JztcbiAgICAvLyAgIGRlZmF1bHQ6XG4gICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZGF0YVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAvLyB9XG4gIH1cbiAgY2xlYXJBY3RpdmVUZXh0dXJlcygpOiB2b2lkIHtcbiAgICB0aGlzLmdsQ29udGV4dC5jbGVhckFjdGl2ZVRleHR1cmVzKCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vLi4vdXRpbCc7XG4vKipcbiAqIEdpdmVuIGEgbm9uIFJHQkEgc2hhcGUgY2FsY3VsYXRlIHRoZSBSIHZlcnNpb25cbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZGltZW5zaW9ucyBhcmUgbXVsdGlwbGVzIG9mIGdpdmVuIGNoYW5uZWxzXG4gKiBOT1RFOiBpdCBpcyBhbHdheXMgdGhlIGxhc3QgZGltIHRoYXQgZ2V0cyBwYWNrZWQuXG4gKiBAcGFyYW0gdW5wYWNrZWRTaGFwZSBvcmlnaW5hbCBzaGFwZSB0byBjcmVhdGUgYSBwYWNrZWQgdmVyc2lvbiBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrZWRTaGFwZSh1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgY29uc3QgbGVuID0gdW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gIHJldHVybiB1bnBhY2tlZFNoYXBlLnNsaWNlKDAsIGxlbiAtIDEpLmNvbmNhdCh1bnBhY2tlZFNoYXBlW2xlbiAtIDFdIC8gNCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXBlYXRlZFRyeShcbiAgICBjaGVja0ZuOiAoKSA9PiBib29sZWFuLCBkZWxheUZuID0gKF9jb3VudGVyOiBudW1iZXIpID0+IDAsIG1heENvdW50ZXI/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgdHJ5Q291bnQgPSAwO1xuXG4gICAgY29uc3QgdHJ5Rm4gPSAoKSA9PiB7XG4gICAgICBpZiAoY2hlY2tGbigpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnlDb3VudCsrO1xuXG4gICAgICBjb25zdCBuZXh0QmFja29mZiA9IGRlbGF5Rm4odHJ5Q291bnQpO1xuXG4gICAgICBpZiAobWF4Q291bnRlciAhPSBudWxsICYmIHRyeUNvdW50ID49IG1heENvdW50ZXIpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIG5leHRCYWNrb2ZmKTtcbiAgICB9O1xuXG4gICAgdHJ5Rm4oKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYW4gaW5wdXQgc2FtcGxlciBuYW1lLlxuICogQHBhcmFtIHNhbXBsZXJOYW1lIE5hbWUgb2YgdGhlIHNhbXBsZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUoc2FtcGxlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydCh0eXBlb2Ygc2FtcGxlck5hbWUgIT09ICd1bmRlZmluZWQnICYmIHNhbXBsZXJOYW1lLmxlbmd0aCAhPT0gMCwgKCkgPT4gJ2VtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lJyk7XG4gIHJldHVybiAnZ2V0JyArIHNhbXBsZXJOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2FtcGxlck5hbWUuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYW4gaW5wdXQgc2FtcGxlciBuYW1lIGF0IG91dHB1dCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSBzYW1wbGVyTmFtZSBOYW1lIG9mIHRoZSBzYW1wbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydCh0eXBlb2Ygc2FtcGxlck5hbWUgIT09ICd1bmRlZmluZWQnICYmIHNhbXBsZXJOYW1lLmxlbmd0aCAhPT0gMCwgKCkgPT4gJ2VtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lJyk7XG4gIHJldHVybiAnZ2V0JyArIHNhbXBsZXJOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2FtcGxlck5hbWUuc2xpY2UoMSkgKyAnQXRPdXRDb29yZHMnO1xufVxuXG4vKiogUmV0dXJucyBhIG5ldyBpbnB1dCBzaGFwZSAoYSBjb3B5KSB0aGF0IGhhcyBhIHNxdWVlemVkIGxvZ2ljYWwgc2hhcGUuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1ZWV6ZUlucHV0U2hhcGUoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNxdWVlemVkU2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAvLyBEZWVwIGNvcHkuXG4gIGxldCBuZXdJbnB1dFNoYXBlOiBudW1iZXJbXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpO1xuICBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgcmV0dXJuIG5ld0lucHV0U2hhcGU7XG59XG5cbi8qKiBSZXR1cm5zIGEgbGlzdCBvZiBzcXVlZXplZCBwYXJhbWV0ZXJzIGZvciBzaGFkZXIgZnVuY3Rpb25zICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zOiBzdHJpbmdbXSwga2VwdERpbXM6IG51bWJlcltdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGtlcHREaW1zLm1hcChkID0+IHBhcmFtc1tkXSkuam9pbignLCAnKTtcbn1cblxuLyoqIFJldHVybnMgdGhlIGRhdGEgdHlwZSBmb3IgZGlmZmVyZW50IHJhbmtzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gJ2ludCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiAnaXZlYzInO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICByZXR1cm4gJ2l2ZWMzJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgcmV0dXJuICdpdmVjNCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNSkge1xuICAgIHJldHVybiAnaXZlYzUnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDYpIHtcbiAgICByZXR1cm4gJ2l2ZWM2JztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmNvbnN0IGNhY2hlOiB7W2NvbnRleHRJZDogc3RyaW5nXTogV2ViR0xDb250ZXh0fSA9IHt9O1xuXG4vKipcbiAqIFRoaXMgZmFjdG9yeSBmdW5jdGlvbiBjcmVhdGVzIHByb3BlciBXZWJHTFJlbmRlcmluZ0NvbnRleHQgYmFzZWQgb25cbiAqIHRoZSBjdXJyZW50IGJyb3dzZXJzIGNhcGFiaWxpdGllc1xuICogVGhlIG9yZGVyIGlzIGZyb20gaGlnaGVyL21vc3QgcmVjZW50IHZlcnNpb25zIHRvIG1vc3QgYmFzaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ29udGV4dChjb250ZXh0SWQ/OiAnd2ViZ2wnfCd3ZWJnbDInKTogV2ViR0xDb250ZXh0IHtcbiAgbGV0IGNvbnRleHQ6IFdlYkdMQ29udGV4dHx1bmRlZmluZWQ7XG4gIGlmICgoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbDInKSAmJiAnd2ViZ2wyJyBpbiBjYWNoZSkge1xuICAgIGNvbnRleHQgPSBjYWNoZS53ZWJnbDI7XG4gIH0gZWxzZSBpZiAoKCFjb250ZXh0SWQgfHwgY29udGV4dElkID09PSAnd2ViZ2wnKSAmJiAnd2ViZ2wnIGluIGNhY2hlKSB7XG4gICAgY29udGV4dCA9IGNhY2hlLndlYmdsO1xuICB9XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgY3JlYXRlTmV3V2ViR0xDb250ZXh0KGNvbnRleHRJZCk7XG4gIGNvbnRleHRJZCA9IGNvbnRleHRJZCB8fCBjb250ZXh0LnZlcnNpb24gPT09IDEgPyAnd2ViZ2wnIDogJ3dlYmdsMic7XG4gIGNvbnN0IGdsID0gY29udGV4dC5nbDtcblxuICBjYWNoZVtjb250ZXh0SWRdID0gY29udGV4dDtcblxuICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgZGVsZXRlIGNhY2hlW2NvbnRleHRJZF07XG4gICAgcmV0dXJuIGNyZWF0ZVdlYkdMQ29udGV4dChjb250ZXh0SWQpO1xuICB9XG5cbiAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgZ2wuZGlzYWJsZShnbC5ESVRIRVIpO1xuICBnbC5kaXNhYmxlKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSk7XG4gIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdXZWJHTENvbnRleHQoY29udGV4dElkPzogJ3dlYmdsJ3wnd2ViZ2wyJyk6IFdlYkdMQ29udGV4dCB7XG4gIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICBjb25zdCBjb250ZXh0QXR0cmlidXRlczogV2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICBhbHBoYTogZmFsc2UsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgc3RlbmNpbDogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhbHNlXG4gIH07XG4gIGxldCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0fG51bGw7XG4gIGNvbnN0IGNhID0gY29udGV4dEF0dHJpYnV0ZXM7XG4gIGlmICghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsMicpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBjYSk7XG4gICAgaWYgKGdsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMQ29udGV4dChnbCwgMik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5pbmcoJ0dsQ29udGV4dEZhY3RvcnknLCBgZmFpbGVkIHRvIGNyZWF0ZSBXZWJHTENvbnRleHQgdXNpbmcgY29udGV4dElkICd3ZWJnbDInLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsJykge1xuICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY2EpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjYSkgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICAgJ0dsQ29udGV4dEZhY3RvcnknLFxuICAgICAgICAgICAgYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gIGNvbnN0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gMTtcbiAgY2FudmFzLmhlaWdodCA9IDE7XG4gIHJldHVybiBjYW52YXM7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCAqIGFzIERhdGFFbmNvZGVycyBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7RGF0YUVuY29kZXIsIEVuY29kZXJ9IGZyb20gJy4vdGV4dHVyZS1kYXRhLWVuY29kZXInO1xuaW1wb3J0IHtyZXBlYXRlZFRyeX0gZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gYW5kIHdyYXBwZXIgYXJvdW5kIFdlYkdMUmVuZGVyaW5nQ29udGV4dCBhbmQgaXRzIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkdMQ29udGV4dCB7XG4gIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gIHZlcnNpb246IDF8MjtcblxuICBwcml2YXRlIHZlcnRleGJ1ZmZlcjogV2ViR0xCdWZmZXI7XG4gIHByaXZhdGUgZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXI7XG5cbiAgLy8gV2ViR0wgZmxhZ3MgYW5kIHZpdGFsIHBhcmFtZXRlcnNcbiAgcHJpdmF0ZSBpc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyOiBib29sZWFuO1xuICBpc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZDogYm9vbGVhbjtcbiAgaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkOiBib29sZWFuO1xuICBpc0JsZW5kU3VwcG9ydGVkOiBib29sZWFuO1xuICBtYXhUZXh0dXJlU2l6ZTogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHM6IG51bWJlcjtcbiAgcHJpdmF0ZSBtYXhUZXh0dXJlSW1hZ2VVbml0czogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heEN1YmVNYXBUZXh0dXJlU2l6ZTogbnVtYmVyO1xuICAvLyBwcml2YXRlIHNoYWRpbmdMYW5ndWFnZVZlcnNpb246IHN0cmluZztcbiAgLy8gcHJpdmF0ZSB3ZWJnbFZlbmRvcjogc3RyaW5nO1xuICAvLyBwcml2YXRlIHdlYmdsVmVyc2lvbjogc3RyaW5nO1xuXG4gIC8vIFdlYkdMMiBmbGFncyBhbmQgdml0YWwgcGFyYW1ldGVyc1xuICAvLyBwcml2YXRlIG1heDNEVGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhBcnJheVRleHR1cmVMYXllcnM6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDb2xvckF0dGFjaG1lbnRzOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4RHJhd0J1ZmZlcnM6IG51bWJlcjtcblxuICAvLyBXZWJHTCBleHRlbnNpb25zXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgdGV4dHVyZUZsb2F0RXh0ZW5zaW9uOiBPRVNfdGV4dHVyZV9mbG9hdHxudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb246IE9FU190ZXh0dXJlX2hhbGZfZmxvYXR8bnVsbDtcblxuICAvLyBXZWJHTDIgZXh0ZW5zaW9uc1xuICBjb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uOiB1bmtub3dufG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uOiB7VElNRV9FTEFQU0VEX0VYVDogR0xlbnVtOyBHUFVfRElTSk9JTlRfRVhUOiBHTGVudW19fG51bGw7XG5cbiAgcHJpdmF0ZSBkaXNwb3NlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBmcmFtZUJ1ZmZlckJvdW5kID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdmVyc2lvbjogMXwyKSB7XG4gICAgdGhpcy5nbCA9IGdsO1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG5cbiAgICB0aGlzLmdldEV4dGVuc2lvbnMoKTtcbiAgICB0aGlzLnZlcnRleGJ1ZmZlciA9IHRoaXMuY3JlYXRlVmVydGV4YnVmZmVyKCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IHRoaXMuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLnF1ZXJ5Vml0YWxQYXJhbWV0ZXJzKCk7XG4gIH1cblxuICBhbGxvY2F0ZVRleHR1cmUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGVuY29kZXI6IERhdGFFbmNvZGVyLCBkYXRhPzogRW5jb2Rlci5EYXRhQXJyYXlUeXBlKTogV2ViR0xUZXh0dXJlIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgLy8gY3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAvLyBiaW5kIHRoZSB0ZXh0dXJlIHNvIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBlZmZlY3QgdGhpcyB0ZXh0dXJlLlxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgY29uc3QgYnVmZmVyID0gZGF0YSA/IGVuY29kZXIuZW5jb2RlKGRhdGEsIHdpZHRoICogaGVpZ2h0KSA6IG51bGw7XG4gICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCwgIC8vIExldmVsIG9mIGRldGFpbC5cbiAgICAgICAgZW5jb2Rlci5pbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgMCwgIC8vIEFsd2F5cyAwIGluIE9wZW5HTCBFUy5cbiAgICAgICAgZW5jb2Rlci5mb3JtYXQsIGVuY29kZXIudGV4dHVyZVR5cGUsIGJ1ZmZlcik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgcmV0dXJuIHRleHR1cmUgYXMgV2ViR0xUZXh0dXJlO1xuICB9XG4gIHVwZGF0ZVRleHR1cmUoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBlbmNvZGVyOiBEYXRhRW5jb2RlciwgZGF0YTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKGRhdGEsIHdpZHRoICogaGVpZ2h0KTtcbiAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICAwLCAgLy8gbGV2ZWxcbiAgICAgICAgMCwgIC8vIHhvZmZzZXRcbiAgICAgICAgMCwgIC8vIHlvZmZzZXRcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgZW5jb2Rlci5mb3JtYXQsIGVuY29kZXIudGV4dHVyZVR5cGUsIGJ1ZmZlcik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgYXR0YWNoRnJhbWVidWZmZXIodGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAvLyBNYWtlIGl0IHRoZSB0YXJnZXQgZm9yIGZyYW1lYnVmZmVyIG9wZXJhdGlvbnMgLSBpbmNsdWRpbmcgcmVuZGVyaW5nLlxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSxcbiAgICAgICAgMCk7ICAvLyAwLCB3ZSBhcmVuJ3QgdXNpbmcgTUlQTUFQc1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGdsLnNjaXNzb3IoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgcmVhZFRleHR1cmUoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBkYXRhU2l6ZTogbnVtYmVyLCBkYXRhVHlwZTogRW5jb2Rlci5EYXRhVHlwZSxcbiAgICAgIGNoYW5uZWxzOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBpZiAoIWNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscyA9IDE7XG4gICAgfVxuICAgIGlmICghdGhpcy5mcmFtZUJ1ZmZlckJvdW5kKSB7XG4gICAgICB0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKGRhdGFUeXBlLCBjaGFubmVscyk7XG4gICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5hbGxvY2F0ZSh3aWR0aCAqIGhlaWdodCk7XG4gICAgLy8gYmluZCB0ZXh0dXJlIHRvIGZyYW1lYnVmZmVyXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSxcbiAgICAgICAgMCk7ICAvLyAwLCB3ZSBhcmVuJ3QgdXNpbmcgTUlQTUFQc1xuICAgIC8vIFRPRE86IENoZWNrIGlmIGZyYW1lYnVmZmVyIGlzIHJlYWR5XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIC8vIHVuYmluZCBGQlxuICAgIHJldHVybiBlbmNvZGVyLmRlY29kZShidWZmZXIsIGRhdGFTaXplKTtcbiAgfVxuICBpc0ZyYW1lYnVmZmVyUmVhZHkoKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGxvZ2ljIHRvIGNoZWNrIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyByZWFkeVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldEFjdGl2ZVRleHR1cmUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgbiA9IGdsLmdldFBhcmFtZXRlcih0aGlzLmdsLkFDVElWRV9URVhUVVJFKTtcbiAgICByZXR1cm4gYFRFWFRVUkUkeyhuIC0gZ2wuVEVYVFVSRTApfWA7XG4gIH1cbiAgZ2V0VGV4dHVyZUJpbmRpbmcoKTogV2ViR0xUZXh0dXJlIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5URVhUVVJFX0JJTkRJTkdfMkQpO1xuICB9XG4gIGdldEZyYW1lYnVmZmVyQmluZGluZygpOiBXZWJHTEZyYW1lYnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgfVxuICBzZXRWZXJ0ZXhBdHRyaWJ1dGVzKHBvc2l0aW9uSGFuZGxlOiBudW1iZXIsIHRleHR1cmVDb29yZEhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25IYW5kbGUsIDMsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uSGFuZGxlKTtcbiAgICBpZiAodGV4dHVyZUNvb3JkSGFuZGxlICE9PSAtMSkge1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXh0dXJlQ29vcmRIYW5kbGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDEyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleHR1cmVDb29yZEhhbmRsZSk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW0oXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLFxuICAgICAgZnJhZ1NoYWRlcjogV2ViR0xTaGFkZXIsXG4gICAgICApOiBXZWJHTFByb2dyYW0ge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpITtcblxuICAgIC8vIHRoZSBwcm9ncmFtIGNvbnNpc3RzIG9mIG91ciBzaGFkZXJzXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGNvbXBpbGVTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcsIHNoYWRlclR5cGU6IG51bWJlcik6IFdlYkdMU2hhZGVyIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7c2hhZGVyVHlwZX1gKTtcbiAgICB9XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7Z2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpfVxuU2hhZGVyIHNvdXJjZTpcbiR7c2hhZGVyU291cmNlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG4gIGRlbGV0ZVNoYWRlcihzaGFkZXI6IFdlYkdMU2hhZGVyKTogdm9pZCB7XG4gICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgfVxuICBiaW5kVGV4dHVyZVRvVW5pZm9ybSh0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHBvc2l0aW9uOiBudW1iZXIsIHVuaWZvcm1IYW5kbGU6IFdlYkdMVW5pZm9ybUxvY2F0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBwb3NpdGlvbik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1IYW5kbGUsIHBvc2l0aW9uKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBkcmF3KCk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBjaGVja0Vycm9yKCk6IHZvaWQge1xuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgIGNvbnN0IGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgIGxldCBsYWJlbCA9ICcnO1xuICAgICAgc3dpdGNoIChlcnJvcikge1xuICAgICAgICBjYXNlIChnbC5OT19FUlJPUik6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX0VOVU0pOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgKGdsLklOVkFMSURfVkFMVUUpOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfVkFMVUUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX09QRVJBVElPTik6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTik6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5PVVRfT0ZfTUVNT1JZKTpcbiAgICAgICAgICBsYWJlbCA9ICdPVVRfT0ZfTUVNT1JZJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAoZ2wuQ09OVEVYVF9MT1NUX1dFQkdMKTpcbiAgICAgICAgICBsYWJlbCA9ICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxhYmVsID0gYFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZXJyb3IudG9TdHJpbmcoMTYpfWA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwpO1xuICAgIH1cbiAgfVxuICBkZWxldGVUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgfVxuICBkZWxldGVQcm9ncmFtKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgfVxuICBnZXRFbmNvZGVyKGRhdGFUeXBlOiBFbmNvZGVyLkRhdGFUeXBlLCBjaGFubmVsczogbnVtYmVyLCB1c2FnZTogRW5jb2Rlci5Vc2FnZSA9IEVuY29kZXIuVXNhZ2UuRGVmYXVsdCk6IERhdGFFbmNvZGVyIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SZWRGbG9hdDMyRGF0YUVuY29kZXIodGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LCBjaGFubmVscyk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBpZiAodXNhZ2UgPT09IEVuY29kZXIuVXNhZ2UuVXBsb2FkT25seSB8fCB0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SR0JBRmxvYXREYXRhRW5jb2RlcihcbiAgICAgICAgICAgICAgdGhpcy5nbCwgY2hhbm5lbHMsIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiEuSEFMRl9GTE9BVF9PRVMpO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgY2FzZSAnYnl0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCwgY2hhbm5lbHMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGFUeXBlOiAke2RhdGFUeXBlfWApO1xuICAgIH1cbiAgfVxuICBjbGVhckFjdGl2ZVRleHR1cmVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBmb3IgKGxldCB1bml0ID0gMDsgdW5pdCA8IHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM7ICsrdW5pdCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXQpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleGJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZmluaXNoKCk7XG4gICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpOiBGbG9hdDMyQXJyYXkge1xuICAgIC8vIFNldHMgb2YgeCx5LHooPTApLHMsdCBjb29yZGluYXRlcy5cbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMS4wLCAxLjAsICAwLjAsIDAuMCwgMS4wLCAgLy8gdXBwZXIgbGVmdFxuICAgICAgLTEuMCwgLTEuMCwgMC4wLCAwLjAsIDAuMCwgIC8vIGxvd2VyIGxlZnRcbiAgICAgIDEuMCwgIDEuMCwgIDAuMCwgMS4wLCAxLjAsICAvLyB1cHBlciByaWdodFxuICAgICAgMS4wLCAgLTEuMCwgMC4wLCAxLjAsIDAuMCAgIC8vIGxvd2VyIHJpZ2h0XG4gICAgXSk7XG4gIH1cbiAgcHJpdmF0ZSBjcmVhdGVWZXJ0ZXhidWZmZXIoKTogV2ViR0xCdWZmZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCdWZmZXIoKSByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHByaXZhdGUgY3JlYXRlRnJhbWVidWZmZXIoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG4gICAgY29uc3QgZmIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgaWYgKCFmYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVGcmFtZWJ1ZmZlciByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBmYjtcbiAgfVxuXG4gIHByaXZhdGUgcXVlcnlWaXRhbFBhcmFtZXRlcnMoKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyID0gdGhpcy5jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk7XG4gICAgdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrUmVuZGVyRmxvYXQzMigpO1xuICAgIHRoaXMuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCk7XG5cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxICYmICF0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gJiYgIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuaXNCbGVuZFN1cHBvcnRlZCA9ICF0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCB8fCB0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCk7XG5cbiAgICAvLyB0aGlzLm1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgdGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0cyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgLy8gdGhpcy5tYXhDdWJlTWFwVGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSk7XG4gICAgLy8gdGhpcy5zaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTik7XG4gICAgLy8gdGhpcy53ZWJnbFZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihnbC5WRU5ET1IpO1xuICAgIC8vIHRoaXMud2ViZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgLy8gdGhpcy5tYXgzRFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUFYXzNEX1RFWFRVUkVfU0laRSk7XG4gICAgICAvLyB0aGlzLm1heEFycmF5VGV4dHVyZUxheWVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyk7XG4gICAgICAvLyB0aGlzLm1heENvbG9yQXR0YWNobWVudHMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfQ09MT1JfQVRUQUNITUVOVFMpO1xuICAgICAgLy8gdGhpcy5tYXhEcmF3QnVmZmVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGdldEV4dGVuc2lvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPSB0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk6IGJvb2xlYW4ge1xuICAgIC8vIHRlc3Qgd2hldGhlciBGbG9hdDMyIHRleHR1cmUgaXMgc3VwcG9ydGVkOlxuICAgIC8vIFNURVAuMSBjcmVhdGUgYSBmbG9hdCB0ZXh0dXJlXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gdGhpcy52ZXJzaW9uID09PSAyID8gKGdsIGFzIHVua25vd24gYXMge1JHQkEzMkY6IG51bWJlcn0pLlJHQkEzMkYgOiBnbC5SR0JBO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICAvLyBTVEVQLjIgYmluZCBhIGZyYW1lIGJ1ZmZlclxuICAgIGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAvLyBTVEVQLjMgYXR0YWNoIHRleHR1cmUgdG8gZnJhbWVidWZmZXJcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIC8vIFNURVAuNCB0ZXN0IHdoZXRoZXIgZnJhbWVidWZmZXIgaXMgY29tcGxldGVcbiAgICBjb25zdCBpc0NvbXBsZXRlID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1ZmZlcik7XG4gICAgcmV0dXJuIGlzQ29tcGxldGU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrUmVuZGVyRmxvYXQzMigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBpZiAoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0MzJEb3dubG9hZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBpZiAoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgR0xfQkxFTkQgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBwcml2YXRlIGNoZWNrRmxvYXQzMkJsZW5kKCk6IGJvb2xlYW4ge1xuICAgIC8vIGl0IGxvb2tzIGxpa2UgY3VycmVudGx5ICgyMDE5LTA1LTA4KSB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3Qgd2hldGhlciBCTEVORCBpcyBzdXBwb3J0ZWRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhqcy9pc3N1ZXMvMTQ1XG5cbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBsZXQgdGV4dHVyZTogV2ViR0xUZXh0dXJlfG51bGx8dW5kZWZpbmVkO1xuICAgIGxldCBmcmFtZUJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyfG51bGx8dW5kZWZpbmVkO1xuICAgIGxldCBwcm9ncmFtOiBXZWJHTFByb2dyYW18bnVsbHx1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMudmVyc2lvbiA9PT0gMiA/IChnbCBhcyB1bmtub3duIGFzIHtSR0JBMzJGOiBudW1iZXJ9KS5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICBpZiAoIXZlcnRleFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCAndm9pZCBtYWluKCl7fScpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKCFmcmFnbWVudFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXZlYzQoMC41KTt9Jyk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcbiAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcblxuICAgIH0gZmluYWxseSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgaWYgKHByb2dyYW0pIHtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZUJ1ZmZlcikge1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBiZWdpblRpbWVyKCk6IFdlYkdMUXVlcnkge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIgJiYgdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IGdsMiA9IHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO1xuXG4gICAgICBjb25zdCBxdWVyeSA9IGdsMi5jcmVhdGVRdWVyeSgpIGFzIFdlYkdMUXVlcnk7XG4gICAgICBnbDIuYmVnaW5RdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcbiAgICAgIGdsMi5lbmRRdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkZCB3ZWJnbCAxIGhhbmRsaW5nLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgaXNUaW1lclJlc3VsdEF2YWlsYWJsZShxdWVyeTogV2ViR0xRdWVyeSk6IGJvb2xlYW4ge1xuICAgIGxldCBhdmFpbGFibGUgPSBmYWxzZSwgZGlzam9pbnQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcblxuICAgICAgYXZhaWxhYmxlID0gZ2wyLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBnbDIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7XG4gICAgICBkaXNqb2ludCA9IGdsMi5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICB9XG5cbiAgZ2V0VGltZXJSZXN1bHQocXVlcnk6IFdlYkdMUXVlcnkpOiBudW1iZXIge1xuICAgIGxldCB0aW1lRWxhcHNlZCA9IDA7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgdGltZUVsYXBzZWQgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFQpO1xuICAgICAgZ2wyLmRlbGV0ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIG1pbGlzZWNvbmRzXG4gICAgcmV0dXJuIHRpbWVFbGFwc2VkIC8gMTAwMDAwMDtcbiAgfVxuXG4gIGFzeW5jIHdhaXRGb3JRdWVyeUFuZEdldFRpbWUocXVlcnk6IFdlYkdMUXVlcnkpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGF3YWl0IHJlcGVhdGVkVHJ5KCgpID0+IHRoaXMuaXNUaW1lclJlc3VsdEF2YWlsYWJsZShxdWVyeSkpO1xuICAgIHJldHVybiB0aGlzLmdldFRpbWVyUmVzdWx0KHF1ZXJ5KTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vYmFja2VuZCc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7TG9nZ2VyLCBQcm9maWxlcn0gZnJvbSAnLi9pbnN0cnVtZW50JztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5cbmNsYXNzIEtlcm5lbE9wIHtcbiAgY29uc3RydWN0b3IocHVibGljIG9wOiBPcGVyYXRvciwgcHVibGljIG5vZGU6IEdyYXBoLk5vZGUpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBFeGVjdXRpb25QbGFuIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBncmFwaDogR3JhcGgsIG9wczogT3BlcmF0b3JbXSwgcHJpdmF0ZSBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+KSB7XG4gICAgdGhpcy5pbml0aWFsaXplKG9wcyk7XG4gIH1cblxuICBpbml0aWFsaXplKG9wczogT3BlcmF0b3JbXSkge1xuICAgIHRoaXMucHJvZmlsZXIuZXZlbnQoJ3Nlc3Npb24nLCAnRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplJywgKCkgPT4ge1xuICAgICAgY29uc3QgZ3JhcGhOb2RlcyA9IHRoaXMuZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChncmFwaE5vZGVzLmxlbmd0aCAhPT0gb3BzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzaXplIG9mIG5vZGVzIGFuZCBPUHMgZG8gbm90IG1hdGNoLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcHMgPSBvcHMubWFwKChvcCwgaSkgPT4gbmV3IEtlcm5lbE9wKG9wLCBncmFwaE5vZGVzW2ldKSk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgIC8vIGxvb2sgZm9yIHN0YXJ0ZXIgbm9kZShzKVxuICAgICAgdGhpcy5fc3RhcnRlciA9IFtdO1xuICAgICAgdGhpcy5fb3BzLmZvckVhY2goKG9wLCBpKSA9PiB7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygb3Aubm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF0aGlzLl92YWx1ZXNbaW5wdXRdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYW4gaW5pdGlhbGl6ZWQgaW5wdXRcbiAgICAgICAgICAgICAgJiYgdGhpcy5ncmFwaC5nZXRJbnB1dEluZGljZXMoKS5pbmRleE9mKGlucHV0KSA9PT0gLTEgIC8vIG5vdCBtb2RlbCBpbnB1dFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICB0aGlzLl9zdGFydGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gdGhpcy5ncmFwaC5nZXRWYWx1ZXMoKS5tYXAoaSA9PiBpLnRlbnNvcik7XG4gIH1cblxuICBhc3luYyBleGVjdXRlKHNlc3Npb25IYW5kbGVyOiBTZXNzaW9uSGFuZGxlciwgbW9kZWxJbnB1dHM6IFRlbnNvcltdKTogUHJvbWlzZTxUZW5zb3JbXT4ge1xuICAgIHJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ0V4ZWN1dGlvblBsYW4uZXhlY3V0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHJlc2V0IG1lZGllbSByZXN1bHRcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgLy8gY3JlYXRlIGluZmVyZW5jZSBoYW5kbGVyXG4gICAgICBjb25zdCBpbmZlcmVuY2VIYW5kbGVyID0gc2Vzc2lvbkhhbmRsZXIuY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpO1xuXG4gICAgICAvLyBwb3B1bGF0ZSBpbnB1dHMgdmFsdWVcbiAgICAgIGNvbnN0IGdyYXBoSW5wdXRzID0gdGhpcy5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGlmIChtb2RlbElucHV0cy5sZW5ndGggIT09IGdyYXBoSW5wdXRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG51bWJlciBvZiBpbnB1dCB0ZW5zb3JzIGRvbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgaW5wdXRzIHRvIHRoZSBtb2RlbDogYWN0dWFsOiAke1xuICAgICAgICAgICAgbW9kZWxJbnB1dHMubGVuZ3RofSBleHBlY3RlZDogJHtncmFwaElucHV0cy5sZW5ndGh9YCk7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsSW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ3JhcGhJbnB1dHNbaV07XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSBpbnB1dDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcmVwYXJlIHJ1bm5pbmcgc2VxdWVuY2VcbiAgICAgIGNvbnN0IHNlcXVlbmNlOiBudW1iZXJbXSA9IHRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCk7XG5cbiAgICAgIC8vIGV4ZWN1dGlvbiBpdGVyYXRpb25zXG4gICAgICBjb25zdCBncmFwaFZhbHVlcyA9IHRoaXMuZ3JhcGguZ2V0VmFsdWVzKCk7XG4gICAgICBjb25zdCBncmFwaE5vZGVzID0gdGhpcy5ncmFwaC5nZXROb2RlcygpO1xuXG4gICAgICBsZXQgcmVhciA9IDA7XG4gICAgICB3aGlsZSAocmVhciA8IHNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0aGlzT3BJbmRleCA9IHNlcXVlbmNlW3JlYXIrK107XG4gICAgICAgIGNvbnN0IHRoaXNPcCA9IHRoaXMuX29wc1t0aGlzT3BJbmRleF07XG5cbiAgICAgICAgLy8gY2hlY2sgaW5wdXRcbiAgICAgICAgY29uc3QgaW5wdXRMaXN0ID0gdGhpc09wLm5vZGUuaW5wdXRzLm1hcChpID0+IHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgIGlmIChpbnB1dExpc3QuaW5kZXhPZih1bmRlZmluZWQpICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZXNvbHZlZCBpbnB1dCBkZXRlY3RlZDogb3A6ICR7dGhpc09wLm5vZGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW5cbiAgICAgICAgY29uc3QgaW5wdXRUZW5zb3JzID0gaW5wdXRMaXN0IGFzIFRlbnNvcltdO1xuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICdFeGVjUGxhbicsXG4gICAgICAgICAgICBgUnVuaW5nIG9wOiR7dGhpc09wLm5vZGUubmFtZX0gKCR7XG4gICAgICAgICAgICAgICAgaW5wdXRUZW5zb3JzLm1hcCgodCwgaSkgPT4gYCcke3RoaXNPcC5ub2RlLmlucHV0c1tpXX0nOiAke3QudHlwZX1bJHt0LmRpbXMuam9pbignLCcpfV1gKS5qb2luKCcsICcpfSlgKTtcblxuICAgICAgICBjb25zdCBleGVjTm9kZUZuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wID0gdGhpc09wLm9wO1xuICAgICAgICAgIGlmICghb3AuY2hlY2tJbnB1dHMoaW5wdXRUZW5zb3JzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0cyBkZXRlY3RlZDsgb3A6ICR7dGhpc09wLm5vZGUubmFtZX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcC5ydW4oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRUZW5zb3JzKTtcblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0TGlzdCA9IGF3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoJ25vZGUnLCB0aGlzT3Aubm9kZS5uYW1lLCBleGVjTm9kZUZuKTtcblxuICAgICAgICAvLyBjaGVjayBvdXRwdXRcbiAgICAgICAgaWYgKG91dHB1dExpc3QubGVuZ3RoICE9PSB0aGlzT3Aubm9kZS5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIHNpemUgb2Ygb3V0cHV0IGRvZXMgbm90IG1hdGNoIG1vZGVsIGRlZmluaXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWxsIHZhbHVlXG4gICAgICAgIG91dHB1dExpc3QuZm9yRWFjaCgob3V0cHV0LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaiA9IHRoaXNPcC5ub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tqXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXQgWyR7an1dIGFscmVhZHkgaGFzIHZhbHVlOiBvcDoke3RoaXNPcC5ub2RlLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3ZhbHVlc1tqXSA9IG91dHB1dDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBkb3duc3RyZWFtIG5vZGVzXG4gICAgICAgIGNvbnN0IGRvd25zdHJlYW1Ob2RlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICAgICAgICBvdXRwdXRMaXN0LmZvckVhY2goKG91dHB1dCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGogPSB0aGlzT3Aubm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXggb2YgZ3JhcGhWYWx1ZXNbal0udG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREb3duc3RyZWFtTm9kZSA9IGdyYXBoTm9kZXNbY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXhdO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBjdXJyZW50RG93bnN0cmVhbU5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fdmFsdWVzW2tdKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgIGRvd25zdHJlYW1Ob2Rlcy5hZGQoY3VycmVudERvd25zdHJlYW1Ob2RlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlcXVlbmNlLnB1c2goLi4uZG93bnN0cmVhbU5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0OiBUZW5zb3JbXSA9IFtdO1xuICAgICAgdGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkuZm9yRWFjaCgob3V0cHV0SW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdGhpc1ZhbHVlID0gdGhpcy5fdmFsdWVzW291dHB1dEluZGV4XTtcbiAgICAgICAgaWYgKHRoaXNWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXF1aXJlZCBvdXRwdXQgWyR7b3V0cHV0SW5kZXh9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICB0aGlzVmFsdWUuZGF0YTtcbiAgICAgICAgb3V0cHV0LnB1c2godGhpc1ZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ0V4ZWNQbGFuJywgJ2Rpc3Bvc2luZyBvZiBpbmZlcmVuY2VIYW5kbGVyJyk7XG4gICAgICBpbmZlcmVuY2VIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG4gIH1cblxuICBfdmFsdWVzOiBBcnJheTxUZW5zb3J8dW5kZWZpbmVkPjtcbiAgX29wczogS2VybmVsT3BbXTtcbiAgX3N0YXJ0ZXI6IG51bWJlcltdO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7b25ueH0gZnJvbSAnb25ueC1wcm90byc7XG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuL2F0dHJpYnV0ZSc7XG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQgb3J0RmJzID0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQge0xvbmdVdGlsLCBQcm90b1V0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBHcmFwaCB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgU2hhcGUge1xuICAgIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsdWVUeXBlIHtcbiAgICByZWFkb25seSB0ZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGU7XG4gICAgcmVhZG9ubHkgc2hhcGU6IFNoYXBlO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVmFsdWUge1xuICAgIC8vIHRoZSB0ZW5zb3IgZGF0YS4gZW1wdHkgZm9yIG5vbi1pbml0aWFsaXplZCBpbnB1dHNcbiAgICByZWFkb25seSB0ZW5zb3I/OiBUZW5zb3I7XG5cbiAgICAvLyBpbmRleCB0byB0aGUgTm9kZSB3aGVyZSB0aGUgdmFsdWUgY29tZXMgZnJvbS4gLTEgZm9yIGluaXRpYWxpemVyLlxuICAgIHJlYWRvbmx5IGZyb206IG51bWJlcjtcblxuICAgIC8vIGluZGljZXMgdG8gdGhlIE5vZGVzIHdoZXJlIHRoZSB2YWx1ZXMgZ28gdG8uXG4gICAgcmVhZG9ubHkgdG86IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgLy8gdmFsdWUgdHlwZSBzcGVjaWZpY2F0aW9uLiBlbXB0eSBmb3Igbm9uLWlucHV0IHZhbHVlcy5cbiAgICByZWFkb25seSB0eXBlPzogVmFsdWVUeXBlO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTm9kZSB7XG4gICAgLy8gbmFtZSBvZiB0aGUgbm9kZVxuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcblxuICAgIC8vIHRoZSBvcGVyYXRvciB0eXBlXG4gICAgcmVhZG9ubHkgb3BUeXBlOiBzdHJpbmc7XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBWYWx1ZXMgd2hlcmUgdGhlIGlucHV0cyBjb21lIGZyb20uXG4gICAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIGluZGljZXMgdG8gdGhlIFZhbHVlcyB3aGVyZSB0aGUgb3V0cHVzIGdvIHRvLlxuICAgIHJlYWRvbmx5IG91dHB1dHM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgLy8gdGhlIGF0dHJpYnV0ZXMgdGhhdCB1c2VkIGJ5IHRoZSBvcGVyYXRvclxuICAgIHJlYWRvbmx5IGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhIFRyYW5zZm9ybWVyIGlzIGFuIGluc3RhbmNlIHRoYXQgYWxsb3dzIGFsbCBwb3NzaWJsZSB0cmFuc2Zvcm1hdGlvbiBvcGVyYXRpb25zIHRoYXQgYXBwbGllZCB0byBhIGdyYXBoXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFRyYW5zZm9ybWVyIHtcbiAgICByZW1vdmVBbGxJZGVudGl0eU5vZGVzKCk6IHZvaWQ7XG4gICAgcmVtb3ZlQWxsRHJvcG91dE5vZGVzKCk6IHZvaWQ7XG4gICAgLy8gVE9ETzogYWRkIGdlbmVyaWMgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoXG4gIH1cblxuICAvLyBhbiBpbml0aWFsaXplciBjYW4gdXNlIHRyYW5zZm9ybWVyIHRvIHRyYW5zZm9ybSB0aGUgZ3JhcGhcbiAgZXhwb3J0IGludGVyZmFjZSBJbml0aWFsaXplciB7XG4gICAgdHJhbnNmb3JtR3JhcGgodHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBHcmFwaCB7XG4gIGdldElucHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXTtcbiAgZ2V0T3V0cHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0T3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW107XG4gIGdldFZhbHVlcygpOiByZWFkb25seSBHcmFwaC5WYWx1ZVtdO1xuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW107XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbmV4cG9ydCBjb25zdCBHcmFwaCA9IHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdCBhIGdyYXBoIGZyb20gYSBncmFwaCBwcm90b2J1ZiB0eXBlXG4gICAqL1xuICBmcm9tOiAoZ3JhcGhQcm90bzogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgsIGluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpID0+XG4gICAgICBuZXcgR3JhcGhJbXBsKGdyYXBoUHJvdG8sIGluaXRpYWxpemVyKSxcbn07XG5cbmNsYXNzIFZhbHVlIGltcGxlbWVudHMgR3JhcGguVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZUluZm8/OiBvbm54LklWYWx1ZUluZm9Qcm90bykge1xuICAgIHRoaXMuX2Zyb20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG8gPSBbXTtcbiAgICB0aGlzLnRlbnNvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodmFsdWVJbmZvKSB7XG4gICAgICB0aGlzLnR5cGUgPSBQcm90b1V0aWwudGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlSW5mby50eXBlIS50ZW5zb3JUeXBlISk7XG4gICAgfVxuICB9XG5cbiAgX2Zyb20/OiBudW1iZXI7ICAvLyAtMSByZXByZXNlbnQgZnJvbSBpbml0aWFsaXplclxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJvbSE7XG4gIH1cbiAgX3RvOiBudW1iZXJbXTtcbiAgZ2V0IHRvKCkge1xuICAgIHJldHVybiB0aGlzLl90bztcbiAgfVxuICB0eXBlPzogR3JhcGguVmFsdWVUeXBlO1xuICB0ZW5zb3I/OiBUZW5zb3I7XG59XG5cbmNsYXNzIE5vZGUgaW1wbGVtZW50cyBHcmFwaC5Ob2RlIHtcbiAgY29uc3RydWN0b3IoX25vZGVQcm90bzogb25ueC5JTm9kZVByb3RvfG9ydEZicy5Ob2RlLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgaWYgKF9ub2RlUHJvdG8gaW5zdGFuY2VvZiBvbm54Lk5vZGVQcm90bykge1xuICAgICAgdGhpcy5uYW1lID0gX25vZGVQcm90by5uYW1lO1xuICAgICAgdGhpcy5vcFR5cGUgPSBfbm9kZVByb3RvLm9wVHlwZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUoX25vZGVQcm90by5hdHRyaWJ1dGUpO1xuICAgIH0gZWxzZSBpZiAoX25vZGVQcm90byBpbnN0YW5jZW9mIG9ydEZicy5Ob2RlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lID8/IF9ub2RlUHJvdG8ubmFtZSgpITtcbiAgICAgIHRoaXMub3BUeXBlID0gX25vZGVQcm90by5vcFR5cGUoKSE7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKFByb3RvVXRpbC50ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChfbm9kZVByb3RvKSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICB0aGlzLmV4ZWN1dGVOb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIG5hbWU6IHN0cmluZztcbiAgb3BUeXBlOiBzdHJpbmc7XG4gIGlucHV0czogbnVtYmVyW107XG4gIG91dHB1dHM6IG51bWJlcltdO1xuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIGV4ZWN1dGVOb2RlOiBib29sZWFuO1xufVxuXG5jbGFzcyBHcmFwaEltcGwgaW1wbGVtZW50cyBHcmFwaCwgR3JhcGguVHJhbnNmb3JtZXIge1xuICBwcml2YXRlIF9hbGxEYXRhOiBWYWx1ZVtdO1xuXG4gIHByaXZhdGUgX2FsbElucHV0SW5kaWNlczogbnVtYmVyW107XG4gIHByaXZhdGUgX2FsbElucHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgX2FsbE91dHB1dEluZGljZXM6IG51bWJlcltdO1xuICBwcml2YXRlIF9hbGxPdXRwdXROYW1lczogc3RyaW5nW107XG5cbiAgcHJpdmF0ZSBfbm9kZXM6IE5vZGVbXTtcblxuICBjb25zdHJ1Y3RvcihncmFwaDogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgsIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikge1xuICAgIGlmICghZ3JhcGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dyYXBoIGlzIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIGdyYXBoIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIHRoaXMuYnVpbGRHcmFwaChncmFwaCk7XG5cbiAgICAvLyBleGVjdXRlIGFueSB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBmb3IgdGhlIGdyYXBoIChpZiBhcHBsaWNhYmxlKVxuICAgIHRoaXMudHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcik7XG5cbiAgICAvLyBjaGVjayBmb3IgY3ljbGVzIGFuZCBvdGhlciBpbmNvbnNpc3RlbmNpZXMgLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgdGhpcy5jaGVja0lzQWN5Y2xpYygpO1xuICB9XG5cbiAgZ2V0SW5wdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsSW5wdXRJbmRpY2VzO1xuICB9XG5cbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXM7XG4gIH1cblxuICBnZXRPdXRwdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcztcbiAgfVxuXG4gIGdldE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXRWYWx1ZXMoKTogcmVhZG9ubHkgR3JhcGguVmFsdWVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbERhdGE7XG4gIH1cblxuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW10ge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaChncmFwaDogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgpIHtcbiAgICAvLyBidWlsZCB0aGUgZ3JhcGggLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgaWYgKGdyYXBoIGluc3RhbmNlb2Ygb25ueC5HcmFwaFByb3RvKSB7XG4gICAgICB0aGlzLmJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdChncmFwaCk7XG4gICAgfSBlbHNlIGlmIChncmFwaCBpbnN0YW5jZW9mIG9ydEZicy5HcmFwaCkge1xuICAgICAgdGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdChncmFwaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBidWlsZEdyYXBoRnJvbU9ubnhGb3JtYXQoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG8pIHtcbiAgICBjb25zdCBkYXRhSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgdGhpcy5fYWxsRGF0YSA9IFtdO1xuXG4gICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsSW5wdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuXG4gICAgY29uc3Qgbm9kZXNJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAgIC8vIHNjYW4gYWxsIGlucHV0c1xuICAgIGlmICghZ3JhcGguaW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRWYWx1ZU5hbWVzID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIGdyYXBoLmlucHV0KSB7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGkubmFtZSEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBpbnB1dCBuYW1lOiAke2kubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoaSkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBjdXJyZW50SW5kZXgpO1xuICAgICAgaW5wdXRWYWx1ZU5hbWVzLnB1c2goaS5uYW1lISk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgaW5pdGlhbGl6ZXJzXG4gICAgaWYgKCFncmFwaC5pbml0aWFsaXplcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBpbml0aWFsaXplcicpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgZ3JhcGguaW5pdGlhbGl6ZXIpIHtcbiAgICAgIGxldCBpbmRleCA9IGRhdGFJbmRpY2VzLmdldChpLm5hbWUhKTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgIHZhbHVlLnR5cGUgPSB7XG4gICAgICAgICAgc2hhcGU6IHtkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhpLmRpbXMhKX0sXG4gICAgICAgICAgdGVuc29yVHlwZTogUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGkuZGF0YVR5cGUhKVxuICAgICAgICB9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaS5uYW1lISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8oaSk7XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBpbnB1dCBpbmRpY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuX2FsbERhdGFbaV0udGVuc29yKSB7XG4gICAgICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goaW5wdXRWYWx1ZU5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBvdXRwdXRzXG4gICAgaWYgKCFncmFwaC5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogb3V0cHV0Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBvZiBncmFwaC5vdXRwdXQpIHtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaS5uYW1lISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke2kubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoaSkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKGkubmFtZSEpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGUnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlUHJvdG8gb2YgZ3JhcGgubm9kZSkge1xuICAgICAgaWYgKCFub2RlUHJvdG8ubmFtZSkge1xuICAgICAgICAvLyBhc3NpZ24gYSBuYW1lIHRvIHRoZSBub2RlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgZm9yIChsZXQgcGljayA9IDA7OyBwaWNrKyspIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYHVubmFtZWRfJHtub2RlUHJvdG8ub3BUeXBlfV8ke3BpY2t9YDtcbiAgICAgICAgICBpZiAoIW5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGVQcm90by5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNJbmRpY2VzLmhhcyhub2RlUHJvdG8ubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChub2RlUHJvdG8ubmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZVtpXTtcbiAgICAgIGlmICghbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXQsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5vdXRwdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHtkYXRhSW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gaTtcblxuICAgICAgICAvLyBmb3IgdGhlICdDb25zdGFudCcgb3BlcmF0b3IsIGp1c3QgY3JlYXRlIGEgbmV3IGVkZ2UgaW4gdGhlIGdyYXBoIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdvdXRwdXQnIG9mIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgaWdub3JlIHRoZSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICAgIGlmIChub2RlUHJvdG8ub3BUeXBlID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8uYXR0cmlidXRlIHx8IG5vZGVQcm90by5hdHRyaWJ1dGUubGVuZ3RoICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlWzBdLnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8ub3V0cHV0IHx8IG5vZGVQcm90by5vdXRwdXQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8obm9kZVByb3RvLmF0dHJpYnV0ZVswXS50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVbaV07XG5cbiAgICAgIGlmICghbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2lucHV0fScgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbnB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fdG8ucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaEZyb21PcnRGb3JtYXQoZ3JhcGg6IG9ydEZicy5HcmFwaCkge1xuICAgIGNvbnN0IGRhdGFJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxEYXRhID0gW107XG5cbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxJbnB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX25vZGVzID0gW107XG5cbiAgICBjb25zdCBub2Rlc0luZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXG4gICAgLy8gc2NhbiBhbGwgaW5wdXRzXG4gICAgY29uc3QgaW5wdXRWYWx1ZU5hbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5pbnB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBpbnB1dE5hbWUgPSBncmFwaC5pbnB1dHMoaSk7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGlucHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7aW5wdXROYW1lfWApO1xuICAgICAgfVxuICAgICAgLy8gRmluZCB0aGUgaW5wdXQgdHlwZUluZm8gZnJvbSBub2RlYXJnc1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaC5ub2RlQXJnc0xlbmd0aCgpOyBqKyspIHtcbiAgICAgICAgaWYgKGdyYXBoLm5vZGVBcmdzKGopPy5uYW1lKCkgPT09IGlucHV0TmFtZSkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ3JhcGgubm9kZUFyZ3Moaik/LnR5cGUoKT8udmFsdWVUeXBlKCk7XG4gICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPT0gb3J0RmJzLlR5cGVJbmZvVmFsdWUudGVuc29yX3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSB0eXBlIGZvciB0aGUgbm9kZUFyZy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdmFsdWVJbmZvID0gZ3JhcGgubm9kZUFyZ3MoaikhLnR5cGUoKSEudmFsdWUobmV3IG9ydEZicy5UZW5zb3JUeXBlQW5kU2hhcGUoKSkhO1xuICAgICAgICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odmFsdWVJbmZvLmVsZW1UeXBlKCkpO1xuICAgICAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWVJbmZvLnNoYXBlKCkhO1xuICAgICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNoYXBlLmRpbUxlbmd0aCgpITsgaysrKSB7XG4gICAgICAgICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHNoYXBlLmRpbShrKSEudmFsdWUoKSEuZGltVmFsdWUoKSEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUudHlwZSA9IHtzaGFwZToge2RpbXN9LCB0ZW5zb3JUeXBlOiB0eXBlfTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2godmFsdWUpIC0gMTtcbiAgICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaW5wdXROYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgIGlucHV0VmFsdWVOYW1lcy5wdXNoKGlucHV0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgaW5pdGlhbGl6ZXJzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5pbml0aWFsaXplcnNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBpbml0aWFsaXplciA9IGdyYXBoLmluaXRpYWxpemVycyhpKSE7XG4gICAgICBsZXQgaW5kZXggPSBkYXRhSW5kaWNlcy5nZXQoaW5pdGlhbGl6ZXIubmFtZSgpISk7XG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBWYWx1ZSgpO1xuICAgICAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KGluaXRpYWxpemVyKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhpbml0aWFsaXplci5kYXRhVHlwZSgpKTtcbiAgICAgICAgdmFsdWUudHlwZSA9IHtzaGFwZToge2RpbXN9LCB0ZW5zb3JUeXBlOiB0eXBlfTtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2godmFsdWUpIC0gMTtcbiAgICAgICAgZGF0YUluZGljZXMuc2V0KGluaXRpYWxpemVyLm5hbWUoKSEsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICB0aGlzLl9hbGxEYXRhW2luZGV4XS50ZW5zb3IgPSBUZW5zb3IuZnJvbU9ydFRlbnNvcihpbml0aWFsaXplcik7XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBpbnB1dCBpbmRpY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuX2FsbERhdGFbaV0udGVuc29yKSB7XG4gICAgICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goaW5wdXRWYWx1ZU5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5vdXRwdXRzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3Qgb3V0cHV0TmFtZSA9IGdyYXBoLm91dHB1dHMoaSk7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKG91dHB1dE5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBvdXRwdXQgbmFtZTogJHtvdXRwdXROYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZSgpKSAtIDE7XG4gICAgICBkYXRhSW5kaWNlcy5zZXQob3V0cHV0TmFtZSwgY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMucHVzaChvdXRwdXROYW1lKTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBub2Rlc1xuICAgIGlmICghZ3JhcGgubm9kZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogbm9kZScpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm5vZGVzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZXMoaSk7XG4gICAgICBsZXQgbmFtZSA9IG5vZGVQcm90byEubmFtZSgpO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIGFzc2lnbiBhIG5hbWUgdG8gdGhlIG5vZGUgaWYgaXQgZG9lc24ndCBoYXZlIG9uZVxuICAgICAgICBmb3IgKGxldCBwaWNrID0gMDs7IHBpY2srKykge1xuICAgICAgICAgIG5hbWUgPSBgdW5uYW1lZF8ke25vZGVQcm90byEub3BUeXBlKCl9XyR7cGlja31gO1xuICAgICAgICAgIGlmICghbm9kZXNJbmRpY2VzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gYW4gdW5pcXVlIG5hbWUgaXMgZm91bmQuIGJyZWFrLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc0luZGljZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7bmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvISwgbmFtZSkpIC0gMTtcbiAgICAgIG5vZGVzSW5kaWNlcy5zZXQobmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZXMoaSk7XG4gICAgICBpZiAobm9kZVByb3RvID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBub2RlIGV4aXN0cyBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZVByb3RvPy5vdXRwdXRzTGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZVByb3RvPy5vdXRwdXRzTGVuZ3RoKCk7IGorKykge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBub2RlUHJvdG8/Lm91dHB1dHMoaik7XG4gICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQob3V0cHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZGF0YUluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKG5ldyBWYWx1ZSgpKSAtIDE7XG4gICAgICAgICAgZGF0YUluZGljZXMuc2V0KG91dHB1dCwgZGF0YUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm91dHB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke2RhdGFJbmRleH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gPSBpO1xuXG4gICAgICAgIC8vIGZvciB0aGUgJ0NvbnN0YW50JyBvcGVyYXRvciwganVzdCBjcmVhdGUgYSBuZXcgZWRnZSBpbiB0aGUgZ3JhcGggY29ycmVzcG9uZGluZyB0byB0aGUgJ291dHB1dCcgb2YgdGhlXG4gICAgICAgIC8vIG9wZXJhdG9yIGFuZCBpZ25vcmUgdGhlIG5vZGUgZnJvbSB0aGUgZ3JhcGhcbiAgICAgICAgaWYgKG5vZGVQcm90by5vcFR5cGUoKSA9PT0gJ0NvbnN0YW50Jykge1xuICAgICAgICAgIGlmIChub2RlUHJvdG8uYXR0cmlidXRlc0xlbmd0aCgpICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlcygwKSEudCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlUHJvdG8ub3V0cHV0c0xlbmd0aCgpICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKG5vZGVQcm90by5hdHRyaWJ1dGVzKDApIS50KCkhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVzKGkpITtcblxuICAgICAgaWYgKG5vZGVQcm90by5pbnB1dHNMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVQcm90by5pbnB1dHNMZW5ndGgoKSE7IGorKykge1xuICAgICAgICBjb25zdCBpbnB1dCA9IG5vZGVQcm90by5pbnB1dHMoaikhO1xuICAgICAgICBjb25zdCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtpbnB1dH0nIGZvciBub2RlOiAke25vZGVQcm90byEubmFtZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5wdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX3RvLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lzQWN5Y2xpYygpIHtcbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBncmFwaCBhbmQgY2hlY2sgZm9yIGN5Y2xlcyBvciBvdGhlciBmYXRhbCBpbmNvbnNpc3RlbmNpZXNcbiAgICBjb25zdCBzdGFydGVyczogU2V0PG51bWJlcj4gPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMuZm9yRWFjaChpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9hbGxEYXRhW2ldO1xuICAgICAgZGF0YS5fdG8uZm9yRWFjaChqID0+IHtcbiAgICAgICAgc3RhcnRlcnMuYWRkKGopO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBJdGVyYXRpdmUgREZTIHRvIGNoZWNrIGZvciBjeWNsZXNcbiAgICBjb25zdCBub2Rlc1N0YWNrID0gQXJyYXkuZnJvbShzdGFydGVycyk7XG4gICAgY29uc3Qgbm9kZXNTdGF0ZSA9IG5ldyBBcnJheTxzdHJpbmc+KHRoaXMuX25vZGVzLmxlbmd0aCkuZmlsbCgnd2hpdGUnKTtcblxuICAgIHdoaWxlIChub2Rlc1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGVzU3RhY2sucG9wKCkhO1xuICAgICAgLy8gdGhpcyBub2RlIGhhcyBub3cgYmVlbiBwcm9jZXNzZWQgY29tcGxldGVseS4gTWFyayB0aGlzIG5vZGUgJ2JsYWNrJyB0byBkZW5vdGUgdGhpcy5cbiAgICAgIGlmIChub2Rlc1N0YXRlW25vZGVJbmRleF0gPT09ICdncmF5Jykge1xuICAgICAgICBub2Rlc1N0YXRlW25vZGVJbmRleF0gPSAnYmxhY2snO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBub2RlIGlzIHVuZGVyIHByb2Nlc3Npbmcgc3RhZ2UuIG1hcmsgdGhpcyBub2RlICdncmF5JyB0byBkZW5vdGUgdGhpcy5cbiAgICAgICAgbm9kZXNTdGFjay5wdXNoKG5vZGVJbmRleCk7XG4gICAgICAgIG5vZGVzU3RhdGVbbm9kZUluZGV4XSA9ICdncmF5JztcblxuICAgICAgICB0aGlzLl9ub2Rlc1tub2RlSW5kZXhdLm91dHB1dHMuZm9yRWFjaCgob3V0Z29pbmdFZGdlSW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fYWxsRGF0YVtvdXRnb2luZ0VkZ2VJbmRleF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnRlbnNvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZSBvdXRwdXRzIHNob3VsZCBub3QgYmUgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEuX2Zyb20gIT09IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tIHByb3BlcnR5IG9mIHRoZSBWYWx1ZSBvYmplY3QgZG9lc25cXCd0IG1hdGNoIGluZGV4IG9mIE5vZGUgYmVpbmcgcHJvY2Vzc2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEuX3RvLmZvckVhY2goKGRvd25zdHJlYW1Ob2RlSW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGJhY2sgZWRnZSBmb3VuZCAtIGN5Y2xpY1xuICAgICAgICAgICAgaWYgKG5vZGVzU3RhdGVbZG93bnN0cmVhbU5vZGVJbmRleF0gPT09ICdncmF5Jykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsIGdyYXBoIGlzIGN5Y2xpYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJlZSBlZGdlIGZvdW5kIC0gY29udGludWUgcHJvY2Vzc2luZyBieSBhZGRpbmcgaXQgdG8gc3RhY2tcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVzU3RhdGVbZG93bnN0cmVhbU5vZGVJbmRleF0gPT09ICd3aGl0ZScpIHtcbiAgICAgICAgICAgICAgbm9kZXNTdGFjay5wdXNoKGRvd25zdHJlYW1Ob2RlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybUdyYXBoKGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcik6IHZvaWQge1xuICAgIC8vIGFwcGx5IGNvbW1vbiB0cmFuc2Zvcm1cbiAgICB0aGlzLnJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKTtcbiAgICB0aGlzLnJlbW92ZUFsbERyb3BvdXROb2RlcygpO1xuXG4gICAgLy8gYXBwbHkgaW5pdGlhbGl6ZXIgc3BlY2lmaWMgdHJhbnNmb3JtXG4gICAgaWYgKGdyYXBoSW5pdGlhbGl6ZXIpIHtcbiAgICAgIGdyYXBoSW5pdGlhbGl6ZXIudHJhbnNmb3JtR3JhcGgodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gZmluYWxpemUgZ3JhcGhcbiAgICB0aGlzLmZpbmFsaXplR3JhcGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5hbGl6ZSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhbGwgdGhlIHRyYW5zZm9ybWF0aW9uIGNvbXBsZXRlZC5cbiAgICogdGhpcyBmdW5jdGlvbiByZW1vdmVzIGFsbCB1bm5lY2Vzc2FyeSBub2RlcyBhbmQgdmFsdWVzIGZyb20gdGhlIGdyYXBoXG4gICAqL1xuICBmaW5hbGl6ZUdyYXBoKCkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIC8vIGRlbGV0ZSBhbGwgbm9kZXMgdGhhdCBhcmUgbm90IGJlaW5nIGV4ZWN1dGVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLl9ub2Rlc1tpXS5leGVjdXRlTm9kZSkge1xuICAgICAgICAvLyBkZWxldGUgdGhpcyBub2RlIGFuZCBzaGlmdCBhbGwgc3Vic2VxdWVudCBub2RlcyB1cFxuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgLy8gZGVsZXRlIGFsbCBvdXRwdXQgdmFsdWVzXG4gICAgICAgIHRoaXMuX25vZGVzW2ldLm91dHB1dHMuZm9yRWFjaChpbmQgPT4ge1xuICAgICAgICAgIHRoaXMuX2FsbERhdGFbaW5kXS5fZnJvbSA9IC0yO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSB0YWJsZVxuICAgICAgICB0aGlzLl9ub2Rlc1tpXS5pbnB1dHMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kID0gdGhpcy5fYWxsRGF0YVt2YWx1ZV0uX3RvLmluZGV4T2YoaSArIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbdmFsdWVdLl90b1tpbmRdID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9ub2Rlc1tpXS5vdXRwdXRzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW3ZhbHVlXS5fZnJvbSAmJiB0aGlzLl9hbGxEYXRhW3ZhbHVlXS5fZnJvbSEgPT09IGkgKyBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbdmFsdWVdLl9mcm9tISA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0ID0gMDtcbiAgICAvLyBkZWxldGUgYWxsIHZhbHVlcyB0aGF0IGFyZSBub3QgYmVpbmcgcmVmZXJlbmNlZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWxsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBuZWl0aGVyIGxpbmtlZCB0byBuZXh0IG5vZGUsIG5vciBhbiBvdXRwdXQgdmFsdWUsIHJlbW92ZSBpdC5cbiAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2ldLmZyb20gPT09IC0yICYmIHRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KSA9PT0gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIHRoaXMuX2FsbERhdGEuc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgbGV0IGluZCA9IC0xO1xuICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIG5laXRoZXIgYW4gaW5wdXQgdmFsdWUgbm9yIGFuIGluaXRpYWxpemVyLCBmaW5kIHRoZSBub2RlIGl0J3NcbiAgICAgICAgLy8gY29taW5nIGZyb20gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBub2RlIG91dHB1dFxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fYWxsRGF0YVtpXS5mcm9tICE9PSAtMSkge1xuICAgICAgICAgIGluZCA9IHRoaXMuX25vZGVzW3RoaXMuX2FsbERhdGFbaV0uZnJvbV0ub3V0cHV0cy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2ldLmZyb21dLm91dHB1dHNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgYW4gaW5wdXQgdmFsdWUsIHVwZGF0ZSBpdHMgcmVmZXJlbmNlIGluIGlucHV0SW5kaWNlc1xuICAgICAgICAgIGluZCA9IHRoaXMuX2FsbElucHV0SW5kaWNlcy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxJbnB1dEluZGljZXNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbm9kZSB0aGF0IHRoZSBjdXJyZW50IHZhbHVlIGlzIGxpbmtpbmcgdG8gYW5kIHVwZGF0ZSBpdHMgaW5wdXQgcmVmZXJlbmNlXG4gICAgICAgIHRoaXMuX2FsbERhdGFbaV0udG8uZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICBpbmQgPSB0aGlzLl9ub2Rlc1tub2RlXS5pbnB1dHMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbbm9kZV0uaW5wdXRzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW2ldLnRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgYSBncmFwaCBvdXRwdXQsIHVwZGF0ZSBpdHMgcmVmZXJlbmNlIGluIG91dHB1dEluZGljZXNcbiAgICAgICAgICBpbmQgPSB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2YoaSArIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXNbaW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgc3BlY2lmZWQgbm9kZS4gQXNzdW1lIHRoZSBub2RlIGhhcyBvbmx5IG9uZSBpbnB1dCBhbmQgdGhlIGZpcnN0IG91dHB1dCBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXNcbiAgICogQHBhcmFtIG5vZGVJbmRleCBUaGUgaW5kZXggb2Ygbm9kZSB0byBiZSBkZWxldGVkXG4gICAqL1xuICBwcml2YXRlIGRlbGV0ZU5vZGUobm9kZUluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGRlbGV0aW9uIHdpdGggbXVsdGlwbGUgaW5wdXRzIGlzIG5vdCBzdXBwb3J0ZWQuICcpO1xuICAgIH1cbiAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1tpXV0udG8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoaXMgbm9kZSB3aWwgbm90IGJlIGV4ZWN1dGVkXG4gICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuICAgIGNvbnN0IGlucHV0VmFsdWVJbmRleCA9IG5vZGUuaW5wdXRzWzBdO1xuICAgIGNvbnN0IG91dHB1dFZhbHVlSW5kZXggPSBub2RlLm91dHB1dHNbMF07XG4gICAgY29uc3Qgbm9kZXNDb25zdW1pbmdPdXRwdXQgPSB0aGlzLl9hbGxEYXRhW291dHB1dFZhbHVlSW5kZXhdLnRvO1xuXG4gICAgLy8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHRoZSB0byBwcm9wZXJ0eSBvZiB0aGUgaW5wdXQgVmFsdWVcbiAgICBjb25zdCBkZWxJbmRleCA9IHRoaXMuX2FsbERhdGFbaW5wdXRWYWx1ZUluZGV4XS50by5pbmRleE9mKG5vZGVJbmRleCk7XG4gICAgLy8gc2hvdWxkIG5vdCBoYXBwZW5cbiAgICBpZiAoZGVsSW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBWYWx1ZSBvYmplY3QgZG9lc25cXCd0IGhhdmUgdGhlIGN1cnJlbnQgTm9kZSBpbiBpdFxcJ3MgXFwndG9cXCcgcHJvcGVydHkgJyk7XG4gICAgfVxuICAgIHRoaXMuX2FsbERhdGFbaW5wdXRWYWx1ZUluZGV4XS50by5zcGxpY2UoZGVsSW5kZXgsIDEpO1xuXG4gICAgLy8gY2xlYXIgbm9kZSBpbmRpY2VzIGNvbnN1bWluZyB0aGlzIG91dHB1dCBWYWx1ZVxuICAgIHRoaXMuX2FsbERhdGFbb3V0cHV0VmFsdWVJbmRleF0uX3RvID0gW107XG5cbiAgICAvLyBpZiB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSBpcyBhIGdyYXBoIG91dHB1dCwgYWRqdXN0IHRoZSBpbmRleCBhcHByb3ByaWF0ZWx5XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yob3V0cHV0VmFsdWVJbmRleCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tpbmRleF0gPSBpbnB1dFZhbHVlSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGlucHV0cyBmb3Igbm9kZXMgY29uc3VtaW5nIHRoaXMgbm9kZSdzIG91dHB1dCB3aXRoIHRoZSBpbnB1dCB0byB0aGlzIG5vZGVcbiAgICBpZiAobm9kZXNDb25zdW1pbmdPdXRwdXQgJiYgbm9kZXNDb25zdW1pbmdPdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBub2RlSW5kZXggb2Ygbm9kZXNDb25zdW1pbmdPdXRwdXQpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZUluZGV4ID0gdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5pbnB1dHMuaW5kZXhPZihvdXRwdXRWYWx1ZUluZGV4KTtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgaWYgKHJlcGxhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBOb2RlIG9iamVjdCBkb2VzblxcJ3QgaGF2ZSB0aGUgb3V0cHV0IFZhbHVlIGluIGl0XFwncyBcXCdpbnB1dHNcXCcgcHJvcGVydHkgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5pbnB1dHNbcmVwbGFjZUluZGV4XSA9IGlucHV0VmFsdWVJbmRleDtcbiAgICAgICAgdGhpcy5fYWxsRGF0YVtpbnB1dFZhbHVlSW5kZXhdLnRvLnB1c2gobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSB7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAvLyB3ZWVkIG91dCAnRHJvcG91dCcgbm9kZXMgc28gdGhhdCBubyB0aW1lIGlzIHdhc3RlZCBpbiBleGVjdXRpb25cbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0Ryb3BvdXQnKSB7XG4gICAgICAgIC8vIHRoZSBub2RlIHNob3VsZCBoYXZlIGV4YWN0bHkgMSBpbnB1dCBhbmQgMSBvciAyIG91dHB1dHNcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cy5sZW5ndGggIT09IDEgJiYgbm9kZS5vdXRwdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2RlcyBzaG91bGQgY29udGFpbiBlaXRoZXIgMSBvciAyIG91dHB1dChzKScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBzZWNvbmQgb3V0cHV0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlZCBieSBhbnkgb3RoZXIgbm9kZVxuICAgICAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1sxXV0uX3RvLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2Rlc1xcJ3Mgc2Vjb25kIG91dHB1dCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZWQgYnkgb3RoZXIgbm9kZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGV0ZU5vZGUobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKSB7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAvLyB3ZWVkIG91dCAnSWRlbnRpdHknIG5vZGVzIHNvIHRoYXQgbm8gdGltZSBpcyB3YXN0ZWQgaW4gZXhlY3V0aW9uXG4gICAgICBpZiAobm9kZS5vcFR5cGUgPT09ICdJZGVudGl0eScpIHtcbiAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGVJbmRleCk7XG4gICAgICB9XG4gICAgICBub2RlSW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBpc0FjdGl2YXRpb24objogTm9kZSk6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAobi5vcFR5cGUpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBvdGhlciBhY3RpdmF0aW9uIG1ldGhvZHNcbiAgICAgIGNhc2UgJ1JlbHUnOlxuICAgICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCkge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLl9ub2Rlcykge1xuICAgICAgaWYgKG5vZGUub3BUeXBlID09PSAnQ29udicpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuX2FsbERhdGFbbm9kZS5vdXRwdXRzWzBdXS5fdG87XG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA9PT0gMSAmJiB0aGlzLmlzQWN0aXZhdGlvbih0aGlzLl9ub2Rlc1tuZXh0WzBdXSkpIHtcbiAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdfX2ludGVybmFsX2FjdGl2YXRpb24nLCAnc3RyaW5nJywgKHRoaXMuX25vZGVzW25leHRbMF1dLm9wVHlwZSkpO1xuICAgICAgICAgIHRoaXMuZGVsZXRlTm9kZShuZXh0WzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vYmFja2VuZHMvd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBMb2dnZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIFNldmVyaXR5VHlwZU1hcCB7XG4gICAgdmVyYm9zZTogJ3YnO1xuICAgIGluZm86ICdpJztcbiAgICB3YXJuaW5nOiAndyc7XG4gICAgZXJyb3I6ICdlJztcbiAgICBmYXRhbDogJ2YnO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgU2V2ZXJpdHkgPSBrZXlvZiBTZXZlcml0eVR5cGVNYXA7XG5cbiAgZXhwb3J0IHR5cGUgUHJvdmlkZXIgPSAnbm9uZSd8J2NvbnNvbGUnO1xuXG4gIC8qKlxuICAgKiBMb2dnaW5nIGNvbmZpZyB0aGF0IHVzZWQgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgbG9nZ2VyXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgbG9nZ2luZyBwcm92aWRlci4gJ2NvbnNvbGUnIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcm92aWRlcj86IFByb3ZpZGVyO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIG1pbmltYWwgbG9nZ2VyIHNlcnZlcml0eS4gJ3dhcm5pbmcnIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5pbWFsU2V2ZXJpdHk/OiBMb2dnZXIuU2V2ZXJpdHk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBvdXRwdXQgZGF0ZSB0aW1lIGluIGxvZy4gdHJ1ZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbG9nRGF0ZVRpbWU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3V0cHV0IHNvdXJjZSBpbmZvcm1hdGlvbiAoTm90IHlldCBzdXBwb3J0ZWQpLiBmYWxzZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbG9nU291cmNlTG9jYXRpb24/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBDYXRlZ29yaXplZExvZ2dlciB7XG4gICAgdmVyYm9zZShjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICAgIGluZm8oY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICB3YXJuaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgZXJyb3IoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIChjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuXG4gIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgdmVyYm9zZShjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGluZm8oY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICB3YXJuaW5nKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGVycm9yKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGZhdGFsKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGZhdGFsKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBsb2dnZXIgY29uZmlndXJhdGlvbi5cbiAgICogQHBhcmFtIGNvbmZpZyBzcGVjaWZ5IGFuIG9wdGlvbmFsIGRlZmF1bHQgY29uZmlnXG4gICAqL1xuICByZXNldChjb25maWc/OiBMb2dnZXIuQ29uZmlnKTogdm9pZDtcbiAgLyoqXG4gICAqIFNldCB0aGUgbG9nZ2VyJ3MgYmVoYXZpb3Igb24gdGhlIGdpdmVuIGNhdGVnb3J5XG4gICAqIEBwYXJhbSBjYXRlZ29yeSBzcGVjaWZ5IGEgY2F0ZWdvcnkgc3RyaW5nLiBJZiAnKicgaXMgc3BlY2lmaWVkLCBhbGwgcHJldmlvdXMgY29uZmlndXJhdGlvbiB3aWxsIGJlIG92ZXJ3cml0dGVuLiBJZlxuICAgKiAnJyBpcyBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIGNvbmZpZyB0aGUgY29uZmlnIG9iamVjdCB0byBpbmRpY2F0ZSB0aGUgbG9nZ2VyJ3MgYmVoYXZpb3JcbiAgICovXG4gIHNldChjYXRlZ29yeTogc3RyaW5nLCBjb25maWc6IExvZ2dlci5Db25maWcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvZ2dlcidzIGJlaGF2aW9yIGZyb20gb3J0LWNvbW1vbiBlbnZcbiAgICogQHBhcmFtIGVudiB0aGUgZW52IHVzZWQgdG8gc2V0IGxvZ2dlci4gQ3VycmVudGx5IG9ubHkgc2V0dGluZyBsb2dsZXZlbCBpcyBzdXBwb3J0ZWQgdGhyb3VnaCBFbnYuXG4gICAqL1xuICBzZXRXaXRoRW52KGVudjogRW52KTogdm9pZDtcbn1cblxuaW50ZXJmYWNlIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgY2F0ZWdvcnk/OiBzdHJpbmcpOiB2b2lkO1xufVxuY2xhc3MgTm9PcExvZ2dlclByb3ZpZGVyIGltcGxlbWVudHMgTG9nZ2VyUHJvdmlkZXIge1xuICBsb2coX3NldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIF9jb250ZW50OiBzdHJpbmcsIF9jYXRlZ29yeT86IHN0cmluZykge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxufVxuY2xhc3MgQ29uc29sZUxvZ2dlclByb3ZpZGVyIGltcGxlbWVudHMgTG9nZ2VyUHJvdmlkZXIge1xuICBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY29udGVudDogc3RyaW5nLCBjYXRlZ29yeT86IHN0cmluZykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy5jb2xvcihzZXZlcml0eSl9ICR7Y2F0ZWdvcnkgPyAnXFx4MWJbMzVtJyArIGNhdGVnb3J5ICsgJ1xceDFiWzBtICcgOiAnJ30ke2NvbnRlbnR9YCk7XG4gIH1cblxuICBwcml2YXRlIGNvbG9yKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHkpIHtcbiAgICBzd2l0Y2ggKHNldmVyaXR5KSB7XG4gICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlszNDs0MG12XFx4MWJbMG0nO1xuICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzJtaVxceDFiWzBtJztcbiAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMwOzQzbXdcXHgxYlswbSc7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzE7NDBtZVxceDFiWzBtJztcbiAgICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlsxMDFtZlxceDFiWzBtJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgc2V2ZXJpdHk6ICR7c2V2ZXJpdHl9YCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFNFVkVSSVRZX1ZBTFVFID0ge1xuICB2ZXJib3NlOiAxMDAwLFxuICBpbmZvOiAyMDAwLFxuICB3YXJuaW5nOiA0MDAwLFxuICBlcnJvcjogNTAwMCxcbiAgZmF0YWw6IDYwMDBcbn07XG5cbmNvbnN0IExPR0dFUl9QUk9WSURFUl9NQVA6IHtyZWFkb25seSBbcHJvdmlkZXI6IHN0cmluZ106IFJlYWRvbmx5PExvZ2dlclByb3ZpZGVyPn0gPSB7XG4gIFsnbm9uZSddOiBuZXcgTm9PcExvZ2dlclByb3ZpZGVyKCksXG4gIFsnY29uc29sZSddOiBuZXcgQ29uc29sZUxvZ2dlclByb3ZpZGVyKClcbn07XG5jb25zdCBMT0dHRVJfREVGQVVMVF9DT05GSUcgPSB7XG4gIHByb3ZpZGVyOiAnY29uc29sZScsXG4gIG1pbmltYWxTZXZlcml0eTogJ3dhcm5pbmcnLFxuICBsb2dEYXRlVGltZTogdHJ1ZSxcbiAgbG9nU291cmNlTG9jYXRpb246IGZhbHNlXG59O1xubGV0IExPR0dFUl9DT05GSUdfTUFQOlxuICAgIHtbY2F0ZWdvcnk6IHN0cmluZ106IFJlYWRvbmx5PFJlcXVpcmVkPExvZ2dlci5Db25maWc+Pn0gPSB7WycnXTogTE9HR0VSX0RFRkFVTFRfQ09ORklHIGFzIFJlcXVpcmVkPExvZ2dlci5Db25maWc+fTtcblxuZnVuY3Rpb24gbG9nKGNhdGVnb3J5OiBzdHJpbmcpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXI7XG5mdW5jdGlvbiBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY29udGVudDogc3RyaW5nKTogdm9pZDtcbmZ1bmN0aW9uIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuZnVuY3Rpb24gbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGFyZzE6IHN0cmluZywgYXJnMj86IHN0cmluZyk6IHZvaWQ7XG5mdW5jdGlvbiBsb2coXG4gICAgYXJnMDogc3RyaW5nfExvZ2dlci5TZXZlcml0eSwgYXJnMT86IHN0cmluZywgYXJnMj86IHN0cmluZ3xudW1iZXIsIGFyZzM/OiBudW1iZXIpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXJ8dm9pZCB7XG4gIGlmIChhcmcxID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlcjtcbiAgICByZXR1cm4gY3JlYXRlQ2F0ZWdvcml6ZWRMb2dnZXIoYXJnMCk7XG4gIH0gZWxzZSBpZiAoYXJnMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjb250ZW50KTtcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMSwgMSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInICYmIGFyZzMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY29udGVudCwgc3RhY2spXG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzEsIGFyZzIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyID09PSAnc3RyaW5nJyAmJiBhcmczID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNhdGVnb3J5LCBjb250ZW50KVxuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcyLCAxLCBhcmcxKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZzMgPT09ICdudW1iZXInKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjYXRlZ29yeSwgY29udGVudCwgc3RhY2spXG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzIsIGFyZzMsIGFyZzEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IGlzIHZhbGlkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2F0ZWdvcml6ZWRMb2dnZXIoY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlciB7XG4gIHJldHVybiB7XG4gICAgdmVyYm9zZTogbG9nLnZlcmJvc2UuYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgaW5mbzogbG9nLmluZm8uYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgd2FybmluZzogbG9nLndhcm5pbmcuYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgZXJyb3I6IGxvZy5lcnJvci5iaW5kKG51bGwsIGNhdGVnb3J5KSxcbiAgICBmYXRhbDogbG9nLmZhdGFsLmJpbmQobnVsbCwgY2F0ZWdvcnkpXG4gIH07XG59XG5cbi8vIE5PVEU6IGFyZ3VtZW50ICdjYXRlZ29yeScgaXMgcHV0IHRoZSBsYXN0IHBhcmFtZXRlciBiZWFjYXVzZSB0eXBlc2NyaXB0XG4vLyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIGFyZ3VtZW50IHB1dCBpbiBmcm9udCBvZiByZXF1aXJlZCBhcmd1bWVudC4gVGhpc1xuLy8gb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gYSB1c3VhbCBsb2dnaW5nIEFQSS5cbmZ1bmN0aW9uIGxvZ0ludGVybmFsKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgc3RhY2s6IG51bWJlciwgY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgY29uc3QgY29uZmlnID0gTE9HR0VSX0NPTkZJR19NQVBbY2F0ZWdvcnkgfHwgJyddIHx8IExPR0dFUl9DT05GSUdfTUFQWycnXTtcbiAgaWYgKFNFVkVSSVRZX1ZBTFVFW3NldmVyaXR5XSA8IFNFVkVSSVRZX1ZBTFVFW2NvbmZpZy5taW5pbWFsU2V2ZXJpdHldKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5sb2dEYXRlVGltZSkge1xuICAgIGNvbnRlbnQgPSBgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9fCR7Y29udGVudH1gO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5sb2dTb3VyY2VMb2NhdGlvbikge1xuICAgIC8vIFRPRE86IGNhbGN1bGF0ZSBzb3VyY2UgbG9jYXRpb24gZnJvbSAnc3RhY2snXG4gIH1cblxuICBMT0dHRVJfUFJPVklERVJfTUFQW2NvbmZpZy5wcm92aWRlcl0ubG9nKHNldmVyaXR5LCBjb250ZW50LCBjYXRlZ29yeSk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXG5uYW1lc3BhY2UgbG9nIHtcbiAgZXhwb3J0IGZ1bmN0aW9uIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIHZlcmJvc2UoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIHZlcmJvc2UoYXJnMDogc3RyaW5nLCBhcmcxPzogc3RyaW5nKSB7XG4gICAgbG9nKCd2ZXJib3NlJywgYXJnMCwgYXJnMSk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIGluZm8oY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGluZm8oY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGluZm8oYXJnMDogc3RyaW5nLCBhcmcxPzogc3RyaW5nKSB7XG4gICAgbG9nKCdpbmZvJywgYXJnMCwgYXJnMSk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoYXJnMDogc3RyaW5nLCBhcmcxPzogc3RyaW5nKSB7XG4gICAgbG9nKCd3YXJuaW5nJywgYXJnMCwgYXJnMSk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZXJyb3IoYXJnMDogc3RyaW5nLCBhcmcxPzogc3RyaW5nKSB7XG4gICAgbG9nKCdlcnJvcicsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZmF0YWwoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGZhdGFsKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnZmF0YWwnLCBhcmcwLCBhcmcxKTtcbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiByZXNldChjb25maWc/OiBMb2dnZXIuQ29uZmlnKTogdm9pZCB7XG4gICAgTE9HR0VSX0NPTkZJR19NQVAgPSB7fTtcbiAgICBzZXQoJycsIGNvbmZpZyB8fCB7fSk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIHNldChjYXRlZ29yeTogc3RyaW5nLCBjb25maWc6IExvZ2dlci5Db25maWcpOiB2b2lkIHtcbiAgICBpZiAoY2F0ZWdvcnkgPT09ICcqJykge1xuICAgICAgcmVzZXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJldmlvdXNDb25maWcgPSBMT0dHRVJfQ09ORklHX01BUFtjYXRlZ29yeV0gfHwgTE9HR0VSX0RFRkFVTFRfQ09ORklHO1xuICAgICAgTE9HR0VSX0NPTkZJR19NQVBbY2F0ZWdvcnldID0ge1xuICAgICAgICBwcm92aWRlcjogY29uZmlnLnByb3ZpZGVyIHx8IHByZXZpb3VzQ29uZmlnLnByb3ZpZGVyLFxuICAgICAgICBtaW5pbWFsU2V2ZXJpdHk6IGNvbmZpZy5taW5pbWFsU2V2ZXJpdHkgfHwgcHJldmlvdXNDb25maWcubWluaW1hbFNldmVyaXR5LFxuICAgICAgICBsb2dEYXRlVGltZTogKGNvbmZpZy5sb2dEYXRlVGltZSA9PT0gdW5kZWZpbmVkKSA/IHByZXZpb3VzQ29uZmlnLmxvZ0RhdGVUaW1lIDogY29uZmlnLmxvZ0RhdGVUaW1lLFxuICAgICAgICBsb2dTb3VyY2VMb2NhdGlvbjogKGNvbmZpZy5sb2dTb3VyY2VMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSA/IHByZXZpb3VzQ29uZmlnLmxvZ1NvdXJjZUxvY2F0aW9uIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcubG9nU291cmNlTG9jYXRpb25cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogd2Ugd2FudCB0byBzdXBwb3J0IHdpbGRjYXJkIG9yIHJlZ2V4P1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHNldFdpdGhFbnYoZW52OiBFbnYpOiB2b2lkIHtcbiAgICBjb25zdCBjb25maWc6IExvZ2dlci5Db25maWcgPSB7fTtcbiAgICBpZiAoZW52LmxvZ0xldmVsKSB7XG4gICAgICBjb25maWcubWluaW1hbFNldmVyaXR5ID0gZW52LmxvZ0xldmVsIGFzIExvZ2dlci5TZXZlcml0eTtcbiAgICB9XG4gICAgc2V0KCcnLCBjb25maWcpO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBMb2dnZXI6IExvZ2dlciA9IGxvZztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFByb2ZpbGVyIHtcbiAgZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICAgIG1heE51bWJlckV2ZW50cz86IG51bWJlcjtcbiAgICBmbHVzaEJhdGNoU2l6ZT86IG51bWJlcjtcbiAgICBmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM/OiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgdHlwZSBFdmVudENhdGVnb3J5ID0gJ3Nlc3Npb24nfCdub2RlJ3wnb3AnfCdiYWNrZW5kJztcblxuICBleHBvcnQgaW50ZXJmYWNlIEV2ZW50IHtcbiAgICBlbmQoKTogdm9pZHxQcm9taXNlPHZvaWQ+O1xuICB9XG59XG4vLyBUT0RPXG4vLyBjbGFzcyBXZWJHTEV2ZW50IGltcGxlbWVudHMgUHJvZmlsZXIuRXZlbnQge31cblxuY2xhc3MgRXZlbnQgaW1wbGVtZW50cyBQcm9maWxlci5FdmVudCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBwdWJsaWMgbmFtZTogc3RyaW5nLCBwdWJsaWMgc3RhcnRUaW1lOiBudW1iZXIsXG4gICAgICBwcml2YXRlIGVuZENhbGxiYWNrOiAoZTogRXZlbnQpID0+IHZvaWR8UHJvbWlzZTx2b2lkPiwgcHVibGljIHRpbWVyPzogV2ViR0xRdWVyeSwgcHVibGljIGN0eD86IFdlYkdMQ29udGV4dCkge31cblxuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kQ2FsbGJhY2sodGhpcyk7XG4gIH1cblxuICBhc3luYyBjaGVja1RpbWVyKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgaWYgKHRoaXMuY3R4ID09PSB1bmRlZmluZWQgfHwgdGhpcy50aW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHdlYmdsIHRpbWVyIGZvdW5kJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmVuZFRpbWVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5jdHgud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0aGlzLnRpbWVyKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRXZlbnRSZWNvcmQge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgcHVibGljIG5hbWU6IHN0cmluZywgcHVibGljIHN0YXJ0VGltZTogbnVtYmVyLCBwdWJsaWMgZW5kVGltZTogbnVtYmVyKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgUHJvZmlsZXIge1xuICBzdGF0aWMgY3JlYXRlKGNvbmZpZz86IFByb2ZpbGVyLkNvbmZpZyk6IFByb2ZpbGVyIHtcbiAgICBpZiAoY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcygpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoY29uZmlnLm1heE51bWJlckV2ZW50cywgY29uZmlnLmZsdXNoQmF0Y2hTaXplLCBjb25maWcuZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IobWF4TnVtYmVyRXZlbnRzPzogbnVtYmVyLCBmbHVzaEJhdGNoU2l6ZT86IG51bWJlciwgZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzPzogbnVtYmVyKSB7XG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX21heE51bWJlckV2ZW50cyA9IG1heE51bWJlckV2ZW50cyA9PT0gdW5kZWZpbmVkID8gMTAwMDAgOiBtYXhOdW1iZXJFdmVudHM7XG4gICAgdGhpcy5fZmx1c2hCYXRjaFNpemUgPSBmbHVzaEJhdGNoU2l6ZSA9PT0gdW5kZWZpbmVkID8gMTAgOiBmbHVzaEJhdGNoU2l6ZTtcbiAgICB0aGlzLl9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMgPSBmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMgPT09IHVuZGVmaW5lZCA/IDUwMDAgOiBmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM7XG4gIH1cblxuICAvLyBzdGFydCBwcm9maWxpbmdcbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgdGhpcy5fdGltaW5nRXZlbnRzID0gW107XG4gICAgdGhpcy5fZmx1c2hUaW1lID0gbm93KCk7XG4gICAgdGhpcy5fZmx1c2hQb2ludGVyID0gMDtcbiAgfVxuXG4gIC8vIHN0b3AgcHJvZmlsaW5nXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIGZvciAoOyB0aGlzLl9mbHVzaFBvaW50ZXIgPCB0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoOyB0aGlzLl9mbHVzaFBvaW50ZXIrKykge1xuICAgICAgdGhpcy5sb2dPbmVFdmVudCh0aGlzLl90aW1pbmdFdmVudHNbdGhpcy5fZmx1c2hQb2ludGVyXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gY3JlYXRlIGFuIGV2ZW50IHNjb3BlIGZvciB0aGUgc3BlY2lmaWMgZnVuY3Rpb25cbiAgZXZlbnQ8VD4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgZnVuYzogKCkgPT4gVCwgY3R4PzogV2ViR0xDb250ZXh0KTogVDtcbiAgZXZlbnQ8VD4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgZnVuYzogKCkgPT4gUHJvbWlzZTxUPiwgY3R4PzogV2ViR0xDb250ZXh0KTogUHJvbWlzZTxUPjtcblxuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBUIHwgUHJvbWlzZTxUPiwgY3R4PzogV2ViR0xDb250ZXh0KTogVFxuICAgICAgfFByb21pc2U8VD4ge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fc3RhcnRlZCA/IHRoaXMuYmVnaW4oY2F0ZWdvcnksIG5hbWUsIGN0eCkgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGlzUHJvbWlzZSA9IGZhbHNlO1xuXG4gICAgY29uc3QgcmVzID0gZnVuYygpO1xuXG4gICAgLy8gd2UgY29uc2lkZXIgYSB0aGVuLWFibGUgb2JqZWN0IGlzIGEgcHJvbWlzZVxuICAgIGlmIChyZXMgJiYgdHlwZW9mIChyZXMgYXMgUHJvbWlzZTxUPikudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaXNQcm9taXNlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIChyZXMgYXMgUHJvbWlzZTxUPilcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgIGFzeW5jIHZhbHVlID0+IHsgIC8vIGZ1bGZpbGxlZFxuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50LmVuZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhc3luYyByZWFzb24gPT4geyAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNQcm9taXNlICYmIGV2ZW50KSB7XG4gICAgICBjb25zdCBldmVudFJlcyA9IGV2ZW50LmVuZCgpO1xuICAgICAgaWYgKGV2ZW50UmVzICYmIHR5cGVvZiBldmVudFJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgKGV2ZW50UmVzKS50aGVuKFxuICAgICAgICAgICAgICAoKSA9PiB7ICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZWFzb24pID0+IHsgIC8vIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIGJlZ2luIGFuIGV2ZW50XG4gIGJlZ2luKGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBuYW1lOiBzdHJpbmcsIGN0eD86IFdlYkdMQ29udGV4dCk6IEV2ZW50IHtcbiAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJvZmlsZXIgaXMgbm90IHN0YXJ0ZWQgeWV0Jyk7XG4gICAgfVxuICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbm93KCk7XG4gICAgICB0aGlzLmZsdXNoKHN0YXJ0VGltZSk7XG4gICAgICByZXR1cm4gbmV3IEV2ZW50KGNhdGVnb3J5LCBuYW1lLCBzdGFydFRpbWUsIGUgPT4gdGhpcy5lbmRTeW5jKGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGltZXI6IFdlYkdMUXVlcnkgPSBjdHguYmVnaW5UaW1lcigpO1xuICAgICAgcmV0dXJuIG5ldyBFdmVudChjYXRlZ29yeSwgbmFtZSwgMCwgYXN5bmMgZSA9PiB0aGlzLmVuZChlKSwgdGltZXIsIGN0eCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kIHRoZSBzcGVjaWZpYyBldmVudFxuICBwcml2YXRlIGFzeW5jIGVuZChldmVudDogRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBlbmRUaW1lOiBudW1iZXIgPSBhd2FpdCBldmVudC5jaGVja1RpbWVyKCk7XG4gICAgaWYgKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGggPCB0aGlzLl9tYXhOdW1iZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBFdmVudFJlY29yZChldmVudC5jYXRlZ29yeSwgZXZlbnQubmFtZSwgZXZlbnQuc3RhcnRUaW1lLCBlbmRUaW1lKSk7XG4gICAgICB0aGlzLmZsdXNoKGVuZFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW5kU3luYyhldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBlbmRUaW1lOiBudW1iZXIgPSBub3coKTtcbiAgICBpZiAodGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCA8IHRoaXMuX21heE51bWJlckV2ZW50cykge1xuICAgICAgdGhpcy5fdGltaW5nRXZlbnRzLnB1c2gobmV3IEV2ZW50UmVjb3JkKGV2ZW50LmNhdGVnb3J5LCBldmVudC5uYW1lLCBldmVudC5zdGFydFRpbWUsIGVuZFRpbWUpKTtcbiAgICAgIHRoaXMuZmx1c2goZW5kVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsb2dPbmVFdmVudChldmVudDogRXZlbnRSZWNvcmQpIHtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgYFByb2ZpbGVyLiR7ZXZlbnQuY2F0ZWdvcnl9YCxcbiAgICAgICAgYCR7KGV2ZW50LmVuZFRpbWUgLSBldmVudC5zdGFydFRpbWUpLnRvRml4ZWQoMil9bXMgb24gZXZlbnQgJyR7ZXZlbnQubmFtZX0nIGF0ICR7ZXZlbnQuZW5kVGltZS50b0ZpeGVkKDIpfWApO1xuICB9XG5cbiAgcHJpdmF0ZSBmbHVzaChjdXJyZW50VGltZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGggLSB0aGlzLl9mbHVzaFBvaW50ZXIgPj0gdGhpcy5fZmx1c2hCYXRjaFNpemUgfHxcbiAgICAgICAgY3VycmVudFRpbWUgLSB0aGlzLl9mbHVzaFRpbWUgPj0gdGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzKSB7XG4gICAgICAvLyBzaG91bGQgZmx1c2ggd2hlbiBlaXRoZXIgYmF0Y2ggc2l6ZSBhY2N1bWxhdGVkIG9yIGludGVydmFsIGVsZXBzZWRcblxuICAgICAgZm9yIChjb25zdCBwcmV2aW91c1BvaW50ZXIgPSB0aGlzLl9mbHVzaFBvaW50ZXI7IHRoaXMuX2ZsdXNoUG9pbnRlciA8IHByZXZpb3VzUG9pbnRlciArIHRoaXMuX2ZsdXNoQmF0Y2hTaXplICYmXG4gICAgICAgICAgIHRoaXMuX2ZsdXNoUG9pbnRlciA8IHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgIHRoaXMuX2ZsdXNoUG9pbnRlcisrKSB7XG4gICAgICAgIHRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mbHVzaFRpbWUgPSBub3coKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgfVxuICBwcml2YXRlIF9zdGFydGVkID0gZmFsc2U7XG4gIHByaXZhdGUgX3RpbWluZ0V2ZW50czogRXZlbnRSZWNvcmRbXTtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9tYXhOdW1iZXJFdmVudHM6IG51bWJlcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IF9mbHVzaEJhdGNoU2l6ZTogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IF9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM6IG51bWJlcjtcblxuICBwcml2YXRlIF9mbHVzaFRpbWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBfZmx1c2hQb2ludGVyID0gMDtcbn1cblxuLyoqXG4gKiByZXR1cm5zIGEgbnVtYmVyIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCB0aW1lc3RhbXAgaW4gYSByZXNvbHV0aW9uIGFzIGhpZ2ggYXMgcG9zc2libGUuXG4gKi9cbmV4cG9ydCBjb25zdCBub3cgPSAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3cpID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdztcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2ZsYXRidWZmZXJzfSBmcm9tICdmbGF0YnVmZmVycyc7XG5pbXBvcnQge29ubnh9IGZyb20gJ29ubngtcHJvdG8nO1xuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7T3BTZXR9IGZyb20gJy4vb3BzZXQnO1xuaW1wb3J0IHtvbm54cnVudGltZX0gZnJvbSAnLi9vcnQtc2NoZW1hL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5pbXBvcnQge0xvbmdVdGlsfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgTW9kZWwge1xuICAvLyBlbXB0eSBtb2RlbFxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgbG9hZChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplciwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKCFpc09ydEZvcm1hdCkge1xuICAgICAgLy8gaXNPcnRGb3JtYXQgPT09IGZhbHNlIHx8IGlzT3J0Rm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KGJ1ZiwgZ3JhcGhJbml0aWFsaXplcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzT3J0Rm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkRnJvbU9ydEZvcm1hdChidWYsIGdyYXBoSW5pdGlhbGl6ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkRnJvbU9ubnhGb3JtYXQoYnVmOiBVaW50OEFycmF5LCBncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpOiB2b2lkIHtcbiAgICBjb25zdCBtb2RlbFByb3RvID0gb25ueC5Nb2RlbFByb3RvLmRlY29kZShidWYpO1xuICAgIGNvbnN0IGlyVmVyc2lvbiA9IExvbmdVdGlsLmxvbmdUb051bWJlcihtb2RlbFByb3RvLmlyVmVyc2lvbik7XG4gICAgaWYgKGlyVmVyc2lvbiA8IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBzdXBwb3J0IE9OTlggbW9kZWwgd2l0aCBJUl9WRVJTSU9OPj0zJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3BzZXRzID1cbiAgICAgICAgbW9kZWxQcm90by5vcHNldEltcG9ydC5tYXAoaSA9PiAoe2RvbWFpbjogaS5kb21haW4gYXMgc3RyaW5nLCB2ZXJzaW9uOiBMb25nVXRpbC5sb25nVG9OdW1iZXIoaS52ZXJzaW9uISl9KSk7XG5cbiAgICB0aGlzLl9ncmFwaCA9IEdyYXBoLmZyb20obW9kZWxQcm90by5ncmFwaCEsIGdyYXBoSW5pdGlhbGl6ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkRnJvbU9ydEZvcm1hdChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcik6IHZvaWQge1xuICAgIGNvbnN0IGZiID0gbmV3IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIoYnVmKTtcbiAgICBjb25zdCBvcnRNb2RlbCA9IG9ydEZicy5JbmZlcmVuY2VTZXNzaW9uLmdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24oZmIpLm1vZGVsKCkhO1xuICAgIGNvbnN0IGlyVmVyc2lvbiA9IExvbmdVdGlsLmxvbmdUb051bWJlcihvcnRNb2RlbC5pclZlcnNpb24oKSk7XG4gICAgaWYgKGlyVmVyc2lvbiA8IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBzdXBwb3J0IE9OTlggbW9kZWwgd2l0aCBJUl9WRVJTSU9OPj0zJyk7XG4gICAgfVxuICAgIHRoaXMuX29wc2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3J0TW9kZWwub3BzZXRJbXBvcnRMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBvcHNldElkID0gb3J0TW9kZWwub3BzZXRJbXBvcnQoaSkhO1xuICAgICAgdGhpcy5fb3BzZXRzLnB1c2goe2RvbWFpbjogb3BzZXRJZD8uZG9tYWluKCkgYXMgc3RyaW5nLCB2ZXJzaW9uOiBMb25nVXRpbC5sb25nVG9OdW1iZXIob3BzZXRJZC52ZXJzaW9uKCkhKX0pO1xuICAgIH1cblxuICAgIHRoaXMuX2dyYXBoID0gR3JhcGguZnJvbShvcnRNb2RlbC5ncmFwaCgpISwgZ3JhcGhJbml0aWFsaXplcik7XG4gIH1cblxuICBwcml2YXRlIF9ncmFwaDogR3JhcGg7XG4gIGdldCBncmFwaCgpOiBHcmFwaCB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoO1xuICB9XG5cbiAgcHJpdmF0ZSBfb3BzZXRzOiBPcFNldFtdO1xuICBnZXQgb3BzZXRzKCk6IHJlYWRvbmx5IE9wU2V0W10ge1xuICAgIHJldHVybiB0aGlzLl9vcHNldHM7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdG9yIHtcbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUsIG5vZGU6IEdyYXBoLk5vZGUsIGdyYXBoOiBHcmFwaCk6IHZvaWQ7XG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuO1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xufVxuXG5leHBvcnQgY29uc3QgTlVNQkVSX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9XG4gICAgWydmbG9hdDMyJywgJ2Zsb2F0NjQnLCAnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgSU5UX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9IFsnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgRkxPQVRfVFlQRVM6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdID0gWydmbG9hdDMyJywgJ2Zsb2F0NjQnXTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbi8vIGN1cnJlbnRseSB0aGlzIG9wZXJhdG9yIHN1cHBvcnRzIE9OTFkgJ3Rlc3QnIG1vZGVcbi8vIGlucHV0cy9vdXRwdXRzIGFuZCBwYXJhbWV0ZXJzIHdpbGwgcmVmbGVjdCB0aGF0XG4vLyB0aGUgb3BlcmF0b3IgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyB0ZXN0IG1vZGVcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXRjaE5vcm1hbGl6YXRpb24gaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmVwc2lsb24gPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdlcHNpbG9uJywgMWUtNSk7XG4gICAgdGhpcy5tb21lbnR1bSA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21vbWVudHVtJywgMC45KTtcbiAgICB0aGlzLnNwYXRpYWwgPSBhdHRyaWJ1dGVzLmdldEludCgnc3BhdGlhbCcsIDEpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IFggPSBpbnB1dHNbMF07XG4gICAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gICAgY29uc3QgQiA9IGlucHV0c1syXTtcbiAgICBjb25zdCBtZWFuID0gaW5wdXRzWzNdO1xuICAgIGNvbnN0IHZhcl8gPSBpbnB1dHNbNF07XG5cbiAgICAvLyBpbnB1dCBzaG91bGQgYXRsZWFzdCBoYXZlIHRocmVlIGRpbWVuc2lvbnMgLSBOLEMsZGltMSwuLi4sZGltblxuICAgIC8vIG90aGVyIGlucHV0cyBjYW4gaGF2ZSBvbmx5IG9uZSBkaW1lbnNpb25zXG4gICAgaWYgKFguZGltcy5sZW5ndGggPCAzIHx8IHNjYWxlLmRpbXMubGVuZ3RoICE9PSAxIHx8IEIuZGltcy5sZW5ndGggIT09IDEgfHwgbWVhbi5kaW1zLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICB2YXJfLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzY2FsZS5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHwgQi5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHwgbWVhbi5kaW1zWzBdICE9PSBYLmRpbXNbMV0gfHxcbiAgICAgICAgdmFyXy5kaW1zWzBdICE9PSBYLmRpbXNbMV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKChYLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBYLnR5cGUgIT09ICdmbG9hdDY0JykgfHwgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAgIChCLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBCLnR5cGUgIT09ICdmbG9hdDY0JykgfHwgKG1lYW4udHlwZSAhPT0gJ2Zsb2F0MzInICYmIG1lYW4udHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgICAodmFyXy50eXBlICE9PSAnZmxvYXQzMicgJiYgdmFyXy50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVwc2lsb246IG51bWJlcjtcbiAgcHJvdGVjdGVkIG1vbWVudHVtOiBudW1iZXI7XG4gIHByb3RlY3RlZCBzcGF0aWFsOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmluYXJ5T3AgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJvdGVjdGVkIHR5cGVDb25zdHJhaW50OiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSwgcHJvdGVjdGVkIG9wVHlwZT86IHN0cmluZyxcbiAgICAgIHByb3RlY3RlZCByZXN1bHRUeXBlPzogVGVuc29yLkRhdGFUeXBlKSB7fVxuXG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShfYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7fVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50eXBlQ29uc3RyYWludC5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENsaXAgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLm1pbiA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21pbicsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KTtcbiAgICB0aGlzLm1heCA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21heCcsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtaW46IG51bWJlcjtcbiAgcHJvdGVjdGVkIG1heDogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbmNhdCBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuYXhpcyA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJyk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS50eXBlO1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9uYWxpdHkgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyBjb25jYXRcbiAgICBpZiAoaW5wdXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdHlwZXMgb2YgYWxsIGlucHV0cyBtYXRjaFxuICAgICAgaWYgKGlucHV0LnR5cGUgIT09IGlucHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZGltZW5zaW9uYWxpdHkgb2YgYWxsIGlucHV0cyBhcmUgdGhlIHNhbWVcbiAgICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gaW5wdXREaW1lbnNpb25hbGl0eSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXhpczogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbnYgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gICAgdGhpcy5hdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICAgIHRoaXMuZGlsYXRpb25zID0gYXR0cmlidXRlcy5nZXRJbnRzKCdkaWxhdGlvbnMnLCBbMSwgMV0pO1xuICAgIHRoaXMuZ3JvdXAgPSBhdHRyaWJ1dGVzLmdldEludCgnZ3JvdXAnLCAxKTtcbiAgICB0aGlzLmtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gICAgdGhpcy5wYWRzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJywgWzAsIDAsIDAsIDBdKTtcbiAgICB0aGlzLnN0cmlkZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbMSwgMV0pO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdfX2ludGVybmFsX2FjdGl2YXRpb24nLCAnJyk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFzdGVyL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gICAgLy8gY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcbiAgICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0IHx8IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcbiAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zWzFdO1xuICAgIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogdGhpcy5ncm91cDtcbiAgICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzFdLmRpbXNbMF0gIT09IGlucHV0c1syXS5kaW1zWzBdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gICAgaWYgKHRoaXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICAgIGlmICh0aGlzLnN0cmlkZXMubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gICAgaWYgKHRoaXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAgIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgICBpZiAodGhpcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IDAgJiYgdGhpcy5rZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBmbG9hdDY0XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgfHwgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS50eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhdXRvUGFkOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBkaWxhdGlvbnM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgZ3JvdXA6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGtlcm5lbFNoYXBlOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIHBhZHM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgc3RyaWRlczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBhY3RpdmF0aW9uOiBzdHJpbmc7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGVwdGhUb1NwYWNlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIC8vIHByb2Nlc3Npbmcgbm9kZSBhdHRyaWJ1dGVzXG4gICAgdGhpcy5ibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmdldEludCgnYmxvY2tzaXplJyk7XG4gICAgaWYgKHRoaXMuYmxvY2tzaXplIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBibG9ja3NpemUgbXVzdCBiZSA+PSAxLCBidXQgZ290IDogJHt0aGlzLmJsb2Nrc2l6ZX0gZm9yIERlcHRoVG9TcGFjZWApO1xuICAgIH1cbiAgICB0aGlzLmJsb2Nrc2l6ZVNxciA9IHRoaXMuYmxvY2tzaXplICogdGhpcy5ibG9ja3NpemU7XG4gICAgdGhpcy5tb2RlID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnRENSJyk7XG4gICAgaWYgKERlcHRoVG9TcGFjZS5zdXBwb3J0ZWRNb2Rlcy5pbmRleE9mKHRoaXMubW9kZSkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke3RoaXMubW9kZX0gZm9yIERlcHRoVG9TcGFjZWApO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0udHlwZTtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbmFsaXR5ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuXG4gICAgLy8gSW5wdXQgaGFzIHRvIGJlIGEgNC1EIHRlbnNvclxuICAgIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGRlcHRoLXRvLXNwYWNlLlxuICAgIGlmIChpbnB1dFR5cGUgPT09ICdzdHJpbmcnIHx8IGlucHV0RGltZW5zaW9uYWxpdHkgIT09IDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtb2RlOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBibG9ja3NpemU6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGJsb2Nrc2l6ZVNxcjogbnVtYmVyO1xuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHN1cHBvcnRlZE1vZGVzID0gWydEQ1InLCAnQ1JEJ107XG59IiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERyb3BvdXQgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLnJhdGlvID0gYXR0cmlidXRlcy5nZXRGbG9hdCgncmF0aW8nLCAwLjUpO1xuICAgIHRoaXMudGVzdE1vZGUgPSB0cnVlOyAgLy8gdGhpcyBpcyBhIGhhY2sgdG8gcmVmbGVjdCB0aGF0IHRlc3QgbW9kZSBpcyBoYXJkY29kZWRcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmF0aW86IG51bWJlcjtcbiAgcHJvdGVjdGVkIHRlc3RNb2RlOiBib29sZWFuO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEVsdSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuYWxwaGEgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdhbHBoYScsIDEuMCk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFscGhhOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRmxhdHRlbiBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuYXhpcyA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMSk7ICAvLyBkZWZhdWx0IGF4aXMgaXMgMVxuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCByID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgIGlmIChyID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7ICAvLyBzY2FsYXIgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5heGlzIDwgLXIgfHwgdGhpcy5heGlzID4gcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogU3VwcG9ydCBzdHJpbmcgdHlwZVxuICAgIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBheGlzOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtOVU1CRVJfVFlQRVMsIE9wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHYXRoZXIgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4aXMgPSBhdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDApO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVuc29yUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICBpZiAodGVuc29yUmFuayA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpcyA8IC10ZW5zb3JSYW5rIHx8IHRoaXMuYXhpcyA+IHRlbnNvclJhbmsgLSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXhpczogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEdlbW0gaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKGlzT3B0aW9uYWxDOiBib29sZWFuKSB7XG4gICAgdGhpcy5pc09wdGlvbmFsQyA9IGlzT3B0aW9uYWxDO1xuICB9XG5cbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNBID0gYXR0cmlidXRlcy5nZXRJbnQoJ3RyYW5zQScsIDApICE9PSAwO1xuICAgIHRoaXMudHJhbnNCID0gYXR0cmlidXRlcy5nZXRJbnQoJ3RyYW5zQicsIDApICE9PSAwO1xuICAgIHRoaXMuYWxwaGEgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdhbHBoYScsIDEpO1xuICAgIHRoaXMuYmV0YSA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JldGEnLCAxKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc09wdGlvbmFsQyAmJiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc09wdGlvbmFsQyAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gJ0MnIGNhbiBiZSBvZiBkaW1lbnNpb25hbGl0eSAxIG9yIDIgb25seVxuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICgoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgICAoaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgICAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1syXS50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKChpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzWzFdLnR5cGUpIHx8IChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMl0udHlwZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0cmFuc0E6IGJvb2xlYW47XG4gIHByb3RlY3RlZCB0cmFuc0I6IGJvb2xlYW47XG4gIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYmV0YTogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBpc09wdGlvbmFsQzogYm9vbGVhbjsgIC8vIGluIG9wc2V0IDExLCBDIGJlY29tZXMgb3B0aW9uYWxcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbWFnZVNjYWxlciBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuc2NhbGUgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdzY2FsZScpO1xuICAgIHRoaXMuYmlhcyA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXRzKCdiaWFzJyk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzY2FsZTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgYmlhczogbnVtYmVyW107XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5zdGFuY2VOb3JtYWxpemF0aW9uIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5lcHNpbG9uID0gYXR0cmlidXRlcy5nZXRGbG9hdCgnZXBzaWxvbicsIDFlLTUpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IFggPSBpbnB1dHNbMF07XG4gICAgY29uc3Qgc2NhbGUgPSBpbnB1dHNbMV07XG4gICAgY29uc3QgQiA9IGlucHV0c1syXTtcblxuICAgIC8vIGlucHV0IHNob3VsZCBhdGxlYXN0IGhhdmUgdGhyZWUgZGltZW5zaW9ucyAtIE4sQyxkaW0xLC4uLixkaW1uXG4gICAgLy8gb3RoZXIgaW5wdXRzIGNhbiBoYXZlIG9ubHkgb25lIGRpbWVuc2lvbnNcbiAgICBpZiAoWC5kaW1zLmxlbmd0aCA8IDMgfHwgc2NhbGUuZGltcy5sZW5ndGggIT09IDEgfHwgQi5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2NhbGUuZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8IEIuZGltc1swXSAhPT0gWC5kaW1zWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoWC50eXBlICE9PSAnZmxvYXQzMicgJiYgWC50eXBlICE9PSAnZmxvYXQ2NCcpIHx8IChzY2FsZS50eXBlICE9PSAnZmxvYXQzMicgJiYgc2NhbGUudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgICAoQi50eXBlICE9PSAnZmxvYXQzMicgJiYgQi50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGVwc2lsb246IG51bWJlcjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMZWFreVJlbHUgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmFscGhhID0gYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAxKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWxwaGE6IG51bWJlcjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXRNdWwgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2YXRpb24gPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnX19pbnRlcm5hbF9hY3RpdmF0aW9uJywgJycpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRzWzBdLmRpbXNbaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV0gIT09IGlucHV0c1sxXS5kaW1zW2lucHV0c1sxXS5kaW1zLmxlbmd0aCAtIDJdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzWzFdLnR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBwcm90ZWN0ZWQgYWN0aXZhdGlvbjogc3RyaW5nO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhZCBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMubW9kZSA9IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG4gICAgdGhpcy52YWx1ZSA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ3ZhbHVlJywgMC4wKTtcbiAgICB0aGlzLnBhZHMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3BhZHMnKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgbW9kZTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcGFkczogbnVtYmVyW107XG4gIHByb3RlY3RlZCB2YWx1ZTogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuY2xhc3MgUG9vbEJhc2Uge1xuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF1dG9QYWQ6IHN0cmluZztcbiAgcHJvdGVjdGVkIGNlaWxNb2RlOiBudW1iZXI7XG4gIHByb3RlY3RlZCBjb3VudEluY2x1ZGVQYWQ6IGJvb2xlYW47XG4gIHByb3RlY3RlZCBrZXJuZWxTaGFwZTogbnVtYmVyW107XG4gIHByb3RlY3RlZCBzdHJpZGVzOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIHBhZHM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXZlcmFnZVBvb2wgZXh0ZW5kcyBQb29sQmFzZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuYXV0b1BhZCA9IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdhdXRvX3BhZCcsICdOT1RTRVQnKTtcbiAgICB0aGlzLmtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnKTtcbiAgICB0aGlzLnN0cmlkZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3N0cmlkZXMnLCBbXSk7XG4gICAgdGhpcy5wYWRzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJywgW10pO1xuICAgIHRoaXMuY291bnRJbmNsdWRlUGFkID0gKGF0dHJpYnV0ZXMuZ2V0SW50KCdjb3VudF9pbmNsdWRlX3BhZCcsIDApID09PSAwID8gZmFsc2UgOiB0cnVlKTtcbiAgICB0aGlzLmNlaWxNb2RlID0gYXR0cmlidXRlcy5nZXRJbnQoJ2NlaWxfbW9kZScsIDApO1xuXG4gICAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgICBpZiAodGhpcy5jZWlsTW9kZSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbG9iYWxBdmVyYWdlUG9vbCBleHRlbmRzIFBvb2xCYXNlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5jb3VudEluY2x1ZGVQYWQgPSAoYXR0cmlidXRlcy5nZXRJbnQoJ2NvdW50X2luY2x1ZGVfcGFkJywgMCkgPT09IDAgPyBmYWxzZSA6IHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNYXhQb29sIGV4dGVuZHMgUG9vbEJhc2UgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF1dG9QYWQgPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYXV0b19wYWQnLCAnTk9UU0VUJyk7XG4gICAgdGhpcy5rZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMuZ2V0SW50cygna2VybmVsX3NoYXBlJyk7XG4gICAgdGhpcy5zdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgW10pO1xuICAgIHRoaXMucGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFtdKTtcbiAgICB0aGlzLmNlaWxNb2RlID0gYXR0cmlidXRlcy5nZXRJbnQoJ2NlaWxfbW9kZScsIDApO1xuICAgIHRoaXMuc3RvcmFnZU9yZGVyID0gYXR0cmlidXRlcy5nZXRJbnQoJ3N0b3JhZ2Vfb3JkZXInLCAwKTtcblxuICAgIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnIGFuZCAnc3RvcmFnZV9vcmRlcidcbiAgICBpZiAodGhpcy5zdG9yYWdlT3JkZXIgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29sdW1uIG1ham9yIHN0b3JhZ2Ugb3JkZXIgaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2VpbE1vZGUgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHN0b3JhZ2VPcmRlcjogbnVtYmVyO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2xvYmFsTWF4UG9vbCBleHRlbmRzIFBvb2xCYXNlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge05VTUJFUl9UWVBFUywgT3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlZHVjZUJhc2UgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4ZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnLCBbXSk7XG4gICAgdGhpcy5rZWVwRGltcyA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdrZWVwZGltcycsIDEpID09PSAxO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXhlczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBrZWVwRGltczogYm9vbGVhbjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge05VTUJFUl9UWVBFUywgT3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJlc2hhcGUgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShfYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7fVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyIHx8IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYXBlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtOVU1CRVJfVFlQRVMsIE9wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTbGljZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuc3RhcnRzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdGFydHMnKTtcbiAgICB0aGlzLmVuZHMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2VuZHMnKTtcbiAgICB0aGlzLmF4ZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnLCBbXSk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF4ZXM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgZW5kczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBzdGFydHM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2xpY2VWMTAgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShfYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7fVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMyB8fCBpbnB1dHMubGVuZ3RoID4gNSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0c1syXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA0ICYmIChpbnB1dHNbM10udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbM10uZGltcy5sZW5ndGggIT09IDEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dHMubGVuZ3RoID49IDUgJiYgKGlucHV0c1s0XS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1s0XS5kaW1zLmxlbmd0aCAhPT0gMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNvZnRtYXggaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4aXMgPSBhdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDEpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBheGlzOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3BsaXQgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBudW1PdXRwdXRzPzogbnVtYmVyKSB7fVxuXG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4aXMgPSBhdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDApO1xuICAgIHRoaXMuc3BsaXQgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3NwbGl0JywgW10pO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDgnICYmIGlucHV0c1swXS50eXBlICE9PSAndWludDgnICYmIGlucHV0c1swXS50eXBlICE9PSAnaW50MTYnICYmXG4gICAgICAgIGlucHV0c1swXS50eXBlICE9PSAndWludDE2JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnICYmIGlucHV0c1swXS50eXBlICE9PSAnYm9vbCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzcGxpdDogbnVtYmVyW107XG4gIHByb3RlY3RlZCBheGlzOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3F1ZWV6ZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuYXhlcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIHR5cGVcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXhlczogbnVtYmVyW107XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3VtIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxlbmd0aCAhPT0gaW5wdXRzW2ldLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaW5wdXRzWzBdLmRpbXNbal0gIT09IGlucHV0c1tpXS5kaW1zW2pdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1tpXS50eXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVGlsZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKF9hdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHt9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzWzFdLmRpbXNbMF0gIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnaW50MTYnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJhbnNwb3NlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5wZXJtID0gYXR0cmlidXRlcy5nZXRJbnRzKCdwZXJtJywgW10pO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBwZXJtOiBudW1iZXJbXTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVbmFyeU9wIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgdHlwZUNvbnN0cmFpbnQ6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdLCBwcm90ZWN0ZWQgcmVzdWx0VHlwZT86IFRlbnNvci5EYXRhVHlwZSkge31cblxuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudHlwZUNvbnN0cmFpbnQuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVbnNxdWVlemUgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4ZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyB0eXBlXG4gICAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF4ZXM6IG51bWJlcltdO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVwc2FtcGxlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgb3BzZXQ6IG51bWJlcikge31cblxuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlLCBfbm9kZTogR3JhcGguTm9kZSwgX2dyYXBoOiBHcmFwaCk6IHZvaWQge1xuICAgIHRoaXMuaXNSZXNpemUgPSAodGhpcy5vcHNldCA+PSAxMCk7XG5cbiAgICAvLyBwcm9jZXNzaW5nIG5vZGUgYXR0cmlidXRlc1xuICAgIHRoaXMubW9kZSA9IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ25lYXJlc3QnKTtcbiAgICBpZiAodGhpcy5tb2RlICE9PSAnbmVhcmVzdCcgJiYgdGhpcy5tb2RlICE9PSAnbGluZWFyJyAmJiAodGhpcy5vcHNldCA8IDExIHx8IHRoaXMubW9kZSAhPT0gJ2N1YmljJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIG1vZGU6ICR7dGhpcy5tb2RlfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wc2V0IDwgOSkge1xuICAgICAgdGhpcy5zY2FsZXMgPSBhdHRyaWJ1dGVzLmdldEZsb2F0cygnc2NhbGVzJyk7XG4gICAgICBzY2FsZXNWYWxpZGF0YWlvbih0aGlzLnNjYWxlcywgdGhpcy5tb2RlLCB0aGlzLmlzUmVzaXplKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4dHJhcG9sYXRpb25WYWx1ZSA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2V4dHJhcG9sYXRpb25fdmFsdWUnLCAwLjApO1xuXG4gICAgdGhpcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9XG4gICAgICAgIHRoaXMub3BzZXQgPiAxMCA/IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGUnLCAnaGFsZl9waXhlbCcpIDogJ2FzeW1tZXRyaWMnO1xuICAgIGlmIChbXG4gICAgICAgICAgJ2FzeW1tZXRyaWMnLCAncHl0b3JjaF9oYWxmX3BpeGVsJywgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJywgJ2FsaWduX2Nvcm5lcnMnLCAndGZfY3JvcF9hbmRfcmVzaXplJyxcbiAgICAgICAgICAnaGFsZl9waXhlbCdcbiAgICAgICAgXS5pbmRleE9mKHRoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb29yZGluYXRlX3RyYW5zZm9ybV9tb2RlICcke3RoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGV9JyBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIHRoaXMudXNlRXh0cmFwb2xhdGlvbiA9IHRoaXMubmVlZFJvaUlucHV0ID0gKHRoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnKTtcblxuICAgIHRoaXMubmVhcmVzdE1vZGUgPVxuICAgICAgICAodGhpcy5tb2RlID09PSAnbmVhcmVzdCcgJiYgdGhpcy5vcHNldCA+PSAxMSkgPyBhdHRyaWJ1dGVzLmdldFN0cmluZygnbmVhcmVzdF9tb2RlJywgJ3JvdW5kX3ByZWZlcl9mbG9vcicpIDogJyc7XG4gICAgaWYgKFsncm91bmRfcHJlZmVyX2Zsb29yJywgJ3JvdW5kX3ByZWZlcl9jZWlsJywgJ2Zsb29yJywgJ2NlaWwnLCAnJ10uaW5kZXhPZih0aGlzLm5lYXJlc3RNb2RlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbmVhcmVzdF9tb2RlICcke3RoaXMubmVhcmVzdE1vZGV9JyBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdWJpY0NvZWZmaWNpZW50QSA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2N1YmljX2NvZWZmX2EnLCAtMC43NSk7XG4gICAgdGhpcy5leGNsdWRlT3V0c2lkZSA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdleGNsdWRlX291dHNpZGUnLCAwKSAhPT0gMDtcbiAgICBpZiAodGhpcy5leGNsdWRlT3V0c2lkZSAmJiB0aGlzLm1vZGUgIT09ICdjdWJpYycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZV9vdXRzaWRlIGNhbiBiZSBzZXQgdG8gMSBvbmx5IHdoZW4gbW9kZSBpcyBDVUJJQy4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnVzZU5lYXJlc3QyeE9wdGltaXphdGlvbiA9ICh0aGlzLm9wc2V0IDwgMTEpID9cbiAgICAgICAgdHJ1ZSA6XG4gICAgICAgICh0aGlzLm1vZGUgPT09ICduZWFyZXN0JyAmJiB0aGlzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAnYXN5bW1ldHJpYycgJiYgdGhpcy5uZWFyZXN0TW9kZSA9PT0gJ2Zsb29yJyk7XG5cbiAgICBpZiAodGhpcy5vcHNldCA+IDEwKSB7XG4gICAgICB0aGlzLnJvaUlucHV0SWR4ID0gMTtcbiAgICAgIHRoaXMuc2NhbGVzSW5wdXRJZHggPSAyO1xuICAgICAgdGhpcy5zaXplc0lucHV0SWR4ID0gMztcbiAgICB9IGVsc2UgaWYgKHRoaXMub3BzZXQgPT09IDkpIHtcbiAgICAgIHRoaXMuc2NhbGVzSW5wdXRJZHggPSAxO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCAodGhpcy5vcHNldCA8IDkgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMSkgfHxcbiAgICAgICAgKHRoaXMub3BzZXQgPj0gOSAmJiB0aGlzLm9wc2V0IDwgMTEgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMikgfHxcbiAgICAgICAgKHRoaXMub3BzZXQgPj0gMTEgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMyAmJiBpbnB1dHMubGVuZ3RoICE9PSA0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjYWxlcyAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IHRoaXMuc2NhbGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIHByZXBhcmVJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IFtudW1iZXJbXSwgbnVtYmVyW10sIHJlYWRvbmx5IG51bWJlcltdXSB7XG4gICAgY29uc3QgeCA9IGlucHV0c1swXTtcbiAgICBjb25zdCB4RGltcyA9IHguZGltcztcblxuICAgIC8vIGdldCByb2kgZGF0YVxuICAgIGxldCByb2kgPSB0aGlzLnJvaTtcbiAgICBpZiAoIXJvaSkge1xuICAgICAgaWYgKHRoaXMubmVlZFJvaUlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnJvaUlucHV0SWR4IDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm9pIGlucHV0IGluZGV4LicpO1xuICAgICAgICB9XG4gICAgICAgIHJvaSA9IHBhcnNlUm9pRGF0YShpbnB1dHNbdGhpcy5yb2lJbnB1dElkeF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9pID0gbmV3IEFycmF5KHhEaW1zLmxlbmd0aCAqIDIpLmZpbGwoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIGxldCBvdXRwdXRTaXplczogbnVtYmVyW118dW5kZWZpbmVkO1xuICAgIGlmICghc2NhbGVzKSB7XG4gICAgICBjb25zdCBzY2FsZXNUZW5zb3IgPSBpbnB1dHNbdGhpcy5zY2FsZXNJbnB1dElkeF07XG4gICAgICBpZiAoc2NhbGVzVGVuc29yICYmIHNjYWxlc1RlbnNvci5zaXplICE9PSAwKSB7XG4gICAgICAgIGlmIChpbnB1dHNbdGhpcy5zaXplc0lucHV0SWR4XSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2Ygc2NhbGVzIG9yIHNpemVzIG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGVzID0gcGFyc2VTY2FsZXNEYXRhKHNjYWxlc1RlbnNvciwgdGhpcy5tb2RlLCB0aGlzLmlzUmVzaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpemVzVGVuc29yID0gaW5wdXRzW3RoaXMuc2l6ZXNJbnB1dElkeF07XG4gICAgICAgIGlmICghc2l6ZXNUZW5zb3IgfHwgc2l6ZXNUZW5zb3Iuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWl0aGVyIHNjYWxlcyBvciBzaXplcyBNVVNUIGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0U2l6ZXMgPSBBcnJheS5mcm9tKHNpemVzVGVuc29yLmludGVnZXJEYXRhKTtcbiAgICAgICAgc2NhbGVzID0gcGFyc2VTY2FsZXNEYXRhRnJvbU91dHB1dFNpemUob3V0cHV0U2l6ZXMsIHhEaW1zLCB0aGlzLm1vZGUsIHRoaXMuaXNSZXNpemUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5wdXRzW3RoaXMuc2l6ZXNJbnB1dElkeF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB5RGltcyA9IG91dHB1dFNpemVzIHx8IGNvbXB1dGVPdXRwdXRTaGFwZShzY2FsZXMsIHhEaW1zKTtcblxuICAgIHJldHVybiBbcm9pLCBzY2FsZXMsIHlEaW1zXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpc1Jlc2l6ZTogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIG1vZGU6IHN0cmluZztcbiAgcHJvdGVjdGVkIHNjYWxlczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBzdHJpbmc7XG4gIHByb3RlY3RlZCB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuO1xuICBwcm90ZWN0ZWQgbmVlZFJvaUlucHV0OiBib29sZWFuO1xuICBwcm90ZWN0ZWQgbmVhcmVzdE1vZGU6IHN0cmluZztcbiAgcHJvdGVjdGVkIGN1YmljQ29lZmZpY2llbnRBOiBudW1iZXI7XG4gIHByb3RlY3RlZCBleGNsdWRlT3V0c2lkZTogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIHJvaUlucHV0SWR4OiBudW1iZXI7XG4gIHByb3RlY3RlZCBzY2FsZXNJbnB1dElkeDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgc2l6ZXNJbnB1dElkeDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgcm9pOiBudW1iZXJbXTtcbn1cblxuZnVuY3Rpb24gc2NhbGVzVmFsaWRhdGFpb24oc2NhbGVzOiBudW1iZXJbXSwgbW9kZTogc3RyaW5nLCBpc1Jlc2l6ZTogYm9vbGVhbikge1xuICBpZiAoIWlzUmVzaXplKSB7XG4gICAgZm9yIChjb25zdCBzY2FsZSBvZiBzY2FsZXMpIHtcbiAgICAgIGlmIChzY2FsZSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICBpZiAoc2NhbGUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdsaW5lYXInIHx8IG1vZGUgPT09ICdjdWJpYycpIHtcbiAgICBpZiAoc2NhbGVzLmxlbmd0aCAhPT0gMiAmJiAoc2NhbGVzLmxlbmd0aCAhPT0gNCB8fCBzY2FsZXNbMF0gIT09IDEgfHwgc2NhbGVzWzFdICE9PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnTGluZWFyJyBtb2RlIGFuZCAnQ3ViaWMnIG1vZGUgb25seSBzdXBwb3J0IDItRCBpbnB1dHMgKCdCaWxpbmVhcicsICdCaWN1YmljJykgb3IgNC1EIGlucHV0c1xcXG53aXRoIHRoZSBjb3JyZXNwb25kaW5nIG91dGVybW9zdCAyIHNjYWxlIHZhbHVlcyBiZWluZyAxIGluIHRoZSAke2lzUmVzaXplID8gJ1Jlc2l6ZScgOiAnVXBzYW1wbGUnfSBvcGVhcnRvci5gKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUm9pRGF0YShyb2k6IFRlbnNvcik6IG51bWJlcltdIHtcbiAgcmV0dXJuIHJvaS5zaXplID4gMCA/IEFycmF5LmZyb20ocm9pLmZsb2F0RGF0YSkgOiBbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2NhbGVzRGF0YShzY2FsZTogVGVuc29yLCBtb2RlOiBzdHJpbmcsIGlzUmVzaXplOiBib29sZWFuKTogbnVtYmVyW10ge1xuICBjb25zdCBzY2FsZXMgPSBBcnJheS5mcm9tKHNjYWxlLmZsb2F0RGF0YSk7XG4gIHNjYWxlc1ZhbGlkYXRhaW9uKHNjYWxlcywgbW9kZSwgaXNSZXNpemUpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTY2FsZXNEYXRhRnJvbU91dHB1dFNpemUoXG4gICAgeURpbXM6IHJlYWRvbmx5IG51bWJlcltdLCB4RGltczogcmVhZG9ubHkgbnVtYmVyW10sIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiBudW1iZXJbXSB7XG4gIGNvbnN0IGxlbmd0aCA9IHhEaW1zLmxlbmd0aDtcbiAgY29uc3Qgc2NhbGVzID0gbmV3IEFycmF5PG51bWJlcj4obGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMCwgZW5kID0gbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoeERpbXNbaV0gPT09IDApIHtcbiAgICAgIGlmICh5RGltc1tpXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzW2ldID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzW2ldID0geURpbXNbaV0gLyB4RGltc1tpXTtcbiAgICB9XG4gIH1cbiAgc2NhbGVzVmFsaWRhdGFpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlT3V0cHV0U2hhcGUoc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgcmV0dXJuIGlucHV0RGltcy5tYXAoKGRpbSwgaSkgPT4gTWF0aC5mbG9vcihkaW0gKiBzY2FsZXNbaV0pKTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4vb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBPcFNldCB7XG4gIGRvbWFpbjogc3RyaW5nO1xuICB2ZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBPcFNldCB7XG4gIGludGVyZmFjZSBPcGVyYXRvckNvbnN0cnVjdG9yIHtcbiAgICAobm9kZTogR3JhcGguTm9kZSk6IE9wZXJhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIERvbWFpbiBvZiBhbiBvcHNldCwgaXQgY2FuIGJlIGFuIGVtcHR5IHN0cmluZyhkZWZhdWx0IHZhbHVlLCByZXByZXNlbnQgZm9yIGFpLm9ubngpLCBvciAnYWkub25ueC5tbCdcbiAgICovXG4gIHR5cGUgRG9tYWluID0gJyd8J2FpLm9ubngubWwnO1xuXG4gIC8qKlxuICAgKiBBIHJlc29sdmUgcnVsZSBjb25zaXN0cyBvZiA0IGl0ZW1zOiBvcFR5cGUsIG9wU2V0RG9tYWluLCB2ZXJzaW9uU2VsZWN0b3IgYW5kIG9wZXJhdG9yQ29uc3RydWN0b3JcbiAgICovXG4gIHR5cGUgUmVzb2x2ZVJ1bGUgPSBbc3RyaW5nLCBEb21haW4sIHN0cmluZywgT3BlcmF0b3JDb25zdHJ1Y3Rvcl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT3BlcmF0b3Iobm9kZTogR3JhcGguTm9kZSwgb3BzZXRzOiByZWFkb25seSBPcFNldFtdLCBydWxlczogcmVhZG9ubHkgT3BTZXQuUmVzb2x2ZVJ1bGVbXSkge1xuICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICBjb25zdCBvcFR5cGUgPSBydWxlWzBdO1xuICAgIGNvbnN0IGRvbWFpbiA9IHJ1bGVbMV07XG4gICAgY29uc3QgdmVyc2lvblNlbGVjdG9yID0gcnVsZVsyXTtcbiAgICBjb25zdCBvcENvbnN0cnVjdG9yID0gcnVsZVszXTtcblxuICAgIGlmIChub2RlLm9wVHlwZSA9PT0gb3BUeXBlKSB7ICAvLyBvcGVyYXRvciB0eXBlIG1hdGNoZXNcbiAgICAgIGZvciAoY29uc3Qgb3BzZXQgb2Ygb3BzZXRzKSB7XG4gICAgICAgIC8vIG9wc2V0ICcnIGFuZCAnYWkub25ueCcgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvcHNldC5kb21haW4gPT09IGRvbWFpbiB8fCAob3BzZXQuZG9tYWluID09PSAnYWkub25ueCcgJiYgZG9tYWluID09PSAnJykpIHsgIC8vIG9wc2V0IGRvbWFpbiBmb3VuZFxuICAgICAgICAgIGlmIChtYXRjaFNlbGVjdG9yKG9wc2V0LnZlcnNpb24sIHZlcnNpb25TZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBvcENvbnN0cnVjdG9yKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke25vZGUub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7XG4gICAgICBvcHNldHMubWFwKHNldCA9PiBgJHtzZXQuZG9tYWluIHx8ICdhaS5vbm54J30gdiR7c2V0LnZlcnNpb259YCkuam9pbignLCAnKX1gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hTZWxlY3Rvcih2ZXJzaW9uOiBudW1iZXIsIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHNlbGVjdG9yLmVuZHNXaXRoKCcrJykpIHtcbiAgICAvLyBtaW5pbXVtIHZlcnNpb24gbWF0Y2ggKCc3KycgZXhwZWN0cyB2ZXJzaW9uPj03KVxuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3Iuc3Vic3RyaW5nKDAsIHNlbGVjdG9yLmxlbmd0aCAtIDEpLCAxMCk7XG4gICAgcmV0dXJuICFpc05hTihyYW5nZVN0YXJ0KSAmJiByYW5nZVN0YXJ0IDw9IHZlcnNpb247XG4gIH0gZWxzZSBpZiAoc2VsZWN0b3Iuc3BsaXQoJy0nKS5sZW5ndGggPT09IDIpIHtcbiAgICAvLyByYW5nZSBtYXRjaCAoJzYtOCcgZXhwZWN0cyA2PD12ZXJzaW9uPD04KVxuICAgIGNvbnN0IHBhaXIgPSBzZWxlY3Rvci5zcGxpdCgnLScpO1xuICAgIGNvbnN0IHJhbmdlU3RhcnQgPSBOdW1iZXIucGFyc2VJbnQocGFpclswXSwgMTApO1xuICAgIGNvbnN0IHJhbmdlRW5kID0gTnVtYmVyLnBhcnNlSW50KHBhaXJbMV0sIDEwKTtcbiAgICByZXR1cm4gIWlzTmFOKHJhbmdlU3RhcnQpICYmICFpc05hTihyYW5nZUVuZCkgJiYgcmFuZ2VTdGFydCA8PSB2ZXJzaW9uICYmIHZlcnNpb24gPD0gcmFuZ2VFbmQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhhY3QgbWF0Y2ggKCc3JyBleHBlY3RzIHZlcnNpb249PT03KVxuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoc2VsZWN0b3IsIDEwKSA9PT0gdmVyc2lvbjtcbiAgfVxufVxuIiwiLy8gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyLCBkbyBub3QgbW9kaWZ5XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5pbXBvcnQge2ZsYXRidWZmZXJzfSBmcm9tICdmbGF0YnVmZmVycyc7XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gQXR0cmlidXRlVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgSU5UID0gMixcbiAgICBTVFJJTkcgPSAzLFxuICAgIFRFTlNPUiA9IDQsXG4gICAgR1JBUEggPSA1LFxuICAgIEZMT0FUUyA9IDYsXG4gICAgSU5UUyA9IDcsXG4gICAgU1RSSU5HUyA9IDgsXG4gICAgVEVOU09SUyA9IDksXG4gICAgR1JBUEhTID0gMTAsXG4gICAgU1BBUlNFX1RFTlNPUiA9IDExLFxuICAgIFNQQVJTRV9URU5TT1JTID0gMTJcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIERpbWVuc2lvblZhbHVlVHlwZSB7VU5LTk9XTiA9IDAsIFZBTFVFID0gMSwgUEFSQU0gPSAyfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIFRlbnNvckRhdGFUeXBlIHtcbiAgICBVTkRFRklORUQgPSAwLFxuICAgIEZMT0FUID0gMSxcbiAgICBVSU5UOCA9IDIsXG4gICAgSU5UOCA9IDMsXG4gICAgVUlOVDE2ID0gNCxcbiAgICBJTlQxNiA9IDUsXG4gICAgSU5UMzIgPSA2LFxuICAgIElOVDY0ID0gNyxcbiAgICBTVFJJTkcgPSA4LFxuICAgIEJPT0wgPSA5LFxuICAgIEZMT0FUMTYgPSAxMCxcbiAgICBET1VCTEUgPSAxMSxcbiAgICBVSU5UMzIgPSAxMixcbiAgICBVSU5UNjQgPSAxMyxcbiAgICBDT01QTEVYNjQgPSAxNCxcbiAgICBDT01QTEVYMTI4ID0gMTUsXG4gICAgQkZMT0FUMTYgPSAxNlxuICB9XG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gTm9kZVR5cGUge1ByaW1pdGl2ZSA9IDAsIEZ1c2VkID0gMX1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBUeXBlSW5mb1ZhbHVlIHtOT05FID0gMCwgdGVuc29yX3R5cGUgPSAxLCBzZXF1ZW5jZV90eXBlID0gMiwgbWFwX3R5cGUgPSAzfVxufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU2hhcGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTaGFwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2hhcGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNoYXBlKTogU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTaGFwZSk6IFNoYXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25cbiAgICAgKi9cbiAgICBkaW0oaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb24pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb24oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1MZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBkaW1PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEaW1WZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNoYXBlLnN0YXJ0U2hhcGUoYnVpbGRlcik7XG4gICAgICBTaGFwZS5hZGREaW0oYnVpbGRlciwgZGltT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTaGFwZS5lbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBEaW1lbnNpb24ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogRGltZW5zaW9uIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0RpbWVuc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uKTogRGltZW5zaW9uIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBEaW1lbnNpb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb249IG9ialxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvbik6IERpbWVuc2lvbiB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBEaW1lbnNpb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZXxudWxsXG4gICAgICovXG4gICAgdmFsdWUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkZW5vdGF0aW9uKCk6IHN0cmluZ3xudWxsO1xuICAgIGRlbm90YXRpb24ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRlbm90YXRpb24ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1lbnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIHZhbHVlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkZW5vdGF0aW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERlbm90YXRpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRlbm90YXRpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kRGltZW5zaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVEaW1lbnNpb24oXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBEaW1lbnNpb24uc3RhcnREaW1lbnNpb24oYnVpbGRlcik7XG4gICAgICBEaW1lbnNpb24uYWRkVmFsdWUoYnVpbGRlciwgdmFsdWVPZmZzZXQpO1xuICAgICAgRGltZW5zaW9uLmFkZERlbm90YXRpb24oYnVpbGRlciwgZGVub3RhdGlvbk9mZnNldCk7XG4gICAgICByZXR1cm4gRGltZW5zaW9uLmVuZERpbWVuc2lvbihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBEaW1lbnNpb25WYWx1ZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IERpbWVuc2lvblZhbHVlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNEaW1lbnNpb25WYWx1ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uVmFsdWUpOiBEaW1lbnNpb25WYWx1ZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uVmFsdWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb25WYWx1ZT0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvblZhbHVlKTogRGltZW5zaW9uVmFsdWUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uVmFsdWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZVxuICAgICAqL1xuICAgIGRpbVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50OCh0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBkaW1WYWx1ZSgpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRpbVBhcmFtKCk6IHN0cmluZ3xudWxsO1xuICAgIGRpbVBhcmFtKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkaW1QYXJhbShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZSBkaW1UeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ4KDAsIGRpbVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV04pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBkaW1WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1WYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1WYWx1ZTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDEsIGRpbVZhbHVlLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbVBhcmFtT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVBhcmFtKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVBhcmFtT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZGltUGFyYW1PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZSxcbiAgICAgICAgZGltVmFsdWU6IGZsYXRidWZmZXJzLkxvbmcsIGRpbVBhcmFtT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgRGltZW5zaW9uVmFsdWUuc3RhcnREaW1lbnNpb25WYWx1ZShidWlsZGVyKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVR5cGUoYnVpbGRlciwgZGltVHlwZSk7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5hZGREaW1WYWx1ZShidWlsZGVyLCBkaW1WYWx1ZSk7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5hZGREaW1QYXJhbShidWlsZGVyLCBkaW1QYXJhbU9mZnNldCk7XG4gICAgICByZXR1cm4gRGltZW5zaW9uVmFsdWUuZW5kRGltZW5zaW9uVmFsdWUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVGVuc29yVHlwZUFuZFNoYXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JUeXBlQW5kU2hhcGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUZW5zb3JUeXBlQW5kU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFRlbnNvclR5cGVBbmRTaGFwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFRlbnNvclR5cGVBbmRTaGFwZSk6IFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVGVuc29yVHlwZUFuZFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yVHlwZUFuZFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JUeXBlQW5kU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3JUeXBlQW5kU2hhcGUpOlxuICAgICAgICBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVGVuc29yVHlwZUFuZFNoYXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZVxuICAgICAqL1xuICAgIGVsZW1UeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2hhcGV8bnVsbFxuICAgICAqL1xuICAgIHNoYXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2hhcGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIGVsZW1UeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEVsZW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwgZWxlbVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzaGFwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzaGFwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHNoYXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yVHlwZUFuZFNoYXBlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBlbGVtVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSxcbiAgICAgICAgc2hhcGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBUZW5zb3JUeXBlQW5kU2hhcGUuc3RhcnRUZW5zb3JUeXBlQW5kU2hhcGUoYnVpbGRlcik7XG4gICAgICBUZW5zb3JUeXBlQW5kU2hhcGUuYWRkRWxlbVR5cGUoYnVpbGRlciwgZWxlbVR5cGUpO1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLmFkZFNoYXBlKGJ1aWxkZXIsIHNoYXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBUZW5zb3JUeXBlQW5kU2hhcGUuZW5kVGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE1hcFR5cGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE1hcFR5cGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTWFwVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgTWFwVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNNYXBUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNYXBUeXBlKTogTWFwVHlwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTWFwVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1hcFR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTWFwVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTWFwVHlwZSk6IE1hcFR5cGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTWFwVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGVcbiAgICAgKi9cbiAgICBrZXlUeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbFxuICAgICAqL1xuICAgIHZhbHVlVHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE1hcFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUga2V5VHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRLZXlUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtleVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigwLCBrZXlUeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVUeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCB2YWx1ZVR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kTWFwVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTWFwVHlwZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2V5VHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSxcbiAgICAgICAgdmFsdWVUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTWFwVHlwZS5zdGFydE1hcFR5cGUoYnVpbGRlcik7XG4gICAgICBNYXBUeXBlLmFkZEtleVR5cGUoYnVpbGRlciwga2V5VHlwZSk7XG4gICAgICBNYXBUeXBlLmFkZFZhbHVlVHlwZShidWlsZGVyLCB2YWx1ZVR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIE1hcFR5cGUuZW5kTWFwVHlwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTZXF1ZW5jZVR5cGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNlcXVlbmNlVHlwZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU2VxdWVuY2VUeXBlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlcXVlbmNlVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2VxdWVuY2VUeXBlKTogU2VxdWVuY2VUeXBlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXF1ZW5jZVR5cGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXF1ZW5jZVR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlcXVlbmNlVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlcXVlbmNlVHlwZSk6IFNlcXVlbmNlVHlwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXF1ZW5jZVR5cGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgZWxlbVR5cGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBlbGVtVHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRFbGVtVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBlbGVtVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGVsZW1UeXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFNlcXVlbmNlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU2VxdWVuY2VUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgU2VxdWVuY2VUeXBlLnN0YXJ0U2VxdWVuY2VUeXBlKGJ1aWxkZXIpO1xuICAgICAgU2VxdWVuY2VUeXBlLmFkZEVsZW1UeXBlKGJ1aWxkZXIsIGVsZW1UeXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTZXF1ZW5jZVR5cGUuZW5kU2VxdWVuY2VUeXBlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIEVkZ2VFbmQge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEVkZ2VFbmRcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEVkZ2VFbmQge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUluZGV4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3Bvcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc3JjQXJnSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkc3RBcmdJbmRleCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG5vZGVfaW5kZXhcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHNyY19hcmdfaW5kZXhcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGRzdF9hcmdfaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRWRnZUVuZChcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZV9pbmRleDogbnVtYmVyLCBzcmNfYXJnX2luZGV4OiBudW1iZXIsXG4gICAgICAgIGRzdF9hcmdfaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnByZXAoNCwgMTIpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKGRzdF9hcmdfaW5kZXgpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKHNyY19hcmdfaW5kZXgpO1xuICAgICAgYnVpbGRlci53cml0ZUludDMyKG5vZGVfaW5kZXgpO1xuICAgICAgcmV0dXJuIGJ1aWxkZXIub2Zmc2V0KCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTm9kZUVkZ2Uge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE5vZGVFZGdlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBOb2RlRWRnZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzTm9kZUVkZ2UoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGVFZGdlKTogTm9kZUVkZ2Uge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE5vZGVFZGdlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZUVkZ2U9IG9ialxuICAgICAqIEByZXR1cm5zIE5vZGVFZGdlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGVFZGdlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlRWRnZSk6IE5vZGVFZGdlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE5vZGVFZGdlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUluZGV4KCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kXG4gICAgICovXG4gICAgaW5wdXRFZGdlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmR8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogMTIsIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dEVkZ2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmRcbiAgICAgKi9cbiAgICBvdXRwdXRFZGdlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmR8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogMTIsIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRFZGdlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUVkZ2UoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlSW5kZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwgbm9kZUluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dEVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0RWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGlucHV0RWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEyLCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3V0cHV0RWRnZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0RWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBvdXRwdXRFZGdlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPdXRwdXRFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEyLCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmROb2RlRWRnZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTm9kZUVkZ2UoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRleDogbnVtYmVyLCBpbnB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIG91dHB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTm9kZUVkZ2Uuc3RhcnROb2RlRWRnZShidWlsZGVyKTtcbiAgICAgIE5vZGVFZGdlLmFkZE5vZGVJbmRleChidWlsZGVyLCBub2RlSW5kZXgpO1xuICAgICAgTm9kZUVkZ2UuYWRkSW5wdXRFZGdlcyhidWlsZGVyLCBpbnB1dEVkZ2VzT2Zmc2V0KTtcbiAgICAgIE5vZGVFZGdlLmFkZE91dHB1dEVkZ2VzKGJ1aWxkZXIsIG91dHB1dEVkZ2VzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBOb2RlRWRnZS5lbmROb2RlRWRnZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBOb2RlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBOb2RlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGU9IG9ialxuICAgICAqIEByZXR1cm5zIE5vZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzTm9kZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZSk6IE5vZGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE5vZGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGUpOiBOb2RlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE5vZGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzaW5jZVZlcnNpb24oKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGluZGV4KCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG9wVHlwZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG9wVHlwZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGVcbiAgICAgKi9cbiAgICB0eXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBleGVjdXRpb25Qcm92aWRlclR5cGUoKTogc3RyaW5nfG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBleGVjdXRpb25Qcm92aWRlclR5cGUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVcbiAgICAgICAgfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRBcmdDb3VudHMoaW5kZXg6IG51bWJlcik6IG51bWJlcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgSW50MzJBcnJheVxuICAgICAqL1xuICAgIGlucHV0QXJnQ291bnRzQXJyYXkoKTogSW50MzJBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/XG4gICAgICAgICAgbmV3IEludDMyQXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnVmZmVyLCB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgaW1wbGljaXRJbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBpbXBsaWNpdElucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbXBsaWNpdElucHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgxMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIHNpbmNlVmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTaW5jZVZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2luY2VWZXJzaW9uOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBzaW5jZVZlcnNpb24sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluZGV4OiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMig0LCBpbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3BUeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9wVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcFR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBvcFR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSB0eXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDYsIHR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBpbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOSwgb3V0cHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBhdHRyaWJ1dGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEF0dHJpYnV0ZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgYXR0cmlidXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEwLCBhdHRyaWJ1dGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQXR0cmlidXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRBdHRyaWJ1dGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0QXJnQ291bnRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0QXJnQ291bnRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0QXJnQ291bnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTEsIGlucHV0QXJnQ291bnRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxudW1iZXI+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW118VWludDhBcnJheSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50MzIoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0QXJnQ291bnRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGltcGxpY2l0SW5wdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEltcGxpY2l0SW5wdXRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGltcGxpY2l0SW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTIsIGltcGxpY2l0SW5wdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmROb2RlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVOb2RlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgc2luY2VWZXJzaW9uOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIG9wVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG91dHB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgYXR0cmlidXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBpbnB1dEFyZ0NvdW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBpbXBsaWNpdElucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE5vZGUuc3RhcnROb2RlKGJ1aWxkZXIpO1xuICAgICAgTm9kZS5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgTm9kZS5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkRG9tYWluKGJ1aWxkZXIsIGRvbWFpbk9mZnNldCk7XG4gICAgICBOb2RlLmFkZFNpbmNlVmVyc2lvbihidWlsZGVyLCBzaW5jZVZlcnNpb24pO1xuICAgICAgTm9kZS5hZGRJbmRleChidWlsZGVyLCBpbmRleCk7XG4gICAgICBOb2RlLmFkZE9wVHlwZShidWlsZGVyLCBvcFR5cGVPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRUeXBlKGJ1aWxkZXIsIHR5cGUpO1xuICAgICAgTm9kZS5hZGRFeGVjdXRpb25Qcm92aWRlclR5cGUoYnVpbGRlciwgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkSW5wdXRzKGJ1aWxkZXIsIGlucHV0c09mZnNldCk7XG4gICAgICBOb2RlLmFkZE91dHB1dHMoYnVpbGRlciwgb3V0cHV0c09mZnNldCk7XG4gICAgICBOb2RlLmFkZEF0dHJpYnV0ZXMoYnVpbGRlciwgYXR0cmlidXRlc09mZnNldCk7XG4gICAgICBOb2RlLmFkZElucHV0QXJnQ291bnRzKGJ1aWxkZXIsIGlucHV0QXJnQ291bnRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkSW1wbGljaXRJbnB1dHMoYnVpbGRlciwgaW1wbGljaXRJbnB1dHNPZmZzZXQpO1xuICAgICAgcmV0dXJuIE5vZGUuZW5kTm9kZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBWYWx1ZUluZm8ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFZhbHVlSW5mb1xuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogVmFsdWVJbmZvIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFZhbHVlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVmFsdWVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1ZhbHVlSW5mbyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVmFsdWVJbmZvKTogVmFsdWVJbmZvIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBWYWx1ZUluZm8oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBWYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFZhbHVlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNWYWx1ZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFZhbHVlSW5mbyk6IFZhbHVlSW5mbyB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBWYWx1ZUluZm8oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgdHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFZhbHVlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgdHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRWYWx1ZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVZhbHVlSW5mbyhcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFZhbHVlSW5mby5zdGFydFZhbHVlSW5mbyhidWlsZGVyKTtcbiAgICAgIFZhbHVlSW5mby5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgVmFsdWVJbmZvLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgVmFsdWVJbmZvLmFkZFR5cGUoYnVpbGRlciwgdHlwZU9mZnNldCk7XG4gICAgICByZXR1cm4gVmFsdWVJbmZvLmVuZFZhbHVlSW5mbyhidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBUeXBlSW5mbyB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVHlwZUluZm9cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFR5cGVJbmZvIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUeXBlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVHlwZUluZm8pOiBUeXBlSW5mbyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVHlwZUluZm8oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVHlwZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVHlwZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFR5cGVJbmZvKTogVHlwZUluZm8ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVHlwZUluZm8oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZGVub3RhdGlvbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWVcbiAgICAgKi9cbiAgICB2YWx1ZVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZFVpbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZS5OT05FO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5UYWJsZSBvYmpcbiAgICAgKiBAcmV0dXJucyA/ZmxhdGJ1ZmZlcnMuVGFibGVcbiAgICAgKi9cbiAgICB2YWx1ZTxUIGV4dGVuZHMgZmxhdGJ1ZmZlcnMuVGFibGU+KG9iajogVCk6IFR8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdW5pb24ob2JqLCB0aGlzLmJiX3BvcyArIG9mZnNldCkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUeXBlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRlbm90YXRpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGVub3RhdGlvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZGVub3RhdGlvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUgdmFsdWVUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDgoMSwgdmFsdWVUeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCB2YWx1ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUeXBlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVHlwZUluZm8oXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdmFsdWVUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUsIHZhbHVlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVHlwZUluZm8uc3RhcnRUeXBlSW5mbyhidWlsZGVyKTtcbiAgICAgIFR5cGVJbmZvLmFkZERlbm90YXRpb24oYnVpbGRlciwgZGVub3RhdGlvbk9mZnNldCk7XG4gICAgICBUeXBlSW5mby5hZGRWYWx1ZVR5cGUoYnVpbGRlciwgdmFsdWVUeXBlKTtcbiAgICAgIFR5cGVJbmZvLmFkZFZhbHVlKGJ1aWxkZXIsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBUeXBlSW5mby5lbmRUeXBlSW5mbyhidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBPcGVyYXRvclNldElkIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRvclNldElkXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBPcGVyYXRvclNldElkIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE9wZXJhdG9yU2V0SWQ9IG9ialxuICAgICAqIEByZXR1cm5zIE9wZXJhdG9yU2V0SWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzT3BlcmF0b3JTZXRJZChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogT3BlcmF0b3JTZXRJZCk6IE9wZXJhdG9yU2V0SWQge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE9wZXJhdG9yU2V0SWQoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBPcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRvclNldElkXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc09wZXJhdG9yU2V0SWQoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE9wZXJhdG9yU2V0SWQpOiBPcGVyYXRvclNldElkIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE9wZXJhdG9yU2V0SWQoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgdmVyc2lvbigpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE9wZXJhdG9yU2V0SWQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb21haW5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9tYWluKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGRvbWFpbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5Mb25nIHZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2ZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50NjQoMSwgdmVyc2lvbiwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE9wZXJhdG9yU2V0SWQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU9wZXJhdG9yU2V0SWQoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCB2ZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE9wZXJhdG9yU2V0SWQuc3RhcnRPcGVyYXRvclNldElkKGJ1aWxkZXIpO1xuICAgICAgT3BlcmF0b3JTZXRJZC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE9wZXJhdG9yU2V0SWQuYWRkVmVyc2lvbihidWlsZGVyLCB2ZXJzaW9uKTtcbiAgICAgIHJldHVybiBPcGVyYXRvclNldElkLmVuZE9wZXJhdG9yU2V0SWQoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFRlbnNvciB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFRlbnNvcik6IFRlbnNvciB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBkaW1zKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KSA6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1zTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGVcbiAgICAgKi9cbiAgICBkYXRhVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgcmF3RGF0YShpbmRleDogbnVtYmVyKTogbnVtYmVyfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQ4KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgcmF3RGF0YUxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVWludDhBcnJheVxuICAgICAqL1xuICAgIHJhd0RhdGFBcnJheSgpOiBVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID9cbiAgICAgICAgICBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgc3RyaW5nRGF0YShpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIHN0cmluZ0RhdGEoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN0cmluZ0RhdGFMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCg2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBuYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1zT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRpbXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLkxvbmc+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5Mb25nW10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBkYXRhLmxlbmd0aCwgOCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDY0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSBkYXRhVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREYXRhVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDMsIGRhdGFUeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgcmF3RGF0YU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRSYXdEYXRhKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHJhd0RhdGFPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCByYXdEYXRhT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxudW1iZXI+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmF3RGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBudW1iZXJbXXxVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMSwgZGF0YS5sZW5ndGgsIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ4KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRSYXdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMSwgbnVtRWxlbXMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHN0cmluZ0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3RyaW5nRGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgc3RyaW5nRGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0cmluZ0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3RyaW5nRGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGRhdGFUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLFxuICAgICAgICByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHN0cmluZ0RhdGFPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBUZW5zb3Iuc3RhcnRUZW5zb3IoYnVpbGRlcik7XG4gICAgICBUZW5zb3IuYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIFRlbnNvci5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIFRlbnNvci5hZGREaW1zKGJ1aWxkZXIsIGRpbXNPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERhdGFUeXBlKGJ1aWxkZXIsIGRhdGFUeXBlKTtcbiAgICAgIFRlbnNvci5hZGRSYXdEYXRhKGJ1aWxkZXIsIHJhd0RhdGFPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZFN0cmluZ0RhdGEoYnVpbGRlciwgc3RyaW5nRGF0YU9mZnNldCk7XG4gICAgICByZXR1cm4gVGVuc29yLmVuZFRlbnNvcihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTcGFyc2VUZW5zb3Ige1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU3BhcnNlVGVuc29yIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNwYXJzZVRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgU3BhcnNlVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1NwYXJzZVRlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU3BhcnNlVGVuc29yKTogU3BhcnNlVGVuc29yIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTcGFyc2VUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTcGFyc2VUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTcGFyc2VUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNwYXJzZVRlbnNvcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTcGFyc2VUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGxcbiAgICAgKi9cbiAgICB2YWx1ZXMob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbFxuICAgICAqL1xuICAgIGluZGljZXMob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltcyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZ3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3BhcnNlVGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCB2YWx1ZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGluZGljZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5kaWNlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgaW5kaWNlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkaW1zT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFNwYXJzZVRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgaW5kaWNlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgU3BhcnNlVGVuc29yLnN0YXJ0U3BhcnNlVGVuc29yKGJ1aWxkZXIpO1xuICAgICAgU3BhcnNlVGVuc29yLmFkZFZhbHVlcyhidWlsZGVyLCB2YWx1ZXNPZmZzZXQpO1xuICAgICAgU3BhcnNlVGVuc29yLmFkZEluZGljZXMoYnVpbGRlciwgaW5kaWNlc09mZnNldCk7XG4gICAgICBTcGFyc2VUZW5zb3IuYWRkRGltcyhidWlsZGVyLCBkaW1zT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTcGFyc2VUZW5zb3IuZW5kU3BhcnNlVGVuc29yKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBBdHRyaWJ1dGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzQXR0cmlidXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBBdHRyaWJ1dGUpOiBBdHRyaWJ1dGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEF0dHJpYnV0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEF0dHJpYnV0ZT0gb2JqXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogQXR0cmlidXRlKTogQXR0cmlidXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEF0dHJpYnV0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZVxuICAgICAqL1xuICAgIHR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZS5VTkRFRklORUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZigpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMC4wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIHMoKTogc3RyaW5nfG51bGw7XG4gICAgcyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgcyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbFxuICAgICAqL1xuICAgIHQob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaHxudWxsXG4gICAgICovXG4gICAgZyhvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBmbG9hdHMoaW5kZXg6IG51bWJlcik6IG51bWJlcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRGbG9hdDMyKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGZsb2F0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgRmxvYXQzMkFycmF5XG4gICAgICovXG4gICAgZmxvYXRzQXJyYXkoKTogRmxvYXQzMkFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID9cbiAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlciwgdGhpcy5iYiEuYnl0ZXMoKS5ieXRlT2Zmc2V0ICsgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGludHMoaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLkxvbmd8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KSA6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBzdHJpbmdzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgc3RyaW5ncyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc3RyaW5nc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JcbiAgICAgKi9cbiAgICB0ZW5zb3JzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHRlbnNvcnNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaFxuICAgICAqL1xuICAgIGdyYXBocyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBncmFwaHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRBdHRyaWJ1dGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgxMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUgdHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDIsIHR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGZcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBmOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRGbG9hdDMyKDMsIGYsIDAuMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5Mb25nIGlcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpOiBmbGF0YnVmZmVycy5Mb25nKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50NjQoNCwgaSwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDUsIHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0T2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNiwgdE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBnT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBmbG9hdHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRmxvYXRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGZsb2F0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDgsIGZsb2F0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZsb2F0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBudW1iZXJbXXxVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRGbG9hdDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW50c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGludHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg5LCBpbnRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUludHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdHJpbmdzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN0cmluZ3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3RyaW5nc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEwLCBzdHJpbmdzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3RyaW5nc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdHJpbmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHRlbnNvcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVGVuc29ycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0ZW5zb3JzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTEsIHRlbnNvcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVUZW5zb3JzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFRlbnNvcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBocyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMiwgZ3JhcGhzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEdyYXBoc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEF0dHJpYnV0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlQXR0cmlidXRlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUsIGY6IG51bWJlciwgaTogZmxhdGJ1ZmZlcnMuTG9uZywgc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICB0T2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZmxvYXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGludHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgc3RyaW5nc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCB0ZW5zb3JzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGdyYXBoc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEF0dHJpYnV0ZS5zdGFydEF0dHJpYnV0ZShidWlsZGVyKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFR5cGUoYnVpbGRlciwgdHlwZSk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRihidWlsZGVyLCBmKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRJKGJ1aWxkZXIsIGkpO1xuICAgICAgQXR0cmlidXRlLmFkZFMoYnVpbGRlciwgc09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkVChidWlsZGVyLCB0T2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRHKGJ1aWxkZXIsIGdPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEZsb2F0cyhidWlsZGVyLCBmbG9hdHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEludHMoYnVpbGRlciwgaW50c09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkU3RyaW5ncyhidWlsZGVyLCBzdHJpbmdzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRUZW5zb3JzKGJ1aWxkZXIsIHRlbnNvcnNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEdyYXBocyhidWlsZGVyLCBncmFwaHNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEF0dHJpYnV0ZS5lbmRBdHRyaWJ1dGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgR3JhcGgge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEdyYXBoXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBHcmFwaCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBHcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzR3JhcGgoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEdyYXBoKTogR3JhcGgge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEdyYXBoKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIEdyYXBoXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0dyYXBoKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBHcmFwaCk6IEdyYXBoIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEdyYXBoKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JcbiAgICAgKi9cbiAgICBpbml0aWFsaXplcnMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbml0aWFsaXplcnNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm9cbiAgICAgKi9cbiAgICBub2RlQXJncyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mbyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mbygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVBcmdzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVcbiAgICAgKi9cbiAgICBub2RlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG1heE5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZVxuICAgICAqL1xuICAgIG5vZGVFZGdlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlRWRnZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIHNwYXJzZUluaXRpYWxpemVycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcik6XG4gICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzcGFyc2VJbml0aWFsaXplcnNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRHcmFwaChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGluaXRpYWxpemVyc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbml0aWFsaXplcnMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5pdGlhbGl6ZXJzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgaW5pdGlhbGl6ZXJzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2RlQXJnc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlQXJncyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlQXJnc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIG5vZGVBcmdzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9kZUFyZ3NWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUFyZ3NWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBub2Rlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG1heE5vZGVJbmRleFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRNYXhOb2RlSW5kZXgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbWF4Tm9kZUluZGV4OiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBtYXhOb2RlSW5kZXgsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVFZGdlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlRWRnZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNCwgbm9kZUVkZ2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5wdXRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDUsIGlucHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3V0cHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPdXRwdXRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG91dHB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg2LCBvdXRwdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNwYXJzZUluaXRpYWxpemVyc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTpcbiAgICAgICAgZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVHcmFwaChcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5pdGlhbGl6ZXJzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG5vZGVBcmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIG5vZGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG1heE5vZGVJbmRleDogbnVtYmVyLCBub2RlRWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG91dHB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgR3JhcGguc3RhcnRHcmFwaChidWlsZGVyKTtcbiAgICAgIEdyYXBoLmFkZEluaXRpYWxpemVycyhidWlsZGVyLCBpbml0aWFsaXplcnNPZmZzZXQpO1xuICAgICAgR3JhcGguYWRkTm9kZUFyZ3MoYnVpbGRlciwgbm9kZUFyZ3NPZmZzZXQpO1xuICAgICAgR3JhcGguYWRkTm9kZXMoYnVpbGRlciwgbm9kZXNPZmZzZXQpO1xuICAgICAgR3JhcGguYWRkTWF4Tm9kZUluZGV4KGJ1aWxkZXIsIG1heE5vZGVJbmRleCk7XG4gICAgICBHcmFwaC5hZGROb2RlRWRnZXMoYnVpbGRlciwgbm9kZUVkZ2VzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZElucHV0cyhidWlsZGVyLCBpbnB1dHNPZmZzZXQpO1xuICAgICAgR3JhcGguYWRkT3V0cHV0cyhidWlsZGVyLCBvdXRwdXRzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZFNwYXJzZUluaXRpYWxpemVycyhidWlsZGVyLCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEdyYXBoLmVuZEdyYXBoKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE1vZGVsIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTW9kZWwge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIE1vZGVsXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc01vZGVsKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNb2RlbCk6IE1vZGVsIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNb2RlbCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1vZGVsPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNb2RlbChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTW9kZWwpOiBNb2RlbCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNb2RlbCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpclZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWRcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydChpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpOlxuICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWR8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG9wc2V0SW1wb3J0TGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBwcm9kdWNlck5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBwcm9kdWNlck5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBwcm9kdWNlclZlcnNpb24oKTogc3RyaW5nfG51bGw7XG4gICAgcHJvZHVjZXJWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBwcm9kdWNlclZlcnNpb24ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9tYWluKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIG1vZGVsVmVyc2lvbigpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaHxudWxsXG4gICAgICovXG4gICAgZ3JhcGgob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZ3JhcGhEb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZ3JhcGhEb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGdyYXBoRG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoOSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5Mb25nIGlyVmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJclZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaXJWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50NjQoMCwgaXJWZXJzaW9uLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG9wc2V0SW1wb3J0T2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9wc2V0SW1wb3J0KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG9wc2V0SW1wb3J0T2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgb3BzZXRJbXBvcnRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPcHNldEltcG9ydFZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPcHNldEltcG9ydFZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBwcm9kdWNlck5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvZHVjZXJOYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHByb2R1Y2VyTmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIHByb2R1Y2VyTmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBwcm9kdWNlclZlcnNpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgzLCBwcm9kdWNlclZlcnNpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvbWFpbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb21haW4oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNCwgZG9tYWluT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgbW9kZWxWZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZE1vZGVsVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBtb2RlbFZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCg1LCBtb2RlbFZlcnNpb24sIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg2LCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGdyYXBoT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgZ3JhcGhPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoRG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBoRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGdyYXBoRG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOCwgZ3JhcGhEb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kTW9kZWwoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU1vZGVsKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpclZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcsIG9wc2V0SW1wb3J0T2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHByb2R1Y2VyTmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBwcm9kdWNlclZlcnNpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG1vZGVsVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZywgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGdyYXBoT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGdyYXBoRG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTW9kZWwuc3RhcnRNb2RlbChidWlsZGVyKTtcbiAgICAgIE1vZGVsLmFkZElyVmVyc2lvbihidWlsZGVyLCBpclZlcnNpb24pO1xuICAgICAgTW9kZWwuYWRkT3BzZXRJbXBvcnQoYnVpbGRlciwgb3BzZXRJbXBvcnRPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkUHJvZHVjZXJOYW1lKGJ1aWxkZXIsIHByb2R1Y2VyTmFtZU9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRQcm9kdWNlclZlcnNpb24oYnVpbGRlciwgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZERvbWFpbihidWlsZGVyLCBkb21haW5PZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkTW9kZWxWZXJzaW9uKGJ1aWxkZXIsIG1vZGVsVmVyc2lvbik7XG4gICAgICBNb2RlbC5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZEdyYXBoKGJ1aWxkZXIsIGdyYXBoT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZEdyYXBoRG9jU3RyaW5nKGJ1aWxkZXIsIGdyYXBoRG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIHJldHVybiBNb2RlbC5lbmRNb2RlbChidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEtlcm5lbENyZWF0ZUluZm9zPSBvYmpcbiAgICAgKiBAcmV0dXJucyBLZXJuZWxDcmVhdGVJbmZvc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogS2VybmVsQ3JlYXRlSW5mb3MpOiBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgS2VybmVsQ3JlYXRlSW5mb3MoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBLZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEtlcm5lbENyZWF0ZUluZm9zKTpcbiAgICAgICAgS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgS2VybmVsQ3JlYXRlSW5mb3MoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUluZGljZXMoaW5kZXg6IG51bWJlcik6IG51bWJlcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kaWNlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBVaW50MzJBcnJheVxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzQXJyYXkoKTogVWludDMyQXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/XG4gICAgICAgICAgbmV3IFVpbnQzMkFycmF5KFxuICAgICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlciwgdGhpcy5iYiEuYnl0ZXMoKS5ieXRlT2Zmc2V0ICsgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGtlcm5lbERlZkhhc2hlcyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZ3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpIDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGtlcm5lbERlZkhhc2hlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0S2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2RlSW5kaWNlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlSW5kaWNlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kaWNlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG5vZGVJbmRpY2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxudW1iZXI+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9kZUluZGljZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW118VWludDhBcnJheSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50MzIoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGtlcm5lbERlZkhhc2hlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRLZXJuZWxEZWZIYXNoZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2VybmVsRGVmSGFzaGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwga2VybmVsRGVmSGFzaGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUtlcm5lbERlZkhhc2hlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5Mb25nW10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBkYXRhLmxlbmd0aCwgOCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDY0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBudW1FbGVtcywgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlS2VybmVsQ3JlYXRlSW5mb3MoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGtlcm5lbERlZkhhc2hlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLnN0YXJ0S2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcik7XG4gICAgICBLZXJuZWxDcmVhdGVJbmZvcy5hZGROb2RlSW5kaWNlcyhidWlsZGVyLCBub2RlSW5kaWNlc09mZnNldCk7XG4gICAgICBLZXJuZWxDcmVhdGVJbmZvcy5hZGRLZXJuZWxEZWZIYXNoZXMoYnVpbGRlciwga2VybmVsRGVmSGFzaGVzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBLZXJuZWxDcmVhdGVJbmZvcy5lbmRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFN1YkdyYXBoU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTdWJHcmFwaFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTdWJHcmFwaFNlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU3ViR3JhcGhTZXNzaW9uU3RhdGUpOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3ViR3JhcGhTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTdWJHcmFwaFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFN1YkdyYXBoU2Vzc2lvblN0YXRlKTpcbiAgICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3ViR3JhcGhTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZ3JhcGhJZCgpOiBzdHJpbmd8bnVsbDtcbiAgICBncmFwaElkKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBncmFwaElkKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGxcbiAgICAgKi9cbiAgICBzZXNzaW9uU3RhdGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoSWRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaElkT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZ3JhcGhJZE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc2Vzc2lvblN0YXRlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzZXNzaW9uU3RhdGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIGJ1aWxkZXIucmVxdWlyZWRGaWVsZChvZmZzZXQsIDQpOyAgLy8gZ3JhcGhfaWRcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaElkT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHNlc3Npb25TdGF0ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZS5hZGRHcmFwaElkKGJ1aWxkZXIsIGdyYXBoSWRPZmZzZXQpO1xuICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUuYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldCk7XG4gICAgICByZXR1cm4gU3ViR3JhcGhTZXNzaW9uU3RhdGUuZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU2Vzc2lvblN0YXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNlc3Npb25TdGF0ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlc3Npb25TdGF0ZSk6IFNlc3Npb25TdGF0ZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXNzaW9uU3RhdGUpOiBTZXNzaW9uU3RhdGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3M9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3N8bnVsbFxuICAgICAqL1xuICAgIGtlcm5lbHMob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3N8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN1YkdyYXBoU2Vzc2lvblN0YXRlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKTpcbiAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQga2VybmVsc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRLZXJuZWxzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBrZXJuZWxzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6XG4gICAgICAgIGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2VybmVsc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTZXNzaW9uU3RhdGUuc3RhcnRTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgICBTZXNzaW9uU3RhdGUuYWRkS2VybmVscyhidWlsZGVyLCBrZXJuZWxzT2Zmc2V0KTtcbiAgICAgIFNlc3Npb25TdGF0ZS5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXMoYnVpbGRlciwgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTZXNzaW9uU3RhdGUuZW5kU2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIEluZmVyZW5jZVNlc3Npb24ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEluZmVyZW5jZVNlc3Npb25cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEluZmVyZW5jZVNlc3Npb24ge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gSW5mZXJlbmNlU2Vzc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgSW5mZXJlbmNlU2Vzc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBJbmZlcmVuY2VTZXNzaW9uKTogSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgSW5mZXJlbmNlU2Vzc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEluZmVyZW5jZVNlc3Npb249IG9ialxuICAgICAqIEByZXR1cm5zIEluZmVyZW5jZVNlc3Npb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogSW5mZXJlbmNlU2Vzc2lvbik6IEluZmVyZW5jZVNlc3Npb24ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgSW5mZXJlbmNlU2Vzc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgYm9vbGVhblxuICAgICAqL1xuICAgIHN0YXRpYyBidWZmZXJIYXNJZGVudGlmaWVyKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gYmIuX19oYXNfaWRlbnRpZmllcignT1JUTScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBvcnRWZXJzaW9uKCk6IHN0cmluZ3xudWxsO1xuICAgIG9ydFZlcnNpb24ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG9ydFZlcnNpb24ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsfG51bGxcbiAgICAgKi9cbiAgICBtb2RlbChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZXxudWxsXG4gICAgICovXG4gICAgc2Vzc2lvblN0YXRlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5mZXJlbmNlU2Vzc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG9ydFZlcnNpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3J0VmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcnRWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgb3J0VmVyc2lvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbW9kZWxPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTW9kZWwoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbW9kZWxPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBtb2RlbE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc2Vzc2lvblN0YXRlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBzZXNzaW9uU3RhdGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kSW5mZXJlbmNlU2Vzc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluaXNoSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5maW5pc2gob2Zmc2V0LCAnT1JUTScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5pc2hTaXplUHJlZml4ZWRJbmZlcmVuY2VTZXNzaW9uQnVmZmVyKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmZpbmlzaChvZmZzZXQsICdPUlRNJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUluZmVyZW5jZVNlc3Npb24oXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG9ydFZlcnNpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgbW9kZWxPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5zdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcik7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZE9ydFZlcnNpb24oYnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldCk7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZE1vZGVsKGJ1aWxkZXIsIG1vZGVsT2Zmc2V0KTtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldCk7XG4gICAgICByZXR1cm4gSW5mZXJlbmNlU2Vzc2lvbi5lbmRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiwgU2Vzc2lvbkhhbmRsZXIsIFRlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi9zZXNzaW9uJztcbmltcG9ydCB7VGVuc29yIGFzIE9ubnhqc1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuXG5leHBvcnQgY2xhc3MgT25ueGpzU2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBTZXNzaW9uSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2Vzc2lvbjogU2Vzc2lvbikge1xuICAgIHRoaXMuaW5wdXROYW1lcyA9IHRoaXMuc2Vzc2lvbi5pbnB1dE5hbWVzO1xuICAgIHRoaXMub3V0cHV0TmFtZXMgPSB0aGlzLnNlc3Npb24ub3V0cHV0TmFtZXM7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge31cbiAgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgYXN5bmMgcnVuKFxuICAgICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSwgX2ZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgX29wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIGNvbnN0IGlucHV0TWFwID0gbmV3IE1hcDxzdHJpbmcsIE9ubnhqc1RlbnNvcj4oKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmVlZHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChmZWVkcywgbmFtZSkpIHtcbiAgICAgICAgY29uc3QgZmVlZCA9IGZlZWRzW25hbWVdO1xuICAgICAgICBpbnB1dE1hcC5zZXQoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbmV3IE9ubnhqc1RlbnNvcihcbiAgICAgICAgICAgICAgICBmZWVkLmRpbXMsIGZlZWQudHlwZSBhcyBPbm54anNUZW5zb3IuRGF0YVR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZlZWQuZGF0YSBhcyBPbm54anNUZW5zb3IuTnVtYmVyVHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvdXRwdXRNYXAgPSBhd2FpdCB0aGlzLnNlc3Npb24ucnVuKGlucHV0TWFwKTtcbiAgICBjb25zdCBvdXRwdXQ6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBvdXRwdXRNYXAuZm9yRWFjaCgodGVuc29yLCBuYW1lKSA9PiB7XG4gICAgICBvdXRwdXRbbmFtZV0gPSBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgdGVuc29yLmRpbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCk7XG4gIH1cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi5lbmRQcm9maWxpbmcoKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7cmVhZEZpbGV9IGZyb20gJ2ZzJztcbmltcG9ydCB7cHJvbWlzaWZ5fSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHtyZXNvbHZlQmFja2VuZCwgU2Vzc2lvbkhhbmRsZXJUeXBlfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHtFeGVjdXRpb25QbGFufSBmcm9tICcuL2V4ZWN1dGlvbi1wbGFuJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtQcm9maWxlcn0gZnJvbSAnLi9pbnN0cnVtZW50JztcbmltcG9ydCB7TW9kZWx9IGZyb20gJy4vbW9kZWwnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG4gICAgcHJvZmlsZXI/OiBQcm9maWxlci5Db25maWc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIENvbnRleHQge1xuICAgIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj47XG4gICAgZ3JhcGhJbnB1dFR5cGVzPzogVGVuc29yLkRhdGFUeXBlW107XG4gICAgZ3JhcGhJbnB1dERpbXM/OiBBcnJheTxyZWFkb25seSBudW1iZXJbXT47XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlc3Npb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWc6IFNlc3Npb24uQ29uZmlnID0ge30pIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2VuZEhpbnQgPSBjb25maWcuYmFja2VuZEhpbnQ7XG4gICAgdGhpcy5wcm9maWxlciA9IFByb2ZpbGVyLmNyZWF0ZShjb25maWcucHJvZmlsZXIpO1xuICAgIHRoaXMuY29udGV4dCA9IHtwcm9maWxlcjogdGhpcy5wcm9maWxlciwgZ3JhcGhJbnB1dFR5cGVzOiBbXSwgZ3JhcGhJbnB1dERpbXM6IFtdfTtcbiAgfVxuXG4gIGdldCBpbnB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpIHtcbiAgICB0aGlzLnByb2ZpbGVyLnN0YXJ0KCk7XG4gIH1cblxuICBlbmRQcm9maWxpbmcoKSB7XG4gICAgdGhpcy5wcm9maWxlci5zdG9wKCk7XG4gIH1cblxuICBhc3luYyBsb2FkTW9kZWwodXJpOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBsb2FkTW9kZWwoYnVmZmVyOiBBcnJheUJ1ZmZlciwgYnl0ZU9mZnNldD86IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPjtcbiAgYXN5bmMgbG9hZE1vZGVsKGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGxvYWRNb2RlbChhcmc6IHN0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5LCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24ubG9hZE1vZGVsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVzb2x2ZSBiYWNrZW5kIGFuZCBzZXNzaW9uIGhhbmRsZXJcbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCByZXNvbHZlQmFja2VuZCh0aGlzLmJhY2tlbmRIaW50KTtcbiAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIgPSBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyKHRoaXMuY29udGV4dCk7XG5cbiAgICAgIHRoaXMuX21vZGVsID0gbmV3IE1vZGVsKCk7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgaXNPcnRGb3JtYXQgPSBhcmcuZW5kc1dpdGgoJy5vcnQnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBub2RlXG4gICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcHJvbWlzaWZ5KHJlYWRGaWxlKShhcmcpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShCdWZmZXIuZnJvbShidWYpLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXJnKTtcbiAgICAgICAgICBjb25zdCBidWYgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShidWYpLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhhcmcpKSB7XG4gICAgICAgIC8vIGxvYWQgbW9kZWwgZnJvbSBBcnJheUJ1ZmZlclxuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhcmcsIGJ5dGVPZmZzZXQgfHwgMCwgbGVuZ3RoIHx8IGFyZy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIG1vZGVsIGZyb20gVWludDhhcnJheVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShtb2RlbFByb3RvQmxvYjogVWludDhBcnJheSwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIC8vIGxvYWQgZ3JhcGhcbiAgICAgIGNvbnN0IGdyYXBoSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIudHJhbnNmb3JtR3JhcGggPyB0aGlzLnNlc3Npb25IYW5kbGVyIGFzIEdyYXBoLkluaXRpYWxpemVyIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fbW9kZWwubG9hZChtb2RlbFByb3RvQmxvYiwgZ3JhcGhJbml0aWFsaXplciwgaXNPcnRGb3JtYXQpO1xuXG4gICAgICAvLyBncmFwaCBpcyBjb21wbGV0ZWx5IGluaXRpYWx6aWVkIGF0IHRoaXMgc3RhZ2UgLCBsZXQgdGhlIGludGVyZXN0ZWQgaGFuZGxlcnMga25vd1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWxpemUgZWFjaCBvcGVyYXRvciBpbiB0aGUgZ3JhcGhcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCk7XG5cbiAgICAgIC8vIGluc3RhbnRpYXRlIGFuIEV4ZWN1dGlvblBsYW4gb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhlIFNlc3Npb24gb2JqZWN0XG4gICAgICB0aGlzLl9leGVjdXRpb25QbGFuID0gbmV3IEV4ZWN1dGlvblBsYW4odGhpcy5fbW9kZWwuZ3JhcGgsIHRoaXMuX29wcywgdGhpcy5wcm9maWxlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBydW4oaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+fFRlbnNvcltdKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBUZW5zb3I+PiB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdTZXNzaW9uLnJ1bicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0VGVuc29ycyA9IHRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgY29uc3Qgb3V0cHV0VGVuc29ycyA9IGF3YWl0IHRoaXMuX2V4ZWN1dGlvblBsYW4uZXhlY3V0ZSh0aGlzLnNlc3Npb25IYW5kbGVyLCBpbnB1dFRlbnNvcnMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQob3V0cHV0VGVuc29ycyk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGlucHV0czogTWFwPHN0cmluZywgVGVuc29yPnxUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBtb2RlbElucHV0TmFtZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7XG5cbiAgICAvLyBub3JtYWxpemUgaW5wdXRzXG4gICAgLy8gaW5wdXRzOiBUZW5zb3JbXVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSBtb2RlbElucHV0TmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IGFycmF5IGxlbmd0aDogZXhwZWN0ZWQgJHttb2RlbElucHV0TmFtZXMubGVuZ3RofSBidXQgZ290ICR7aW5wdXRzLmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29udmVydCBtYXAgdG8gYXJyYXlcbiAgICAvLyBpbnB1dHM6IE1hcDxzdHJpbmcsIFRlbnNvcj5cbiAgICBlbHNlIHtcbiAgICAgIGlmIChpbnB1dHMuc2l6ZSAhPT0gbW9kZWxJbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBtYXAgc2l6ZTogZXhwZWN0ZWQgJHttb2RlbElucHV0TmFtZXMubGVuZ3RofSBidXQgZ290ICR7aW5wdXRzLnNpemV9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNvcnRlZElucHV0cyA9IG5ldyBBcnJheTxUZW5zb3I+KGlucHV0cy5zaXplKTtcbiAgICAgIGxldCBzb3J0ZWRJbnB1dHNJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsSW5wdXROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSBpbnB1dHMuZ2V0KG1vZGVsSW5wdXROYW1lc1tpXSk7XG4gICAgICAgIGlmICghdGVuc29yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IHRlbnNvciBmb3I6ICcke25hbWV9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRlZElucHV0c1tzb3J0ZWRJbnB1dHNJbmRleCsrXSA9IHRlbnNvcjtcbiAgICAgIH1cblxuICAgICAgaW5wdXRzID0gc29ydGVkSW5wdXRzO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGRpbXMgcmVxdWlyZW1lbnRzXG4gICAgLy8gRmlyc3Qgc2Vzc2lvbiBydW4gLSBncmFwaCBpbnB1dCBkYXRhIGlzIG5vdCBjYWNoZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAgaWYgKCF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzIHx8IHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMgfHxcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbW9kZWxJbnB1dEluZGljZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0VmFsdWVzKCk7XG5cbiAgICAgIGNvbnN0IGdyYXBoSW5wdXREaW1zID0gbmV3IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPihtb2RlbElucHV0SW5kaWNlcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsSW5wdXRJbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoSW5wdXQgPSBtb2RlbFZhbHVlc1ttb2RlbElucHV0SW5kaWNlc1tpXV07XG4gICAgICAgIGdyYXBoSW5wdXREaW1zW2ldID0gZ3JhcGhJbnB1dC50eXBlIS5zaGFwZS5kaW1zO1xuXG4gICAgICAgIC8vIGNhY2hlZCBmb3Igc2Vjb25kIGFuZCBzdWJzZXF1ZW50IHJ1bnMuXG4gICAgICAgIC8vIFNvbWUgcGFydHMgb2YgdGhlIGZyYW1ld29yayB3b3JrcyBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSBncmFwaCBhbmQgdHlwZXMgYW5kIHNoYXBlcyBhcmUgc3RhdGljXG4gICAgICAgIHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMhLnB1c2goZ3JhcGhJbnB1dC50eXBlIS50ZW5zb3JUeXBlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zIS5wdXNoKGlucHV0c1tpXS5kaW1zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyhncmFwaElucHV0RGltcywgaW5wdXRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgYW5kIHN1YnNlcXVlbnQgc2Vzc2lvbiBydW5zIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBjYWNoZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcywgaW5wdXRzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgdHlwZXMgcmVxdWlyZW1lbnRcbiAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzISwgaW5wdXRzKTtcblxuICAgIHJldHVybiBpbnB1dHM7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyhncmFwaElucHV0VHlwZXM6IFRlbnNvci5EYXRhVHlwZVtdLCBnaXZlbklucHV0czogVGVuc29yW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdpdmVuSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBncmFwaElucHV0VHlwZXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZ2l2ZW5JbnB1dHNbaV0udHlwZTtcbiAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGFjdHVhbFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtpfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCB0eXBlICcke2V4cGVjdGVkVHlwZX0nIGJ1dCBnb3QgJHthY3R1YWxUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbnB1dFRlbnNvckRpbXMoXG4gICAgICBncmFwaElucHV0RGltczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LCBnaXZlbklucHV0czogVGVuc29yW10sIG5vbmVEaW1TdXBwb3J0ZWQ6IGJvb2xlYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdpdmVuSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHBlY3RlZERpbXMgPSBncmFwaElucHV0RGltc1tpXTtcbiAgICAgIGNvbnN0IGFjdHVhbERpbXMgPSBnaXZlbklucHV0c1tpXS5kaW1zO1xuICAgICAgaWYgKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGV4cGVjdGVkRGltcywgYWN0dWFsRGltcywgbm9uZURpbVN1cHBvcnRlZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtpfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCBzaGFwZSAnWyR7ZXhwZWN0ZWREaW1zLmpvaW4oJywnKX1dJyBidXQgZ290IFske1xuICAgICAgICAgICAgYWN0dWFsRGltcy5qb2luKCcsJyl9XWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29tcGFyZVRlbnNvckRpbXMoZXhwZWN0ZWREaW1zOiByZWFkb25seSBudW1iZXJbXSwgYWN0dWFsRGltczogcmVhZG9ubHkgbnVtYmVyW10sIG5vbmVEaW1TdXBwb3J0ZWQ6IGJvb2xlYW4pOlxuICAgICAgYm9vbGVhbiB7XG4gICAgaWYgKGV4cGVjdGVkRGltcy5sZW5ndGggIT09IGFjdHVhbERpbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZERpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChleHBlY3RlZERpbXNbaV0gIT09IGFjdHVhbERpbXNbaV0gJiYgKCFub25lRGltU3VwcG9ydGVkIHx8IGV4cGVjdGVkRGltc1tpXSAhPT0gMCkpIHtcbiAgICAgICAgLy8gZGF0YSBzaGFwZSBtaXMtbWF0Y2ggQU5EIG5vdCBhICdOb25lJyBkaW1lbnNpb24uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlT3V0cHV0KG91dHB1dFRlbnNvcnM6IFRlbnNvcltdKTogTWFwPHN0cmluZywgVGVuc29yPiB7XG4gICAgY29uc3QgbW9kZWxPdXRwdXROYW1lcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gICAgaWYgKG91dHB1dFRlbnNvcnMubGVuZ3RoICE9PSBtb2RlbE91dHB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IE1hcDxzdHJpbmcsIFRlbnNvcj4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsT3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG91dHB1dC5zZXQobW9kZWxPdXRwdXROYW1lc1tpXSwgb3V0cHV0VGVuc29yc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZU9wcyhncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgdGhpcy5fb3BzID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vcHNbaV0gPSB0aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUobm9kZXNbaV0sIHRoaXMuX21vZGVsLm9wc2V0cywgZ3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX21vZGVsOiBNb2RlbDtcbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3BzOiBPcGVyYXRvcltdO1xuICBwcml2YXRlIF9leGVjdXRpb25QbGFuOiBFeGVjdXRpb25QbGFuO1xuXG4gIHByaXZhdGUgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzZXNzaW9uSGFuZGxlcjogU2Vzc2lvbkhhbmRsZXJUeXBlO1xuICBwcml2YXRlIGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dDtcbiAgcHJpdmF0ZSBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R3VpZH0gZnJvbSAnZ3VpZC10eXBlc2NyaXB0JztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IHtvbm54fSBmcm9tICdvbm54LXByb3RvJztcblxuaW1wb3J0IHtvbm54cnVudGltZX0gZnJvbSAnLi9vcnQtc2NoZW1hL29ydC1nZW5lcmF0ZWQnO1xuXG5pbXBvcnQgb3J0RmJzID0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztcblxuaW1wb3J0IHtQcm90b1V0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRlbnNvciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGJvb2w6IFVpbnQ4QXJyYXk7XG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICBzdHJpbmc6IHN0cmluZ1tdO1xuICAgIGludDg6IEludDhBcnJheTtcbiAgICB1aW50ODogVWludDhBcnJheTtcbiAgICBpbnQxNjogSW50MTZBcnJheTtcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xuICAgIGludDMyOiBJbnQzMkFycmF5O1xuICAgIHVpbnQzMjogVWludDMyQXJyYXk7XG4gIH1cblxuICBleHBvcnQgdHlwZSBEYXRhVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xuXG4gIGV4cG9ydCB0eXBlIFN0cmluZ1R5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ3N0cmluZyddO1xuICBleHBvcnQgdHlwZSBCb29sZWFuVHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnYm9vbCddO1xuICBleHBvcnQgdHlwZSBJbnRlZ2VyVHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnaW50OCddfFRlbnNvci5EYXRhVHlwZU1hcFsndWludDgnXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ2ludDE2J118XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVGVuc29yLkRhdGFUeXBlTWFwWyd1aW50MTYnXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ2ludDMyJ118VGVuc29yLkRhdGFUeXBlTWFwWyd1aW50MzInXTtcbiAgZXhwb3J0IHR5cGUgRmxvYXRUeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydmbG9hdDMyJ118VGVuc29yLkRhdGFUeXBlTWFwWydmbG9hdDY0J107XG4gIGV4cG9ydCB0eXBlIE51bWJlclR5cGUgPSBCb29sZWFuVHlwZXxJbnRlZ2VyVHlwZXxGbG9hdFR5cGU7XG5cbiAgZXhwb3J0IHR5cGUgSWQgPSBHdWlkO1xufVxuXG50eXBlIFRlbnNvckRhdGEgPSBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXTtcblxudHlwZSBEYXRhUHJvdmlkZXIgPSAoaWQ6IFRlbnNvci5JZCkgPT4gVGVuc29yRGF0YTtcbnR5cGUgQXN5bmNEYXRhUHJvdmlkZXIgPSAoaWQ6IFRlbnNvci5JZCkgPT4gUHJvbWlzZTxUZW5zb3JEYXRhPjtcblxuZXhwb3J0IGNsYXNzIFRlbnNvciB7XG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgdGVuc29yIGRhdGFcbiAgICovXG4gIGdldCBkYXRhKCk6IFRlbnNvckRhdGEge1xuICAgIGlmICh0aGlzLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGFQcm92aWRlciEodGhpcy5kYXRhSWQpO1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggb2YgZGF0YSBwcm92aWRlZCBieSB0aGUgRGF0YSBQcm92aWRlciBpcyBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgZGltcyBvZiB0aGlzIFRlbnNvci4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgc3RyaW5nIHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIFNUUklOR1xuICAgKi9cbiAgZ2V0IHN0cmluZ0RhdGEoKSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgdHlwZSBpcyBub3Qgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YSBhcyBUZW5zb3IuU3RyaW5nVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgaW50ZWdlciB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzogKFVJTlQ4LCBJTlQ4LCBVSU5UMTYsXG4gICAqIElOVDE2LCBJTlQzMiwgVUlOVDMyLCBCT09MKVxuICAgKi9cbiAgZ2V0IGludGVnZXJEYXRhKCkge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLkludGVnZXJUeXBlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIHR5cGUgaXMgbm90IGludGVnZXIgKHVpbnQ4LCBpbnQ4LCB1aW50MTYsIGludDE2LCBpbnQzMiwgdWludDMyLCBib29sKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgZmxvYXQgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6IChGTE9BVCwgRE9VQkxFKVxuICAgKi9cbiAgZ2V0IGZsb2F0RGF0YSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSBhcyBUZW5zb3IuRmxvYXRUeXBlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIHR5cGUgaXMgbm90IGZsb2F0IChmbG9hdDMyLCBmbG9hdDY0KScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgbnVtYmVyIHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAoVUlOVDgsIElOVDgsIFVJTlQxNixcbiAgICogSU5UMTYsIElOVDMyLCBVSU5UMzIsIEJPT0wsIEZMT0FULCBET1VCTEUpXG4gICAqL1xuICBnZXQgbnVtYmVyRGF0YSgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YSBhcyBUZW5zb3IuTnVtYmVyVHlwZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHlwZSBjYW5ub3QgYmUgbm9uLW51bWJlciAoc3RyaW5nKScpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB2YWx1ZSBvZiBhbiBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRpY2VzXG4gICAqL1xuICBnZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXVtudW1iZXJdIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW1NoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoaW5kaWNlcywgdGhpcy5zdHJpZGVzKV07XG4gIH1cblxuICAvKipcbiAgICogc2V0IHZhbHVlIG9mIGFuIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGljZXNcbiAgICovXG4gIHNldChpbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgdmFsdWU6IFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuRGF0YVR5cGVdW251bWJlcl0pIHtcbiAgICB0aGlzLmRhdGFbU2hhcGVVdGlsLmluZGljZXNUb09mZnNldChpbmRpY2VzLCB0aGlzLnN0cmlkZXMpXSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyB0ZW5zb3IgZGF0YSBhc3luY2hyb25vdXNseVxuICAgKi9cbiAgYXN5bmMgZ2V0RGF0YSgpOiBQcm9taXNlPFRlbnNvckRhdGE+IHtcbiAgICAvLyBUQkQ6IFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgZm9yIHVzYWdlIHdoZW4gYW55IGJhY2tlbmQgZGF0YSBwcm92aWRlciBvZmZlcnMgYSB3YXkgdG8gcmV0cmlldmUgZGF0YSBpbiBhblxuICAgIC8vICAgICAgYXN5bmNocm9ub3VzIHdheS4gc2hvdWxkIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uIHdoZW4gZW5hYmxpbmcgd2ViZ2wgYXN5bmMgcmVhZCBkYXRhLlxuXG4gICAgaWYgKHRoaXMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jYWNoZSA9IGF3YWl0IHRoaXMuYXN5bmNEYXRhUHJvdmlkZXIhKHRoaXMuZGF0YUlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRlbnNvclxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcblxuICBwcml2YXRlIF9zdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIGdldCB0aGUgc3RyaWRlcyBmb3IgZWFjaCBkaW1lbnNpb25cbiAgICovXG4gIGdldCBzdHJpZGVzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAoIXRoaXMuX3N0cmlkZXMpIHtcbiAgICAgIHRoaXMuX3N0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXModGhpcy5kaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlkZXM7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIHR5cGUgb2YgdGhlIHRlbnNvclxuICAgICAgICovXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogVGVuc29yLkRhdGFUeXBlLCBwcml2YXRlIGRhdGFQcm92aWRlcj86IERhdGFQcm92aWRlcixcbiAgICAgIHByaXZhdGUgYXN5bmNEYXRhUHJvdmlkZXI/OiBBc3luY0RhdGFQcm92aWRlciwgcHJpdmF0ZSBjYWNoZT86IFRlbnNvckRhdGEsXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgZGF0YSBJRCB0aGF0IHVzZWQgdG8gbWFwIHRvIGEgdGVuc29yIGRhdGFcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IGRhdGFJZDogR3VpZCA9IEd1aWQuY3JlYXRlKCkpIHtcbiAgICB0aGlzLnNpemUgPSBTaGFwZVV0aWwudmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZGltcyk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBjb25zdCBlbXB0eSA9IChkYXRhUHJvdmlkZXIgPT09IHVuZGVmaW5lZCAmJiBhc3luY0RhdGFQcm92aWRlciA9PT0gdW5kZWZpbmVkICYmIGNhY2hlID09PSB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjYWNoZS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0lucHV0IGRpbXMgZG9lc25cXCd0IG1hdGNoIGRhdGEgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGNhY2hlICE9PSB1bmRlZmluZWQgJiYgKCFBcnJheS5pc0FycmF5KGNhY2hlKSB8fCAhY2FjaGUuZXZlcnkoaSA9PiB0eXBlb2YgaSA9PT0gJ3N0cmluZycpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWNoZSBzaG91bGQgYmUgYSBzdHJpbmcgYXJyYXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgQXJyYXk8c3RyaW5nPihzaXplKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBkYXRhdmlld0NvbnN0cnVjdG9yKHR5cGUpO1xuICAgICAgICBpZiAoIShjYWNoZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGNhY2hlIHNob3VsZCBiZSB0eXBlICR7Y29uc3RydWN0b3IubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKHNpemUgKiBzaXplb2YodHlwZSkpO1xuICAgICAgICB0aGlzLmNhY2hlID0gY3JlYXRlVmlldyhidWYsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IFRlbnNvciBmcm9tIGEgT05OWCBUZW5zb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB0ZW5zb3JQcm90byB0aGUgT05OWCBUZW5zb3JcbiAgICovXG4gIHN0YXRpYyBmcm9tUHJvdG8odGVuc29yUHJvdG86IG9ubnguSVRlbnNvclByb3RvKTogVGVuc29yIHtcbiAgICBpZiAoIXRlbnNvclByb3RvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3InKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh0ZW5zb3JQcm90by5kYXRhVHlwZSEpO1xuICAgIGNvbnN0IGRpbXMgPSBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byh0ZW5zb3JQcm90by5kaW1zISk7XG5cbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBUZW5zb3IoZGltcywgdHlwZSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdoZW4gaXQncyBTVFJJTkcgdHlwZSwgdGhlIHZhbHVlIHNob3VsZCBhbHdheXMgYmUgc3RvcmVkIGluIGZpZWxkXG4gICAgICAvLyAnc3RyaW5nRGF0YSdcbiAgICAgIHRlbnNvclByb3RvLnN0cmluZ0RhdGEhLmZvckVhY2goKHN0ciwgaSkgPT4ge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzdHIuYnVmZmVyLCBzdHIuYnl0ZU9mZnNldCwgc3RyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB2YWx1ZS5kYXRhW2ldID0gYnVmLnRvU3RyaW5nKCk7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRlbnNvclByb3RvLnJhd0RhdGEgJiYgdHlwZW9mIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID4gMCkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPVxuICAgICAgICAgIG5ldyBEYXRhVmlldyh0ZW5zb3JQcm90by5yYXdEYXRhLmJ1ZmZlciwgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlT2Zmc2V0LCB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBzaXplb2ZQcm90byh0ZW5zb3JQcm90by5kYXRhVHlwZSEpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoIC8gZWxlbWVudFNpemU7XG5cbiAgICAgIGlmICh0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggJSBlbGVtZW50U2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYnVmZmVyIGxlbmd0aCcpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFEZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGxlbmd0aCBtaXNtYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG4gPSByZWFkUHJvdG8oZGF0YVNvdXJjZSwgdGVuc29yUHJvdG8uZGF0YVR5cGUhLCBpICogZWxlbWVudFNpemUpO1xuICAgICAgICBkYXRhRGVzdFtpXSA9IG47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBvcHVsYXRlIHZhbHVlIGZyb20gYXJyYXlcbiAgICAgIGxldCBhcnJheTogQXJyYXk8bnVtYmVyfExvbmc+O1xuICAgICAgc3dpdGNoICh0ZW5zb3JQcm90by5kYXRhVHlwZSkge1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgICAgICAgYXJyYXkgPSB0ZW5zb3JQcm90by5mbG9hdERhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgICAgICAgYXJyYXkgPSB0ZW5zb3JQcm90by5pbnQzMkRhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgICAgICAgYXJyYXkgPSB0ZW5zb3JQcm90by5pbnQ2NERhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uZG91YmxlRGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICAgICAgYXJyYXkgPSB0ZW5zb3JQcm90by51aW50NjREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBzaG91bGQgbmV2ZXIgcnVuIGhlcmVcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlY2lmaWMgZXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycmF5ID09PSBudWxsIHx8IGFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gcG9wdWxhdGUgZGF0YSBmcm9tIGEgdGVuc29ycHJvdG8gdmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IHZhbHVlLmRhdGE7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGxlbmd0aCBtaXNtYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKGVsZW1lbnQpKSB7XG4gICAgICAgICAgZGF0YVtpXSA9IGxvbmdUb051bWJlcihlbGVtZW50LCB0ZW5zb3JQcm90by5kYXRhVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtpXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW5zb3IgZnJvbSByYXcgZGF0YVxuICAgKiBAcGFyYW0gZGF0YSB0aGUgcmF3IGRhdGEgb2JqZWN0LiBTaG91bGQgYmUgYSBzdHJpbmcgYXJyYXkgZm9yICdzdHJpbmcnIHRlbnNvciwgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHR5cGVkIGFycmF5XG4gICAqIGZvciBvdGhlciB0eXBlcyBvZiB0ZW5zb3IuXG4gICAqIEBwYXJhbSBkaW1zIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3JcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIHRlbnNvclxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRhKGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuRGF0YVR5cGVdLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSwgdHlwZTogVGVuc29yLkRhdGFUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBUZW5zb3IoZGltcywgdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRhdGEpO1xuICB9XG5cbiAgc3RhdGljIGZyb21PcnRUZW5zb3Iob3J0VGVuc29yOiBvcnRGYnMuVGVuc29yKSB7XG4gICAgaWYgKCFvcnRUZW5zb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvcicpO1xuICAgIH1cbiAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tT1JURm9ybWF0KG9ydFRlbnNvcik7XG4gICAgY29uc3QgdHlwZSA9IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhvcnRUZW5zb3IuZGF0YVR5cGUoKSk7XG5cbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBUZW5zb3IoZGltcywgdHlwZSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdoZW4gaXQncyBTVFJJTkcgdHlwZSwgdGhlIHZhbHVlIHNob3VsZCBhbHdheXMgYmUgc3RvcmVkIGluIGZpZWxkXG4gICAgICAvLyAnc3RyaW5nRGF0YSdcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3J0VGVuc29yLnN0cmluZ0RhdGFMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgIHZhbHVlLmRhdGFbaV0gPSBvcnRUZW5zb3Iuc3RyaW5nRGF0YShpKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSAmJiB0eXBlb2Ygb3J0VGVuc29yLnJhd0RhdGFMZW5ndGgoKSA9PT0gJ251bWJlcicgJiYgb3J0VGVuc29yLnJhd0RhdGFMZW5ndGgoKSA+IDApIHtcbiAgICAgIC8vIE5PVCBjb25zaWRlcmluZyBzZWdtZW50IGZvciBub3cgKElNUE9SVEFOVClcblxuICAgICAgLy8gcG9wdWxhdGUgdmFsdWUgZnJvbSByYXdEYXRhXG4gICAgICBjb25zdCBkYXRhRGVzdCA9IHZhbHVlLmRhdGE7XG4gICAgICBjb25zdCBkYXRhU291cmNlID0gbmV3IERhdGFWaWV3KFxuICAgICAgICAgIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSEuYnVmZmVyLCBvcnRUZW5zb3IucmF3RGF0YUFycmF5KCkhLmJ5dGVPZmZzZXQsIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkpO1xuICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBzaXplb2ZQcm90byhvcnRUZW5zb3IuZGF0YVR5cGUoKSk7XG4gICAgICBjb25zdCBsZW5ndGggPSBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpIC8gZWxlbWVudFNpemU7XG5cbiAgICAgIGlmIChvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpICUgZWxlbWVudFNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhRGVzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gcmVhZFByb3RvKGRhdGFTb3VyY2UsIG9ydFRlbnNvci5kYXRhVHlwZSgpLCBpICogZWxlbWVudFNpemUpO1xuICAgICAgICBkYXRhRGVzdFtpXSA9IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplb2YodHlwZTogVGVuc29yLkRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgY2FzZSAnaW50OCc6XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgY2FzZSAndWludDMyJzpcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7dHlwZX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplb2ZQcm90byh0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlfG9ydEZicy5UZW5zb3JEYXRhVHlwZSk6IG51bWJlciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgIHJldHVybiA4O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBjYWxjdWxhdGUgc2l6ZW9mKCkgb24gdHlwZSAke29ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdHlwZV19YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmlldyhkYXRhQnVmZmVyOiBBcnJheUJ1ZmZlciwgdHlwZTogVGVuc29yLkRhdGFUeXBlKSB7XG4gIHJldHVybiBuZXcgKGRhdGF2aWV3Q29uc3RydWN0b3IodHlwZSkpKGRhdGFCdWZmZXIpO1xufVxuXG5mdW5jdGlvbiBkYXRhdmlld0NvbnN0cnVjdG9yKHR5cGU6IFRlbnNvci5EYXRhVHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sJzpcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgICBjYXNlICd1aW50MzInOlxuICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiBGbG9hdDY0QXJyYXk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHNob3VsZCBuZXZlciBydW4gdG8gaGVyZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNwZWNpZmllZCBlcnJvcicpO1xuICB9XG59XG5cbi8vIGNvbnZlcnQgYSBsb25nIG51bWJlciB0byBhIDMyLWJpdCBpbnRlZ2VyIChjYXN0LWRvd24pXG5mdW5jdGlvbiBsb25nVG9OdW1iZXIoaTogTG9uZywgdHlwZTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZXxvcnRGYnMuVGVuc29yRGF0YVR5cGUpOiBudW1iZXIge1xuICAvLyBJTlQ2NCwgVUlOVDMyLCBVSU5UNjRcbiAgaWYgKHR5cGUgPT09IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQgfHwgdHlwZSA9PT0gb3J0RmJzLlRlbnNvckRhdGFUeXBlLklOVDY0KSB7XG4gICAgaWYgKGkuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpIHx8IGkubGVzc1RoYW4oLTIxNDc0ODM2NDgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZSA9PT0gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzIgfHwgdHlwZSA9PT0gb3J0RmJzLlRlbnNvckRhdGFUeXBlLlVJTlQzMiB8fFxuICAgICAgdHlwZSA9PT0gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQgfHwgdHlwZSA9PT0gb3J0RmJzLlRlbnNvckRhdGFUeXBlLlVJTlQ2NCkge1xuICAgIGlmIChpLmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KSB8fCBpLmxlc3NUaGFuKDApKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1aW50NjQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBub3QgYSBMT05HIHR5cGU6ICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlXX1gKTtcbiAgfVxuXG4gIHJldHVybiBpLnRvTnVtYmVyKCk7XG59XG5cbi8vIHJlYWQgb25lIHZhbHVlIGZyb20gVGVuc29yUHJvdG9cbmZ1bmN0aW9uIHJlYWRQcm90byh2aWV3OiBEYXRhVmlldywgdHlwZTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZXxvcnRGYnMuVGVuc29yRGF0YVR5cGUsIGJ5dGVPZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpcbiAgICAgIHJldHVybiB2aWV3LmdldFVpbnQ4KGJ5dGVPZmZzZXQpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50OChieXRlT2Zmc2V0KTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDE2KGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpcbiAgICAgIHJldHVybiB2aWV3LmdldEludDE2KGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0MzIoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpcbiAgICAgIHJldHVybiB2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgICByZXR1cm4gbG9uZ1RvTnVtYmVyKFxuICAgICAgICAgIExvbmcuZnJvbUJpdHModmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSksIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCB0cnVlKSwgZmFsc2UpLCB0eXBlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIGxvbmdUb051bWJlcihcbiAgICAgICAgICBMb25nLmZyb21CaXRzKHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIHRydWUpLCB2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgNCwgdHJ1ZSksIHRydWUpLCB0eXBlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVhZCBmcm9tIERhdGFWaWV3IGZvciB0eXBlICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlXX1gKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZmxhdGJ1ZmZlcnN9IGZyb20gJ2ZsYXRidWZmZXJzJztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IHtvbm54fSBmcm9tICdvbm54LXByb3RvJztcblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuXG4vLyBjaGVjayB0aGUgaW5wdXRzIHNoYXBlIGJlZm9yZSBydW5uaW5nIGFuIE9QLlxuLy8gcmV0dXJuIHRydWUgd2hlbiB0aGUgaW5wdXRzIHBhc3MgdGhlIGNoZWNrXG4vLyByZXR1cm4gZmFsc2Ugd2hlbiB0aGUgaW5wdXRzIGRvIG5vdCBmaXQgdGhlIHJlcXVpcmVtZW50XG4vLyB0aHJvdyBleGNlcHRpb24gd2hlbiBmYXRhbCBlcnJvciBvciBub3QgaW1wbGVtZW50ZWRcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lucHV0c1NoYXBlKGlucHV0czogVGVuc29yW10sIC4uLmV4cGVjdGVkRGltZW5zaW9uczogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gZXhwZWN0ZWREaW1lbnNpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaW5wdXRzW2ldLmRpbXMgfHwgaW5wdXRzW2ldLmRpbXMubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbnNbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBhbmQgYXNzZXJ0cyBlcnJvciBtZXNzYWdlIGlmIGNvbmRpdGlvbiBpcyB1bm1ldC5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZXhwcjogYm9vbGVhbiwgbXNnOiAoKSA9PiBzdHJpbmcpIHtcbiAgaWYgKCFleHByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogbXNnKCkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheVV0aWwge1xuICAvKipcbiAgICogVmVyaWZpZXMgaWYgMiBpbnB1dCBhcnJheXMgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50cy5cbiAgICogQHBhcmFtIG4xIEFycmF5IDFcbiAgICogQHBhcmFtIG4yIEFycmF5IDJcbiAgICogQHJldHVybnMgV2hldGhlciB0aGVzZSAyIGFyZSBlcXVhbFxuICAgKi9cbiAgc3RhdGljIGFycmF5c0VxdWFsKFxuICAgICAgbjE6IHJlYWRvbmx5IG51bWJlcltdfEludDhBcnJheXxVaW50OEFycmF5fEludDE2QXJyYXl8VWludDE2QXJyYXl8SW50MzJBcnJheXxVaW50MzJBcnJheXxVaW50OENsYW1wZWRBcnJheXxcbiAgICAgIEZsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXksXG4gICAgICBuMjogcmVhZG9ubHkgbnVtYmVyW118SW50OEFycmF5fFVpbnQ4QXJyYXl8SW50MTZBcnJheXxVaW50MTZBcnJheXxJbnQzMkFycmF5fFVpbnQzMkFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fFxuICAgICAgRmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheSkge1xuICAgIGlmIChuMS5sZW5ndGggIT09IG4yLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4xLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogRml4IHRoZSBpbnB1dCBzaGFwZXMgZm9yIE1hdE11bCBvcGVyYXRpb24gaWYgdGhleSBuZWVkIGZpeGluZ1xuICAgKiBAcGFyYW0gZGltc0EgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGRpbXNCIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgcHJlcHJvY2Vzc2VkIGlucHV0IHNoYXBlcyBhcyByZXF1aXJlZCBieSBPTk5YIHNwZWNpZmljYXRpb25zXG4gICAqL1xuICBzdGF0aWMgcHJlcHJvY2Vzc0lucHV0U2hhcGVzKGRpbXNBOiByZWFkb25seSBudW1iZXJbXSwgZGltc0I6IHJlYWRvbmx5IG51bWJlcltdKTpcbiAgICAgIFtyZWFkb25seSBudW1iZXJbXSwgcmVhZG9ubHkgbnVtYmVyW11dIHtcbiAgICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgMS1ELCBpdCBpcyBwcm9tb3RlZCB0byBhIG1hdHJpeCBieSBwcmVwZW5kaW5nXG4gICAgLy8gYSAxIHRvIGl0cyBkaW1lbnNpb25zLiBBZnRlciBtYXRyaXggbXVsdGlwbGljYXRpb24gdGhlIHByZXBlbmRlZCAxIGlzXG4gICAgLy8gcmVtb3ZlZC5cbiAgICBjb25zdCBhID0gKGRpbXNBLmxlbmd0aCA9PT0gMSkgPyBbMSwgZGltc0FbMF1dIDogZGltc0E7XG5cbiAgICAvLyBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIDEtRCwgaXQgaXMgcHJvbW90ZWQgdG8gYSBtYXRyaXggYnkgYXBwZW5kaW5nXG4gICAgLy8gYSAxIHRvIGl0cyBkaW1lbnNpb25zLiBBZnRlciBtYXRyaXggbXVsdGlwbGljYXRpb24gdGhlIGFwcGVuZGVkIDEgaXNcbiAgICAvLyByZW1vdmVkLlxuICAgIGNvbnN0IGIgPSAoZGltc0IubGVuZ3RoID09PSAxKSA/IFtkaW1zQlswXSwgMV0gOiBkaW1zQjtcblxuICAgIHJldHVybiBbYSwgYl07XG4gIH1cblxuICAvKipcbiAgICogRml4IHRoZSBvdXRwdXQgc2hhcGUgY29tcHV0ZWQgZm9yIE1hdE11bCBvcGVyYXRpb24gaWYgaXQgbmVlZHMgZml4aW5nXG4gICAqIEBwYXJhbSBvdXRwdXRTaGFwZSBUaGUgY29tcHV0ZWQgb3V0cHV0U2hhcGUuIFNob3VsZCBiZSBhbiBhcnJheSAoYXRsZWFzdCBvZiBsZW5ndGggMikgb2YgcG9zaXRpdmUgaW50ZWdlcnMuXG4gICAqIFRoaXMgd2lsbCBiZSBtdXRhdGVkLlxuICAgKiBAcGFyYW0gYVJhbmsgVGhlIHJhbmsgb2YgdGVuc29yIEEuXG4gICAqIEBwYXJhbSBiUmFuayBUaGUgcmFuayBvZiB0ZW5zb3IgQi5cbiAgICovXG4gIHN0YXRpYyBwb3N0cHJvY2Vzc091dHB1dFNoYXBlKG91dHB1dFNoYXBlOiBudW1iZXJbXSwgYVJhbms6IG51bWJlciwgYlJhbms6IG51bWJlcikge1xuICAgIC8vIFJlbW92ZSBwcmVwZW5kZWQgZGltZW5zaW9uIGlmIGZpcnN0IGlucHV0IGlzIDFkXG4gICAgaWYgKGFSYW5rID09PSAxKSB7XG4gICAgICAvLyBvdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLnNsaWNlKDAsIG91dHB1dFNoYXBlLmxlbmd0aCAtIDIpLmNvbmNhdChvdXRwdXRTaGFwZS5zbGljZShvdXRwdXRTaGFwZS5sZW5ndGggLSAxKSk7XG4gICAgICBvdXRwdXRTaGFwZS5zcGxpY2Uob3V0cHV0U2hhcGUubGVuZ3RoIC0gMiwgMSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhcHBlbmRlZCBkaW1lbnNpb24gaWYgc2Vjb25kIGlucHV0IGlzIDFkXG4gICAgaWYgKGJSYW5rID09PSAxKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY01hdE11bFNoYXBlKGE6IFtudW1iZXIsIG51bWJlcl0sIGI6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIChhWzFdICE9PSBiWzBdKSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShhZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGJkaW1zOiByZWFkb25seSBudW1iZXJbXSwgaXNNYXRNdWwgPSBmYWxzZSk6IHJlYWRvbmx5IG51bWJlcltdfHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXJhbmsgPSBhZGltcy5sZW5ndGg7XG4gICAgY29uc3QgYnJhbmsgPSBiZGltcy5sZW5ndGg7XG4gICAgaWYgKGFyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYmRpbXM7XG4gICAgfVxuICAgIGlmIChicmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFkaW1zO1xuICAgIH1cbiAgICBjb25zdCBjcmFuayA9IE1hdGgubWF4KGFkaW1zLmxlbmd0aCwgYmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBjZGltcyA9IG5ldyBBcnJheTxudW1iZXI+KGNyYW5rKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGFzdCAyIGRpbWVuc2lvbiBpZiBpdCBpcyBNYXRNdWxcbiAgICBpZiAoaXNNYXRNdWwpIHtcbiAgICAgIGlmIChhcmFuayA8IDIgfHwgYnJhbmsgPCAyKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBjU2hhcGVNYXRNdWwgPVxuICAgICAgICAgIE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFthZGltc1thcmFuayAtIDJdLCBhZGltc1thcmFuayAtIDFdXSwgW2JkaW1zW2JyYW5rIC0gMl0sIGJkaW1zW2JyYW5rIC0gMV1dKTtcbiAgICAgIGlmIChjU2hhcGVNYXRNdWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgW2NkaW1zW2NyYW5rIC0gMl0sIGNkaW1zW2NyYW5rIC0gMV1dID0gY1NoYXBlTWF0TXVsO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpc01hdE11bCA/IDMgOiAxOyBpIDw9IGNyYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGFMZW4gPSBhcmFuayAtIGkgPCAwID8gMSA6IGFkaW1zW2FyYW5rIC0gaV07XG4gICAgICBjb25zdCBiTGVuID0gYnJhbmsgLSBpIDwgMCA/IDEgOiBiZGltc1ticmFuayAtIGldO1xuXG4gICAgICBpZiAoYUxlbiAhPT0gYkxlbiAmJiBhTGVuID4gMSAmJiBiTGVuID4gMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY2RpbXNbY3JhbmsgLSBpXSA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBjZGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgaW5kaWNlcyBvZiBhIGJyb2FkY2FzdGVkIHRlbnNvciwgY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBpbmRpY2VzXG4gICAqIEBwYXJhbSBicm9hZGNhc3RlZEluZGljZXMgVGhlIGdpdmVuIGluZGljZXMgb2YgdGhlIGJyb2FkY2FzdGVkIHRlbnNvci5cbiAgICogQHBhcmFtIG9yaWdpbmFsU2hhcGUgVGhlIG9yaWdpbmFsIHNoYXBlIG9mIHRoZSB0ZW5zb3IgYmVmb3JlIGJyb2FkY2FzXG4gICAqIEByZXR1cm5zIFRoZSBjYWxjdWxhdGVkIGluZGljZXMgdGhhdCBtYXBzIHRvIHRoZSBvcmlnaW5hbCB0ZW5zb3IuXG4gICAqL1xuICBzdGF0aWMgaW5kZXgoYnJvYWRjYXN0ZWRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgb3JpZ2luYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgLy8gTk9URSAxOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBicm9hZGNhc3RlZEluZGljZXMgaXMgdmFsaWQuIGllLiBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZVxuICAgIC8vIGxlbmd0aCBhcyB0aGUgYnJvYWRjYXN0ZWQgc2hhcGUsIGFuZCBmb3IgZWFjaCBkaW1lbnNpb24gdGhlIGluZGV4IHNob3VsZFxuICAgIC8vIG5vdCBiZSBvdXQgb2YgcmFuZ2UuXG4gICAgY29uc3Qgb3JpZ2luYWxJbmRpY2VzID0gbmV3IEFycmF5KG9yaWdpbmFsU2hhcGUubGVuZ3RoKTtcbiAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChicm9hZGNhc3RlZEluZGljZXMsIG9yaWdpbmFsU2hhcGUsIG9yaWdpbmFsSW5kaWNlcyk7XG4gICAgcmV0dXJuIG9yaWdpbmFsSW5kaWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiB0aGUgaW5kaWNlcyBvZiBhIGJyb2FkY2FzdGVkIHRlbnNvciwgY2FsY3VsYXRlIHRoZSBvcmlnaW5hbCBpbmRpY2VzXG4gICAqIEBwYXJhbSBicm9hZGNhc3RlZEluZGljZXMgVGhlIGdpdmVuIGluZGljZXMgb2YgdGhlIGJyb2FkY2FzdGVkIHRlbnNvci5cbiAgICogQHBhcmFtIG9yaWdpbmFsU2hhcGUgVGhlIG9yaWdpbmFsIHNoYXBlIG9mIHRoZSB0ZW5zb3IgYmVmb3JlIGJyb2FkY2FzdFxuICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRpY2VzIFRoZSBtYXBwaW5nIG9mIGJyb2FkY2FzdGVkSW5kaWNlcyB0byB0aGUgb3JpZ2luYWxJbmRpY2VzIChvdXRwdXQgcGFyYW1ldGVyIC0gd2lsbCBiZVxuICAgKiAgICAgbXV0YXRlZCkuXG4gICAqL1xuICBzdGF0aWMgZmlsbEluZGV4KGJyb2FkY2FzdGVkSW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIG9yaWdpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvcmlnaW5hbEluZGljZXM6IG51bWJlcltdKSB7XG4gICAgLy8gTk9URSAxOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBicm9hZGNhc3RlZEluZGljZXMgaXMgdmFsaWQuIGllLiBpdCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG4gICAgLy8gYnJvYWRjYXN0ZWQgc2hhcGUsIGFuZCBmb3IgZWFjaCBkaW1lbnNpb24gdGhlIGluZGV4IHNob3VsZCBub3QgYmUgb3V0IG9mIHJhbmdlLlxuICAgIC8vIE5PVEUgMjogd2UgYXNzdW1lIHRoZSBwYXJhbWV0ZXIgb3JpZ2luYWxJbmRpY2VzIGhhcyB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIG9yaWdpbmFsU2hhcGVcbiAgICBjb25zdCBkaW1PZmZzZXQgPSBicm9hZGNhc3RlZEluZGljZXMubGVuZ3RoIC0gb3JpZ2luYWxTaGFwZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcmlnaW5hbEluZGljZXNbaV0gPSBicm9hZGNhc3RlZEluZGljZXNbZGltT2Zmc2V0ICsgaV0gJSBvcmlnaW5hbFNoYXBlW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHRoZSBicm9hZGNhc3Rpbmcgb3BlcmF0aW9uIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBUaGUgaW5wdXQgdGVuc29yIEFcbiAgICogQHBhcmFtIGIgVGhlIGlucHV0IHRlbnNvciBCXG4gICAqIEBwYXJhbSBvcCBUaGUgb3BlcmF0b3IgbGFtYmRhIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSBpbnBsYWNlIFdoZXRoZXIgdG8gd3JpdGUgdGhlIHJlc3VsdCBiYWNrIHRvIEEuXG4gICAqIEByZXR1cm5zIFRoZSByZXN1bHQgdGVuc29yLCBvciB1bmRlZmluZWQgaWYgaW5wdXQgbm90IGJyb2FkY2FzdGFibGUuXG4gICAqL1xuICBzdGF0aWMgY2FsYyhcbiAgICAgIGE6IFRlbnNvciwgYjogVGVuc29yLCBvcDogKGE6IHN0cmluZ3xudW1iZXIsIGI6IHN0cmluZ3xudW1iZXIpID0+IChzdHJpbmcgfCBudW1iZXIpLCBpbnBsYWNlOiBib29sZWFuLFxuICAgICAgcmVzdWx0VHlwZT86IFRlbnNvci5EYXRhVHlwZSk6IFRlbnNvcnx1bmRlZmluZWQge1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYS5kaW1zLCBiLmRpbXMpO1xuXG4gICAgaWYgKG91dHB1dFNoYXBlKSB7XG4gICAgICBpZiAoaW5wbGFjZSAmJiAhU2hhcGVVdGlsLmFyZUVxdWFsKG91dHB1dFNoYXBlLCBhLmRpbXMpKSB7XG4gICAgICAgIC8vIEIgaXMgbm90IGJyb2FkY2FzdGFibGUgdG8gQSwgZmFpbGVkIHRvIGNhbGN1bGF0ZSBpbnBsYWNlLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3QgYyA9IGlucGxhY2UgPyBhIDogbmV3IFRlbnNvcihvdXRwdXRTaGFwZSwgcmVzdWx0VHlwZSB8fCBhLnR5cGUpO1xuXG4gICAgICAvLyBib3RoIGlucHV0cyBhcmUgc2NhbGFyc1xuICAgICAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjLnNldChbXSwgb3AoYS5nZXQoW10pLCBiLmdldChbXSkpKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXRsZWFzdCBvbmUgaW5wdXQgaXMgYSBub24tc2NhbGFyXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5kaWNlcyA9IG5ldyBBcnJheTxudW1iZXI+KG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kaWNlc0EgPSBuZXcgQXJyYXkoYS5kaW1zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kaWNlc0IgPSBuZXcgQXJyYXkoYi5kaW1zLmxlbmd0aCk7XG4gICAgICAgIGxldCB2YWxBOiBzdHJpbmd8bnVtYmVyID0gMDtcbiAgICAgICAgbGV0IHZhbEI6IHN0cmluZ3xudW1iZXIgPSAwO1xuICAgICAgICBsZXQgaXNBU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGxldCBpc0JTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKGEuZGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YWxBID0gYS5nZXQoW10pO1xuICAgICAgICAgIGlzQVNjYWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIuZGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YWxCID0gYi5nZXQoW10pO1xuICAgICAgICAgIGlzQlNjYWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3Q6IG51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAvLyB0cmF2ZXJzYWwgaW5kaWNlc1xuICAgICAgICAgIHJlc3QgPSBpO1xuICAgICAgICAgIGZvciAobGV0IGogPSBvdXRwdXRTaGFwZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgb3V0cHV0SW5kaWNlc1tqXSA9IHJlc3QgJSBvdXRwdXRTaGFwZVtqXTtcbiAgICAgICAgICAgIHJlc3QgPSBNYXRoLmZsb29yKHJlc3QgLyBvdXRwdXRTaGFwZVtqXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0FTY2FsYXIpIHtcbiAgICAgICAgICAgIC8vIG1hcCBvdXRwdXRJbmRpY2VzICh3aGljaCBpcyBhY3R1YWxseSBicm9hZGNhc3RlZCkgdG8gdGhlIG9yaWdpbmFsSW5kaWNlc1xuICAgICAgICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgob3V0cHV0SW5kaWNlcywgYS5kaW1zLCBvcmlnaW5hbEluZGljZXNBKTtcbiAgICAgICAgICAgIHZhbEEgPSBhLmdldChvcmlnaW5hbEluZGljZXNBKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc0JTY2FsYXIpIHtcbiAgICAgICAgICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KG91dHB1dEluZGljZXMsIGIuZGltcywgb3JpZ2luYWxJbmRpY2VzQik7XG4gICAgICAgICAgICB2YWxCID0gYi5nZXQob3JpZ2luYWxJbmRpY2VzQik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYy5zZXQob3V0cHV0SW5kaWNlcywgb3AodmFsQSwgdmFsQikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgYnJvYWRjYXN0ZWQgZGltcyBpbiBpbnB1dCBzaGFwZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb3V0cHV0IHNoYXBlLlxuICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHJldHVybnMgdGhlIGJyb2FkY2FzdGVkIGRpbXMuXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gb3V0cHV0U2hhcGUgVGhlIG91dHB1dCBzaGFwZVxuICAgKiBAcmV0dXJucyBUaGUgYnJvYWRjYXN0ZWQgZGltcyBpbiBpbnB1dCBzaGFwZS5cbiAgICovXG4gIHN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgY29uc3QgaW5SYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZGltczogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgIGNvbnN0IGEgPSBpbnB1dFNoYXBlW2RpbV0gfHwgMTtcbiAgICAgIGNvbnN0IGIgPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxufVxuXG4vLyBjb3B5IGFycmF5IGhlbHBlclxuLy8gbWltaWNzIG1lbWNweSBhcyBtdWNoIGFzIHBvc3NpYmxlXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDb3B5SGVscGVyKFxuICAgIHRhcmdldDogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHNvdXJjZTogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHRhcmdldEluZGV4OiBudW1iZXIsIHNvdXJjZUluZGV4OiBudW1iZXIsXG4gICAgYmxvY2tTaXplOiBudW1iZXIpIHtcbiAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICB9XG4gIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgfVxuXG4gIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdID0gc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgICAgbGVmdFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdHJhbnNMZWZ0OiBib29sZWFuLCByaWdodFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdHJhbnNSaWdodDogYm9vbGVhbixcbiAgICAgIGJpYXNTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChsZWZ0U2hhcGUubGVuZ3RoICE9PSAyIHx8IHJpZ2h0U2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyJyk7XG4gICAgfVxuXG4gICAgbGV0IE06IG51bWJlcjtcbiAgICBsZXQgSzogbnVtYmVyO1xuICAgIGxldCBOOiBudW1iZXI7XG5cbiAgICBpZiAodHJhbnNMZWZ0KSB7XG4gICAgICBNID0gbGVmdFNoYXBlWzFdO1xuICAgICAgSyA9IGxlZnRTaGFwZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgTSA9IGxlZnRTaGFwZVswXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMV07XG4gICAgfVxuXG4gICAgbGV0IGtEaW0gPSAtMTtcblxuICAgIGlmICh0cmFuc1JpZ2h0KSB7XG4gICAgICBOID0gcmlnaHRTaGFwZVswXTtcbiAgICAgIGtEaW0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBOID0gcmlnaHRTaGFwZVsxXTtcbiAgICAgIGtEaW0gPSAwO1xuICAgIH1cblxuICAgIGlmIChyaWdodFNoYXBlW2tEaW1dICE9PSBLKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbWVuc2lvbiBtaXNtYXRjaCcpO1xuICAgIH1cblxuICAgIGlmIChNIDw9IDAgfHwgTiA8PSAwIHx8IEsgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNoYXBlIHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIGlmIChiaWFzU2hhcGUgJiYgIUJyb2FkY2FzdFV0aWwuaXNWYWxpZEJyb2FkY2FzdChiaWFzU2hhcGUsIFtNLCBOXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2VtbTogaW52YWxpZCBiaWFzIHNoYXBlIGZvciBicm9hZGNhc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW00sIE4sIEtdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm90b1V0aWwge1xuICBzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odHlwZVByb3RvOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSk6IFRlbnNvci5EYXRhVHlwZSB7XG4gICAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgICByZXR1cm4gJ2ludDgnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgICByZXR1cm4gJ2ludDE2JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICAgIHJldHVybiAndWludDE2JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0NjQnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuXG4gICAgICAvLyBGb3IgSU5UNjQvVUlOVDY0LCByZWR1Y2UgdGhlaXIgdmFsdWUgdG8gMzItYml0cy5cbiAgICAgIC8vIFNob3VsZCB0aHJvdyBleGNlcHRpb24gd2hlbiBvdmVyZmxvd1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICAgIHJldHVybiAndWludDMyJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlUHJvdG9dfWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSh0eXBlOiBzdHJpbmcpOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4O1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODtcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MO1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjtcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjtcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI7XG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ7XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HO1xuICAgICAgY2FzZSAnaW50NjQnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDtcbiAgICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGVuc29yRGltc0Zyb21Qcm90byhkaW1zOiBBcnJheTxudW1iZXJ8TG9uZz4pOiBudW1iZXJbXSB7XG4gICAgLy8gZ2V0IHJpZCBvZiBMb25nIHR5cGUgZm9yIGRpbXNcbiAgICByZXR1cm4gZGltcy5tYXAoZCA9PiBMb25nLmlzTG9uZyhkKSA/IGQudG9OdW1iZXIoKSA6IGQpO1xuICB9XG5cbiAgc3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh2YWx1ZVR5cGU6IG9ubnguVHlwZVByb3RvLklUZW5zb3IpOiBHcmFwaC5WYWx1ZVR5cGUge1xuICAgIHJldHVybiB7XG4gICAgICB0ZW5zb3JUeXBlOiBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odmFsdWVUeXBlLmVsZW1UeXBlISksXG4gICAgICBzaGFwZToge2RpbXM6IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbVByb3RvKHZhbHVlVHlwZS5zaGFwZSEuZGltIS5tYXAoZCA9PiBkLmRpbVZhbHVlISkpfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQodGVuc29yOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcikge1xuICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbnNvci5kaW1zTGVuZ3RoKCk7IGkrKykge1xuICAgICAgZGltcy5wdXNoKExvbmdVdGlsLmxvbmdUb051bWJlcih0ZW5zb3IuZGltcyhpKSEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbXM7XG4gIH1cblxuICBzdGF0aWMgdGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQobm9kZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKG5vZGUuYXR0cmlidXRlcyhpKSEpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTG9uZ1V0aWwge1xuICBzdGF0aWMgbG9uZ1RvTnVtYmVyKG46IExvbmd8ZmxhdGJ1ZmZlcnMuTG9uZ3xudW1iZXIpIHtcbiAgICBpZiAoTG9uZy5pc0xvbmcobikpIHtcbiAgICAgIHJldHVybiBuLnRvTnVtYmVyKCk7XG4gICAgfSBlbHNlIGlmIChuIGluc3RhbmNlb2YgZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgcmV0dXJuIExvbmcuZnJvbVZhbHVlKHtsb3c6IG4ubG93LCBoaWdoOiBuLmhpZ2gsIHVuc2lnbmVkOiB0cnVlfSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgc3RhdGljIGlzTG9uZyhuOiB1bmtub3duKSB7XG4gICAgcmV0dXJuIExvbmcuaXNMb25nKG4pIHx8IG4gaW5zdGFuY2VvZiBmbGF0YnVmZmVycy5Mb25nO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGBheGlzYCBpbmNsdXNpdmVcbiAgc3RhdGljIHNpemVGcm9tRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZUZyb21EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgYXhpcywgZGltcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gYGF4aXNgIGV4Y2x1c2l2ZVxuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgc3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIC8vIHNhZmV0eSBjaGVjayBhcyB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgbXVsdGlwbGUgb3RoZXIgbWV0aG9kcyByZXF1aXJpbmcgc2l6ZS5cbiAgICAgIC8vIHNpemUgY2Fubm90IGJlIDAgb3IgbmVnYXRpdmUuXG4gICAgICBpZiAoZGltc1tpXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIDAgb3IgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uJyk7XG4gICAgICB9XG4gICAgICBzaXplICo9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAxXSA9IDE7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBkaW1zW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZXM7XG4gIH1cblxuICBzdGF0aWMgdHJhbnNwb3NlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IGNvcHkgPSBkaW1zLnNsaWNlKCk7XG4gICAgcmV0dXJuIGNvcHkucmV2ZXJzZSgpO1xuICB9XG5cbiAgc3RhdGljIGluZGljZXNUb09mZnNldChpbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM/OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF4aXMgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGlzOyArK2kpIHtcbiAgICAgIG9mZnNldCArPSBzdHJpZGVzW2ldICogaW5kaWNlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIHN0YXRpYyBvZmZzZXRUb0luZGljZXMob2Zmc2V0OiBudW1iZXIsIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBzdHJpZGVzLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFtvZmZzZXQgKiBzdHJpZGVzWzBdXTtcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlczogbnVtYmVyW10gPSBuZXcgQXJyYXkoc3RyaWRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGluZGljZXNbaV0gPSBNYXRoLmZsb29yKG9mZnNldCAvIHN0cmlkZXNbaV0pO1xuICAgICAgb2Zmc2V0IC09IGluZGljZXNbaV0gKiBzdHJpZGVzW2ldO1xuICAgIH1cbiAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFpbHplIGF4aXMgb2YgcmFuZ2UgWy1yLCByKSBpbnRvIFswLCByKS5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVBeGlzKGF4aXM6IG51bWJlciwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rICYmIGF4aXMgPj0gdGVuc29yUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXMgPCAwID8gYXhpcyArIHRlbnNvclJhbmsgOiBheGlzO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZUF4ZXMoYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHRlbnNvclJhbms6IG51bWJlcik6IG51bWJlcltdIHtcbiAgICByZXR1cm4gYXhlcy5tYXAoeCA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuaykpO1xuICB9XG5cbiAgLy8gSW5jcmVtZW50IGFuIGluZGV4IGludG8gYSB0ZW5zb3IgKGluIGxleGljb2dyYXBoaWNcbiAgLy8gb3JkZXJpbmcpLCB3cmFwcGluZyBhcm91bmQgdGhlIHNwZWNpZmllZCB1cHBlcl9ib3VuZC5cbiAgLyoqXG4gICAqIEluY3JlbWVudCBhbiBpbmRleCBpbnRvIGEgdGVuc29yIChpbiBsZXhpY29ncmFwaGljIG9yZGVyaW5nKSwgd3JhcHBpbmcgYXJvdW5kIHRoZSBzcGVjaWZpZWQgdXBwZXJfYm91bmQuXG4gICAqIEBwYXJhbSBpbmRleCBHaXZlbiBpbmRleCB0byBpbmNyZW1lbnQgKFdpbGwgYmUgbXV0YXRlZClcbiAgICogQHBhcmFtIGRpbXMgVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvciBmb3Igd2hpY2ggdGhlIGdpdmVuIGluZGV4IGNvcnJlc3BvbmRzIHRvXG4gICAqIEBwYXJhbSBheGlzVG9JbmNyZW1lbnRPbiBUaGUgMS1pbmRleGVkIGF4aXMgdG8gaW5jcmVtZW50IG9uLiBJZiB1bmRlZmluZWQsIGF4aXNUb0luY3JlbWVudE9uID09IHJhbmtcbiAgICovXG4gIHN0YXRpYyBpbmNyZW1lbnRJbmRleChpbmRleDogbnVtYmVyW10sIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzVG9JbmNyZW1lbnRPbj86IG51bWJlcikge1xuICAgIGlmIChkaW1zLmxlbmd0aCA9PT0gMCB8fCBpbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yJyk7XG4gICAgfVxuICAgIGlmIChheGlzVG9JbmNyZW1lbnRPbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBheGlzVG9JbmNyZW1lbnRPbiA9IGRpbXMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXhpc1RvSW5jcmVtZW50T24gPD0gMCB8fCBheGlzVG9JbmNyZW1lbnRPbiA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgayA9IGF4aXNUb0luY3JlbWVudE9uIC0gMTsgayA+PSAwOyAtLWspIHtcbiAgICAgIGluZGV4W2tdKys7XG4gICAgICBpZiAoaW5kZXhba10gPCBkaW1zW2tdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5kZXhba10gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIG5ldyBkaW1lbnNpb25zIGFycmF5IGJhc2VkIG9uIHRoZSB2YWx1ZXMgaW4gdGhlICdvcmlnaW5hbERpbWVuc2lvbnMnIGFuZCAnc2hhcGUnIGFycmF5XG4gICAqIFVzZWQgaW4gUmVzaGFwZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxEaW1zIE9yaWdpbmFsIFNoYXBlIGFycmF5XG4gICAqIEBwYXJhbSBzaGFwZUhpbnRzIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIHRvIGNvbXB1dGUgdGhlIG5ldyBkaW1lbnNpb25zXG4gICAqIEZvciBleGFtcGxlOlxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFswLC0xXSB3aWxsIHJldHVybiBbMiwyXVxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFs0XSB3aWxsIHJldHVybiBbNF1cbiAgICogb3JpZ2luYWxEaW1zID0gWzIsMl0gYW5kIHNoYXBlSGludHMgPSBbNV0gd2lsbCB0aHJvdyBhbiBleGNlcHRpb25cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNSZXNoYXBlXG4gICAqL1xuXG4gIHN0YXRpYyBjYWxjdWxhdGVSZXNoYXBlZERpbXMoXG4gICAgICBvcmlnaW5hbERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZUhpbnRzOiBudW1iZXJbXXxyZWFkb25seSBudW1iZXJbXXxUZW5zb3IuSW50ZWdlclR5cGUpOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgLy8gcmVzaGFwZSB0byBhIFNjYWxhciBUZW5zb3JcbiAgICBpZiAoc2hhcGVIaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChvcmlnaW5hbERpbXMubGVuZ3RoID09PSAwIHx8IFNoYXBlVXRpbC5zaXplKG9yaWdpbmFsRGltcykgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVzaGFwZSB0byBhIHNjYWxhciBUZW5zb3InKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuRGltcyA9IHNoYXBlSGludHMubGVuZ3RoO1xuICAgIGNvbnN0IHJlc2hhcGVkRGltcyA9IG5ldyBBcnJheTxudW1iZXI+KG5EaW1zKTtcbiAgICBsZXQgdW5rbm93bkRpbWVuc2lvbiA9IC0xO1xuICAgIGxldCBuZXdUZW5zb3JTaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5EaW1zOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZUhpbnRzW2ldIDwgLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGRpbWVuc2lvbiBpbiBzaGFwZSBoaW50cyBjYW5ub3QgYmUgbGVzcyB0aGFuIC0xJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVIaW50c1tpXSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHVua25vd25EaW1lbnNpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdCBtb3N0IG9uZSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2FuIGJlIC0xJyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5rbm93bkRpbWVuc2lvbiA9IGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hhcGVIaW50c1tpXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChpID49IG9yaWdpbmFsRGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNoYXBlZERpbXNbaV0gPSBvcmlnaW5hbERpbXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzaGFwZWREaW1zW2ldID0gc2hhcGVIaW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdUZW5zb3JTaXplICo9IHJlc2hhcGVkRGltc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbGRUZW5zb3JTaXplID0gU2hhcGVVdGlsLnNpemUob3JpZ2luYWxEaW1zKTtcbiAgICBpZiAodW5rbm93bkRpbWVuc2lvbiAhPT0gLTEpIHtcbiAgICAgIGlmIChvbGRUZW5zb3JTaXplICUgbmV3VGVuc29yU2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoZSBpbnB1dCB0ZW5zb3IgY2Fubm90IGJlIHJlc2hhcGVkIHRvIHRoZSByZXF1ZXN0ZWQgc2hhcGUuIElucHV0IHNoYXBlOiBbJHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGltc31dIE91dHB1dCBzaGFwZTogWyR7c2hhcGVIaW50c31dYCk7XG4gICAgICB9XG4gICAgICByZXNoYXBlZERpbXNbdW5rbm93bkRpbWVuc2lvbl0gPSBvbGRUZW5zb3JTaXplIC8gbmV3VGVuc29yU2l6ZTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgc2l6ZXMgZnJvbSBvcmlnaW5hbERpbXMgYW5kIHJlc2hhcGVkRGltcyBtYXRjaFxuICAgIGVsc2Uge1xuICAgICAgaWYgKG5ld1RlbnNvclNpemUgIT09IG9sZFRlbnNvclNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb25cXCd0IGhhdmUgbWF0Y2hpbmcgc2l6ZXMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2hhcGVkRGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhIGdpdmVuIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRpY2VzIGluIHRoZSBQZXJtIGFycmF5XG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXG4gICAqIEBwYXJhbSBhIEFycmF5IHRvIGJlIHNvcnRlZCBzdWNoIGFzIGRpbXMgb3Igc3RyaWRlc1xuICAgKiBAcGFyYW0gcGVybSBQZXJtIGdpdmVuOyBpZiBudWxsIGEgd2lsbCBiZSByZXZlcnNlZFxuICAgKi9cbiAgc3RhdGljIHNvcnRCYXNlZE9uUGVybShhOiByZWFkb25seSBudW1iZXJbXSwgcGVybT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChwZXJtKSB7XG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIGdpdmVuIHNoYXBlIGFjY29yZGluZyB0byB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGRpbXMgc2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBwYWRkZWRcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgcGFkU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHBhZDogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIHJldHVybiBkaW1zLm1hcCgodiwgaSkgPT4gdiArIHBhZFtpXSArIHBhZFtpICsgcmFua10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHR3byBzaGFwZXMgYXJlIGlkZW50aWNhbFxuICAgKiBAcGFyYW0gc2hhcGUxXG4gICAqIEBwYXJhbSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGUyW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGdpdmVuIGBkaW1zYCBvciBgc2hhcGVgIGlzIHZhbGlkIGluIE9OTlguanMgY29udGV4dCBhbmQgcmV0dXJucyBkYXRhIHNpemVcbiAgICogQHBhcmFtIGRpbXMgLSBpbnB1dCBgZGltc2AgdGhhdCBuZWVkcyB0byBiZSBjaGVja2VkXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChkaW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuJyk7XG4gICAgfVxuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGltcykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMCB8fCBuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBuO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSBmbGF0dGVuKHgsIGF4aXMpXG4gICAqIEBwYXJhbSBkaW1zIC0gc2hhcGUgb2YgaW5wdXQgdGVuc29yXG4gICAqIEBwYXJhbSBheGlzIC0gZmxhdHRlbiBheGlzLCBpbiB0aGUgcmFuZ2UgWy1yLCByXVxuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW5TaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgYXhpcyArPSBkaW1zLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgdG90YWwgPSBkaW1zLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGltcy5zbGljZShheGlzKS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW3RvdGFsIC8gcmlnaHQsIHJpZ2h0XTtcblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHNxdWVlemUoeCwgYXhlcylcbiAgICogQHBhcmFtIGRpbXMgLSBzaGFwZSBvZiBpbnB1dCB0ZW5zb3JcbiAgICogQHBhcmFtIGF4ZXMgLSBzcXVlZXplIGF4ZXNcbiAgICovXG4gIHN0YXRpYyBzcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGRpbXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5TcXVlZXplTGlzdCA9IGF4ZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgaWYgKGluU3F1ZWV6ZUxpc3QgJiYgZGltc1tpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxdWVlemUgYW4gYXhpcyBvZiBzaXplIGRpZmZlcmVudCB0aGFuIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChheGVzLmxlbmd0aCA9PT0gMCAmJiBkaW1zW2ldID4gMSkgfHwgKGF4ZXMubGVuZ3RoID4gMCAmJiAhaW5TcXVlZXplTGlzdCkpIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKGRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHVuc3F1ZWV6ZSh4LCBheGVzKVxuICAgKiBAcGFyYW0gZGltcyAtIHNoYXBlIG9mIGlucHV0IHRlbnNvclxuICAgKiBAcGFyYW0gYXhlcyAtIHVuc3F1ZWV6ZSBheGVzXG4gICAqL1xuICBzdGF0aWMgdW5zcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW1zLmxlbmd0aCArIGF4ZXMubGVuZ3RoKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGFycmF5IGVsZW1lbnRzIHRvIDBcbiAgICBvdXRwdXREaW1zLmZpbGwoMCk7XG5cbiAgICAvLyBzZXQgYWxsIGF4ZXMgaW5kaWNlcyB0byAxIGluIG91dHB1dERpbXMgYW5kIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhlc1tpXSwgZGltcy5sZW5ndGgpO1xuICAgICAgaWYgKGF4aXMgPj0gb3V0cHV0RGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdheGVzXFwnIGhhcyBhbiBvdXQgb2YgcmFuZ2UgYXhpcycpO1xuICAgICAgfVxuICAgICAgaWYgKG91dHB1dERpbXNbYXhpc10gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdheGVzXFwnIGhhcyBhIGR1cGxpY2F0ZSBheGlzJyk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dERpbXNbYXhpc10gPSAxO1xuICAgIH1cblxuICAgIC8vIGZpbGwgaW4gdGhlIHplcm8gZW50cmllcyBvZiBvdXRwdXREaW1zIHdpdGggdGhlIGlucHV0IHRlbnNvcidzIHNoYXBlXG4gICAgbGV0IGlucHV0RGltc0l0ZXJhdG9yID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dERpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvdXRwdXREaW1zW2ldID09PSAwKSB7XG4gICAgICAgIG91dHB1dERpbXNbaV0gPSBkaW1zW2lucHV0RGltc0l0ZXJhdG9yKytdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVjayBhc3NlcnRpb24uICdpbnB1dERpbXNJdGVyYXRvcidcbiAgICAvLyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiAnZGltcydcbiAgICBpZiAoaW5wdXREaW1zSXRlcmF0b3IgIT09IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSB1bnNxdWVlemVkIGRpbWVuc2lvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxufVxuXG4vLyBidW5jaCBvZiBoZWxwZXIgbWV0aG9kcyB0aGF0IGRvIGEgdmFyaWV0eSBvZiBtYXRoIG9wZXJhdGlvbnNcbmV4cG9ydCBjbGFzcyBNYXRoVXRpbCB7XG4gIC8vIHkgPSAoeCp4KSArIHlcbiAgc3RhdGljIHNxcihcbiAgICAgIHRhcmdldDogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHNvdXJjZTogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHRhcmdldEluZGV4OiBudW1iZXIsIHNvdXJjZUluZGV4OiBudW1iZXIsXG4gICAgICBibG9ja1NpemU6IG51bWJlcikge1xuICAgIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdICs9IE1hdGgucG93KHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0sIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHkgPSBheCArIHlcbiAgc3RhdGljIGF4cHkoXG4gICAgICB0YXJnZXQ6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCBzb3VyY2U6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCB0YXJnZXRJbmRleDogbnVtYmVyLCBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgICAgYmxvY2tTaXplOiBudW1iZXIsIGFscGhhOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSArPSAoYWxwaGEgKiBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gcG93KHgsIGIpXG4gIHN0YXRpYyBwb3d4KFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSA9IE1hdGgucG93KHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0sIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHkgPSB4ICogeVxuICBzdGF0aWMgbXVsKFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSAoc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XSAqIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3BsaXRVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgbmV3IFNoYXBlcyBmcm9tIGV4aXN0aW5nIG9uZSBhbmQgdGhlIHNwbGl0cyBnaXZlbiBhbG9uZyB0aGUgYXhpcyBwcm92aWRlc1xuICAgKiBAcGFyYW0gZGltcyBTaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHNwbGl0dGVkIGludG8gdHdvIG9yIG1vcmUgU2hhcGVzXG4gICAqIEBwYXJhbSBheGlzIFRoZSBkaW1lbnNpb24gYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHNwbGl0XG4gICAqIEBwYXJhbSBzcGxpdHMgT2Zmc2V0cyBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggc3BsaXRcbiAgICovXG4gIHN0YXRpYyBzcGxpdFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIsIHNwbGl0OiBudW1iZXJbXSwgbnVtT3V0cHV0cz86IG51bWJlcik6XG4gICAgICBbbnVtYmVyW11bXSwgbnVtYmVyW11dIHtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIW51bU91dHB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgXFwnc3BsaXRcXCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQnKTtcbiAgICAgIH1cbiAgICAgIFNwbGl0VXRpbC5kZXRlcm1pbmVTcGxpdChkaW1zW2F4aXNdLCBudW1PdXRwdXRzLCBzcGxpdCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFswXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0c1tpIC0gMV0gKyBzcGxpdFtpIC0gMV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcGUgPSBkaW1zLnNsaWNlKCk7XG4gICAgICBzaGFwZVtheGlzXSA9IHNwbGl0W2ldO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gW3NoYXBlcywgb2Zmc2V0c107XG4gIH1cblxuICBzdGF0aWMgZGV0ZXJtaW5lU3BsaXQobnVtRWxlbWVudHNBbG9uZ0F4aXM6IG51bWJlciwgbnVtT3V0cHV0czogbnVtYmVyLCBzcGxpdDogbnVtYmVyW10pIHtcbiAgICAvLyBJZiAnc3BsaXQnIGlzIG5vdCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlIG5lZWQgdG8gcGFydGl0aW9uIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWxseSBhbW9uZyB0aGUgb3V0cHV0c1xuICAgIGlmIChudW1FbGVtZW50c0Fsb25nQXhpcyAlIG51bU91dHB1dHMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0cycpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU91dHB1dHM7ICsraSkge1xuICAgICAgc3BsaXQucHVzaChudW1FbGVtZW50c0Fsb25nQXhpcyAvIG51bU91dHB1dHMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVkdWNlVXRpbCB7XG4gIC8qKlxuICAgKiBQZXJmb3JtIHJlZHVjZSBvcGVyYXRpb25zIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0ga2VlcGRpbXMgSWYgc2V0IHRvIHRydWUsIHRoZSBheGVzIHdoaWNoIGFyZSByZWR1Y2VkIGFyZSBsZWZ0IGluIHRoZVxuICAgKiAgICByZXN1bHQgYXMgZGltZW5zaW9ucyB3aXRoIHNpemUgb25lLlxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZShcbiAgICAgIGE6IFRlbnNvciwgYXhlczogbnVtYmVyW10sIGtlZXBkaW1zOiBib29sZWFuLCBvcDE6IChiOiBudW1iZXIpID0+IG51bWJlcixcbiAgICAgIG9wMjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpOiBUZW5zb3Ige1xuICAgIGNvbnN0IGRpbXMgPSBhLmRpbXMuc2xpY2UoMCk7XG4gICAgLy8gaWYgYXhlcyBpcyBub3Qgc2V0LCBwZXJmb3JtIHJlZHVjZSBvbiBhbGwgYXhlc1xuICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGltcy5mb3JFYWNoKChkLCBpbmQpID0+IGF4ZXMucHVzaChpbmQpKTtcbiAgICB9XG4gICAgLy8gZ2V0IGEgdGVtcG9yYXJ5IGJyb2FkY2FzdGFibGUgb3V0cHV0IHNoYXBlXG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFJlZHVjZVV0aWwuY2FsY1JlZHVjZVNoYXBlKGRpbXMsIGF4ZXMsIHRydWUpO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBvdXRwdXQgYW5kIGNhbGN1bGF0ZSByZXN1bHQgb25lIGJ5IG9uZVxuICAgIGNvbnN0IHNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXREaW1zKTtcbiAgICBjb25zdCB5ID0gbmV3IFRlbnNvcihvdXRwdXREaW1zLCBhLnR5cGUpO1xuICAgIGNvbnN0IHN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMob3V0cHV0RGltcyk7XG4gICAgY29uc3QgaW5wdXRTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGRpbXMpO1xuICAgIGNvbnN0IGluZGljZXNZID0gbmV3IEFycmF5KGRpbXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFNoYXBlVXRpbC5vZmZzZXRUb0luZGljZXMoaSwgc3RyaWRlcyk7XG4gICAgICAvLyBtYXAgaW5kZXhcbiAgICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KGluZGljZXMsIGRpbXMsIGluZGljZXNZKTtcbiAgICAgIHkuc2V0KFxuICAgICAgICAgIGluZGljZXMsXG4gICAgICAgICAgUmVkdWNlVXRpbC5jYWxjUmVkdWNlQnlBeGlzKFxuICAgICAgICAgICAgICBhLm51bWJlckRhdGEsIGF4ZXMsIGRpbXMsIDAsIFNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoaW5kaWNlc1ksIGlucHV0U3RyaWRlcyksIG9wMSwgb3AyKSk7XG4gICAgfVxuXG4gICAgaWYgKGtlZXBkaW1zKSB7XG4gICAgICByZXR1cm4geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ga2VlcGRpbXMgPT0gMCwgY2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZVxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoXG4gICAgICAgICAgUmVkdWNlVXRpbC5jYWxjUmVkdWNlU2hhcGUoZGltcywgYXhlcywga2VlcGRpbXMpLCB5LnR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB5LmRhdGEsIHkuZGF0YUlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSByZWR1Y2Ugb3BlcmF0aW9ucyBvbiB0aGUgc3BlY2lmaWMgb3BlcmF0b3Igb24gc3BlY2lmaWMgYXhlc1xuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0gZGltcyBUaGUgaW5wdXQgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0gY3VyQXhpc0luZCBJbmRleCBpbiBheGVzIHNwZWNpZnlpbmcgdGhlIGN1cnJlbnQgZGltZW5zaW9uIGFsb25nXG4gICAqICAgICAgd2hpY2ggdGhlIHRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIHBvcyBUaGUgY3VycmVudCBpbmRleCBvZiBlbGVtZW50IHRvIHBlcmZvcm0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBvcDEgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgb24gZWFjaCBlbGVtZW50IGluIHRoZSB0ZW5zb3JcbiAgICogQHBhcmFtIG9wMiBUaGUgb3BlcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBiZXR3ZWVuIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlQnlBeGlzKFxuICAgICAgaW5wdXQ6IFRlbnNvci5OdW1iZXJUeXBlLCBheGVzOiBudW1iZXJbXSwgZGltczogbnVtYmVyW10sIGN1ckF4aXNJbmQ6IG51bWJlciwgcG9zOiBudW1iZXIsXG4gICAgICBvcDE6IChiOiBudW1iZXIpID0+IG51bWJlciwgb3AyOiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHJlcyA9IDA7XG4gICAgaWYgKGN1ckF4aXNJbmQgPj0gYXhlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBvcDEoaW5wdXRbcG9zXSk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBheGVzW2N1ckF4aXNJbmRdO1xuICAgIGNvbnN0IHN0ZXAgPSBheGlzID49IGRpbXMubGVuZ3RoID8gMSA6IFNoYXBlVXRpbC5zaXplKGRpbXMuc2xpY2UoYXhpcyArIDEpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNbYXhpc107IGkrKykge1xuICAgICAgcmVzID0gaSA9PT0gMCA/IFJlZHVjZVV0aWwuY2FsY1JlZHVjZUJ5QXhpcyhpbnB1dCwgYXhlcywgZGltcywgY3VyQXhpc0luZCArIDEsIHBvcywgb3AxLCBvcDIpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvcDIocmVzLCBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VCeUF4aXMoaW5wdXQsIGF4ZXMsIGRpbXMsIGN1ckF4aXNJbmQgKyAxLCBwb3MsIG9wMSwgb3AyKSk7XG4gICAgICBwb3MgKz0gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIG9mIGEgcmVkdWNlIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gZGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvblxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0ga2VlcGRpbXMgSWYgc2V0IHRvIHRydWUsIHRoZSBheGVzIHdoaWNoIGFyZSByZWR1Y2VkIGFyZSBsZWZ0IGluIHRoZVxuICAgKiAgICByZXN1bHQgYXMgZGltZW5zaW9ucyB3aXRoIHNpemUgb25lLlxuICAgKi9cbiAgc3RhdGljIGNhbGNSZWR1Y2VTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIGtlZXBEaW1zOiBib29sZWFuKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBkaW1zLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgb3V0cHV0RGltc1theGVzW2ldXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXREaW1zW2F4ZXNbaV1dID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dERpbXMuZmlsdGVyKGRpbSA9PiBkaW0gIT09IDApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqL1xuICBzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXMoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLFxuICAgICAgcGFkczogbnVtYmVyW10pIHtcbiAgICBpZiAoIWlzR2xvYmFsT3BlcmF0b3IgJiYga2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dERpbXMubGVuZ3RoIC0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzR2xvYmFsT3BlcmF0b3IpIHtcbiAgICAgIC8vIGFkanVzdCBrZXJuZWwgc2hhcGUgdG8gY292ZXIgdGhlIGlucHV0IGRpbXNcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBpZiAoZGltID49IGtlcm5lbFNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgIGtlcm5lbFNoYXBlLnB1c2goaW5wdXREaW1zW2RpbSArIDJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZVtkaW1dID0gaW5wdXREaW1zW2RpbSArIDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHN0cmlkZXMgbGVuZ3RoIHRvIG1hdGNoIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoZGltIDwgc3RyaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN0cmlkZXNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmlkZXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBkaWxhdGlvbnM6IG51bWJlcltdLCBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLFxuICAgICAgYXV0b1BhZD86IHN0cmluZykge1xuICAgIGlmICghYXV0b1BhZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYWRzLmxlbmd0aCAhPT0gMiAqIChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmlkZXMubGVuZ3RoICE9PSAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChrZXJuZWxTaGFwZS5sZW5ndGggIT09IChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgaW5wdXREaW1zW2RpbSArIDJdLCBzdHJpZGVzW2RpbV0sIGRpbGF0aW9uc1tkaW1dLCBrZXJuZWxTaGFwZVtkaW1dLCBwYWRzLCBkaW0sIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICAgIGF1dG9QYWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaGFwZSBmb3IgUG9vbCBvcHMgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIFBvb2wgb3BzKVxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cbiAgICovXG4gIHN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sXG4gICAgICBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hhcGUgbXVzdCBiZSBvZiBzaXplIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgaW5wdXREaW1zWzFdXTtcblxuICAgIC8vIFRPRE86IHN1cHBvcnQgZGlsYXRpb25zIGZvciBwb29sIG9wZXJhdG9yc1xuICAgIGNvbnN0IGRpbGF0aW9ucyA9IG5ldyBBcnJheTxudW1iZXI+KGtlcm5lbFNoYXBlLmxlbmd0aCkuZmlsbCgxKTtcblxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgICAgIGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0RGltcywgb3V0cHV0RGltcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XG4gICAgcmV0dXJuIG91dHB1dERpbXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIENvbnYgb3AgYmFzZWQgb24gaW5wdXQgYXR0cmlidXRlcy4gKFNob3VsZCBiZSB1c2VkIG9ubHkgZm9yIENvbnYgb3ApXG4gICAqIEBwYXJhbSBpbnB1dERpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMF0uZGltcylcbiAgICogQHBhcmFtIGZpbHRlckRpbXMgVGhlIGZpbHRlciB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzFdLmRpbXMpXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBrZXJuZWxTaGFwZSBUaGUgc2l6ZSBvZiB0aGUga2VybmVsIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGF1dG9QYWQgREVQUkVDQVRFRCBhdHRyaWJ1dGUgc3VwcG9ydGVkIGZvciBsZWdhY3kgbW9kZWxzLiBTcGVjaWZpZXMgaG93IHRvIGltcGxpY2l0bHkgY2FsY3VsYXRlIHBhZHMgaW4gZWFjaFxuICAgKiAgICAgZGltZW5zaW9uLiBDYW4gdGFrZSB2YWx1ZXMgTk9UU0VULCBTQU1FX1VQUEVSLCBTQU1FX0xPV0VSLCBvciBWQUxJRC5cbiAgICovXG4gIHN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKFxuICAgICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgZmlsdGVyRGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBkaWxhdGlvbnM6IG51bWJlcltdLFxuICAgICAga2VybmVsU2hhcGU6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgYXV0b1BhZD86IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0RGltczogbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgYXV0b1BhZD86IHN0cmluZykge1xuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKFBvb2xDb252VXRpbC5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAyXSwgc3RyaWRlc1tkaW1dLCBkaWxhdGlvbnNbZGltXSwga2VybmVsU2hhcGVbZGltXSwgcGFkcywgZGltLCBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcbiAgICAgICAgICAgIGF1dG9QYWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGNvbXB1dGVTaGFwZUhlbHBlcigpIGFuZCBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoKVxuICAvLyBhZGp1c3RzIHBhZCB2YWx1ZSBmb3IgZ2l2ZW4gJ2F1dG9QYWQnIHN0cmluZyBhbmQgY29tcHV0ZXMgb3V0cHV0IHNoYXBlIGFsb25nIGEgcGFydGljdWxhciBkaW1lbnNpb25cbiAgcHJpdmF0ZSBzdGF0aWMgYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICBpblNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIGRpbGF0aW9uOiBudW1iZXIsIGtlcm5lbDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSwgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgICBwYWRUYWlsSW5kZXg6IG51bWJlciwgYXV0b1BhZD86IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgZGtlcm5lbCA9IGRpbGF0aW9uICogKGtlcm5lbCAtIDEpICsgMTtcbiAgICBpZiAoYXV0b1BhZCAmJiBhdXRvUGFkICE9PSAnTk9UU0VUJykge1xuICAgICAgc3dpdGNoIChhdXRvUGFkKSB7XG4gICAgICAgIGNhc2UgJ1ZBTElEJzpcbiAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSAwO1xuICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IDA7XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgLSBka2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPVxuICAgICAgICAgICAgICAgIChhdXRvUGFkID09PSAnU0FNRV9MT1dFUicpID8gTWF0aC5mbG9vcigocGFkTmVlZGVkICsgMSkgLyAyKSA6IE1hdGguZmxvb3IocGFkTmVlZGVkIC8gMik7XG4gICAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSBwYWROZWVkZWQgLSBwYWRzW3BhZEhlYWRJbmRleF07XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSArIHBhZE5lZWRlZCAtIGtlcm5lbCkgLyBzdHJpZGUpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplICsgcGFkc1twYWRIZWFkSW5kZXhdICsgcGFkc1twYWRUYWlsSW5kZXhdIC0gZGtlcm5lbCkgLyBzdHJpZGUpICsgMSk7XG4gICAgfVxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW50ZXJmYWNlIEV4dHJhT3B0aW9uc0hhbmRsZXIge1xuICAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IGl0ZXJhdGVFeHRyYU9wdGlvbnMgPVxuICAgIChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgcHJlZml4OiBzdHJpbmcsIHNlZW46IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+LFxuICAgICBoYW5kbGVyOiBFeHRyYU9wdGlvbnNIYW5kbGVyKTogdm9pZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2Vlbi5oYXMob3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vlbi5hZGQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAocHJlZml4KSA/IHByZWZpeCArIGtleSA6IGtleTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBuYW1lICsgJy4nLCBzZWVuLCBoYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgaGFuZGxlcihuYW1lLCAodmFsdWUpID8gJzEnIDogJzAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge2l0ZXJhdGVFeHRyYU9wdGlvbnN9IGZyb20gJy4vb3B0aW9ucy11dGlscyc7XG5pbXBvcnQge2FsbG9jV2FzbVN0cmluZ30gZnJvbSAnLi9zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuXG5leHBvcnQgY29uc3Qgc2V0UnVuT3B0aW9ucyA9IChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBbbnVtYmVyLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHJ1bk9wdGlvbnNIYW5kbGUgPSAwO1xuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgcnVuT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0cnkge1xuICAgIGlmIChvcHRpb25zPy5sb2dTZXZlcml0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA9IDI7ICAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwpIHx8XG4gICAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHwgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1ZlcmJvc2l0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPSAwOyAgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8udGVybWluYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy50YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhvcHRpb25zLnRhZywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBydW5PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhcbiAgICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsISwgcnVuT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCEsICEhcnVuT3B0aW9ucy50ZXJtaW5hdGUhLCB0YWdEYXRhT2Zmc2V0KTtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNyZWF0ZSBydW4gb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKG9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcblxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkUnVuQ29uZmlnRW50cnkocnVuT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtrZXl9IC0gJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtydW5PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaCh3YXNtLl9mcmVlKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7b25ueH0gZnJvbSAnb25ueC1wcm90byc7XG5pbXBvcnQge2VudiwgSW5mZXJlbmNlU2Vzc2lvbiwgU2Vzc2lvbkhhbmRsZXIsIFRlbnNvciwgVHlwZWRUZW5zb3J9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7c2V0UnVuT3B0aW9uc30gZnJvbSAnLi9ydW4tb3B0aW9ucyc7XG5pbXBvcnQge3NldFNlc3Npb25PcHRpb25zfSBmcm9tICcuL3Nlc3Npb24tb3B0aW9ucyc7XG5pbXBvcnQge2FsbG9jV2FzbVN0cmluZ30gZnJvbSAnLi9zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuXG5sZXQgb3J0SW5pdDogYm9vbGVhbjtcblxuY29uc3QgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0gPSAodHlwZTogc3RyaW5nKTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODtcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODtcbiAgICBjYXNlICdib29sJzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjtcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtcbiAgICBjYXNlICd1aW50MzInOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyO1xuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORztcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbmNvbnN0IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nID0gKHR5cGVQcm90bzogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSk6IFRlbnNvci5UeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpcbiAgICAgIHJldHVybiAnaW50OCc7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgcmV0dXJuICd1aW50OCc7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpcbiAgICAgIHJldHVybiAnaW50MTYnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICByZXR1cm4gJ3VpbnQxNic7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpcbiAgICAgIHJldHVybiAndWludDMyJztcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gJ2Zsb2F0NjQnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgIHJldHVybiAndWludDMyJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVQcm90b119YCk7XG4gIH1cbn07XG5cbmNvbnN0IG51bWVyaWNUZW5zb3JUeXBlVG9UeXBlZEFycmF5ID0gKHR5cGU6IFRlbnNvci5UeXBlKTogRmxvYXQzMkFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIEludDhBcnJheUNvbnN0cnVjdG9yfFVpbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MTZBcnJheUNvbnN0cnVjdG9yfEludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8XG4gICAgVWludDhBcnJheUNvbnN0cnVjdG9yfEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfFVpbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICAgICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICAgICAgY2FzZSAnaW50NjQnOlxuICAgICAgICAgIHJldHVybiBCaWdJbnQ2NEFycmF5O1xuICAgICAgICBjYXNlICd1aW50NjQnOlxuICAgICAgICAgIHJldHVybiBCaWdVaW50NjRBcnJheTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG5jb25zdCBnZXRMb2dMZXZlbCA9IChsb2dMZXZlbDogJ3ZlcmJvc2UnfCdpbmZvJ3wnd2FybmluZyd8J2Vycm9yJ3wnZmF0YWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7bG9nTGV2ZWx9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbkhhbmRsZTogbnVtYmVyO1xuXG4gIGlucHV0TmFtZXM6IHN0cmluZ1tdO1xuICBwcml2YXRlIGlucHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW107XG4gIG91dHB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBvdXRwdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXTtcblxuICBsb2FkTW9kZWwobW9kZWw6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogdm9pZCB7XG4gICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gICAgaWYgKCFvcnRJbml0KSB7XG4gICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRJbml0KGVudi53YXNtLm51bVRocmVhZHMhLCBnZXRMb2dMZXZlbChlbnYubG9nTGV2ZWwhKSk7XG4gICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS4gZXJyb3IgY29kZSA9ICR7ZXJyb3JDb2RlfWApO1xuICAgICAgfVxuICAgICAgb3J0SW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZWxEYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKG1vZGVsLmJ5dGVMZW5ndGgpO1xuICAgIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gICAgbGV0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBbc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGFsbG9jc10gPSBzZXRTZXNzaW9uT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgd2FzbS5IRUFQVTguc2V0KG1vZGVsLCBtb2RlbERhdGFPZmZzZXQpO1xuICAgICAgdGhpcy5zZXNzaW9uSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbihtb2RlbERhdGFPZmZzZXQsIG1vZGVsLmJ5dGVMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICAgIGlmICh0aGlzLnNlc3Npb25IYW5kbGUgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb24nKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgd2FzbS5fZnJlZShtb2RlbERhdGFPZmZzZXQpO1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICAgIGFsbG9jcy5mb3JFYWNoKHdhc20uX2ZyZWUpO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0Q291bnQgPSB3YXNtLl9PcnRHZXRJbnB1dENvdW50KHRoaXMuc2Vzc2lvbkhhbmRsZSk7XG4gICAgY29uc3Qgb3V0cHV0Q291bnQgPSB3YXNtLl9PcnRHZXRPdXRwdXRDb3VudCh0aGlzLnNlc3Npb25IYW5kbGUpO1xuXG4gICAgdGhpcy5pbnB1dE5hbWVzID0gW107XG4gICAgdGhpcy5pbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgICB0aGlzLm91dHB1dE5hbWVzID0gW107XG4gICAgdGhpcy5vdXRwdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRJbnB1dE5hbWUodGhpcy5zZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBnZXQgYW4gaW5wdXQgbmFtZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnB1dE5hbWVzVVRGOEVuY29kZWQucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuaW5wdXROYW1lcy5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBuYW1lID0gd2FzbS5fT3J0R2V0T3V0cHV0TmFtZSh0aGlzLnNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGdldCBhbiBvdXRwdXQgbmFtZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5vdXRwdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLm91dHB1dE5hbWVzLnB1c2god2FzbS5VVEY4VG9TdHJpbmcobmFtZSkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRpc3Bvc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gICAgaWYgKHRoaXMuaW5wdXROYW1lc1VURjhFbmNvZGVkKSB7XG4gICAgICB0aGlzLmlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKHdhc20uX09ydEZyZWUpO1xuICAgICAgdGhpcy5pbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3V0cHV0TmFtZXNVVEY4RW5jb2RlZCkge1xuICAgICAgdGhpcy5vdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2god2FzbS5fT3J0RnJlZSk7XG4gICAgICB0aGlzLm91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2Vzc2lvbkhhbmRsZSkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24odGhpcy5zZXNzaW9uSGFuZGxlKTtcbiAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcnVuKGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLCBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPiB7XG4gICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaChrdnAgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnB1dE5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtuYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIGlucHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgaW5wdXRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZXRjaGVzKS5mb3JFYWNoKGt2cCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBwcmUtYWxsb2NhdGVkIG91dHB1dFxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7bmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBvdXRwdXRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRDb3VudCA9IGlucHV0SW5kaWNlcy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0cHV0Q291bnQgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aDtcblxuICAgIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgICBsZXQgcnVuT3B0aW9uc0FsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICAgIGNvbnN0IGlucHV0VmFsdWVzOiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0QWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIFtydW5PcHRpb25zSGFuZGxlLCBydW5PcHRpb25zQWxsb2NzXSA9IHNldFJ1bk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIC8vIGNyZWF0ZSBpbnB1dCB0ZW5zb3JzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhID0gaW5wdXRBcnJheVtpXS5kYXRhO1xuXG4gICAgICAgIGxldCBkYXRhT2Zmc2V0OiBudW1iZXI7XG4gICAgICAgIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gNCAqIGRhdGEubGVuZ3RoO1xuICAgICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGlucHV0QWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG4gICAgICAgICAgbGV0IGRhdGFJbmRleCA9IGRhdGFPZmZzZXQgLyA0O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXSA9IGFsbG9jV2FzbVN0cmluZyhkYXRhW2ldLCBpbnB1dEFsbG9jcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGlucHV0QWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG4gICAgICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgZGF0YU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaW1zID0gaW5wdXRBcnJheVtpXS5kaW1zO1xuXG4gICAgICAgIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogZGltcy5sZW5ndGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBkaW1JbmRleCA9IGRpbXNPZmZzZXQgLyA0O1xuICAgICAgICAgIGRpbXMuZm9yRWFjaChkID0+IHdhc20uSEVBUDMyW2RpbUluZGV4KytdID0gZCk7XG4gICAgICAgICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgICAgICAgICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShpbnB1dEFycmF5W2ldLnR5cGUpLCBkYXRhT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCwgZGltc09mZnNldCwgZGltcy5sZW5ndGgpO1xuICAgICAgICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgYSB0ZW5zb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXRWYWx1ZXMucHVzaCh0ZW5zb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmVSdW5TdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gICAgICBjb25zdCBpbnB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gICAgICBjb25zdCBpbnB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgICAgIGNvbnN0IG91dHB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhvdXRwdXRDb3VudCAqIDQpO1xuICAgICAgY29uc3Qgb3V0cHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiA0KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGlucHV0VmFsdWVzSW5kZXggPSBpbnB1dFZhbHVlc09mZnNldCAvIDQ7XG4gICAgICAgIGxldCBpbnB1dE5hbWVzSW5kZXggPSBpbnB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICAgICAgbGV0IG91dHB1dFZhbHVlc0luZGV4ID0gb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICAgICAgbGV0IG91dHB1dE5hbWVzSW5kZXggPSBvdXRwdXROYW1lc09mZnNldCAvIDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgd2FzbS5IRUFQVTMyW2lucHV0VmFsdWVzSW5kZXgrK10gPSBpbnB1dFZhbHVlc1tpXTtcbiAgICAgICAgICB3YXNtLkhFQVBVMzJbaW5wdXROYW1lc0luZGV4KytdID0gdGhpcy5pbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5wdXRJbmRpY2VzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgICB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzSW5kZXgrK10gPSAwO1xuICAgICAgICAgIHdhc20uSEVBUFUzMltvdXRwdXROYW1lc0luZGV4KytdID0gdGhpcy5vdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3VwcG9ydCBSdW5PcHRpb25zXG4gICAgICAgIGxldCBlcnJvckNvZGUgPSB3YXNtLl9PcnRSdW4oXG4gICAgICAgICAgICB0aGlzLnNlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNPZmZzZXQsIGlucHV0VmFsdWVzT2Zmc2V0LCBpbnB1dENvdW50LCBvdXRwdXROYW1lc09mZnNldCwgb3V0cHV0Q291bnQsXG4gICAgICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsIHJ1bk9wdGlvbnNIYW5kbGUpO1xuXG4gICAgICAgIGNvbnN0IG91dHB1dDoge1tuYW1lOiBzdHJpbmddOiBUZW5zb3J9ID0ge307XG5cbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gMCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGVuc29yID0gd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc09mZnNldCAvIDQgKyBpXTtcblxuICAgICAgICAgICAgY29uc3QgYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgICAgICAgIC8vIHN0YWNrIGFsbG9jYXRlIDQgcG9pbnRlciB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdGVuc29yRGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogNCk7XG5cbiAgICAgICAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZXx1bmRlZmluZWQsIGRhdGFPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0VGVuc29yRGF0YShcbiAgICAgICAgICAgICAgICAgIHRlbnNvciwgdGVuc29yRGF0YU9mZnNldCwgdGVuc29yRGF0YU9mZnNldCArIDQsIHRlbnNvckRhdGFPZmZzZXQgKyA4LCB0ZW5zb3JEYXRhT2Zmc2V0ICsgMTIpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBnZXQgYSB0ZW5zb3IgZGF0YS4gZXJyb3IgY29kZSA9ICR7ZXJyb3JDb2RlfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB0ZW5zb3JEYXRhSW5kZXggPSB0ZW5zb3JEYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgICAgICAgIGNvbnN0IGRpbXNMZW5ndGggPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICAgICAgICBjb25zdCBkaW1zID0gW107XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGltcy5wdXNoKHdhc20uSEVBUFUzMltkaW1zT2Zmc2V0IC8gNCArIGldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3YXNtLl9PcnRGcmVlKGRpbXNPZmZzZXQpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBkaW1zLmxlbmd0aCA9PT0gMCA/IDEgOiBkaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgICAgICAgICB0eXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZGF0YVR5cGUpO1xuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiB3YXNtLkhFQVBVMzJbZGF0YUluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG5ldyBUZW5zb3IoJ3N0cmluZycsIHN0cmluZ0RhdGEsIGRpbXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXkgPSBudW1lcmljVGVuc29yVHlwZVRvVHlwZWRBcnJheSh0eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gbmV3IFRlbnNvcih0eXBlLCBuZXcgdHlwZWRBcnJheShzaXplKSwgZGltcykgYXMgVHlwZWRUZW5zb3I8RXhjbHVkZTxUZW5zb3IuVHlwZSwgJ3N0cmluZyc+PjtcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh0LmRhdGEuYnVmZmVyLCB0LmRhdGEuYnl0ZU9mZnNldCwgdC5kYXRhLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIC5zZXQod2FzbS5IRUFQVTguc3ViYXJyYXkoZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIHQuZGF0YS5ieXRlTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0W3RoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kaWNlc1tpXV1dID0gdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB3YXNtLl9mcmVlKGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JDb2RlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLiBlcnJvciBjb2RlID0gJHtlcnJvckNvZGV9LmApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLnN0YWNrUmVzdG9yZShiZWZvcmVSdW5TdGFjayk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlucHV0VmFsdWVzLmZvckVhY2god2FzbS5fT3J0UmVsZWFzZVRlbnNvcik7XG4gICAgICBpbnB1dEFsbG9jcy5mb3JFYWNoKHdhc20uX2ZyZWUpO1xuXG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICAgIHJ1bk9wdGlvbnNBbGxvY3MuZm9yRWFjaCh3YXNtLl9mcmVlKTtcbiAgICB9XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHByb2ZpbGluZ1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge2l0ZXJhdGVFeHRyYU9wdGlvbnN9IGZyb20gJy4vb3B0aW9ucy11dGlscyc7XG5pbXBvcnQge2FsbG9jV2FzbVN0cmluZ30gZnJvbSAnLi9zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuXG5jb25zdCBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwgPSAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbDogc3RyaW5nfHVua25vd24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpIHtcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdleHRlbmRlZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdhbGwnOlxuICAgICAgcmV0dXJuIDk5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtncmFwaE9wdGltaXphdGlvbkxldmVsfWApO1xuICB9XG59O1xuXG5jb25zdCBnZXRFeGVjdXRpb25Nb2RlID0gKGV4ZWN1dGlvbk1vZGU6ICdzZXF1ZW50aWFsJ3wncGFyYWxsZWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChleGVjdXRpb25Nb2RlKSB7XG4gICAgY2FzZSAnc2VxdWVudGlhbCc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdwYXJhbGxlbCc6XG4gICAgICByZXR1cm4gMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtleGVjdXRpb25Nb2RlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0U2Vzc2lvbk9wdGlvbnMgPSAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBbbnVtYmVyLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0cnkge1xuICAgIGlmIChvcHRpb25zPy5ncmFwaE9wdGltaXphdGlvbkxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlc3Npb25PcHRpb25zLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPSAnYWxsJztcbiAgICB9XG4gICAgY29uc3QgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA9IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbChzZXNzaW9uT3B0aW9ucy5ncmFwaE9wdGltaXphdGlvbkxldmVsISk7XG5cbiAgICBpZiAob3B0aW9ucz8uZW5hYmxlQ3B1TWVtQXJlbmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2Vzc2lvbk9wdGlvbnMuZW5hYmxlQ3B1TWVtQXJlbmEgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5lbmFibGVNZW1QYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlc3Npb25PcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5leGVjdXRpb25Nb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvbk1vZGUgPSAnc2VxdWVudGlhbCc7XG4gICAgfVxuICAgIGNvbnN0IGV4ZWN1dGlvbk1vZGUgPSBnZXRFeGVjdXRpb25Nb2RlKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvbk1vZGUhKTtcblxuICAgIGxldCBsb2dJZERhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy5sb2dJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dJZERhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcob3B0aW9ucy5sb2dJZCwgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ubG9nU2V2ZXJpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXNzaW9uT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID0gMjsgIC8vIERlZmF1bHQgdG8gd2FybmluZ1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsIDwgMCB8fCBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ubG9nVmVyYm9zaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2Vzc2lvbk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPSAwOyAgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IHByb2ZpbGluZ1xuICAgIHNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xuXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcbiAgICAgICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCwgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVDcHVNZW1BcmVuYSEsICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlTWVtUGF0dGVybiEsIGV4ZWN1dGlvbk1vZGUsXG4gICAgICAgIHNlc3Npb25PcHRpb25zLmVuYWJsZVByb2ZpbGluZywgMCwgbG9nSWREYXRhT2Zmc2V0LCBzZXNzaW9uT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsISxcbiAgICAgICAgc2Vzc2lvbk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwhKTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uZXhlY3V0aW9uUHJvdmlkZXJzKSB7XG4gICAgICBjb25zdCBlcHMgPSBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycztcbiAgICAgIGNvbnN0IGVwc05hbWVzID0gZXBzLm1hcChpID0+IHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpO1xuICAgICAgaWYgKGVwc05hbWVzLmluZGV4T2YoJ3dlYm5uJykgIT09IC0xKSB7XG4gICAgICAgIGlmICh3YXNtLl9PcnRTZXNzaW9uT3B0aW9uc0FwcGVuZEV4ZWN1dGlvblByb3ZpZGVyV2ViTk4oc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIDApICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBhcHBlbmQgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaCh3YXNtLl9mcmVlKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtPcnRXYXNtTW9kdWxlfSBmcm9tICcuL2JpbmRpbmcvb3J0LXdhc20nO1xuaW1wb3J0IHtPcnRXYXNtVGhyZWFkZWRNb2R1bGV9IGZyb20gJy4vYmluZGluZy9vcnQtd2FzbS10aHJlYWRlZCc7XG5pbXBvcnQgb3J0V2FzbUZhY3RvcnlUaHJlYWRlZCBmcm9tICcuL2JpbmRpbmcvb3J0LXdhc20tdGhyZWFkZWQuanMnO1xuaW1wb3J0IG9ydFdhc21GYWN0b3J5IGZyb20gJy4vYmluZGluZy9vcnQtd2FzbS5qcyc7XG5cbmxldCB3YXNtOiBPcnRXYXNtTW9kdWxlO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xuXG5jb25zdCBpc011bHRpVGhyZWFkU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIGlmICgodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAodHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAodHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVGhyZWFkcyBpcyBub3Qgc3VwcG9ydGVkIGluIE5vZGUuanMnKTtcbiAgICB9XG4gICAgLy8gVGVzdCBmb3IgdHJhbnNmZXJhYmlsaXR5IG9mIFNBQnMgKGZvciBicm93c2Vycy4gbmVlZGVkIGZvciBGaXJlZm94KVxuICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFtc2cvbW96aWxsYS5kZXYucGxhdGZvcm0vSUhrQlpsSEVUcEEvZHdzTU5jaFdFUUFKXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSk7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgdGhyZWFkcyBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIHRocmVhZGVkIGluc3RydWN0aW9ucy5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAgMCwgIDAsIDEsIDQsIDEsICA5NiwgMCwgICAwLCAgMywgMiwgMSwgIDAsIDUsXG4gICAgICA0LCAxLCAgMywgICAxLCAgIDEsIDEwLCAxMSwgMSwgOSwgMCwgNjUsIDAsICAyNTQsIDE2LCAyLCAwLCAyNiwgMTFcbiAgICBdKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgU0lNRCBpbnN0cnVjdGlvbnMuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFxuICAgICAgICBbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA0LCAxLCA5NiwgMCwgMCwgMywgMiwgMSwgMCwgMTAsIDksIDEsIDcsIDAsIDY1LCAwLCAyNTMsIDE1LCAyNiwgMTFdKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHkgPSBhc3luYygpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIGlmIChpbml0aWFsaXppbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpcGxlIGNhbGxzIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGRldGVjdGVkLicpO1xuICB9XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmV2aW91cyBjYWxsIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGZhaWxlZC4nKTtcbiAgfVxuXG4gIGluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgLy8gd2FzbSBmbGFncyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFxuICBjb25zdCB0aW1lb3V0ID0gZW52Lndhc20uaW5pdFRpbWVvdXQhO1xuICBjb25zdCBudW1UaHJlYWRzID0gZW52Lndhc20ubnVtVGhyZWFkcyE7XG4gIGNvbnN0IHNpbWQgPSBlbnYud2FzbS5zaW1kITtcblxuICBjb25zdCB1c2VUaHJlYWRzID0gbnVtVGhyZWFkcyA+IDEgJiYgaXNNdWx0aVRocmVhZFN1cHBvcnRlZCgpO1xuICBjb25zdCB1c2VTaW1kID0gc2ltZCAmJiBpc1NpbWRTdXBwb3J0ZWQoKTtcbiAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuXG4gIGNvbnN0IHRhc2tzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuXG4gIC8vIHByb21pc2UgZm9yIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgdGFza3MucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmYWN0b3J5ID0gdXNlVGhyZWFkcyA/IG9ydFdhc21GYWN0b3J5VGhyZWFkZWQgOiBvcnRXYXNtRmFjdG9yeTtcbiAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8T3J0V2FzbU1vZHVsZT4gPSB7fTtcblxuICAgIGlmICghdXNlVGhyZWFkcykge1xuICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWU6IHN0cmluZywgc2NyaXB0RGlyZWN0b3J5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHVzZVNpbWQgJiYgZmlsZU5hbWUgPT09ICdvcnQtd2FzbS53YXNtJykge1xuICAgICAgICAgIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyAnb3J0LXdhc20tc2ltZC53YXNtJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgZmlsZU5hbWU7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbmZpZy5tYWluU2NyaXB0VXJsT3JCbG9iID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ29ydC13YXNtLXRocmVhZGVkLmpzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY3JpcHRTb3VyY2VDb2RlID1cbiAgICAgICAgICAgIGB2YXIgb3J0V2FzbVRocmVhZGVkPShmdW5jdGlvbigpe3ZhciBfc2NyaXB0RGlyO3JldHVybiAke29ydFdhc21GYWN0b3J5VGhyZWFkZWQudG9TdHJpbmcoKX19KSgpO2A7XG4gICAgICAgIGNvbmZpZy5tYWluU2NyaXB0VXJsT3JCbG9iID0gbmV3IEJsb2IoW3NjcmlwdFNvdXJjZUNvZGVdLCB7dHlwZTogJ3RleHQvamF2YXNjcmlwdCd9KTtcbiAgICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWU6IHN0cmluZywgc2NyaXB0RGlyZWN0b3J5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAoZmlsZU5hbWUuZW5kc1dpdGgoJy53b3JrZXIuanMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZXF1aXJlKCkgZnVuY3Rpb24gaXMgaGFuZGxlZCBieSB3ZWJwYWNrIHRvIGxvYWQgZmlsZSBjb250ZW50IG9mIHRoZSBjb3JyZXNwb25kaW5nIC53b3JrZXIuanNcbiAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2JpbmRpbmcvb3J0LXdhc20tdGhyZWFkZWQud29ya2VyLmpzJylcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHt0eXBlOiAndGV4dC9qYXZhc2NyaXB0J30pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXNlU2ltZCAmJiBmaWxlTmFtZSA9PT0gJ29ydC13YXNtLXRocmVhZGVkLndhc20nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyBmaWxlTmFtZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmYWN0b3J5KGNvbmZpZykudGhlbihcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIG1vZHVsZSA9PiB7XG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHdhc20gPSBtb2R1bGU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyB3YXNtIG1vZHVsZSBmYWlsZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAod2hhdCkgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJlamVjdCh3aGF0KTtcbiAgICAgICAgfSk7XG4gIH0pKTtcblxuICBhd2FpdCBQcm9taXNlLnJhY2UodGFza3MpO1xuXG4gIGlmIChpc1RpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0aW1lb3V0fW1zYCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZSA9ICgpOiBPcnRXYXNtTW9kdWxlID0+IHtcbiAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuIHdhc207XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGlzcG9zZSA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKGluaXRpYWxpemVkICYmICFpbml0aWFsaXppbmcgJiYgIWFib3J0ZWQpIHtcbiAgICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gICAgKHdhc20gYXMgT3J0V2FzbVRocmVhZGVkTW9kdWxlKS5QVGhyZWFkPy50ZXJtaW5hdGVBbGxUaHJlYWRzKCk7XG5cbiAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2xpYi9pbmRleC50c1wiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=