/*!
* ONNX Runtime Web v1.8.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("onnxruntime-common"));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("onnxruntime-common")) : factory(root["ort"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function(__WEBPACK_EXTERNAL_MODULE_onnxruntime_common__) {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/wasm/binding/ort-wasm-threaded.js":
/*!***********************************************!*\
  !*** ./lib/wasm/binding/ort-wasm-threaded.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __filename = "/index.js";
var __dirname = "/";

var ortWasmThreaded = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (true) _scriptDir = _scriptDir || __filename;
  return (
function(ortWasmThreaded) {
  ortWasmThreaded = ortWasmThreaded || {};

function GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU8}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF64}var Module=typeof ortWasmThreaded!=="undefined"?ortWasmThreaded:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var ENVIRONMENT_IS_PTHREAD=Module["ENVIRONMENT_IS_PTHREAD"]||false;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;var nodeFS;var nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=__webpack_require__(/*! path */ "?75c6").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=__webpack_require__(/*! fs */ "?63c8");if(!nodePath)nodePath=__webpack_require__(/*! path */ "?75c6");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"};var nodeWorkerThreads;try{nodeWorkerThreads=__webpack_require__(/*! worker_threads */ "?c6f7")}catch(e){console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');throw e}__webpack_require__.g.Worker=nodeWorkerThreads.Worker}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs}else if(typeof arguments!="undefined"){arguments_=arguments}if(typeof quit==="function"){quit_=function(status){quit(status)}}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}if(ENVIRONMENT_IS_NODE){read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=__webpack_require__(/*! fs */ "?63c8");if(!nodePath)nodePath=__webpack_require__(/*! path */ "?75c6");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret}}else{read_=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=function(title){document.title=title}}else{}if(ENVIRONMENT_IS_NODE){if(typeof performance==="undefined"){__webpack_require__.g.performance=__webpack_require__(/*! perf_hooks */ "?674f").performance}}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}var Atomics_load=Atomics.load;var Atomics_store=Atomics.store;var Atomics_compareExchange=Atomics.compareExchange;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||false;if(typeof WebAssembly!=="object"){abort("no native wasm support detected")}var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var str="";while(!(idx>=endIdx)){var u0=heap[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,GROWABLE_HEAP_I8(),ret,size);return ret}function writeArrayToMemory(array,buffer){GROWABLE_HEAP_I8().set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){GROWABLE_HEAP_I8()[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)GROWABLE_HEAP_I8()[buffer>>0]=0}function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;if(ENVIRONMENT_IS_PTHREAD){buffer=Module["buffer"]}function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;if(ENVIRONMENT_IS_PTHREAD){wasmMemory=Module["wasmMemory"];buffer=Module["buffer"]}else{if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"]}else{wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,"maximum":2147483648/65536,"shared":true});if(!(wasmMemory.buffer instanceof SharedArrayBuffer)){err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");if(ENVIRONMENT_IS_NODE){console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)")}throw Error("bad memory")}}}if(wasmMemory){buffer=wasmMemory.buffer}INITIAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATINIT__)}function exitRuntime(){if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATEXIT__);flush_NO_FILESYSTEM();PThread.runExitHandlers();runtimeExited=true}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){assert(!ENVIRONMENT_IS_PTHREAD,"addRunDependency cannot be used in a pthread worker");runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(ENVIRONMENT_IS_PTHREAD)console.error("Pthread aborting at "+(new Error).stack);what+="";err(what);ABORT=true;EXITSTATUS=1;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile="ort-wasm-threaded.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmTable=Module["asm"]["eb"];addOnInit(Module["asm"]["Ma"]);PThread.tlsInitFunctions.push(Module["asm"]["jb"]);wasmModule=module;if(!ENVIRONMENT_IS_PTHREAD){removeRunDependency("wasm-instantiate")}}if(!ENVIRONMENT_IS_PTHREAD){addRunDependency("wasm-instantiate")}function receiveInstantiationResult(result){receiveInstance(result["instance"],result["module"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){var result=WebAssembly.instantiate(binary,info);return result}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}var ASM_CONSTS={653988:function(){throw"Canceled!"},654006:function($0,$1){setTimeout(function(){__emscripten_do_dispatch_to_thread($0,$1)},0)}};function initPthreadsJS(){PThread.initRuntime()}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)()}else{wasmTable.get(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var ERRNO_CODES={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function _emscripten_futex_wake(addr,count){if(addr<=0||addr>GROWABLE_HEAP_I8().length||addr&3!=0||count<0)return-28;if(count==0)return 0;if(count>=2147483647)count=Infinity;var mainThreadWaitAddress=Atomics.load(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2);var mainThreadWoken=0;if(mainThreadWaitAddress==addr){var loadedAddr=Atomics.compareExchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,mainThreadWaitAddress,0);if(loadedAddr==mainThreadWaitAddress){--count;mainThreadWoken=1;if(count<=0)return 1}}var ret=Atomics.notify(GROWABLE_HEAP_I32(),addr>>2,count);if(ret>=0)return ret+mainThreadWoken;throw"Atomics.notify returned an unexpected value "+ret}Module["_emscripten_futex_wake"]=_emscripten_futex_wake;function killThread(pthread_ptr){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!pthread_ptr)throw"Internal Error! Null pthread_ptr in killThread!";GROWABLE_HEAP_I32()[pthread_ptr+12>>2]=0;var pthread=PThread.pthreads[pthread_ptr];pthread.worker.terminate();PThread.freeThreadData(pthread);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker),1);pthread.worker.pthread=undefined}function cancelThread(pthread_ptr){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!pthread_ptr)throw"Internal Error! Null pthread_ptr in cancelThread!";var pthread=PThread.pthreads[pthread_ptr];pthread.worker.postMessage({"cmd":"cancel"})}function cleanupThread(pthread_ptr){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!pthread_ptr)throw"Internal Error! Null pthread_ptr in cleanupThread!";var pthread=PThread.pthreads[pthread_ptr];if(pthread){GROWABLE_HEAP_I32()[pthread_ptr+12>>2]=0;var worker=pthread.worker;PThread.returnWorkerToPool(worker)}}var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],initMainThreadBlock:function(){},initRuntime:function(){var tb=_malloc(228);for(var i=0;i<228/4;++i)GROWABLE_HEAP_U32()[tb/4+i]=0;GROWABLE_HEAP_I32()[tb+12>>2]=tb;var headPtr=tb+152;GROWABLE_HEAP_I32()[headPtr>>2]=headPtr;var tlsMemory=_malloc(512);for(var i=0;i<128;++i)GROWABLE_HEAP_U32()[tlsMemory/4+i]=0;Atomics.store(GROWABLE_HEAP_U32(),tb+100>>2,tlsMemory);Atomics.store(GROWABLE_HEAP_U32(),tb+40>>2,tb);__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1);_emscripten_register_main_browser_thread_id(tb)},initWorker:function(){},pthreads:{},threadExitHandlers:[],runExitHandlers:function(){while(PThread.threadExitHandlers.length>0){PThread.threadExitHandlers.pop()()}if(ENVIRONMENT_IS_PTHREAD&&_pthread_self())___pthread_tsd_run_dtors()},runExitHandlersAndDeinitThread:function(tb,exitCode){Atomics.store(GROWABLE_HEAP_U32(),tb+56>>2,1);Atomics.store(GROWABLE_HEAP_U32(),tb+60>>2,0);PThread.runExitHandlers();Atomics.store(GROWABLE_HEAP_U32(),tb+4>>2,exitCode);Atomics.store(GROWABLE_HEAP_U32(),tb+0>>2,1);_emscripten_futex_wake(tb+0,2147483647);__emscripten_thread_init(0,0,0)},setExitStatus:function(status){EXITSTATUS=status},threadExit:function(exitCode){var tb=_pthread_self();if(tb){PThread.runExitHandlersAndDeinitThread(tb,exitCode);if(ENVIRONMENT_IS_PTHREAD){postMessage({"cmd":"exit"})}}},threadCancel:function(){PThread.runExitHandlersAndDeinitThread(_pthread_self(),-1);postMessage({"cmd":"cancelDone"})},terminateAllThreads:function(){for(var t in PThread.pthreads){var pthread=PThread.pthreads[t];if(pthread&&pthread.worker){PThread.returnWorkerToPool(pthread.worker)}}PThread.pthreads={};for(var i=0;i<PThread.unusedWorkers.length;++i){var worker=PThread.unusedWorkers[i];worker.terminate()}PThread.unusedWorkers=[];for(var i=0;i<PThread.runningWorkers.length;++i){var worker=PThread.runningWorkers[i];var pthread=worker.pthread;PThread.freeThreadData(pthread);worker.terminate()}PThread.runningWorkers=[]},freeThreadData:function(pthread){if(!pthread)return;if(pthread.threadInfoStruct){var tlsMemory=GROWABLE_HEAP_I32()[pthread.threadInfoStruct+100>>2];GROWABLE_HEAP_I32()[pthread.threadInfoStruct+100>>2]=0;_free(tlsMemory);_free(pthread.threadInfoStruct)}pthread.threadInfoStruct=0;if(pthread.allocatedOwnStack&&pthread.stackBase)_free(pthread.stackBase);pthread.stackBase=0;if(pthread.worker)pthread.worker.pthread=null},returnWorkerToPool:function(worker){PThread.runWithoutMainThreadQueuedCalls(function(){delete PThread.pthreads[worker.pthread.threadInfoStruct];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);PThread.freeThreadData(worker.pthread);worker.pthread=undefined})},runWithoutMainThreadQueuedCalls:function(func){GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls>>2]=0;try{func()}finally{GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls>>2]=1}},receiveObjectTransfer:function(data){},threadInit:function(){for(var i in PThread.tlsInitFunctions){PThread.tlsInitFunctions[i]()}},loadWasmModuleToWorker:function(worker,onFinishedLoading){worker.onmessage=function(e){var d=e["data"];var cmd=d["cmd"];if(worker.pthread)PThread.currentProxiedOperationCallerThread=worker.pthread.threadInfoStruct;if(d["targetThread"]&&d["targetThread"]!=_pthread_self()){var thread=PThread.pthreads[d.targetThread];if(thread){thread.worker.postMessage(e.data,d["transferList"])}else{console.error('Internal error! Worker sent a message "'+cmd+'" to target pthread '+d["targetThread"]+", but that thread no longer exists!")}PThread.currentProxiedOperationCallerThread=undefined;return}if(cmd==="processQueuedMainThreadWork"){_emscripten_main_thread_process_queued_calls()}else if(cmd==="spawnThread"){spawnThread(e.data)}else if(cmd==="cleanupThread"){cleanupThread(d["thread"])}else if(cmd==="killThread"){killThread(d["thread"])}else if(cmd==="cancelThread"){cancelThread(d["thread"])}else if(cmd==="loaded"){worker.loaded=true;if(onFinishedLoading)onFinishedLoading(worker);if(worker.runPthread){worker.runPthread();delete worker.runPthread}}else if(cmd==="print"){out("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="printErr"){err("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="alert"){alert("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="exit"){var detached=worker.pthread&&Atomics.load(GROWABLE_HEAP_U32(),worker.pthread.threadInfoStruct+64>>2);if(detached){PThread.returnWorkerToPool(worker)}}else if(cmd==="exitProcess"){try{exit(d["returnCode"])}catch(e){if(e instanceof ExitStatus)return;throw e}}else if(cmd==="cancelDone"){PThread.returnWorkerToPool(worker)}else if(cmd==="objectTransfer"){PThread.receiveObjectTransfer(e.data)}else if(e.data.target==="setimmediate"){worker.postMessage(e.data)}else{err("worker sent an unknown command "+cmd)}PThread.currentProxiedOperationCallerThread=undefined};worker.onerror=function(e){err("pthread sent an error! "+e.filename+":"+e.lineno+": "+e.message)};if(ENVIRONMENT_IS_NODE){worker.on("message",function(data){worker.onmessage({data:data})});worker.on("error",function(data){worker.onerror(data)});worker.on("exit",function(data){})}worker.postMessage({"cmd":"load","urlOrBlob":Module["mainScriptUrlOrBlob"]||_scriptDir,"wasmMemory":wasmMemory,"wasmModule":wasmModule})},allocateUnusedWorker:function(){var pthreadMainJs=locateFile("ort-wasm-threaded.worker.js");PThread.unusedWorkers.push(new Worker(pthreadMainJs))},getNewWorker:function(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()},busySpinWait:function(msecs){var t=performance.now()+msecs;while(performance.now()<t){}}};function establishStackSpace(stackTop,stackMax){_emscripten_stack_set_limits(stackTop,stackMax);stackRestore(stackTop)}Module["establishStackSpace"]=establishStackSpace;function invokeEntryPoint(ptr,arg){return wasmTable.get(ptr)(arg)}Module["invokeEntryPoint"]=invokeEntryPoint;var runtimeKeepaliveCounter=0;function keepRuntimeAlive(){return noExitRuntime||runtimeKeepaliveCounter>0}Module["keepRuntimeAlive"]=keepRuntimeAlive;function ___assert_fail(condition,filename,line,func){abort("Assertion failed: "+UTF8ToString(condition)+", at: "+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"])}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(ENVIRONMENT_IS_PTHREAD){_emscripten_get_now=function(){return performance.now()-Module["__performance_now_clock_drift"]}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else _emscripten_get_now=function(){return performance.now()};var _emscripten_get_now_is_monotonic=true;function setErrNo(value){GROWABLE_HEAP_I32()[___errno_location()>>2]=value;return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if((clk_id===1||clk_id===4)&&_emscripten_get_now_is_monotonic){now=_emscripten_get_now()}else{setErrNo(28);return-1}GROWABLE_HEAP_I32()[tp>>2]=now/1e3|0;GROWABLE_HEAP_I32()[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function ___clock_gettime(a0,a1){return _clock_gettime(a0,a1)}var ExceptionInfoAttrs={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};function ___cxa_allocate_exception(size){return _malloc(size+ExceptionInfoAttrs.SIZE)+ExceptionInfoAttrs.SIZE}function _atexit(func,arg){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(1,1,func,arg);__ATEXIT__.unshift({func:func,arg:arg})}function ___cxa_atexit(a0,a1){return _atexit(a0,a1)}function _pthread_cleanup_push(routine,arg){PThread.threadExitHandlers.push(function(){wasmTable.get(routine)(arg)})}function ___cxa_thread_atexit(a0,a1){return _pthread_cleanup_push(a0,a1)}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-ExceptionInfoAttrs.SIZE;this.set_type=function(type){GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]=type};this.get_type=function(){return GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]};this.set_destructor=function(destructor){GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]=destructor};this.get_destructor=function(){return GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]};this.set_refcount=function(refcount){GROWABLE_HEAP_I32()[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]=caught};this.get_caught=function(){return GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]=rethrown};this.get_rethrown=function(){return GROWABLE_HEAP_I8()[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]!=0};this.init=function(type,destructor){this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){Atomics.add(GROWABLE_HEAP_I32(),this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2,1)};this.release_ref=function(){var prev=Atomics.sub(GROWABLE_HEAP_I32(),this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2,1);return prev===1}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=GROWABLE_HEAP_I32()[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},get64:function(low,high){return low}};function ___sys_access(path,amode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(2,1,path,amode);path=SYSCALLS.getStr(path);return SYSCALLS.doAccess(path,amode)}function ___sys_fcntl64(fd,cmd,varargs){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(3,1,fd,cmd,varargs);SYSCALLS.varargs=varargs;return 0}function ___sys_fstat64(fd,buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(4,1,fd,buf)}function ___sys_getdents64(fd,dirp,count){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(5,1,fd,dirp,count)}function ___sys_getpid(){return 42}function ___sys_ioctl(fd,op,varargs){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(6,1,fd,op,varargs);SYSCALLS.varargs=varargs;return 0}function ___sys_lstat64(path,buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(7,1,path,buf)}function ___sys_mkdir(path,mode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(8,1,path,mode);path=SYSCALLS.getStr(path);return SYSCALLS.doMkdir(path,mode)}function syscallMmap2(addr,len,prot,flags,fd,off){off<<=12;var ptr;var allocated=false;if((flags&16)!==0&&addr%65536!==0){return-28}if((flags&32)!==0){ptr=_memalign(65536,len);if(!ptr)return-48;_memset(ptr,0,len);allocated=true}else{return-52}SYSCALLS.mappings[ptr]={malloc:ptr,len:len,allocated:allocated,fd:fd,prot:prot,flags:flags,offset:off};return ptr}function ___sys_mmap2(addr,len,prot,flags,fd,off){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(9,1,addr,len,prot,flags,fd,off);return syscallMmap2(addr,len,prot,flags,fd,off)}function syscallMunmap(addr,len){if((addr|0)===-1||len===0){return-28}var info=SYSCALLS.mappings[addr];if(!info)return 0;if(len===info.len){SYSCALLS.mappings[addr]=null;if(info.allocated){_free(info.malloc)}}return 0}function ___sys_munmap(addr,len){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(10,1,addr,len);return syscallMunmap(addr,len)}function ___sys_open(path,flags,varargs){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(11,1,path,flags,varargs);SYSCALLS.varargs=varargs}function ___sys_readlink(path,buf,bufsize){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(12,1,path,buf,bufsize);path=SYSCALLS.getStr(path);return SYSCALLS.doReadlink(path,buf,bufsize)}function ___sys_rmdir(path){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(13,1,path)}function ___sys_stat64(path,buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(14,1,path,buf)}function ___sys_unlink(path){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(15,1,path)}function __emscripten_notify_thread_queue(targetThreadId,mainThreadId){if(targetThreadId==mainThreadId){postMessage({"cmd":"processQueuedMainThreadWork"})}else if(ENVIRONMENT_IS_PTHREAD){postMessage({"targetThread":targetThreadId,"cmd":"processThreadQueue"})}else{var pthread=PThread.pthreads[targetThreadId];var worker=pthread&&pthread.worker;if(!worker){return}worker.postMessage({"cmd":"processThreadQueue"})}return 1}function _abort(){abort()}function _difftime(time1,time0){return time1-time0}function _dlclose(handle){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlerror(){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlopen(filename,flag){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlsym(handle,symbol){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}var readAsmConstArgsArray=[];function readAsmConstArgs(sigPtr,buf){readAsmConstArgsArray.length=0;var ch;buf>>=2;while(ch=GROWABLE_HEAP_U8()[sigPtr++]){var double=ch<105;if(double&&buf&1)buf++;readAsmConstArgsArray.push(double?GROWABLE_HEAP_F64()[buf++>>1]:GROWABLE_HEAP_I32()[buf]);++buf}return readAsmConstArgsArray}function _emscripten_asm_const_int(code,sigPtr,argbuf){var args=readAsmConstArgs(sigPtr,argbuf);return ASM_CONSTS[code].apply(null,args)}function _emscripten_check_blocking_allowed(){if(ENVIRONMENT_IS_NODE)return;if(ENVIRONMENT_IS_WORKER)return;warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function _emscripten_conditional_set_current_thread_status(expectedStatus,newStatus){}function _emscripten_futex_wait(addr,val,timeout){if(addr<=0||addr>GROWABLE_HEAP_I8().length||addr&3!=0)return-28;if(!ENVIRONMENT_IS_WEB){var ret=Atomics.wait(GROWABLE_HEAP_I32(),addr>>2,val,timeout);if(ret==="timed-out")return-73;if(ret==="not-equal")return-6;if(ret==="ok")return 0;throw"Atomics.wait returned an unexpected value "+ret}else{if(Atomics.load(GROWABLE_HEAP_I32(),addr>>2)!=val){return-6}var tNow=performance.now();var tEnd=tNow+timeout;var lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,addr);while(1){tNow=performance.now();if(tNow>tEnd){lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,0);return-73}lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,0);if(lastAddr==0){break}_emscripten_main_thread_process_queued_calls();if(Atomics.load(GROWABLE_HEAP_I32(),addr>>2)!=val){return-6}lastAddr=Atomics.exchange(GROWABLE_HEAP_I32(),__emscripten_main_thread_futex>>2,addr)}return 0}}function _emscripten_get_heap_max(){return 2147483648}function _emscripten_memcpy_big(dest,src,num){GROWABLE_HEAP_U8().copyWithin(dest,src,src+num)}function _emscripten_num_logical_cores(){if(ENVIRONMENT_IS_NODE)return __webpack_require__(/*! os */ "?aedb").cpus().length;return navigator["hardwareConcurrency"]}function _emscripten_proxy_to_main_thread_js(index,sync){var numCallArgs=arguments.length-2;var stack=stackSave();var serializedNumCallArgs=numCallArgs;var args=stackAlloc(serializedNumCallArgs*8);var b=args>>3;for(var i=0;i<numCallArgs;i++){var arg=arguments[2+i];GROWABLE_HEAP_F64()[b+i]=arg}var ret=_emscripten_run_in_main_runtime_thread_js(index,serializedNumCallArgs,args,sync);stackRestore(stack);return ret}var _emscripten_receive_on_main_thread_js_callArgs=[];function _emscripten_receive_on_main_thread_js(index,numCallArgs,args){_emscripten_receive_on_main_thread_js_callArgs.length=numCallArgs;var b=args>>3;for(var i=0;i<numCallArgs;i++){_emscripten_receive_on_main_thread_js_callArgs[i]=GROWABLE_HEAP_F64()[b+i]}var isEmAsmConst=index<0;var func=!isEmAsmConst?proxiedFunctionTable[index]:ASM_CONSTS[-index-1];return func.apply(null,_emscripten_receive_on_main_thread_js_callArgs)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=GROWABLE_HEAP_U8().length;requestedSize=requestedSize>>>0;if(requestedSize<=oldSize){return false}var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var JSEvents={inEventHandler:0,removeAllEventListeners:function(){for(var i=JSEvents.eventHandlers.length-1;i>=0;--i){JSEvents._removeHandler(i)}JSEvents.eventHandlers=[];JSEvents.deferredCalls=[]},registerRemoveEventListeners:function(){if(!JSEvents.removeEventListenersRegistered){__ATEXIT__.push(JSEvents.removeAllEventListeners);JSEvents.removeEventListenersRegistered=true}},deferredCalls:[],deferCall:function(targetFunction,precedence,argsList){function arraysHaveEqualContent(arrA,arrB){if(arrA.length!=arrB.length)return false;for(var i in arrA){if(arrA[i]!=arrB[i])return false}return true}for(var i in JSEvents.deferredCalls){var call=JSEvents.deferredCalls[i];if(call.targetFunction==targetFunction&&arraysHaveEqualContent(call.argsList,argsList)){return}}JSEvents.deferredCalls.push({targetFunction:targetFunction,precedence:precedence,argsList:argsList});JSEvents.deferredCalls.sort(function(x,y){return x.precedence<y.precedence})},removeDeferredCalls:function(targetFunction){for(var i=0;i<JSEvents.deferredCalls.length;++i){if(JSEvents.deferredCalls[i].targetFunction==targetFunction){JSEvents.deferredCalls.splice(i,1);--i}}},canPerformEventHandlerRequests:function(){return JSEvents.inEventHandler&&JSEvents.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!JSEvents.canPerformEventHandlerRequests()){return}for(var i=0;i<JSEvents.deferredCalls.length;++i){var call=JSEvents.deferredCalls[i];JSEvents.deferredCalls.splice(i,1);--i;call.targetFunction.apply(null,call.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(target,eventTypeString){for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==target&&(!eventTypeString||eventTypeString==JSEvents.eventHandlers[i].eventTypeString)){JSEvents._removeHandler(i--)}}},_removeHandler:function(i){var h=JSEvents.eventHandlers[i];h.target.removeEventListener(h.eventTypeString,h.eventListenerFunc,h.useCapture);JSEvents.eventHandlers.splice(i,1)},registerOrRemoveHandler:function(eventHandler){var jsEventHandler=function jsEventHandler(event){++JSEvents.inEventHandler;JSEvents.currentEventHandler=eventHandler;JSEvents.runDeferredCalls();eventHandler.handlerFunc(event);JSEvents.runDeferredCalls();--JSEvents.inEventHandler};if(eventHandler.callbackfunc){eventHandler.eventListenerFunc=jsEventHandler;eventHandler.target.addEventListener(eventHandler.eventTypeString,jsEventHandler,eventHandler.useCapture);JSEvents.eventHandlers.push(eventHandler);JSEvents.registerRemoveEventListeners()}else{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==eventHandler.target&&JSEvents.eventHandlers[i].eventTypeString==eventHandler.eventTypeString){JSEvents._removeHandler(i--)}}}},queueEventHandlerOnThread_iiii:function(targetThread,eventHandlerFunc,eventTypeId,eventData,userData){var stackTop=stackSave();var varargs=stackAlloc(12);GROWABLE_HEAP_I32()[varargs>>2]=eventTypeId;GROWABLE_HEAP_I32()[varargs+4>>2]=eventData;GROWABLE_HEAP_I32()[varargs+8>>2]=userData;__emscripten_call_on_thread(0,targetThread,637534208,eventHandlerFunc,eventData,varargs);stackRestore(stackTop)},getTargetThreadForEventCallback:function(targetThread){switch(targetThread){case 1:return 0;case 2:return PThread.currentProxiedOperationCallerThread;default:return targetThread}},getNodeNameForTarget:function(target){if(!target)return"";if(target==window)return"#window";if(target==screen)return"#screen";return target&&target.nodeName?target.nodeName:""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function stringToNewUTF8(jsString){var length=lengthBytesUTF8(jsString)+1;var cString=_malloc(length);stringToUTF8(jsString,cString,length);return cString}function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread,targetCanvas,width,height){var stackTop=stackSave();var varargs=stackAlloc(12);var targetCanvasPtr=0;if(targetCanvas){targetCanvasPtr=stringToNewUTF8(targetCanvas)}GROWABLE_HEAP_I32()[varargs>>2]=targetCanvasPtr;GROWABLE_HEAP_I32()[varargs+4>>2]=width;GROWABLE_HEAP_I32()[varargs+8>>2]=height;__emscripten_call_on_thread(0,targetThread,657457152,0,targetCanvasPtr,varargs);stackRestore(stackTop)}function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread,targetCanvas,width,height){targetCanvas=targetCanvas?UTF8ToString(targetCanvas):"";_emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread,targetCanvas,width,height)}function maybeCStringToJsString(cString){return cString>2?UTF8ToString(cString):cString}var specialHTMLTargets=[0,typeof document!=="undefined"?document:0,typeof window!=="undefined"?window:0];function findEventTarget(target){target=maybeCStringToJsString(target);var domElement=specialHTMLTargets[target]||(typeof document!=="undefined"?document.querySelector(target):undefined);return domElement}function findCanvasEventTarget(target){return findEventTarget(target)}function _emscripten_set_canvas_element_size_calling_thread(target,width,height){var canvas=findCanvasEventTarget(target);if(!canvas)return-4;if(canvas.canvasSharedPtr){GROWABLE_HEAP_I32()[canvas.canvasSharedPtr>>2]=width;GROWABLE_HEAP_I32()[canvas.canvasSharedPtr+4>>2]=height}if(canvas.offscreenCanvas||!canvas.controlTransferredOffscreen){if(canvas.offscreenCanvas)canvas=canvas.offscreenCanvas;var autoResizeViewport=false;if(canvas.GLctxObject&&canvas.GLctxObject.GLctx){var prevViewport=canvas.GLctxObject.GLctx.getParameter(2978);autoResizeViewport=prevViewport[0]===0&&prevViewport[1]===0&&prevViewport[2]===canvas.width&&prevViewport[3]===canvas.height}canvas.width=width;canvas.height=height;if(autoResizeViewport){canvas.GLctxObject.GLctx.viewport(0,0,width,height)}}else if(canvas.canvasSharedPtr){var targetThread=GROWABLE_HEAP_I32()[canvas.canvasSharedPtr+8>>2];_emscripten_set_offscreencanvas_size_on_target_thread(targetThread,target,width,height);return 1}else{return-4}return 0}function _emscripten_set_canvas_element_size_main_thread(target,width,height){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(16,1,target,width,height);return _emscripten_set_canvas_element_size_calling_thread(target,width,height)}function _emscripten_set_canvas_element_size(target,width,height){var canvas=findCanvasEventTarget(target);if(canvas){return _emscripten_set_canvas_element_size_calling_thread(target,width,height)}else{return _emscripten_set_canvas_element_size_main_thread(target,width,height)}}function _emscripten_set_current_thread_status(newStatus){}function __webgl_enable_ANGLE_instanced_arrays(ctx){var ext=ctx.getExtension("ANGLE_instanced_arrays");if(ext){ctx["vertexAttribDivisor"]=function(index,divisor){ext["vertexAttribDivisorANGLE"](index,divisor)};ctx["drawArraysInstanced"]=function(mode,first,count,primcount){ext["drawArraysInstancedANGLE"](mode,first,count,primcount)};ctx["drawElementsInstanced"]=function(mode,count,type,indices,primcount){ext["drawElementsInstancedANGLE"](mode,count,type,indices,primcount)};return 1}}function __webgl_enable_OES_vertex_array_object(ctx){var ext=ctx.getExtension("OES_vertex_array_object");if(ext){ctx["createVertexArray"]=function(){return ext["createVertexArrayOES"]()};ctx["deleteVertexArray"]=function(vao){ext["deleteVertexArrayOES"](vao)};ctx["bindVertexArray"]=function(vao){ext["bindVertexArrayOES"](vao)};ctx["isVertexArray"]=function(vao){return ext["isVertexArrayOES"](vao)};return 1}}function __webgl_enable_WEBGL_draw_buffers(ctx){var ext=ctx.getExtension("WEBGL_draw_buffers");if(ext){ctx["drawBuffers"]=function(n,bufs){ext["drawBuffersWEBGL"](n,bufs)};return 1}}function __webgl_enable_WEBGL_multi_draw(ctx){return!!(ctx.multiDrawWebgl=ctx.getExtension("WEBGL_multi_draw"))}var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function recordError(errorCode){if(!GL.lastError){GL.lastError=errorCode}},getNewId:function(table){var ret=GL.counter++;for(var i=table.length;i<ret;i++){table[i]=null}return ret},getSource:function(shader,count,string,length){var source="";for(var i=0;i<count;++i){var len=length?GROWABLE_HEAP_I32()[length+i*4>>2]:-1;source+=UTF8ToString(GROWABLE_HEAP_I32()[string+i*4>>2],len<0?undefined:len)}return source},createContext:function(canvas,webGLContextAttributes){if(!canvas.getContextSafariWebGL2Fixed){canvas.getContextSafariWebGL2Fixed=canvas.getContext;canvas.getContext=function(ver,attrs){var gl=canvas.getContextSafariWebGL2Fixed(ver,attrs);return ver=="webgl"==gl instanceof WebGLRenderingContext?gl:null}}var ctx=canvas.getContext("webgl",webGLContextAttributes);if(!ctx)return 0;var handle=GL.registerContext(ctx,webGLContextAttributes);return handle},registerContext:function(ctx,webGLContextAttributes){var handle=_malloc(8);GROWABLE_HEAP_I32()[handle+4>>2]=_pthread_self();var context={handle:handle,attributes:webGLContextAttributes,version:webGLContextAttributes.majorVersion,GLctx:ctx};if(ctx.canvas)ctx.canvas.GLctxObject=context;GL.contexts[handle]=context;if(typeof webGLContextAttributes.enableExtensionsByDefault==="undefined"||webGLContextAttributes.enableExtensionsByDefault){GL.initExtensions(context)}return handle},makeContextCurrent:function(contextHandle){GL.currentContext=GL.contexts[contextHandle];Module.ctx=GLctx=GL.currentContext&&GL.currentContext.GLctx;return!(contextHandle&&!GLctx)},getContext:function(contextHandle){return GL.contexts[contextHandle]},deleteContext:function(contextHandle){if(GL.currentContext===GL.contexts[contextHandle])GL.currentContext=null;if(typeof JSEvents==="object")JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);if(GL.contexts[contextHandle]&&GL.contexts[contextHandle].GLctx.canvas)GL.contexts[contextHandle].GLctx.canvas.GLctxObject=undefined;_free(GL.contexts[contextHandle].handle);GL.contexts[contextHandle]=null},initExtensions:function(context){if(!context)context=GL.currentContext;if(context.initExtensionsDone)return;context.initExtensionsDone=true;var GLctx=context.GLctx;__webgl_enable_ANGLE_instanced_arrays(GLctx);__webgl_enable_OES_vertex_array_object(GLctx);__webgl_enable_WEBGL_draw_buffers(GLctx);{GLctx.disjointTimerQueryExt=GLctx.getExtension("EXT_disjoint_timer_query")}__webgl_enable_WEBGL_multi_draw(GLctx);var exts=GLctx.getSupportedExtensions()||[];exts.forEach(function(ext){if(!ext.includes("lose_context")&&!ext.includes("debug")){GLctx.getExtension(ext)}})}};var __emscripten_webgl_power_preferences=["default","low-power","high-performance"];function _emscripten_webgl_do_create_context(target,attributes){var a=attributes>>2;var powerPreference=GROWABLE_HEAP_I32()[a+(24>>2)];var contextAttributes={"alpha":!!GROWABLE_HEAP_I32()[a+(0>>2)],"depth":!!GROWABLE_HEAP_I32()[a+(4>>2)],"stencil":!!GROWABLE_HEAP_I32()[a+(8>>2)],"antialias":!!GROWABLE_HEAP_I32()[a+(12>>2)],"premultipliedAlpha":!!GROWABLE_HEAP_I32()[a+(16>>2)],"preserveDrawingBuffer":!!GROWABLE_HEAP_I32()[a+(20>>2)],"powerPreference":__emscripten_webgl_power_preferences[powerPreference],"failIfMajorPerformanceCaveat":!!GROWABLE_HEAP_I32()[a+(28>>2)],majorVersion:GROWABLE_HEAP_I32()[a+(32>>2)],minorVersion:GROWABLE_HEAP_I32()[a+(36>>2)],enableExtensionsByDefault:GROWABLE_HEAP_I32()[a+(40>>2)],explicitSwapControl:GROWABLE_HEAP_I32()[a+(44>>2)],proxyContextToMainThread:GROWABLE_HEAP_I32()[a+(48>>2)],renderViaOffscreenBackBuffer:GROWABLE_HEAP_I32()[a+(52>>2)]};var canvas=findCanvasEventTarget(target);if(!canvas){return 0}if(contextAttributes.explicitSwapControl){return 0}var contextHandle=GL.createContext(canvas,contextAttributes);return contextHandle}function _emscripten_webgl_create_context(a0,a1){return _emscripten_webgl_do_create_context(a0,a1)}var WebNN={initManagers:function(){if(this["mgrContext"])return;function makeManager(){return{objects:{},nextId:1,create:function(object,wrapper){wrapper=wrapper||{};var id=this.nextId++;wrapper.refcount=1;wrapper.object=object;this.objects[id]=wrapper;return id},get:function(id){if(id===0)return undefined;var o=this.objects[id];return o.object},reference:function(id){var o=this.objects[id];o.refcount++},release:function(id){var o=this.objects[id];o.refcount--;if(o.refcount<=0){delete this.objects[id]}}}}this["mgrContext"]=this["mgrContext"]||makeManager();this.mgrGraph=this.mgrGraph||makeManager();this.mgrGraphBuilder=this.mgrGraphBuilder||makeManager();this.mgrNamedInputs=this.mgrNamedInputs||makeManager();this.mgrNamedOperands=this.mgrNamedOperands||makeManager();this.mgrNamedOutputs=this.mgrNamedOutputs||makeManager();this.mgrNamedResults=this.mgrNamedResults||makeManager();this.mgrOperand=this.mgrOperand||makeManager();this.mgrResult=this.mgrResult||makeManager()},AutoPad:["explicit","same-upper","same-lower"],BuildGraphStatus:["success","error","context-lost","unknown"],ComputeGraphStatus:["success","error","context-lost","unknown"],ErrorFilter:["none","validation","out-of-memory"],ErrorType:["no-error","validation","out-of-memory","unknown","device-lost"],FilterOperandLayout:["oihw","hwio","ohwi","ihwo"],FusedActivation:["none","relu"],InputOperandLayout:["nchw","nhwc"],OperandType:["float32","float16","int32","uint32","int8","uint8"],PowerPreference:["default","high_performance","low_power"],makeI32Array:function(count,arrayPtr){if(count===0||arrayPtr===0){return undefined}var array=[];for(var i=0;i<count;++i,arrayPtr+=4){array.push(GROWABLE_HEAP_I32()[arrayPtr>>2])}return array},makeArrayBufferView:function(offset,byteSize,type="float32"){assert(type==="float32");return new Float32Array(GROWABLE_HEAP_U8().buffer,offset,byteSize/Float32Array.BYTES_PER_ELEMENT)},makeClampOptions:function(ptr){return{"minValue":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr>>2]),"maxValue":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr+4>>2])}},makeBatchNormOptions:function(ptr){return{"scale":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr>>2]),"bias":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr+4>>2]),"axis":GROWABLE_HEAP_I32()[ptr+8>>2],"epsilon":GROWABLE_HEAP_F32()[ptr+12>>2],"activation":this.FusedActivation[GROWABLE_HEAP_I32()[ptr+16>>2]]}},makeGemmOptions:function(ptr){return{"c":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr>>2]),"alpha":GROWABLE_HEAP_F32()[ptr+4>>2],"beta":GROWABLE_HEAP_F32()[ptr+8>>2],"aTranspose":GROWABLE_HEAP_I8()[ptr+12>>0]!==0,"bTranspose":GROWABLE_HEAP_I8()[ptr+13>>0]!==0}},makeOperandDescriptor:function(ptr){return{"type":this.OperandType[GROWABLE_HEAP_U32()[ptr>>2]],"dimensions":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+8>>2],GROWABLE_HEAP_I32()[ptr+4>>2])}},makeConv2dOptions:function(ptr){return{"padding":this.AutoPad[GROWABLE_HEAP_I32()[ptr+24>>2]]==="explicit"?this.makeI32Array(GROWABLE_HEAP_U32()[ptr>>2],GROWABLE_HEAP_I32()[ptr+4>>2]):undefined,"strides":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+8>>2],GROWABLE_HEAP_I32()[ptr+12>>2]),"dilations":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+16>>2],GROWABLE_HEAP_I32()[ptr+20>>2]),"autoPad":this.AutoPad[GROWABLE_HEAP_I32()[ptr+24>>2]],"groups":GROWABLE_HEAP_I32()[ptr+28>>2],"inputLayout":this.InputOperandLayout[GROWABLE_HEAP_I32()[ptr+32>>2]],"filterLayout":this.FilterOperandLayout[GROWABLE_HEAP_I32()[ptr+36>>2]],"bias":this.mgrOperand.get(GROWABLE_HEAP_I32()[ptr+40>>2]),"activation":this.FusedActivation[GROWABLE_HEAP_I32()[ptr+44>>2]]}},makePool2dOptions:function(ptr){return{"windowDimensions":this.makeI32Array(GROWABLE_HEAP_U32()[ptr>>2],GROWABLE_HEAP_I32()[ptr+4>>2]),"padding":this.AutoPad[GROWABLE_HEAP_I32()[ptr+32>>2]]==="explicit"?this.makeI32Array(GROWABLE_HEAP_U32()[ptr+8>>2],GROWABLE_HEAP_I32()[ptr+12>>2]):undefined,"strides":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+16>>2],GROWABLE_HEAP_I32()[ptr+20>>2]),"dilations":this.makeI32Array(GROWABLE_HEAP_U32()[ptr+24>>2],GROWABLE_HEAP_I32()[ptr+28>>2]),"autoPad":this.AutoPad[GROWABLE_HEAP_I32()[ptr+32>>2]],"inputLayout":this.InputOperandLayout[GROWABLE_HEAP_I32()[ptr+36>>2]]}},makeInput:function(ptr){return{"data":this.makeArrayBufferView(GROWABLE_HEAP_I32()[ptr>>2],GROWABLE_HEAP_U32()[ptr+4>>2]),"dimensions":GROWABLE_HEAP_I32()[ptr+8>>2]===0?undefined:this.makeI32Array(GROWABLE_HEAP_U32()[ptr+12>>2],GROWABLE_HEAP_I32()[ptr+8>>2])}},makeOutput:function(ptr){return{"data":GROWABLE_HEAP_I32()[ptr>>2]===0?undefined:this.makeArrayBufferView(GROWABLE_HEAP_I32()[ptr>>2],GROWABLE_HEAP_U32()[ptr+4>>2]),"dimensions":GROWABLE_HEAP_I32()[ptr+8>>2]===0?undefined:this.makeI32Array(GROWABLE_HEAP_U32()[ptr+12>>2],GROWABLE_HEAP_I32()[ptr+8>>2])}}};function _emscripten_webnn_create_context(){var context=navigator.ml.createContext();return WebNN.mgrContext.create(context)}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(17,1,__environ,environ_buf);var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;GROWABLE_HEAP_I32()[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(18,1,penviron_count,penviron_buf_size);var strings=getEnvStrings();GROWABLE_HEAP_I32()[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});GROWABLE_HEAP_I32()[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(19,1,fd);return 0}function _fd_fdstat_get(fd,pbuf){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(20,1,fd,pbuf);var type=fd==1||fd==2?2:abort();GROWABLE_HEAP_I8()[pbuf>>0]=type;return 0}function _fd_read(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(21,1,fd,iov,iovcnt,pnum);var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doReadv(stream,iov,iovcnt);GROWABLE_HEAP_I32()[pnum>>2]=num;return 0}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(22,1,fd,offset_low,offset_high,whence,newOffset)}function flush_NO_FILESYSTEM(){if(typeof _fflush!=="undefined")_fflush(0);var buffers=SYSCALLS.buffers;if(buffers[1].length)SYSCALLS.printChar(1,10);if(buffers[2].length)SYSCALLS.printChar(2,10)}function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(23,1,fd,iov,iovcnt,pnum);var num=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_I32()[iov+i*8>>2];var len=GROWABLE_HEAP_I32()[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,GROWABLE_HEAP_U8()[ptr+j])}num+=len}GROWABLE_HEAP_I32()[pnum>>2]=num;return 0}function _gettimeofday(ptr){var now=Date.now();GROWABLE_HEAP_I32()[ptr>>2]=now/1e3|0;GROWABLE_HEAP_I32()[ptr+4>>2]=now%1e3*1e3|0;return 0}function _gmtime_r(time,tmPtr){var date=new Date(GROWABLE_HEAP_I32()[time>>2]*1e3);GROWABLE_HEAP_I32()[tmPtr>>2]=date.getUTCSeconds();GROWABLE_HEAP_I32()[tmPtr+4>>2]=date.getUTCMinutes();GROWABLE_HEAP_I32()[tmPtr+8>>2]=date.getUTCHours();GROWABLE_HEAP_I32()[tmPtr+12>>2]=date.getUTCDate();GROWABLE_HEAP_I32()[tmPtr+16>>2]=date.getUTCMonth();GROWABLE_HEAP_I32()[tmPtr+20>>2]=date.getUTCFullYear()-1900;GROWABLE_HEAP_I32()[tmPtr+24>>2]=date.getUTCDay();GROWABLE_HEAP_I32()[tmPtr+36>>2]=0;GROWABLE_HEAP_I32()[tmPtr+32>>2]=0;var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;GROWABLE_HEAP_I32()[tmPtr+28>>2]=yday;if(!_gmtime_r.GMTString)_gmtime_r.GMTString=allocateUTF8("GMT");GROWABLE_HEAP_I32()[tmPtr+40>>2]=_gmtime_r.GMTString;return tmPtr}function _tzset(){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(24,1);if(_tzset.called)return;_tzset.called=true;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);GROWABLE_HEAP_I32()[__get_timezone()>>2]=stdTimezoneOffset*60;GROWABLE_HEAP_I32()[__get_daylight()>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){GROWABLE_HEAP_I32()[__get_tzname()>>2]=winterNamePtr;GROWABLE_HEAP_I32()[__get_tzname()+4>>2]=summerNamePtr}else{GROWABLE_HEAP_I32()[__get_tzname()>>2]=summerNamePtr;GROWABLE_HEAP_I32()[__get_tzname()+4>>2]=winterNamePtr}}function _localtime_r(time,tmPtr){_tzset();var date=new Date(GROWABLE_HEAP_I32()[time>>2]*1e3);GROWABLE_HEAP_I32()[tmPtr>>2]=date.getSeconds();GROWABLE_HEAP_I32()[tmPtr+4>>2]=date.getMinutes();GROWABLE_HEAP_I32()[tmPtr+8>>2]=date.getHours();GROWABLE_HEAP_I32()[tmPtr+12>>2]=date.getDate();GROWABLE_HEAP_I32()[tmPtr+16>>2]=date.getMonth();GROWABLE_HEAP_I32()[tmPtr+20>>2]=date.getFullYear()-1900;GROWABLE_HEAP_I32()[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;GROWABLE_HEAP_I32()[tmPtr+28>>2]=yday;GROWABLE_HEAP_I32()[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;GROWABLE_HEAP_I32()[tmPtr+32>>2]=dst;var zonePtr=GROWABLE_HEAP_I32()[__get_tzname()+(dst?4:0)>>2];GROWABLE_HEAP_I32()[tmPtr+40>>2]=zonePtr;return tmPtr}function _mktime(tmPtr){_tzset();var date=new Date(GROWABLE_HEAP_I32()[tmPtr+20>>2]+1900,GROWABLE_HEAP_I32()[tmPtr+16>>2],GROWABLE_HEAP_I32()[tmPtr+12>>2],GROWABLE_HEAP_I32()[tmPtr+8>>2],GROWABLE_HEAP_I32()[tmPtr+4>>2],GROWABLE_HEAP_I32()[tmPtr>>2],0);var dst=GROWABLE_HEAP_I32()[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){GROWABLE_HEAP_I32()[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}GROWABLE_HEAP_I32()[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;GROWABLE_HEAP_I32()[tmPtr+28>>2]=yday;GROWABLE_HEAP_I32()[tmPtr>>2]=date.getSeconds();GROWABLE_HEAP_I32()[tmPtr+4>>2]=date.getMinutes();GROWABLE_HEAP_I32()[tmPtr+8>>2]=date.getHours();GROWABLE_HEAP_I32()[tmPtr+12>>2]=date.getDate();GROWABLE_HEAP_I32()[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function _mlContextReference(id){WebNN.mgrContext.reference(id)}function _mlContextRelease(id){WebNN.mgrContext.release(id)}function _mlGraphBuilderAdd(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.add(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderAveragePool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.averagePool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderBatchNorm(builderId,inputId,meanId,varianceId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var mean=WebNN.mgrOperand.get(meanId);var variance=WebNN.mgrOperand.get(varianceId);var options=WebNN.makeBatchNormOptions(optionsPtr);var output=builder.batchNormalization(input,mean,variance,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderBuildSync(builderId,namedOperandsId){var builder=WebNN.mgrGraphBuilder.get(builderId);var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);try{var graph=builder.buildSync(namedOperands);return WebNN.mgrGraph.create(graph)}catch(error){console.log("builder.buildSync failed: "+error);return 0}}function _mlGraphBuilderConcat(builderId,inputsCount,inputsPtr,axis){var builder=WebNN.mgrGraphBuilder.get(builderId);var inputIds=WebNN.makeI32Array(inputsCount,inputsPtr);var inputs=[];for(var i=0;i<inputIds.length;++i){inputs.push(WebNN.mgrOperand.get(inputIds[i]))}var output=builder.concat(inputs,axis);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderConstant(builderId,descPtr,valuePtr,size){var builder=WebNN.mgrGraphBuilder.get(builderId);var desc=WebNN.makeOperandDescriptor(descPtr);var buffer=WebNN.makeArrayBufferView(valuePtr,size);var constant=builder.constant(desc,buffer);return WebNN.mgrOperand.create(constant)}function _mlGraphBuilderConv2d(builderId,inputId,filterId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var filter=WebNN.mgrOperand.get(filterId);var options=WebNN.makeConv2dOptions(optionsPtr);var conv2d=builder.conv2d(input,filter,options);return WebNN.mgrOperand.create(conv2d)}function _mlGraphBuilderGemm(builderId,aId,bId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var options=WebNN.makeGemmOptions(optionsPtr);var output=builder.gemm(a,b,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderInput(builderId,namePtr,descPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var name=UTF8ToString(namePtr);var desc=WebNN.makeOperandDescriptor(descPtr);var input=builder.input(name,desc);return WebNN.mgrOperand.create(input)}function _mlGraphBuilderMatmul(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.matmul(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderMaxPool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.maxPool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderRelease(id){WebNN.mgrGraphBuilder.release(id)}function _mlGraphBuilderRelu(builderId,inputId){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var output=builder.relu(input);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderReshape(builderId,inputId,newShapePtr,newShapeCount){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var newShape=WebNN.makeI32Array(newShapeCount,newShapePtr);var output=builder.reshape(input,newShape);return WebNN.mgrOperand.create(output)}function _mlGraphComputeSync(graphId,inputsId,outputsId){var graph=WebNN.mgrGraph.get(graphId);var inputs=WebNN.mgrNamedInputs.get(inputsId);var outputs=WebNN.mgrNamedOutputs.get(outputsId);return graph.computeSync(inputs,outputs)}function _mlGraphReference(id){WebNN.mgrGraph.reference(id)}function _mlGraphRelease(id){WebNN.mgrGraph.release(id)}function _mlNamedInputsRelease(id){WebNN.mgrNamedInputs.release(id)}function _mlNamedInputsSet(namedInputsId,namePtr,inputPtr){var namedInputs=WebNN.mgrNamedInputs.get(namedInputsId);var name=UTF8ToString(namePtr);var input=WebNN.makeInput(inputPtr);namedInputs[name]=input}function _mlNamedOperandsRelease(id){WebNN.mgrNamedOperands.release(id)}function _mlNamedOperandsSet(namedOperandsId,namePtr,operandId){var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);var name=UTF8ToString(namePtr);var operand=WebNN.mgrOperand.get(operandId);namedOperands[name]=operand}function _mlNamedOutputsRelease(id){WebNN.mgrNamedOutputs.release(id)}function _mlNamedOutputsSet(namedOutputsId,namePtr,outputPtr){var namedOutputs=WebNN.mgrNamedOutputs.get(namedOutputsId);var name=UTF8ToString(namePtr);var output=WebNN.makeOutput(outputPtr);namedOutputs[name]=output}function _mlOperandReference(id){WebNN.mgrOperand.reference(id)}function _mlOperandRelease(id){WebNN.mgrOperand.release(id)}function spawnThread(threadParams){if(ENVIRONMENT_IS_PTHREAD)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var worker=PThread.getNewWorker();if(!worker){return 6}if(worker.pthread!==undefined)throw"Internal error!";if(!threadParams.pthread_ptr)throw"Internal error, no pthread ptr!";PThread.runningWorkers.push(worker);var tlsMemory=_malloc(128*4);for(var i=0;i<128;++i){GROWABLE_HEAP_I32()[tlsMemory+i*4>>2]=0}var stackHigh=threadParams.stackBase+threadParams.stackSize;var pthread=PThread.pthreads[threadParams.pthread_ptr]={worker:worker,stackBase:threadParams.stackBase,stackSize:threadParams.stackSize,allocatedOwnStack:threadParams.allocatedOwnStack,threadInfoStruct:threadParams.pthread_ptr};var tis=pthread.threadInfoStruct>>2;Atomics.store(GROWABLE_HEAP_U32(),tis+(64>>2),threadParams.detached);Atomics.store(GROWABLE_HEAP_U32(),tis+(100>>2),tlsMemory);Atomics.store(GROWABLE_HEAP_U32(),tis+(40>>2),pthread.threadInfoStruct);Atomics.store(GROWABLE_HEAP_U32(),tis+(80>>2),threadParams.stackSize);Atomics.store(GROWABLE_HEAP_U32(),tis+(76>>2),stackHigh);Atomics.store(GROWABLE_HEAP_U32(),tis+(104>>2),threadParams.stackSize);Atomics.store(GROWABLE_HEAP_U32(),tis+(104+8>>2),stackHigh);Atomics.store(GROWABLE_HEAP_U32(),tis+(104+12>>2),threadParams.detached);var global_libc=_emscripten_get_global_libc();var global_locale=global_libc+40;Atomics.store(GROWABLE_HEAP_U32(),tis+(172>>2),global_locale);worker.pthread=pthread;var msg={"cmd":"run","start_routine":threadParams.startRoutine,"arg":threadParams.arg,"threadInfoStruct":threadParams.pthread_ptr,"stackBase":threadParams.stackBase,"stackSize":threadParams.stackSize};worker.runPthread=function(){msg.time=performance.now();worker.postMessage(msg,threadParams.transferList)};if(worker.loaded){worker.runPthread();delete worker.runPthread}return 0}function _pthread_create(pthread_ptr,attr,start_routine,arg){if(typeof SharedArrayBuffer==="undefined"){err("Current environment does not support SharedArrayBuffer, pthreads are not available!");return 6}if(!pthread_ptr){err("pthread_create called with a null thread pointer!");return 28}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return _emscripten_sync_run_in_main_thread_4(687865856,pthread_ptr,attr,start_routine,arg)}if(error)return error;var stackSize=0;var stackBase=0;var detached=0;if(attr&&attr!=-1){stackSize=GROWABLE_HEAP_I32()[attr>>2];stackSize+=81920;stackBase=GROWABLE_HEAP_I32()[attr+8>>2];detached=GROWABLE_HEAP_I32()[attr+12>>2]!==0}else{stackSize=2097152}var allocatedOwnStack=stackBase==0;if(allocatedOwnStack){stackBase=_memalign(16,stackSize)}else{stackBase-=stackSize;assert(stackBase>0)}var threadInfoStruct=_malloc(228);for(var i=0;i<228>>2;++i)GROWABLE_HEAP_U32()[(threadInfoStruct>>2)+i]=0;GROWABLE_HEAP_I32()[pthread_ptr>>2]=threadInfoStruct;GROWABLE_HEAP_I32()[threadInfoStruct+12>>2]=threadInfoStruct;var headPtr=threadInfoStruct+152;GROWABLE_HEAP_I32()[headPtr>>2]=headPtr;var threadParams={stackBase:stackBase,stackSize:stackSize,allocatedOwnStack:allocatedOwnStack,detached:detached,startRoutine:start_routine,pthread_ptr:threadInfoStruct,arg:arg,transferList:transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd="spawnThread";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}function __pthread_testcancel_js(){if(!ENVIRONMENT_IS_PTHREAD)return;var tb=_pthread_self();if(!tb)return;var cancelDisabled=Atomics.load(GROWABLE_HEAP_U32(),tb+56>>2);if(cancelDisabled)return;var canceled=Atomics.load(GROWABLE_HEAP_U32(),tb+0>>2);if(canceled==2)throw"Canceled!"}function __emscripten_do_pthread_join(thread,status,block){if(!thread){err("pthread_join attempted on a null thread pointer!");return ERRNO_CODES.ESRCH}if(ENVIRONMENT_IS_PTHREAD&&_pthread_self()==thread){err("PThread "+thread+" is attempting to join to itself!");return ERRNO_CODES.EDEADLK}else if(!ENVIRONMENT_IS_PTHREAD&&_emscripten_main_browser_thread_id()==thread){err("Main thread "+thread+" is attempting to join to itself!");return ERRNO_CODES.EDEADLK}var self=GROWABLE_HEAP_I32()[thread+12>>2];if(self!==thread){err("pthread_join attempted on thread "+thread+", which does not point to a valid thread, or does not exist anymore!");return ERRNO_CODES.ESRCH}var detached=Atomics.load(GROWABLE_HEAP_U32(),thread+64>>2);if(detached){err("Attempted to join thread "+thread+", which was already detached!");return ERRNO_CODES.EINVAL}if(block){_emscripten_check_blocking_allowed()}for(;;){var threadStatus=Atomics.load(GROWABLE_HEAP_U32(),thread+0>>2);if(threadStatus==1){var threadExitCode=Atomics.load(GROWABLE_HEAP_U32(),thread+4>>2);if(status)GROWABLE_HEAP_I32()[status>>2]=threadExitCode;Atomics.store(GROWABLE_HEAP_U32(),thread+64>>2,1);if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({"cmd":"cleanupThread","thread":thread});return 0}if(!block){return ERRNO_CODES.EBUSY}__pthread_testcancel_js();if(!ENVIRONMENT_IS_PTHREAD)_emscripten_main_thread_process_queued_calls();_emscripten_futex_wait(thread+0,threadStatus,ENVIRONMENT_IS_PTHREAD?100:1)}}function _pthread_join(thread,status){return __emscripten_do_pthread_join(thread,status,true)}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=GROWABLE_HEAP_I32()[tm+40>>2];var date={tm_sec:GROWABLE_HEAP_I32()[tm>>2],tm_min:GROWABLE_HEAP_I32()[tm+4>>2],tm_hour:GROWABLE_HEAP_I32()[tm+8>>2],tm_mday:GROWABLE_HEAP_I32()[tm+12>>2],tm_mon:GROWABLE_HEAP_I32()[tm+16>>2],tm_year:GROWABLE_HEAP_I32()[tm+20>>2],tm_wday:GROWABLE_HEAP_I32()[tm+24>>2],tm_yday:GROWABLE_HEAP_I32()[tm+28>>2],tm_isdst:GROWABLE_HEAP_I32()[tm+32>>2],tm_gmtoff:GROWABLE_HEAP_I32()[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value==="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return"\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}else{return"PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return"\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var janFirst=new Date(date.tm_year+1900,0,1);var firstSunday=janFirst.getDay()===0?janFirst:__addDays(janFirst,7-janFirst.getDay());var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstSunday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstSundayUntilEndJanuary=31-firstSunday.getDate();var days=firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstSunday,janFirst)===0?"01":"00"},"%V":function(date){var janFourthThisYear=new Date(date.tm_year+1900,0,4);var janFourthNextYear=new Date(date.tm_year+1901,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);var endDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);if(compareByDay(endDate,firstWeekStartThisYear)<0){return"53"}if(compareByDay(firstWeekStartNextYear,endDate)<=0){return"01"}var daysDifference;if(firstWeekStartThisYear.getFullYear()<date.tm_year+1900){daysDifference=date.tm_yday+32-firstWeekStartThisYear.getDate()}else{daysDifference=date.tm_yday+1-firstWeekStartThisYear.getDate()}return leadingNulls(Math.ceil(daysDifference/7),2)},"%w":function(date){return date.tm_wday},"%W":function(date){var janFirst=new Date(date.tm_year,0,1);var firstMonday=janFirst.getDay()===1?janFirst:__addDays(janFirst,janFirst.getDay()===0?1:7-janFirst.getDay()+1);var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstMonday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstMondayUntilEndJanuary=31-firstMonday.getDate();var days=firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstMonday,janFirst)===0?"01":"00"},"%y":function(date){return(date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return"%"}};for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _webnnCreateGraphBuilder(contextId){var context=WebNN.mgrContext.get(contextId);var builder=new MLGraphBuilder(context);return WebNN.mgrGraphBuilder.create(builder)}function _webnnCreateNamedInputs(){var inputs={};return WebNN.mgrNamedInputs.create(inputs)}function _webnnCreateNamedOperands(){var operands={};return WebNN.mgrNamedOperands.create(operands)}function _webnnCreateNamedOutputs(){var outputs={};return WebNN.mgrNamedOutputs.create(outputs)}if(!ENVIRONMENT_IS_PTHREAD)PThread.initMainThreadBlock();var GLctx;WebNN.initManagers();var proxiedFunctionTable=[null,_atexit,___sys_access,___sys_fcntl64,___sys_fstat64,___sys_getdents64,___sys_ioctl,___sys_lstat64,___sys_mkdir,___sys_mmap2,___sys_munmap,___sys_open,___sys_readlink,___sys_rmdir,___sys_stat64,___sys_unlink,_emscripten_set_canvas_element_size_main_thread,_environ_get,_environ_sizes_get,_fd_close,_fd_fdstat_get,_fd_read,_fd_seek,_fd_write,_tzset];function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var asmLibraryArg={"h":___assert_fail,"ba":___clock_gettime,"b":___cxa_allocate_exception,"d":___cxa_atexit,"e":___cxa_thread_atexit,"c":___cxa_throw,"Q":___sys_access,"r":___sys_fcntl64,"X":___sys_fstat64,"R":___sys_getdents64,"t":___sys_getpid,"I":___sys_ioctl,"S":___sys_lstat64,"W":___sys_mkdir,"V":___sys_mmap2,"U":___sys_munmap,"q":___sys_open,"P":___sys_readlink,"N":___sys_rmdir,"u":___sys_stat64,"O":___sys_unlink,"aa":__emscripten_notify_thread_queue,"g":_abort,"y":_clock_gettime,"Ka":_difftime,"M":_dlclose,"m":_dlerror,"T":_dlopen,"D":_dlsym,"w":_emscripten_asm_const_int,"H":_emscripten_check_blocking_allowed,"n":_emscripten_conditional_set_current_thread_status,"j":_emscripten_futex_wait,"k":_emscripten_futex_wake,"Y":_emscripten_get_heap_max,"i":_emscripten_get_now,"F":_emscripten_memcpy_big,"o":_emscripten_num_logical_cores,"Z":_emscripten_receive_on_main_thread_js,"G":_emscripten_resize_heap,"_":_emscripten_set_canvas_element_size,"v":_emscripten_set_current_thread_status,"$":_emscripten_webgl_create_context,"Ia":_emscripten_webnn_create_context,"K":_environ_get,"L":_environ_sizes_get,"l":_fd_close,"J":_fd_fdstat_get,"s":_fd_read,"C":_fd_seek,"p":_fd_write,"na":_gettimeofday,"La":_gmtime_r,"E":initPthreadsJS,"A":_localtime_r,"a":wasmMemory||Module["wasmMemory"],"z":_mktime,"Ha":_mlContextReference,"Ga":_mlContextRelease,"Ca":_mlGraphBuilderAdd,"Ba":_mlGraphBuilderAveragePool2d,"Aa":_mlGraphBuilderBatchNorm,"za":_mlGraphBuilderBuildSync,"ya":_mlGraphBuilderConcat,"xa":_mlGraphBuilderConstant,"wa":_mlGraphBuilderConv2d,"va":_mlGraphBuilderGemm,"ua":_mlGraphBuilderInput,"ta":_mlGraphBuilderMatmul,"sa":_mlGraphBuilderMaxPool2d,"pa":_mlGraphBuilderRelease,"ra":_mlGraphBuilderRelu,"qa":_mlGraphBuilderReshape,"Fa":_mlGraphComputeSync,"Ea":_mlGraphReference,"Da":_mlGraphRelease,"ma":_mlNamedInputsRelease,"oa":_mlNamedInputsSet,"ka":_mlNamedOperandsRelease,"la":_mlNamedOperandsSet,"ia":_mlNamedOutputsRelease,"ja":_mlNamedOutputsSet,"ha":_mlOperandReference,"ga":_mlOperandRelease,"x":_pthread_create,"B":_pthread_join,"Ja":_strftime,"f":_strftime_l,"fa":_webnnCreateGraphBuilder,"ea":_webnnCreateNamedInputs,"da":_webnnCreateNamedOperands,"ca":_webnnCreateNamedOutputs};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["Ma"]).apply(null,arguments)};var _OrtInit=Module["_OrtInit"]=function(){return(_OrtInit=Module["_OrtInit"]=Module["asm"]["Na"]).apply(null,arguments)};var _OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=function(){return(_OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=Module["asm"]["Oa"]).apply(null,arguments)};var _OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=function(){return(_OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=Module["asm"]["Pa"]).apply(null,arguments)};var _OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=function(){return(_OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=Module["asm"]["Qa"]).apply(null,arguments)};var _OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=function(){return(_OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=Module["asm"]["Ra"]).apply(null,arguments)};var _OrtCreateSession=Module["_OrtCreateSession"]=function(){return(_OrtCreateSession=Module["_OrtCreateSession"]=Module["asm"]["Sa"]).apply(null,arguments)};var _OrtReleaseSession=Module["_OrtReleaseSession"]=function(){return(_OrtReleaseSession=Module["_OrtReleaseSession"]=Module["asm"]["Ta"]).apply(null,arguments)};var _OrtGetInputCount=Module["_OrtGetInputCount"]=function(){return(_OrtGetInputCount=Module["_OrtGetInputCount"]=Module["asm"]["Ua"]).apply(null,arguments)};var _OrtGetOutputCount=Module["_OrtGetOutputCount"]=function(){return(_OrtGetOutputCount=Module["_OrtGetOutputCount"]=Module["asm"]["Va"]).apply(null,arguments)};var _OrtGetInputName=Module["_OrtGetInputName"]=function(){return(_OrtGetInputName=Module["_OrtGetInputName"]=Module["asm"]["Wa"]).apply(null,arguments)};var _OrtGetOutputName=Module["_OrtGetOutputName"]=function(){return(_OrtGetOutputName=Module["_OrtGetOutputName"]=Module["asm"]["Xa"]).apply(null,arguments)};var _OrtFree=Module["_OrtFree"]=function(){return(_OrtFree=Module["_OrtFree"]=Module["asm"]["Ya"]).apply(null,arguments)};var _OrtCreateTensor=Module["_OrtCreateTensor"]=function(){return(_OrtCreateTensor=Module["_OrtCreateTensor"]=Module["asm"]["Za"]).apply(null,arguments)};var _OrtGetTensorData=Module["_OrtGetTensorData"]=function(){return(_OrtGetTensorData=Module["_OrtGetTensorData"]=Module["asm"]["_a"]).apply(null,arguments)};var _OrtReleaseTensor=Module["_OrtReleaseTensor"]=function(){return(_OrtReleaseTensor=Module["_OrtReleaseTensor"]=Module["asm"]["$a"]).apply(null,arguments)};var _OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=function(){return(_OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=Module["asm"]["ab"]).apply(null,arguments)};var _OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=function(){return(_OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=Module["asm"]["bb"]).apply(null,arguments)};var _OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=function(){return(_OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=Module["asm"]["cb"]).apply(null,arguments)};var _OrtRun=Module["_OrtRun"]=function(){return(_OrtRun=Module["_OrtRun"]=Module["asm"]["db"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["fb"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["gb"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["hb"]).apply(null,arguments)};var _pthread_self=Module["_pthread_self"]=function(){return(_pthread_self=Module["_pthread_self"]=Module["asm"]["ib"]).apply(null,arguments)};var _emscripten_tls_init=Module["_emscripten_tls_init"]=function(){return(_emscripten_tls_init=Module["_emscripten_tls_init"]=Module["asm"]["jb"]).apply(null,arguments)};var _emscripten_current_thread_process_queued_calls=Module["_emscripten_current_thread_process_queued_calls"]=function(){return(_emscripten_current_thread_process_queued_calls=Module["_emscripten_current_thread_process_queued_calls"]=Module["asm"]["kb"]).apply(null,arguments)};var _emscripten_register_main_browser_thread_id=Module["_emscripten_register_main_browser_thread_id"]=function(){return(_emscripten_register_main_browser_thread_id=Module["_emscripten_register_main_browser_thread_id"]=Module["asm"]["lb"]).apply(null,arguments)};var _emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=function(){return(_emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=Module["asm"]["mb"]).apply(null,arguments)};var __emscripten_do_dispatch_to_thread=Module["__emscripten_do_dispatch_to_thread"]=function(){return(__emscripten_do_dispatch_to_thread=Module["__emscripten_do_dispatch_to_thread"]=Module["asm"]["nb"]).apply(null,arguments)};var _emscripten_sync_run_in_main_thread_4=Module["_emscripten_sync_run_in_main_thread_4"]=function(){return(_emscripten_sync_run_in_main_thread_4=Module["_emscripten_sync_run_in_main_thread_4"]=Module["asm"]["ob"]).apply(null,arguments)};var _emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=function(){return(_emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=Module["asm"]["pb"]).apply(null,arguments)};var _emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=function(){return(_emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=Module["asm"]["qb"]).apply(null,arguments)};var __emscripten_call_on_thread=Module["__emscripten_call_on_thread"]=function(){return(__emscripten_call_on_thread=Module["__emscripten_call_on_thread"]=Module["asm"]["rb"]).apply(null,arguments)};var __emscripten_thread_init=Module["__emscripten_thread_init"]=function(){return(__emscripten_thread_init=Module["__emscripten_thread_init"]=Module["asm"]["sb"]).apply(null,arguments)};var _memset=Module["_memset"]=function(){return(_memset=Module["_memset"]=Module["asm"]["tb"]).apply(null,arguments)};var ___pthread_tsd_run_dtors=Module["___pthread_tsd_run_dtors"]=function(){return(___pthread_tsd_run_dtors=Module["___pthread_tsd_run_dtors"]=Module["asm"]["ub"]).apply(null,arguments)};var _emscripten_get_global_libc=Module["_emscripten_get_global_libc"]=function(){return(_emscripten_get_global_libc=Module["_emscripten_get_global_libc"]=Module["asm"]["vb"]).apply(null,arguments)};var __get_tzname=Module["__get_tzname"]=function(){return(__get_tzname=Module["__get_tzname"]=Module["asm"]["wb"]).apply(null,arguments)};var __get_daylight=Module["__get_daylight"]=function(){return(__get_daylight=Module["__get_daylight"]=Module["asm"]["xb"]).apply(null,arguments)};var __get_timezone=Module["__get_timezone"]=function(){return(__get_timezone=Module["__get_timezone"]=Module["asm"]["yb"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["zb"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["Ab"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["Bb"]).apply(null,arguments)};var _emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=function(){return(_emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=Module["asm"]["Cb"]).apply(null,arguments)};var _memalign=Module["_memalign"]=function(){return(_memalign=Module["_memalign"]=Module["asm"]["Db"]).apply(null,arguments)};var __emscripten_allow_main_runtime_queued_calls=Module["__emscripten_allow_main_runtime_queued_calls"]=653536;var __emscripten_main_thread_futex=Module["__emscripten_main_thread_futex"]=658904;Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["PThread"]=PThread;Module["stackSave"]=stackSave;Module["stackRestore"]=stackRestore;Module["stackAlloc"]=stackAlloc;Module["PThread"]=PThread;Module["wasmMemory"]=wasmMemory;Module["ExitStatus"]=ExitStatus;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}if(ENVIRONMENT_IS_PTHREAD){readyPromiseResolve(Module);initRuntime();postMessage({"cmd":"loaded"});return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;function exit(status,implicit){EXITSTATUS=status;if(implicit&&keepRuntimeAlive()&&status===0){return}if(!implicit){if(ENVIRONMENT_IS_PTHREAD){postMessage({"cmd":"exitProcess","returnCode":status});throw new ExitStatus(status)}else{}}if(keepRuntimeAlive()){}else{PThread.terminateAllThreads();exitRuntime();if(Module["onExit"])Module["onExit"](status);ABORT=true}quit_(status,new ExitStatus(status))}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}if(ENVIRONMENT_IS_PTHREAD){noExitRuntime=false;PThread.initWorker()}run();


  return ortWasmThreaded.ready
}
);
})();
if (true)
  module.exports = ortWasmThreaded;
else {}


/***/ }),

/***/ "./lib/wasm/binding/ort-wasm-threaded.worker.js":
/*!******************************************************!*\
  !*** ./lib/wasm/binding/ort-wasm-threaded.worker.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = "\"use strict\";var Module={};if(typeof process===\"object\"&&typeof process.versions===\"object\"&&typeof process.versions.node===\"string\"){var nodeWorkerThreads=require(\"worker_threads\");var parentPort=nodeWorkerThreads.parentPort;parentPort.on(\"message\",function(data){onmessage({data:data})});var nodeFS=require(\"fs\");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(nodeFS.readFileSync(f,\"utf8\"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(\" \");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:text,threadId:Module[\"_pthread_self\"]()})}var err=threadPrintErr;self.alert=threadAlert;Module[\"instantiateWasm\"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module[\"wasmModule\"],info);receiveInstance(instance);Module[\"wasmModule\"]=null;return instance.exports};function moduleLoaded(){}self.onmessage=function(e){try{if(e.data.cmd===\"load\"){Module[\"wasmModule\"]=e.data.wasmModule;Module[\"wasmMemory\"]=e.data.wasmMemory;Module[\"buffer\"]=Module[\"wasmMemory\"].buffer;Module[\"ENVIRONMENT_IS_PTHREAD\"]=true;if(typeof e.data.urlOrBlob===\"string\"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}ortWasmThreaded(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd===\"objectTransfer\"){Module[\"PThread\"].receiveObjectTransfer(e.data)}else if(e.data.cmd===\"run\"){Module[\"__performance_now_clock_drift\"]=performance.now()-e.data.time;Module[\"__emscripten_thread_init\"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module[\"establishStackSpace\"](top,max);Module[\"PThread\"].receiveObjectTransfer(e.data);Module[\"PThread\"].threadInit();try{var result=Module[\"invokeEntryPoint\"](e.data.start_routine,e.data.arg);if(Module[\"keepRuntimeAlive\"]()){Module[\"PThread\"].setExitStatus(result)}else{Module[\"PThread\"].threadExit(result)}}catch(ex){if(ex===\"Canceled!\"){Module[\"PThread\"].threadCancel()}else if(ex!=\"unwind\"){if(ex instanceof Module[\"ExitStatus\"]){if(Module[\"keepRuntimeAlive\"]()){}else{Module[\"PThread\"].threadExit(ex.status)}}else{Module[\"PThread\"].threadExit(-2);throw ex}}}}else if(e.data.cmd===\"cancel\"){if(Module[\"_pthread_self\"]()){Module[\"PThread\"].threadCancel()}}else if(e.data.target===\"setimmediate\"){}else if(e.data.cmd===\"processThreadQueue\"){if(Module[\"_pthread_self\"]()){Module[\"_emscripten_current_thread_process_queued_calls\"]()}}else{err(\"worker.js received unknown command \"+e.data.cmd);err(e.data)}}catch(ex){err(\"worker.js onmessage() captured an uncaught exception: \"+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};\n";

/***/ }),

/***/ "./lib/wasm/binding/ort-wasm.js":
/*!**************************************!*\
  !*** ./lib/wasm/binding/ort-wasm.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __filename = "/index.js";
var __dirname = "/";

var ortWasm = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (true) _scriptDir = _scriptDir || __filename;
  return (
function(ortWasm) {
  ortWasm = ortWasm || {};

var Module=typeof ortWasm!=="undefined"?ortWasm:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}var arguments_=[];var thisProgram="./this.program";var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;var nodeFS;var nodePath;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=__webpack_require__(/*! path */ "?75c6").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}read_=function shell_read(filename,binary){if(!nodeFS)nodeFS=__webpack_require__(/*! fs */ "?63c8");if(!nodePath)nodePath=__webpack_require__(/*! path */ "?75c6");filename=nodePath["normalize"](filename);return nodeFS["readFileSync"](filename,binary?null:"utf8")};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",abort);quit_=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)}}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){arguments_=scriptArgs}else if(typeof arguments!="undefined"){arguments_=arguments}if(typeof quit==="function"){quit_=function(status){quit(status)}}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!=="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=function(title){document.title=title}}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||false;if(typeof WebAssembly!=="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heap,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heap[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heap.subarray&&UTF8Decoder){return UTF8Decoder.decode(heap.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=heap[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heap[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heap[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heap[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}what+="";err(what);ABORT=true;EXITSTATUS=1;what="abort("+what+"). Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile="ort-wasm.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch==="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["xa"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["bb"];addOnInit(Module["asm"]["ya"]);removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){var result=WebAssembly.instantiate(binary,info);return result}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){wasmTable.get(func)()}else{wasmTable.get(func)(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var ExceptionInfoAttrs={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};function ___cxa_allocate_exception(size){return _malloc(size+ExceptionInfoAttrs.SIZE)+ExceptionInfoAttrs.SIZE}function _atexit(func,arg){__ATEXIT__.unshift({func:func,arg:arg})}function ___cxa_atexit(a0,a1){return _atexit(a0,a1)}function ___cxa_thread_atexit(a0,a1){return _atexit(a0,a1)}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-ExceptionInfoAttrs.SIZE;this.set_type=function(type){HEAP32[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]=type};this.get_type=function(){return HEAP32[this.ptr+ExceptionInfoAttrs.TYPE_OFFSET>>2]};this.set_destructor=function(destructor){HEAP32[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]=destructor};this.get_destructor=function(){return HEAP32[this.ptr+ExceptionInfoAttrs.DESTRUCTOR_OFFSET>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+ExceptionInfoAttrs.CAUGHT_OFFSET>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+ExceptionInfoAttrs.RETHROWN_OFFSET>>0]!=0};this.init=function(type,destructor){this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2];HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2];HEAP32[this.ptr+ExceptionInfoAttrs.REFCOUNT_OFFSET>>2]=prev-1;return prev===1}}var exceptionLast=0;var uncaughtExceptionCount=0;function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},get64:function(low,high){return low}};function ___sys_access(path,amode){path=SYSCALLS.getStr(path);return SYSCALLS.doAccess(path,amode)}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}function ___sys_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;return 0}function ___sys_fstat64(fd,buf){}function ___sys_getdents64(fd,dirp,count){}function ___sys_getpid(){return 42}function ___sys_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;return 0}function ___sys_lstat64(path,buf){}function ___sys_mkdir(path,mode){path=SYSCALLS.getStr(path);return SYSCALLS.doMkdir(path,mode)}function syscallMmap2(addr,len,prot,flags,fd,off){off<<=12;var ptr;var allocated=false;if((flags&16)!==0&&addr%65536!==0){return-28}if((flags&32)!==0){ptr=_memalign(65536,len);if(!ptr)return-48;_memset(ptr,0,len);allocated=true}else{return-52}SYSCALLS.mappings[ptr]={malloc:ptr,len:len,allocated:allocated,fd:fd,prot:prot,flags:flags,offset:off};return ptr}function ___sys_mmap2(addr,len,prot,flags,fd,off){return syscallMmap2(addr,len,prot,flags,fd,off)}function syscallMunmap(addr,len){if((addr|0)===-1||len===0){return-28}var info=SYSCALLS.mappings[addr];if(!info)return 0;if(len===info.len){SYSCALLS.mappings[addr]=null;if(info.allocated){_free(info.malloc)}}return 0}function ___sys_munmap(addr,len){return syscallMunmap(addr,len)}function ___sys_open(path,flags,varargs){SYSCALLS.varargs=varargs}function ___sys_readlink(path,buf,bufsize){path=SYSCALLS.getStr(path);return SYSCALLS.doReadlink(path,buf,bufsize)}function ___sys_rmdir(path){}function ___sys_stat64(path,buf){}function ___sys_unlink(path){}function _abort(){abort()}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else _emscripten_get_now=function(){return performance.now()};var _emscripten_get_now_is_monotonic=true;function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if((clk_id===1||clk_id===4)&&_emscripten_get_now_is_monotonic){now=_emscripten_get_now()}else{setErrNo(28);return-1}HEAP32[tp>>2]=now/1e3|0;HEAP32[tp+4>>2]=now%1e3*1e3*1e3|0;return 0}function _difftime(time1,time0){return time1-time0}function _dlclose(handle){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlerror(){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlopen(filename,flag){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _dlsym(handle,symbol){abort("To use dlopen, you need to use Emscripten's linking support, see https://github.com/emscripten-core/emscripten/wiki/Linking")}function _emscripten_get_heap_max(){return 2147483648}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=2147483648;if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_thread_sleep(msecs){var start=_emscripten_get_now();while(_emscripten_get_now()-start<msecs){}}var WebNN={initManagers:function(){if(this["mgrContext"])return;function makeManager(){return{objects:{},nextId:1,create:function(object,wrapper){wrapper=wrapper||{};var id=this.nextId++;wrapper.refcount=1;wrapper.object=object;this.objects[id]=wrapper;return id},get:function(id){if(id===0)return undefined;var o=this.objects[id];return o.object},reference:function(id){var o=this.objects[id];o.refcount++},release:function(id){var o=this.objects[id];o.refcount--;if(o.refcount<=0){delete this.objects[id]}}}}this["mgrContext"]=this["mgrContext"]||makeManager();this.mgrGraph=this.mgrGraph||makeManager();this.mgrGraphBuilder=this.mgrGraphBuilder||makeManager();this.mgrNamedInputs=this.mgrNamedInputs||makeManager();this.mgrNamedOperands=this.mgrNamedOperands||makeManager();this.mgrNamedOutputs=this.mgrNamedOutputs||makeManager();this.mgrNamedResults=this.mgrNamedResults||makeManager();this.mgrOperand=this.mgrOperand||makeManager();this.mgrResult=this.mgrResult||makeManager()},AutoPad:["explicit","same-upper","same-lower"],BuildGraphStatus:["success","error","context-lost","unknown"],ComputeGraphStatus:["success","error","context-lost","unknown"],ErrorFilter:["none","validation","out-of-memory"],ErrorType:["no-error","validation","out-of-memory","unknown","device-lost"],FilterOperandLayout:["oihw","hwio","ohwi","ihwo"],FusedActivation:["none","relu"],InputOperandLayout:["nchw","nhwc"],OperandType:["float32","float16","int32","uint32","int8","uint8"],PowerPreference:["default","high_performance","low_power"],makeI32Array:function(count,arrayPtr){if(count===0||arrayPtr===0){return undefined}var array=[];for(var i=0;i<count;++i,arrayPtr+=4){array.push(HEAP32[arrayPtr>>2])}return array},makeArrayBufferView:function(offset,byteSize,type="float32"){assert(type==="float32");return new Float32Array(HEAPU8.buffer,offset,byteSize/Float32Array.BYTES_PER_ELEMENT)},makeClampOptions:function(ptr){return{"minValue":this.mgrOperand.get(HEAP32[ptr>>2]),"maxValue":this.mgrOperand.get(HEAP32[ptr+4>>2])}},makeBatchNormOptions:function(ptr){return{"scale":this.mgrOperand.get(HEAP32[ptr>>2]),"bias":this.mgrOperand.get(HEAP32[ptr+4>>2]),"axis":HEAP32[ptr+8>>2],"epsilon":HEAPF32[ptr+12>>2],"activation":this.FusedActivation[HEAP32[ptr+16>>2]]}},makeGemmOptions:function(ptr){return{"c":this.mgrOperand.get(HEAP32[ptr>>2]),"alpha":HEAPF32[ptr+4>>2],"beta":HEAPF32[ptr+8>>2],"aTranspose":HEAP8[ptr+12>>0]!==0,"bTranspose":HEAP8[ptr+13>>0]!==0}},makeOperandDescriptor:function(ptr){return{"type":this.OperandType[HEAPU32[ptr>>2]],"dimensions":this.makeI32Array(HEAPU32[ptr+8>>2],HEAP32[ptr+4>>2])}},makeConv2dOptions:function(ptr){return{"padding":this.AutoPad[HEAP32[ptr+24>>2]]==="explicit"?this.makeI32Array(HEAPU32[ptr>>2],HEAP32[ptr+4>>2]):undefined,"strides":this.makeI32Array(HEAPU32[ptr+8>>2],HEAP32[ptr+12>>2]),"dilations":this.makeI32Array(HEAPU32[ptr+16>>2],HEAP32[ptr+20>>2]),"autoPad":this.AutoPad[HEAP32[ptr+24>>2]],"groups":HEAP32[ptr+28>>2],"inputLayout":this.InputOperandLayout[HEAP32[ptr+32>>2]],"filterLayout":this.FilterOperandLayout[HEAP32[ptr+36>>2]],"bias":this.mgrOperand.get(HEAP32[ptr+40>>2]),"activation":this.FusedActivation[HEAP32[ptr+44>>2]]}},makePool2dOptions:function(ptr){return{"windowDimensions":this.makeI32Array(HEAPU32[ptr>>2],HEAP32[ptr+4>>2]),"padding":this.AutoPad[HEAP32[ptr+32>>2]]==="explicit"?this.makeI32Array(HEAPU32[ptr+8>>2],HEAP32[ptr+12>>2]):undefined,"strides":this.makeI32Array(HEAPU32[ptr+16>>2],HEAP32[ptr+20>>2]),"dilations":this.makeI32Array(HEAPU32[ptr+24>>2],HEAP32[ptr+28>>2]),"autoPad":this.AutoPad[HEAP32[ptr+32>>2]],"inputLayout":this.InputOperandLayout[HEAP32[ptr+36>>2]]}},makeInput:function(ptr){return{"data":this.makeArrayBufferView(HEAP32[ptr>>2],HEAPU32[ptr+4>>2]),"dimensions":HEAP32[ptr+8>>2]===0?undefined:this.makeI32Array(HEAPU32[ptr+12>>2],HEAP32[ptr+8>>2])}},makeOutput:function(ptr){return{"data":HEAP32[ptr>>2]===0?undefined:this.makeArrayBufferView(HEAP32[ptr>>2],HEAPU32[ptr+4>>2]),"dimensions":HEAP32[ptr+8>>2]===0?undefined:this.makeI32Array(HEAPU32[ptr+12>>2],HEAP32[ptr+8>>2])}}};function _emscripten_webnn_create_context(){var context=navigator.ml.createContext();return WebNN.mgrContext.create(context)}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator==="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){return 0}function _fd_fdstat_get(fd,pbuf){var type=fd==1||fd==2?2:abort();HEAP8[pbuf>>0]=type;return 0}function _fd_read(fd,iov,iovcnt,pnum){var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doReadv(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){}function _fd_write(fd,iov,iovcnt,pnum){var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j])}num+=len}HEAP32[pnum>>2]=num;return 0}function _gettimeofday(ptr){var now=Date.now();HEAP32[ptr>>2]=now/1e3|0;HEAP32[ptr+4>>2]=now%1e3*1e3|0;return 0}function _gmtime_r(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();HEAP32[tmPtr+36>>2]=0;HEAP32[tmPtr+32>>2]=0;var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;if(!_gmtime_r.GMTString)_gmtime_r.GMTString=allocateUTF8("GMT");HEAP32[tmPtr+40>>2]=_gmtime_r.GMTString;return tmPtr}function _tzset(){if(_tzset.called)return;_tzset.called=true;var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[__get_timezone()>>2]=stdTimezoneOffset*60;HEAP32[__get_daylight()>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAP32[__get_tzname()>>2]=winterNamePtr;HEAP32[__get_tzname()+4>>2]=summerNamePtr}else{HEAP32[__get_tzname()>>2]=summerNamePtr;HEAP32[__get_tzname()+4>>2]=winterNamePtr}}function _localtime_r(time,tmPtr){_tzset();var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst;var zonePtr=HEAP32[__get_tzname()+(dst?4:0)>>2];HEAP32[tmPtr+40>>2]=zonePtr;return tmPtr}function _mktime(tmPtr){_tzset();var date=new Date(HEAP32[tmPtr+20>>2]+1900,HEAP32[tmPtr+16>>2],HEAP32[tmPtr+12>>2],HEAP32[tmPtr+8>>2],HEAP32[tmPtr+4>>2],HEAP32[tmPtr>>2],0);var dst=HEAP32[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){HEAP32[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}HEAP32[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function _mlContextReference(id){WebNN.mgrContext.reference(id)}function _mlContextRelease(id){WebNN.mgrContext.release(id)}function _mlGraphBuilderAdd(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.add(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderAveragePool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.averagePool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderBatchNorm(builderId,inputId,meanId,varianceId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var mean=WebNN.mgrOperand.get(meanId);var variance=WebNN.mgrOperand.get(varianceId);var options=WebNN.makeBatchNormOptions(optionsPtr);var output=builder.batchNormalization(input,mean,variance,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderBuildSync(builderId,namedOperandsId){var builder=WebNN.mgrGraphBuilder.get(builderId);var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);try{var graph=builder.buildSync(namedOperands);return WebNN.mgrGraph.create(graph)}catch(error){console.log("builder.buildSync failed: "+error);return 0}}function _mlGraphBuilderConcat(builderId,inputsCount,inputsPtr,axis){var builder=WebNN.mgrGraphBuilder.get(builderId);var inputIds=WebNN.makeI32Array(inputsCount,inputsPtr);var inputs=[];for(var i=0;i<inputIds.length;++i){inputs.push(WebNN.mgrOperand.get(inputIds[i]))}var output=builder.concat(inputs,axis);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderConstant(builderId,descPtr,valuePtr,size){var builder=WebNN.mgrGraphBuilder.get(builderId);var desc=WebNN.makeOperandDescriptor(descPtr);var buffer=WebNN.makeArrayBufferView(valuePtr,size);var constant=builder.constant(desc,buffer);return WebNN.mgrOperand.create(constant)}function _mlGraphBuilderConv2d(builderId,inputId,filterId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var filter=WebNN.mgrOperand.get(filterId);var options=WebNN.makeConv2dOptions(optionsPtr);var conv2d=builder.conv2d(input,filter,options);return WebNN.mgrOperand.create(conv2d)}function _mlGraphBuilderGemm(builderId,aId,bId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var options=WebNN.makeGemmOptions(optionsPtr);var output=builder.gemm(a,b,options);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderInput(builderId,namePtr,descPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var name=UTF8ToString(namePtr);var desc=WebNN.makeOperandDescriptor(descPtr);var input=builder.input(name,desc);return WebNN.mgrOperand.create(input)}function _mlGraphBuilderMatmul(builderId,aId,bId){var builder=WebNN.mgrGraphBuilder.get(builderId);var a=WebNN.mgrOperand.get(aId);var b=WebNN.mgrOperand.get(bId);var c=builder.matmul(a,b);return WebNN.mgrOperand.create(c)}function _mlGraphBuilderMaxPool2d(builderId,inputId,optionsPtr){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var options=WebNN.makePool2dOptions(optionsPtr);var pool2d=builder.maxPool2d(input,options);return WebNN.mgrOperand.create(pool2d)}function _mlGraphBuilderRelease(id){WebNN.mgrGraphBuilder.release(id)}function _mlGraphBuilderRelu(builderId,inputId){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var output=builder.relu(input);return WebNN.mgrOperand.create(output)}function _mlGraphBuilderReshape(builderId,inputId,newShapePtr,newShapeCount){var builder=WebNN.mgrGraphBuilder.get(builderId);var input=WebNN.mgrOperand.get(inputId);var newShape=WebNN.makeI32Array(newShapeCount,newShapePtr);var output=builder.reshape(input,newShape);return WebNN.mgrOperand.create(output)}function _mlGraphComputeSync(graphId,inputsId,outputsId){var graph=WebNN.mgrGraph.get(graphId);var inputs=WebNN.mgrNamedInputs.get(inputsId);var outputs=WebNN.mgrNamedOutputs.get(outputsId);return graph.computeSync(inputs,outputs)}function _mlGraphReference(id){WebNN.mgrGraph.reference(id)}function _mlGraphRelease(id){WebNN.mgrGraph.release(id)}function _mlNamedInputsRelease(id){WebNN.mgrNamedInputs.release(id)}function _mlNamedInputsSet(namedInputsId,namePtr,inputPtr){var namedInputs=WebNN.mgrNamedInputs.get(namedInputsId);var name=UTF8ToString(namePtr);var input=WebNN.makeInput(inputPtr);namedInputs[name]=input}function _mlNamedOperandsRelease(id){WebNN.mgrNamedOperands.release(id)}function _mlNamedOperandsSet(namedOperandsId,namePtr,operandId){var namedOperands=WebNN.mgrNamedOperands.get(namedOperandsId);var name=UTF8ToString(namePtr);var operand=WebNN.mgrOperand.get(operandId);namedOperands[name]=operand}function _mlNamedOutputsRelease(id){WebNN.mgrNamedOutputs.release(id)}function _mlNamedOutputsSet(namedOutputsId,namePtr,outputPtr){var namedOutputs=WebNN.mgrNamedOutputs.get(namedOutputsId);var name=UTF8ToString(namePtr);var output=WebNN.makeOutput(outputPtr);namedOutputs[name]=output}function _mlOperandReference(id){WebNN.mgrOperand.reference(id)}function _mlOperandRelease(id){WebNN.mgrOperand.release(id)}function _pthread_create(){return 6}function _pthread_join(){return 28}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value==="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return"\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}else{return"PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return"\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var janFirst=new Date(date.tm_year+1900,0,1);var firstSunday=janFirst.getDay()===0?janFirst:__addDays(janFirst,7-janFirst.getDay());var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstSunday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstSundayUntilEndJanuary=31-firstSunday.getDate();var days=firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstSunday,janFirst)===0?"01":"00"},"%V":function(date){var janFourthThisYear=new Date(date.tm_year+1900,0,4);var janFourthNextYear=new Date(date.tm_year+1901,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);var endDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);if(compareByDay(endDate,firstWeekStartThisYear)<0){return"53"}if(compareByDay(firstWeekStartNextYear,endDate)<=0){return"01"}var daysDifference;if(firstWeekStartThisYear.getFullYear()<date.tm_year+1900){daysDifference=date.tm_yday+32-firstWeekStartThisYear.getDate()}else{daysDifference=date.tm_yday+1-firstWeekStartThisYear.getDate()}return leadingNulls(Math.ceil(daysDifference/7),2)},"%w":function(date){return date.tm_wday},"%W":function(date){var janFirst=new Date(date.tm_year,0,1);var firstMonday=janFirst.getDay()===1?janFirst:__addDays(janFirst,janFirst.getDay()===0?1:7-janFirst.getDay()+1);var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstMonday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstMondayUntilEndJanuary=31-firstMonday.getDate();var days=firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstMonday,janFirst)===0?"01":"00"},"%y":function(date){return(date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return"%"}};for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function _webnnCreateGraphBuilder(contextId){var context=WebNN.mgrContext.get(contextId);var builder=new MLGraphBuilder(context);return WebNN.mgrGraphBuilder.create(builder)}function _webnnCreateNamedInputs(){var inputs={};return WebNN.mgrNamedInputs.create(inputs)}function _webnnCreateNamedOperands(){var operands={};return WebNN.mgrNamedOperands.create(operands)}function _webnnCreateNamedOutputs(){var outputs={};return WebNN.mgrNamedOutputs.create(outputs)}WebNN.initManagers();function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var asmLibraryArg={"a":___cxa_allocate_exception,"c":___cxa_atexit,"f":___cxa_thread_atexit,"b":___cxa_throw,"L":___sys_access,"m":___sys_fcntl64,"R":___sys_fstat64,"M":___sys_getdents64,"q":___sys_getpid,"D":___sys_ioctl,"N":___sys_lstat64,"Q":___sys_mkdir,"P":___sys_mmap2,"O":___sys_munmap,"l":___sys_open,"K":___sys_readlink,"I":___sys_rmdir,"s":___sys_stat64,"J":___sys_unlink,"j":_abort,"u":_clock_gettime,"z":_difftime,"va":_dlclose,"i":_dlerror,"wa":_dlopen,"ua":_dlsym,"S":_emscripten_get_heap_max,"C":_emscripten_memcpy_big,"k":_emscripten_resize_heap,"H":_emscripten_thread_sleep,"sa":_emscripten_webnn_create_context,"F":_environ_get,"G":_environ_sizes_get,"h":_fd_close,"E":_fd_fdstat_get,"o":_fd_read,"B":_fd_seek,"p":_fd_write,"aa":_gettimeofday,"A":_gmtime_r,"n":_localtime_r,"y":_mktime,"x":_mlContextReference,"w":_mlContextRelease,"pa":_mlGraphBuilderAdd,"oa":_mlGraphBuilderAveragePool2d,"na":_mlGraphBuilderBatchNorm,"ma":_mlGraphBuilderBuildSync,"la":_mlGraphBuilderConcat,"ka":_mlGraphBuilderConstant,"ja":_mlGraphBuilderConv2d,"ia":_mlGraphBuilderGemm,"ha":_mlGraphBuilderInput,"ga":_mlGraphBuilderMatmul,"fa":_mlGraphBuilderMaxPool2d,"t":_mlGraphBuilderRelease,"ea":_mlGraphBuilderRelu,"da":_mlGraphBuilderReshape,"ra":_mlGraphComputeSync,"qa":_mlGraphReference,"v":_mlGraphRelease,"ba":_mlNamedInputsRelease,"ca":_mlNamedInputsSet,"_":_mlNamedOperandsRelease,"$":_mlNamedOperandsSet,"Y":_mlNamedOutputsRelease,"Z":_mlNamedOutputsSet,"e":_mlOperandReference,"d":_mlOperandRelease,"T":_pthread_create,"r":_pthread_join,"ta":_strftime,"g":_strftime_l,"X":_webnnCreateGraphBuilder,"W":_webnnCreateNamedInputs,"V":_webnnCreateNamedOperands,"U":_webnnCreateNamedOutputs};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["ya"]).apply(null,arguments)};var _OrtInit=Module["_OrtInit"]=function(){return(_OrtInit=Module["_OrtInit"]=Module["asm"]["za"]).apply(null,arguments)};var _OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=function(){return(_OrtCreateSessionOptions=Module["_OrtCreateSessionOptions"]=Module["asm"]["Aa"]).apply(null,arguments)};var _OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=function(){return(_OrtSessionOptionsAppendExecutionProviderWebNN=Module["_OrtSessionOptionsAppendExecutionProviderWebNN"]=Module["asm"]["Ba"]).apply(null,arguments)};var _OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=function(){return(_OrtAddSessionConfigEntry=Module["_OrtAddSessionConfigEntry"]=Module["asm"]["Ca"]).apply(null,arguments)};var _OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=function(){return(_OrtReleaseSessionOptions=Module["_OrtReleaseSessionOptions"]=Module["asm"]["Da"]).apply(null,arguments)};var _OrtCreateSession=Module["_OrtCreateSession"]=function(){return(_OrtCreateSession=Module["_OrtCreateSession"]=Module["asm"]["Ea"]).apply(null,arguments)};var _OrtReleaseSession=Module["_OrtReleaseSession"]=function(){return(_OrtReleaseSession=Module["_OrtReleaseSession"]=Module["asm"]["Fa"]).apply(null,arguments)};var _OrtGetInputCount=Module["_OrtGetInputCount"]=function(){return(_OrtGetInputCount=Module["_OrtGetInputCount"]=Module["asm"]["Ga"]).apply(null,arguments)};var _OrtGetOutputCount=Module["_OrtGetOutputCount"]=function(){return(_OrtGetOutputCount=Module["_OrtGetOutputCount"]=Module["asm"]["Ha"]).apply(null,arguments)};var _OrtGetInputName=Module["_OrtGetInputName"]=function(){return(_OrtGetInputName=Module["_OrtGetInputName"]=Module["asm"]["Ia"]).apply(null,arguments)};var _OrtGetOutputName=Module["_OrtGetOutputName"]=function(){return(_OrtGetOutputName=Module["_OrtGetOutputName"]=Module["asm"]["Ja"]).apply(null,arguments)};var _OrtFree=Module["_OrtFree"]=function(){return(_OrtFree=Module["_OrtFree"]=Module["asm"]["Ka"]).apply(null,arguments)};var _OrtCreateTensor=Module["_OrtCreateTensor"]=function(){return(_OrtCreateTensor=Module["_OrtCreateTensor"]=Module["asm"]["La"]).apply(null,arguments)};var _OrtGetTensorData=Module["_OrtGetTensorData"]=function(){return(_OrtGetTensorData=Module["_OrtGetTensorData"]=Module["asm"]["Ma"]).apply(null,arguments)};var _OrtReleaseTensor=Module["_OrtReleaseTensor"]=function(){return(_OrtReleaseTensor=Module["_OrtReleaseTensor"]=Module["asm"]["Na"]).apply(null,arguments)};var _OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=function(){return(_OrtCreateRunOptions=Module["_OrtCreateRunOptions"]=Module["asm"]["Oa"]).apply(null,arguments)};var _OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=function(){return(_OrtAddRunConfigEntry=Module["_OrtAddRunConfigEntry"]=Module["asm"]["Pa"]).apply(null,arguments)};var _OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=function(){return(_OrtReleaseRunOptions=Module["_OrtReleaseRunOptions"]=Module["asm"]["Qa"]).apply(null,arguments)};var _OrtRun=Module["_OrtRun"]=function(){return(_OrtRun=Module["_OrtRun"]=Module["asm"]["Ra"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["Sa"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["Ta"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["Ua"]).apply(null,arguments)};var _memset=Module["_memset"]=function(){return(_memset=Module["_memset"]=Module["asm"]["Va"]).apply(null,arguments)};var __get_tzname=Module["__get_tzname"]=function(){return(__get_tzname=Module["__get_tzname"]=Module["asm"]["Wa"]).apply(null,arguments)};var __get_daylight=Module["__get_daylight"]=function(){return(__get_daylight=Module["__get_daylight"]=Module["asm"]["Xa"]).apply(null,arguments)};var __get_timezone=Module["__get_timezone"]=function(){return(__get_timezone=Module["__get_timezone"]=Module["asm"]["Ya"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["Za"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["_a"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["$a"]).apply(null,arguments)};var _memalign=Module["_memalign"]=function(){return(_memalign=Module["_memalign"]=Module["asm"]["ab"]).apply(null,arguments)};Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["stackSave"]=stackSave;Module["stackRestore"]=stackRestore;Module["stackAlloc"]=stackAlloc;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}run();


  return ortWasm.ready
}
);
})();
if (true)
  module.exports = ortWasm;
else {}


/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/flatbuffers/js/flatbuffers.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/flatbuffers/js/flatbuffers.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "flatbuffers": () => (/* binding */ flatbuffers)
/* harmony export */ });
/// @file
/// @addtogroup flatbuffers_javascript_api
/// @{
/// @cond FLATBUFFERS_INTERNAL

/**
 * @fileoverview
 *
 * Need to suppress 'global this' error so the Node.js export line doesn't cause
 * closure compile to error out.
 * @suppress {globalThis}
 */

/**
 * @const
 * @namespace
 */
var flatbuffers = {};

/**
 * @typedef {number}
 */
flatbuffers.Offset;

/**
 * @typedef {{
 *   bb: flatbuffers.ByteBuffer,
 *   bb_pos: number
 * }}
 */
flatbuffers.Table;

/**
 * @type {number}
 * @const
 */
flatbuffers.SIZEOF_SHORT = 2;

/**
 * @type {number}
 * @const
 */
flatbuffers.SIZEOF_INT = 4;

/**
 * @type {number}
 * @const
 */
flatbuffers.FILE_IDENTIFIER_LENGTH = 4;

/**
 * @type {number}
 * @const
 */
flatbuffers.SIZE_PREFIX_LENGTH = 4;

/**
 * @enum {number}
 */
flatbuffers.Encoding = {
  UTF8_BYTES: 1,
  UTF16_STRING: 2
};

/**
 * @type {Int32Array}
 * @const
 */
flatbuffers.int32 = new Int32Array(2);

/**
 * @type {Float32Array}
 * @const
 */
flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);

/**
 * @type {Float64Array}
 * @const
 */
flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);

/**
 * @type {boolean}
 * @const
 */
flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

////////////////////////////////////////////////////////////////////////////////

/**
 * @constructor
 * @param {number} low
 * @param {number} high
 */
flatbuffers.Long = function(low, high) {
  /**
   * @type {number}
   * @const
   */
  this.low = low | 0;

  /**
   * @type {number}
   * @const
   */
  this.high = high | 0;
};

/**
 * @param {number} low
 * @param {number} high
 * @returns {!flatbuffers.Long}
 */
flatbuffers.Long.create = function(low, high) {
  // Special-case zero to avoid GC overhead for default values
  return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
};

/**
 * @returns {number}
 */
flatbuffers.Long.prototype.toFloat64 = function() {
  return (this.low >>> 0) + this.high * 0x100000000;
};

/**
 * @param {flatbuffers.Long} other
 * @returns {boolean}
 */
flatbuffers.Long.prototype.equals = function(other) {
  return this.low == other.low && this.high == other.high;
};

/**
 * @type {!flatbuffers.Long}
 * @const
 */
flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);

/// @endcond
////////////////////////////////////////////////////////////////////////////////
/**
 * Create a FlatBufferBuilder.
 *
 * @constructor
 * @param {number=} opt_initial_size
 */
flatbuffers.Builder = function(opt_initial_size) {
  if (!opt_initial_size) {
    var initial_size = 1024;
  } else {
    var initial_size = opt_initial_size;
  }

  /**
   * @type {flatbuffers.ByteBuffer}
   * @private
   */
  this.bb = flatbuffers.ByteBuffer.allocate(initial_size);

  /**
   * Remaining space in the ByteBuffer.
   *
   * @type {number}
   * @private
   */
  this.space = initial_size;

  /**
   * Minimum alignment encountered so far.
   *
   * @type {number}
   * @private
   */
  this.minalign = 1;

  /**
   * The vtable for the current table.
   *
   * @type {Array.<number>}
   * @private
   */
  this.vtable = null;

  /**
   * The amount of fields we're actually using.
   *
   * @type {number}
   * @private
   */
  this.vtable_in_use = 0;

  /**
   * Whether we are currently serializing a table.
   *
   * @type {boolean}
   * @private
   */
  this.isNested = false;

  /**
   * Starting offset of the current struct/table.
   *
   * @type {number}
   * @private
   */
  this.object_start = 0;

  /**
   * List of offsets of all vtables.
   *
   * @type {Array.<number>}
   * @private
   */
  this.vtables = [];

  /**
   * For the current vector being built.
   *
   * @type {number}
   * @private
   */
  this.vector_num_elems = 0;

  /**
   * False omits default values from the serialized data
   *
   * @type {boolean}
   * @private
   */
  this.force_defaults = false;
};

flatbuffers.Builder.prototype.clear = function() {
  this.bb.clear();
  this.space = this.bb.capacity();
  this.minalign = 1;
  this.vtable = null;
  this.vtable_in_use = 0;
  this.isNested = false;
  this.object_start = 0;
  this.vtables = [];
  this.vector_num_elems = 0;
  this.force_defaults = false;
};

/**
 * In order to save space, fields that are set to their default value
 * don't get serialized into the buffer. Forcing defaults provides a
 * way to manually disable this optimization.
 *
 * @param {boolean} forceDefaults true always serializes default values
 */
flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
  this.force_defaults = forceDefaults;
};

/**
 * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
 * called finish(). The actual data starts at the ByteBuffer's current position,
 * not necessarily at 0.
 *
 * @returns {flatbuffers.ByteBuffer}
 */
flatbuffers.Builder.prototype.dataBuffer = function() {
  return this.bb;
};

/**
 * Get the bytes representing the FlatBuffer. Only call this after you've
 * called finish().
 *
 * @returns {!Uint8Array}
 */
flatbuffers.Builder.prototype.asUint8Array = function() {
  return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * Prepare to write an element of `size` after `additional_bytes` have been
 * written, e.g. if you write a string, you need to align such the int length
 * field is aligned to 4 bytes, and the string data follows it directly. If all
 * you need to do is alignment, `additional_bytes` will be 0.
 *
 * @param {number} size This is the of the new element to write
 * @param {number} additional_bytes The padding size
 */
flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
  // Track the biggest thing we've ever aligned to.
  if (size > this.minalign) {
    this.minalign = size;
  }

  // Find the amount of alignment needed such that `size` is properly
  // aligned after `additional_bytes`
  var align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);

  // Reallocate the buffer if needed.
  while (this.space < align_size + size + additional_bytes) {
    var old_buf_size = this.bb.capacity();
    this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
    this.space += this.bb.capacity() - old_buf_size;
  }

  this.pad(align_size);
};

/**
 * @param {number} byte_size
 */
flatbuffers.Builder.prototype.pad = function(byte_size) {
  for (var i = 0; i < byte_size; i++) {
    this.bb.writeInt8(--this.space, 0);
  }
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeInt8 = function(value) {
  this.bb.writeInt8(this.space -= 1, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeInt16 = function(value) {
  this.bb.writeInt16(this.space -= 2, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeInt32 = function(value) {
  this.bb.writeInt32(this.space -= 4, value);
};

/**
 * @param {flatbuffers.Long} value
 */
flatbuffers.Builder.prototype.writeInt64 = function(value) {
  this.bb.writeInt64(this.space -= 8, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeFloat32 = function(value) {
  this.bb.writeFloat32(this.space -= 4, value);
};

/**
 * @param {number} value
 */
flatbuffers.Builder.prototype.writeFloat64 = function(value) {
  this.bb.writeFloat64(this.space -= 8, value);
};
/// @endcond

/**
 * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `int8` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt8 = function(value) {
  this.prep(1, 0);
  this.writeInt8(value);
};

/**
 * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `int16` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt16 = function(value) {
  this.prep(2, 0);
  this.writeInt16(value);
};

/**
 * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `int32` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt32 = function(value) {
  this.prep(4, 0);
  this.writeInt32(value);
};

/**
 * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {flatbuffers.Long} value The `int64` to add the the buffer.
 */
flatbuffers.Builder.prototype.addInt64 = function(value) {
  this.prep(8, 0);
  this.writeInt64(value);
};

/**
 * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `float32` to add the the buffer.
 */
flatbuffers.Builder.prototype.addFloat32 = function(value) {
  this.prep(4, 0);
  this.writeFloat32(value);
};

/**
 * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
 * @param {number} value The `float64` to add the the buffer.
 */
flatbuffers.Builder.prototype.addFloat64 = function(value) {
  this.prep(8, 0);
  this.writeFloat64(value);
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt8(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt16(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addInt32(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {flatbuffers.Long} value
 * @param {flatbuffers.Long} defaultValue
 */
flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
  if (this.force_defaults || !value.equals(defaultValue)) {
    this.addInt64(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addFloat32(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {number} value
 * @param {number} defaultValue
 */
flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addFloat64(value);
    this.slot(voffset);
  }
};

/**
 * @param {number} voffset
 * @param {flatbuffers.Offset} value
 * @param {flatbuffers.Offset} defaultValue
 */
flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
  if (this.force_defaults || value != defaultValue) {
    this.addOffset(value);
    this.slot(voffset);
  }
};

/**
 * Structs are stored inline, so nothing additional is being added. `d` is always 0.
 *
 * @param {number} voffset
 * @param {flatbuffers.Offset} value
 * @param {flatbuffers.Offset} defaultValue
 */
flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
  if (value != defaultValue) {
    this.nested(value);
    this.slot(voffset);
  }
};

/**
 * Structures are always stored inline, they need to be created right
 * where they're used.  You'll get this assertion failure if you
 * created it elsewhere.
 *
 * @param {flatbuffers.Offset} obj The offset of the created object
 */
flatbuffers.Builder.prototype.nested = function(obj) {
  if (obj != this.offset()) {
    throw new Error('FlatBuffers: struct must be serialized inline.');
  }
};

/**
 * Should not be creating any other object, string or vector
 * while an object is being constructed
 */
flatbuffers.Builder.prototype.notNested = function() {
  if (this.isNested) {
    throw new Error('FlatBuffers: object serialization must not be nested.');
  }
};

/**
 * Set the current vtable at `voffset` to the current location in the buffer.
 *
 * @param {number} voffset
 */
flatbuffers.Builder.prototype.slot = function(voffset) {
  this.vtable[voffset] = this.offset();
};

/**
 * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.
 */
flatbuffers.Builder.prototype.offset = function() {
  return this.bb.capacity() - this.space;
};

/**
 * Doubles the size of the backing ByteBuffer and copies the old data towards
 * the end of the new buffer (since we build the buffer backwards).
 *
 * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data
 * @returns {!flatbuffers.ByteBuffer} A new byte buffer with the old data copied
 * to it. The data is located at the end of the buffer.
 *
 * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
 * it a uint8Array we need to suppress the type check:
 * @suppress {checkTypes}
 */
flatbuffers.Builder.growByteBuffer = function(bb) {
  var old_buf_size = bb.capacity();

  // Ensure we don't grow beyond what fits in an int.
  if (old_buf_size & 0xC0000000) {
    throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
  }

  var new_buf_size = old_buf_size << 1;
  var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
  nbb.setPosition(new_buf_size - old_buf_size);
  nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
  return nbb;
};
/// @endcond

/**
 * Adds on offset, relative to where it will be written.
 *
 * @param {flatbuffers.Offset} offset The offset to add.
 */
flatbuffers.Builder.prototype.addOffset = function(offset) {
  this.prep(flatbuffers.SIZEOF_INT, 0); // Ensure alignment is already done.
  this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * Start encoding a new object in the buffer.  Users will not usually need to
 * call this directly. The FlatBuffers compiler will generate helper methods
 * that call this method internally.
 *
 * @param {number} numfields
 */
flatbuffers.Builder.prototype.startObject = function(numfields) {
  this.notNested();
  if (this.vtable == null) {
    this.vtable = [];
  }
  this.vtable_in_use = numfields;
  for (var i = 0; i < numfields; i++) {
    this.vtable[i] = 0; // This will push additional elements as needed
  }
  this.isNested = true;
  this.object_start = this.offset();
};

/**
 * Finish off writing the object that is under construction.
 *
 * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`
 */
flatbuffers.Builder.prototype.endObject = function() {
  if (this.vtable == null || !this.isNested) {
    throw new Error('FlatBuffers: endObject called without startObject');
  }

  this.addInt32(0);
  var vtableloc = this.offset();

  // Trim trailing zeroes.
  var i = this.vtable_in_use - 1;
  for (; i >= 0 && this.vtable[i] == 0; i--) {}
  var trimmed_size = i + 1;

  // Write out the current vtable.
  for (; i >= 0; i--) {
    // Offset relative to the start of the table.
    this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
  }

  var standard_fields = 2; // The fields below:
  this.addInt16(vtableloc - this.object_start);
  var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
  this.addInt16(len);

  // Search for an existing vtable that matches the current one.
  var existing_vtable = 0;
  var vt1 = this.space;
outer_loop:
  for (i = 0; i < this.vtables.length; i++) {
    var vt2 = this.bb.capacity() - this.vtables[i];
    if (len == this.bb.readInt16(vt2)) {
      for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
        if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
          continue outer_loop;
        }
      }
      existing_vtable = this.vtables[i];
      break;
    }
  }

  if (existing_vtable) {
    // Found a match:
    // Remove the current vtable.
    this.space = this.bb.capacity() - vtableloc;

    // Point table to existing vtable.
    this.bb.writeInt32(this.space, existing_vtable - vtableloc);
  } else {
    // No match:
    // Add the location of the current vtable to the list of vtables.
    this.vtables.push(this.offset());

    // Point table to current vtable.
    this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
  }

  this.isNested = false;
  return vtableloc;
};
/// @endcond

/**
 * Finalize a buffer, poiting to the given `root_table`.
 *
 * @param {flatbuffers.Offset} root_table
 * @param {string=} opt_file_identifier
 * @param {boolean=} opt_size_prefix
 */
flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {
  var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
  if (opt_file_identifier) {
    var file_identifier = opt_file_identifier;
    this.prep(this.minalign, flatbuffers.SIZEOF_INT +
      flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
    if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
      throw new Error('FlatBuffers: file identifier must be length ' +
        flatbuffers.FILE_IDENTIFIER_LENGTH);
    }
    for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
      this.writeInt8(file_identifier.charCodeAt(i));
    }
  }
  this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
  this.addOffset(root_table);
  if (size_prefix) {
    this.addInt32(this.bb.capacity() - this.space);
  }
  this.bb.setPosition(this.space);
};

/**
 * Finalize a size prefixed buffer, pointing to the given `root_table`.
 *
 * @param {flatbuffers.Offset} root_table
 * @param {string=} opt_file_identifier
 */
flatbuffers.Builder.prototype.finishSizePrefixed = function (root_table, opt_file_identifier) {
  this.finish(root_table, opt_file_identifier, true);
};

/// @cond FLATBUFFERS_INTERNAL
/**
 * This checks a required field has been set in a given table that has
 * just been constructed.
 *
 * @param {flatbuffers.Offset} table
 * @param {number} field
 */
flatbuffers.Builder.prototype.requiredField = function(table, field) {
  var table_start = this.bb.capacity() - table;
  var vtable_start = table_start - this.bb.readInt32(table_start);
  var ok = this.bb.readInt16(vtable_start + field) != 0;

  // If this fails, the caller will show what field needs to be set.
  if (!ok) {
    throw new Error('FlatBuffers: field ' + field + ' must be set');
  }
};

/**
 * Start a new array/vector of objects.  Users usually will not call
 * this directly. The FlatBuffers compiler will create a start/end
 * method for vector types in generated code.
 *
 * @param {number} elem_size The size of each element in the array
 * @param {number} num_elems The number of elements in the array
 * @param {number} alignment The alignment of the array
 */
flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
  this.notNested();
  this.vector_num_elems = num_elems;
  this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
  this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
};

/**
 * Finish off the creation of an array and all its elements. The array must be
 * created with `startVector`.
 *
 * @returns {flatbuffers.Offset} The offset at which the newly created array
 * starts.
 */
flatbuffers.Builder.prototype.endVector = function() {
  this.writeInt32(this.vector_num_elems);
  return this.offset();
};
/// @endcond

/**
 * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
 * instead of a string, it is assumed to contain valid UTF-8 encoded data.
 *
 * @param {string|Uint8Array} s The string to encode
 * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts
 */
flatbuffers.Builder.prototype.createString = function(s) {
  if (s instanceof Uint8Array) {
    var utf8 = s;
  } else {
    var utf8 = [];
    var i = 0;

    while (i < s.length) {
      var codePoint;

      // Decode UTF-16
      var a = s.charCodeAt(i++);
      if (a < 0xD800 || a >= 0xDC00) {
        codePoint = a;
      } else {
        var b = s.charCodeAt(i++);
        codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
      }

      // Encode UTF-8
      if (codePoint < 0x80) {
        utf8.push(codePoint);
      } else {
        if (codePoint < 0x800) {
          utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);
        } else {
          if (codePoint < 0x10000) {
            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);
          } else {
            utf8.push(
              ((codePoint >> 18) & 0x07) | 0xF0,
              ((codePoint >> 12) & 0x3F) | 0x80);
          }
          utf8.push(((codePoint >> 6) & 0x3F) | 0x80);
        }
        utf8.push((codePoint & 0x3F) | 0x80);
      }
    }
  }

  this.addInt8(0);
  this.startVector(1, utf8.length, 1);
  this.bb.setPosition(this.space -= utf8.length);
  for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
    bytes[offset++] = utf8[i];
  }
  return this.endVector();
};

/**
 * A helper function to avoid generated code depending on this file directly.
 *
 * @param {number} low
 * @param {number} high
 * @returns {!flatbuffers.Long}
 */
flatbuffers.Builder.prototype.createLong = function(low, high) {
  return flatbuffers.Long.create(low, high);
};
////////////////////////////////////////////////////////////////////////////////
/// @cond FLATBUFFERS_INTERNAL
/**
 * Create a new ByteBuffer with a given array of bytes (`Uint8Array`).
 *
 * @constructor
 * @param {Uint8Array} bytes
 */
flatbuffers.ByteBuffer = function(bytes) {
  /**
   * @type {Uint8Array}
   * @private
   */
  this.bytes_ = bytes;

  /**
   * @type {number}
   * @private
   */
  this.position_ = 0;
};

/**
 * Create and allocate a new ByteBuffer with a given size.
 *
 * @param {number} byte_size
 * @returns {!flatbuffers.ByteBuffer}
 */
flatbuffers.ByteBuffer.allocate = function(byte_size) {
  return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
};

flatbuffers.ByteBuffer.prototype.clear = function() {
  this.position_ = 0;
};

/**
 * Get the underlying `Uint8Array`.
 *
 * @returns {Uint8Array}
 */
flatbuffers.ByteBuffer.prototype.bytes = function() {
  return this.bytes_;
};

/**
 * Get the buffer's position.
 *
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.position = function() {
  return this.position_;
};

/**
 * Set the buffer's position.
 *
 * @param {number} position
 */
flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
  this.position_ = position;
};

/**
 * Get the buffer's capacity.
 *
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.capacity = function() {
  return this.bytes_.length;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
  return this.readUint8(offset) << 24 >> 24;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
  return this.bytes_[offset];
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
  return this.readUint16(offset) << 16 >> 16;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
  return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
  return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
  return this.readInt32(offset) >>> 0;
};

/**
 * @param {number} offset
 * @returns {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
  return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
};

/**
 * @param {number} offset
 * @returns {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
  return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
  flatbuffers.int32[0] = this.readInt32(offset);
  return flatbuffers.float32[0];
};

/**
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
  flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
  flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
  return flatbuffers.float64[0];
};

/**
 * @param {number} offset
 * @param {number|boolean} value
 */
flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
  this.bytes_[offset] = /** @type {number} */(value);
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
  this.bytes_[offset] = value;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
  this.bytes_[offset] = value;
  this.bytes_[offset + 1] = value >> 8;
  this.bytes_[offset + 2] = value >> 16;
  this.bytes_[offset + 3] = value >> 24;
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
};

/**
 * @param {number} offset
 * @param {flatbuffers.Long} value
 */
flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
  this.writeInt32(offset, value.low);
  this.writeInt32(offset + 4, value.high);
};

/**
 * @param {number} offset
 * @param {flatbuffers.Long} value
 */
flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
    this.writeUint32(offset, value.low);
    this.writeUint32(offset + 4, value.high);
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
  flatbuffers.float32[0] = value;
  this.writeInt32(offset, flatbuffers.int32[0]);
};

/**
 * @param {number} offset
 * @param {number} value
 */
flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
  flatbuffers.float64[0] = value;
  this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
  this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
};

/**
 * Return the file identifier.   Behavior is undefined for FlatBuffers whose
 * schema does not include a file_identifier (likely points at padding or the
 * start of a the root vtable).
 * @returns {string}
 */
flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
  if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +
      flatbuffers.FILE_IDENTIFIER_LENGTH) {
    throw new Error(
        'FlatBuffers: ByteBuffer is too short to contain an identifier.');
  }
  var result = "";
  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
    result += String.fromCharCode(
        this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));
  }
  return result;
};

/**
 * Look up a field in the vtable, return an offset into the object, or 0 if the
 * field is not present.
 *
 * @param {number} bb_pos
 * @param {number} vtable_offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
  var vtable = bb_pos - this.readInt32(bb_pos);
  return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
};

/**
 * Initialize any Table-derived type to point to the union at the given offset.
 *
 * @param {flatbuffers.Table} t
 * @param {number} offset
 * @returns {flatbuffers.Table}
 */
flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
  t.bb_pos = offset + this.readInt32(offset);
  t.bb = this;
  return t;
};

/**
 * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
 * This allocates a new string and converts to wide chars upon each access.
 *
 * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as
 * the "optionalEncoding" argument. This is useful for avoiding conversion to
 * and from UTF-16 when the data will just be packaged back up in another
 * FlatBuffer later on.
 *
 * @param {number} offset
 * @param {flatbuffers.Encoding=} opt_encoding Defaults to UTF16_STRING
 * @returns {string|!Uint8Array}
 */
flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
  offset += this.readInt32(offset);

  var length = this.readInt32(offset);
  var result = '';
  var i = 0;

  offset += flatbuffers.SIZEOF_INT;

  if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
    return this.bytes_.subarray(offset, offset + length);
  }

  while (i < length) {
    var codePoint;

    // Decode UTF-8
    var a = this.readUint8(offset + i++);
    if (a < 0xC0) {
      codePoint = a;
    } else {
      var b = this.readUint8(offset + i++);
      if (a < 0xE0) {
        codePoint =
          ((a & 0x1F) << 6) |
          (b & 0x3F);
      } else {
        var c = this.readUint8(offset + i++);
        if (a < 0xF0) {
          codePoint =
            ((a & 0x0F) << 12) |
            ((b & 0x3F) << 6) |
            (c & 0x3F);
        } else {
          var d = this.readUint8(offset + i++);
          codePoint =
            ((a & 0x07) << 18) |
            ((b & 0x3F) << 12) |
            ((c & 0x3F) << 6) |
            (d & 0x3F);
        }
      }
    }

    // Encode UTF-16
    if (codePoint < 0x10000) {
      result += String.fromCharCode(codePoint);
    } else {
      codePoint -= 0x10000;
      result += String.fromCharCode(
        (codePoint >> 10) + 0xD800,
        (codePoint & ((1 << 10) - 1)) + 0xDC00);
    }
  }

  return result;
};

/**
 * Retrieve the relative offset stored at "offset"
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
  return offset + this.readInt32(offset);
};

/**
 * Get the start of data of a vector whose offset is stored at "offset" in this object.
 *
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
  return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT; // data starts after the length
};

/**
 * Get the length of a vector whose offset is stored at "offset" in this object.
 *
 * @param {number} offset
 * @returns {number}
 */
flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
  return this.readInt32(offset + this.readInt32(offset));
};

/**
 * @param {string} ident
 * @returns {boolean}
 */
flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
  if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
    throw new Error('FlatBuffers: file identifier must be length ' +
                    flatbuffers.FILE_IDENTIFIER_LENGTH);
  }
  for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
    if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
      return false;
    }
  }
  return true;
};

/**
 * A helper function to avoid generated code depending on this file directly.
 *
 * @param {number} low
 * @param {number} high
 * @returns {!flatbuffers.Long}
 */
flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
  return flatbuffers.Long.create(low, high);
};

// Exports for Node.js and RequireJS


/// @endcond
/// @}


/***/ }),

/***/ "./node_modules/guid-typescript/dist/guid.js":
/*!***************************************************!*\
  !*** ./node_modules/guid-typescript/dist/guid.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
var Guid = /** @class */ (function () {
    function Guid(guid) {
        if (!guid) {
            throw new TypeError("Invalid argument; `value` has no value.");
        }
        this.value = Guid.EMPTY;
        if (guid && Guid.isGuid(guid)) {
            this.value = guid;
        }
    }
    Guid.isGuid = function (guid) {
        var value = guid.toString();
        return guid && (guid instanceof Guid || Guid.validator.test(value));
    };
    Guid.create = function () {
        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-"));
    };
    Guid.createEmpty = function () {
        return new Guid("emptyguid");
    };
    Guid.parse = function (guid) {
        return new Guid(guid);
    };
    Guid.raw = function () {
        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join("-");
    };
    Guid.gen = function (count) {
        var out = "";
        for (var i = 0; i < count; i++) {
            // tslint:disable-next-line:no-bitwise
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    };
    Guid.prototype.equals = function (other) {
        // Comparing string `value` against provided `guid` will auto-call
        // toString on `guid` for comparison
        return Guid.isGuid(other) && this.value === other.toString();
    };
    Guid.prototype.isEmpty = function () {
        return this.value === Guid.EMPTY;
    };
    Guid.prototype.toString = function () {
        return this.value;
    };
    Guid.prototype.toJSON = function () {
        return {
            value: this.value
        };
    };
    Guid.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
    Guid.EMPTY = "00000000-0000-0000-0000-000000000000";
    return Guid;
}());
exports.Guid = Guid;


/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ ((module) => {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/onnx-proto/dist/onnx.js":
/*!**********************************************!*\
  !*** ./node_modules/onnx-proto/dist/onnx.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.onnx = (function() {

    /**
     * Namespace onnx.
     * @exports onnx
     * @namespace
     */
    var onnx = {};

    /**
     * Version enum.
     * @name onnx.Version
     * @enum {string}
     * @property {number} _START_VERSION=0 _START_VERSION value
     * @property {number} IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_10 value
     * @property {number} IR_VERSION_2017_10_30=2 IR_VERSION_2017_10_30 value
     * @property {number} IR_VERSION_2017_11_3=3 IR_VERSION_2017_11_3 value
     * @property {number} IR_VERSION_2019_1_22=4 IR_VERSION_2019_1_22 value
     * @property {number} IR_VERSION=5 IR_VERSION value
     */
    onnx.Version = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "_START_VERSION"] = 0;
        values[valuesById[1] = "IR_VERSION_2017_10_10"] = 1;
        values[valuesById[2] = "IR_VERSION_2017_10_30"] = 2;
        values[valuesById[3] = "IR_VERSION_2017_11_3"] = 3;
        values[valuesById[4] = "IR_VERSION_2019_1_22"] = 4;
        values[valuesById[5] = "IR_VERSION"] = 5;
        return values;
    })();

    onnx.AttributeProto = (function() {

        /**
         * Properties of an AttributeProto.
         * @memberof onnx
         * @interface IAttributeProto
         * @property {string|null} [name] AttributeProto name
         * @property {string|null} [refAttrName] AttributeProto refAttrName
         * @property {string|null} [docString] AttributeProto docString
         * @property {onnx.AttributeProto.AttributeType|null} [type] AttributeProto type
         * @property {number|null} [f] AttributeProto f
         * @property {number|Long|null} [i] AttributeProto i
         * @property {Uint8Array|null} [s] AttributeProto s
         * @property {onnx.ITensorProto|null} [t] AttributeProto t
         * @property {onnx.IGraphProto|null} [g] AttributeProto g
         * @property {Array.<number>|null} [floats] AttributeProto floats
         * @property {Array.<number|Long>|null} [ints] AttributeProto ints
         * @property {Array.<Uint8Array>|null} [strings] AttributeProto strings
         * @property {Array.<onnx.ITensorProto>|null} [tensors] AttributeProto tensors
         * @property {Array.<onnx.IGraphProto>|null} [graphs] AttributeProto graphs
         */

        /**
         * Constructs a new AttributeProto.
         * @memberof onnx
         * @classdesc Represents an AttributeProto.
         * @implements IAttributeProto
         * @constructor
         * @param {onnx.IAttributeProto=} [properties] Properties to set
         */
        function AttributeProto(properties) {
            this.floats = [];
            this.ints = [];
            this.strings = [];
            this.tensors = [];
            this.graphs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttributeProto name.
         * @member {string} name
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.name = "";

        /**
         * AttributeProto refAttrName.
         * @member {string} refAttrName
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.refAttrName = "";

        /**
         * AttributeProto docString.
         * @member {string} docString
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.docString = "";

        /**
         * AttributeProto type.
         * @member {onnx.AttributeProto.AttributeType} type
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.type = 0;

        /**
         * AttributeProto f.
         * @member {number} f
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.f = 0;

        /**
         * AttributeProto i.
         * @member {number|Long} i
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AttributeProto s.
         * @member {Uint8Array} s
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.s = $util.newBuffer([]);

        /**
         * AttributeProto t.
         * @member {onnx.ITensorProto|null|undefined} t
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.t = null;

        /**
         * AttributeProto g.
         * @member {onnx.IGraphProto|null|undefined} g
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.g = null;

        /**
         * AttributeProto floats.
         * @member {Array.<number>} floats
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.floats = $util.emptyArray;

        /**
         * AttributeProto ints.
         * @member {Array.<number|Long>} ints
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.ints = $util.emptyArray;

        /**
         * AttributeProto strings.
         * @member {Array.<Uint8Array>} strings
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.strings = $util.emptyArray;

        /**
         * AttributeProto tensors.
         * @member {Array.<onnx.ITensorProto>} tensors
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.tensors = $util.emptyArray;

        /**
         * AttributeProto graphs.
         * @member {Array.<onnx.IGraphProto>} graphs
         * @memberof onnx.AttributeProto
         * @instance
         */
        AttributeProto.prototype.graphs = $util.emptyArray;

        /**
         * Creates a new AttributeProto instance using the specified properties.
         * @function create
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.IAttributeProto=} [properties] Properties to set
         * @returns {onnx.AttributeProto} AttributeProto instance
         */
        AttributeProto.create = function create(properties) {
            return new AttributeProto(properties);
        };

        /**
         * Encodes the specified AttributeProto message. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttributeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.f != null && message.hasOwnProperty("f"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.f);
            if (message.i != null && message.hasOwnProperty("i"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.i);
            if (message.s != null && message.hasOwnProperty("s"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.s);
            if (message.t != null && message.hasOwnProperty("t"))
                $root.onnx.TensorProto.encode(message.t, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.g != null && message.hasOwnProperty("g"))
                $root.onnx.GraphProto.encode(message.g, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.floats != null && message.floats.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.floats.length; ++i)
                    writer.float(message.floats[i]);
                writer.ldelim();
            }
            if (message.ints != null && message.ints.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (var i = 0; i < message.ints.length; ++i)
                    writer.int64(message.ints[i]);
                writer.ldelim();
            }
            if (message.strings != null && message.strings.length)
                for (var i = 0; i < message.strings.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.strings[i]);
            if (message.tensors != null && message.tensors.length)
                for (var i = 0; i < message.tensors.length; ++i)
                    $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.graphs != null && message.graphs.length)
                for (var i = 0; i < message.graphs.length; ++i)
                    $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.docString);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.type);
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.refAttrName);
            return writer;
        };

        /**
         * Encodes the specified AttributeProto message, length delimited. Does not implicitly {@link onnx.AttributeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.IAttributeProto} message AttributeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttributeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.AttributeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.AttributeProto} AttributeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttributeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 21:
                    message.refAttrName = reader.string();
                    break;
                case 13:
                    message.docString = reader.string();
                    break;
                case 20:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.f = reader.float();
                    break;
                case 3:
                    message.i = reader.int64();
                    break;
                case 4:
                    message.s = reader.bytes();
                    break;
                case 5:
                    message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.floats && message.floats.length))
                        message.floats = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.floats.push(reader.float());
                    } else
                        message.floats.push(reader.float());
                    break;
                case 8:
                    if (!(message.ints && message.ints.length))
                        message.ints = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ints.push(reader.int64());
                    } else
                        message.ints.push(reader.int64());
                    break;
                case 9:
                    if (!(message.strings && message.strings.length))
                        message.strings = [];
                    message.strings.push(reader.bytes());
                    break;
                case 10:
                    if (!(message.tensors && message.tensors.length))
                        message.tensors = [];
                    message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.graphs && message.graphs.length))
                        message.graphs = [];
                    message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttributeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.AttributeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.AttributeProto} AttributeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttributeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AttributeProto message.
         * @function verify
         * @memberof onnx.AttributeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AttributeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
                if (!$util.isString(message.refAttrName))
                    return "refAttrName: string expected";
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.f != null && message.hasOwnProperty("f"))
                if (typeof message.f !== "number")
                    return "f: number expected";
            if (message.i != null && message.hasOwnProperty("i"))
                if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
                    return "i: integer|Long expected";
            if (message.s != null && message.hasOwnProperty("s"))
                if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
                    return "s: buffer expected";
            if (message.t != null && message.hasOwnProperty("t")) {
                var error = $root.onnx.TensorProto.verify(message.t);
                if (error)
                    return "t." + error;
            }
            if (message.g != null && message.hasOwnProperty("g")) {
                var error = $root.onnx.GraphProto.verify(message.g);
                if (error)
                    return "g." + error;
            }
            if (message.floats != null && message.hasOwnProperty("floats")) {
                if (!Array.isArray(message.floats))
                    return "floats: array expected";
                for (var i = 0; i < message.floats.length; ++i)
                    if (typeof message.floats[i] !== "number")
                        return "floats: number[] expected";
            }
            if (message.ints != null && message.hasOwnProperty("ints")) {
                if (!Array.isArray(message.ints))
                    return "ints: array expected";
                for (var i = 0; i < message.ints.length; ++i)
                    if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))
                        return "ints: integer|Long[] expected";
            }
            if (message.strings != null && message.hasOwnProperty("strings")) {
                if (!Array.isArray(message.strings))
                    return "strings: array expected";
                for (var i = 0; i < message.strings.length; ++i)
                    if (!(message.strings[i] && typeof message.strings[i].length === "number" || $util.isString(message.strings[i])))
                        return "strings: buffer[] expected";
            }
            if (message.tensors != null && message.hasOwnProperty("tensors")) {
                if (!Array.isArray(message.tensors))
                    return "tensors: array expected";
                for (var i = 0; i < message.tensors.length; ++i) {
                    var error = $root.onnx.TensorProto.verify(message.tensors[i]);
                    if (error)
                        return "tensors." + error;
                }
            }
            if (message.graphs != null && message.hasOwnProperty("graphs")) {
                if (!Array.isArray(message.graphs))
                    return "graphs: array expected";
                for (var i = 0; i < message.graphs.length; ++i) {
                    var error = $root.onnx.GraphProto.verify(message.graphs[i]);
                    if (error)
                        return "graphs." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AttributeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.AttributeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.AttributeProto} AttributeProto
         */
        AttributeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.AttributeProto)
                return object;
            var message = new $root.onnx.AttributeProto();
            if (object.name != null)
                message.name = String(object.name);
            if (object.refAttrName != null)
                message.refAttrName = String(object.refAttrName);
            if (object.docString != null)
                message.docString = String(object.docString);
            switch (object.type) {
            case "UNDEFINED":
            case 0:
                message.type = 0;
                break;
            case "FLOAT":
            case 1:
                message.type = 1;
                break;
            case "INT":
            case 2:
                message.type = 2;
                break;
            case "STRING":
            case 3:
                message.type = 3;
                break;
            case "TENSOR":
            case 4:
                message.type = 4;
                break;
            case "GRAPH":
            case 5:
                message.type = 5;
                break;
            case "FLOATS":
            case 6:
                message.type = 6;
                break;
            case "INTS":
            case 7:
                message.type = 7;
                break;
            case "STRINGS":
            case 8:
                message.type = 8;
                break;
            case "TENSORS":
            case 9:
                message.type = 9;
                break;
            case "GRAPHS":
            case 10:
                message.type = 10;
                break;
            }
            if (object.f != null)
                message.f = Number(object.f);
            if (object.i != null)
                if ($util.Long)
                    (message.i = $util.Long.fromValue(object.i)).unsigned = false;
                else if (typeof object.i === "string")
                    message.i = parseInt(object.i, 10);
                else if (typeof object.i === "number")
                    message.i = object.i;
                else if (typeof object.i === "object")
                    message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
            if (object.s != null)
                if (typeof object.s === "string")
                    $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
                else if (object.s.length)
                    message.s = object.s;
            if (object.t != null) {
                if (typeof object.t !== "object")
                    throw TypeError(".onnx.AttributeProto.t: object expected");
                message.t = $root.onnx.TensorProto.fromObject(object.t);
            }
            if (object.g != null) {
                if (typeof object.g !== "object")
                    throw TypeError(".onnx.AttributeProto.g: object expected");
                message.g = $root.onnx.GraphProto.fromObject(object.g);
            }
            if (object.floats) {
                if (!Array.isArray(object.floats))
                    throw TypeError(".onnx.AttributeProto.floats: array expected");
                message.floats = [];
                for (var i = 0; i < object.floats.length; ++i)
                    message.floats[i] = Number(object.floats[i]);
            }
            if (object.ints) {
                if (!Array.isArray(object.ints))
                    throw TypeError(".onnx.AttributeProto.ints: array expected");
                message.ints = [];
                for (var i = 0; i < object.ints.length; ++i)
                    if ($util.Long)
                        (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;
                    else if (typeof object.ints[i] === "string")
                        message.ints[i] = parseInt(object.ints[i], 10);
                    else if (typeof object.ints[i] === "number")
                        message.ints[i] = object.ints[i];
                    else if (typeof object.ints[i] === "object")
                        message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();
            }
            if (object.strings) {
                if (!Array.isArray(object.strings))
                    throw TypeError(".onnx.AttributeProto.strings: array expected");
                message.strings = [];
                for (var i = 0; i < object.strings.length; ++i)
                    if (typeof object.strings[i] === "string")
                        $util.base64.decode(object.strings[i], message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])), 0);
                    else if (object.strings[i].length)
                        message.strings[i] = object.strings[i];
            }
            if (object.tensors) {
                if (!Array.isArray(object.tensors))
                    throw TypeError(".onnx.AttributeProto.tensors: array expected");
                message.tensors = [];
                for (var i = 0; i < object.tensors.length; ++i) {
                    if (typeof object.tensors[i] !== "object")
                        throw TypeError(".onnx.AttributeProto.tensors: object expected");
                    message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);
                }
            }
            if (object.graphs) {
                if (!Array.isArray(object.graphs))
                    throw TypeError(".onnx.AttributeProto.graphs: array expected");
                message.graphs = [];
                for (var i = 0; i < object.graphs.length; ++i) {
                    if (typeof object.graphs[i] !== "object")
                        throw TypeError(".onnx.AttributeProto.graphs: object expected");
                    message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AttributeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.AttributeProto
         * @static
         * @param {onnx.AttributeProto} message AttributeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AttributeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.floats = [];
                object.ints = [];
                object.strings = [];
                object.tensors = [];
                object.graphs = [];
            }
            if (options.defaults) {
                object.name = "";
                object.f = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.i = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.s = "";
                else {
                    object.s = [];
                    if (options.bytes !== Array)
                        object.s = $util.newBuffer(object.s);
                }
                object.t = null;
                object.g = null;
                object.docString = "";
                object.type = options.enums === String ? "UNDEFINED" : 0;
                object.refAttrName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.f != null && message.hasOwnProperty("f"))
                object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
            if (message.i != null && message.hasOwnProperty("i"))
                if (typeof message.i === "number")
                    object.i = options.longs === String ? String(message.i) : message.i;
                else
                    object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
            if (message.s != null && message.hasOwnProperty("s"))
                object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
            if (message.t != null && message.hasOwnProperty("t"))
                object.t = $root.onnx.TensorProto.toObject(message.t, options);
            if (message.g != null && message.hasOwnProperty("g"))
                object.g = $root.onnx.GraphProto.toObject(message.g, options);
            if (message.floats && message.floats.length) {
                object.floats = [];
                for (var j = 0; j < message.floats.length; ++j)
                    object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];
            }
            if (message.ints && message.ints.length) {
                object.ints = [];
                for (var j = 0; j < message.ints.length; ++j)
                    if (typeof message.ints[j] === "number")
                        object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];
                    else
                        object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];
            }
            if (message.strings && message.strings.length) {
                object.strings = [];
                for (var j = 0; j < message.strings.length; ++j)
                    object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];
            }
            if (message.tensors && message.tensors.length) {
                object.tensors = [];
                for (var j = 0; j < message.tensors.length; ++j)
                    object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);
            }
            if (message.graphs && message.graphs.length) {
                object.graphs = [];
                for (var j = 0; j < message.graphs.length; ++j)
                    object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] : message.type;
            if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
                object.refAttrName = message.refAttrName;
            return object;
        };

        /**
         * Converts this AttributeProto to JSON.
         * @function toJSON
         * @memberof onnx.AttributeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AttributeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * AttributeType enum.
         * @name onnx.AttributeProto.AttributeType
         * @enum {string}
         * @property {number} UNDEFINED=0 UNDEFINED value
         * @property {number} FLOAT=1 FLOAT value
         * @property {number} INT=2 INT value
         * @property {number} STRING=3 STRING value
         * @property {number} TENSOR=4 TENSOR value
         * @property {number} GRAPH=5 GRAPH value
         * @property {number} FLOATS=6 FLOATS value
         * @property {number} INTS=7 INTS value
         * @property {number} STRINGS=8 STRINGS value
         * @property {number} TENSORS=9 TENSORS value
         * @property {number} GRAPHS=10 GRAPHS value
         */
        AttributeProto.AttributeType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "INT"] = 2;
            values[valuesById[3] = "STRING"] = 3;
            values[valuesById[4] = "TENSOR"] = 4;
            values[valuesById[5] = "GRAPH"] = 5;
            values[valuesById[6] = "FLOATS"] = 6;
            values[valuesById[7] = "INTS"] = 7;
            values[valuesById[8] = "STRINGS"] = 8;
            values[valuesById[9] = "TENSORS"] = 9;
            values[valuesById[10] = "GRAPHS"] = 10;
            return values;
        })();

        return AttributeProto;
    })();

    onnx.ValueInfoProto = (function() {

        /**
         * Properties of a ValueInfoProto.
         * @memberof onnx
         * @interface IValueInfoProto
         * @property {string|null} [name] ValueInfoProto name
         * @property {onnx.ITypeProto|null} [type] ValueInfoProto type
         * @property {string|null} [docString] ValueInfoProto docString
         */

        /**
         * Constructs a new ValueInfoProto.
         * @memberof onnx
         * @classdesc Represents a ValueInfoProto.
         * @implements IValueInfoProto
         * @constructor
         * @param {onnx.IValueInfoProto=} [properties] Properties to set
         */
        function ValueInfoProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValueInfoProto name.
         * @member {string} name
         * @memberof onnx.ValueInfoProto
         * @instance
         */
        ValueInfoProto.prototype.name = "";

        /**
         * ValueInfoProto type.
         * @member {onnx.ITypeProto|null|undefined} type
         * @memberof onnx.ValueInfoProto
         * @instance
         */
        ValueInfoProto.prototype.type = null;

        /**
         * ValueInfoProto docString.
         * @member {string} docString
         * @memberof onnx.ValueInfoProto
         * @instance
         */
        ValueInfoProto.prototype.docString = "";

        /**
         * Creates a new ValueInfoProto instance using the specified properties.
         * @function create
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.IValueInfoProto=} [properties] Properties to set
         * @returns {onnx.ValueInfoProto} ValueInfoProto instance
         */
        ValueInfoProto.create = function create(properties) {
            return new ValueInfoProto(properties);
        };

        /**
         * Encodes the specified ValueInfoProto message. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValueInfoProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && message.hasOwnProperty("type"))
                $root.onnx.TypeProto.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.docString);
            return writer;
        };

        /**
         * Encodes the specified ValueInfoProto message, length delimited. Does not implicitly {@link onnx.ValueInfoProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.IValueInfoProto} message ValueInfoProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValueInfoProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.ValueInfoProto} ValueInfoProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueInfoProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.docString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValueInfoProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.ValueInfoProto} ValueInfoProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValueInfoProto message.
         * @function verify
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValueInfoProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.onnx.TypeProto.verify(message.type);
                if (error)
                    return "type." + error;
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            return null;
        };

        /**
         * Creates a ValueInfoProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.ValueInfoProto} ValueInfoProto
         */
        ValueInfoProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ValueInfoProto)
                return object;
            var message = new $root.onnx.ValueInfoProto();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".onnx.ValueInfoProto.type: object expected");
                message.type = $root.onnx.TypeProto.fromObject(object.type);
            }
            if (object.docString != null)
                message.docString = String(object.docString);
            return message;
        };

        /**
         * Creates a plain object from a ValueInfoProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.ValueInfoProto
         * @static
         * @param {onnx.ValueInfoProto} message ValueInfoProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValueInfoProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = null;
                object.docString = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.onnx.TypeProto.toObject(message.type, options);
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            return object;
        };

        /**
         * Converts this ValueInfoProto to JSON.
         * @function toJSON
         * @memberof onnx.ValueInfoProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValueInfoProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValueInfoProto;
    })();

    onnx.NodeProto = (function() {

        /**
         * Properties of a NodeProto.
         * @memberof onnx
         * @interface INodeProto
         * @property {Array.<string>|null} [input] NodeProto input
         * @property {Array.<string>|null} [output] NodeProto output
         * @property {string|null} [name] NodeProto name
         * @property {string|null} [opType] NodeProto opType
         * @property {string|null} [domain] NodeProto domain
         * @property {Array.<onnx.IAttributeProto>|null} [attribute] NodeProto attribute
         * @property {string|null} [docString] NodeProto docString
         */

        /**
         * Constructs a new NodeProto.
         * @memberof onnx
         * @classdesc Represents a NodeProto.
         * @implements INodeProto
         * @constructor
         * @param {onnx.INodeProto=} [properties] Properties to set
         */
        function NodeProto(properties) {
            this.input = [];
            this.output = [];
            this.attribute = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeProto input.
         * @member {Array.<string>} input
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.input = $util.emptyArray;

        /**
         * NodeProto output.
         * @member {Array.<string>} output
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.output = $util.emptyArray;

        /**
         * NodeProto name.
         * @member {string} name
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.name = "";

        /**
         * NodeProto opType.
         * @member {string} opType
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.opType = "";

        /**
         * NodeProto domain.
         * @member {string} domain
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.domain = "";

        /**
         * NodeProto attribute.
         * @member {Array.<onnx.IAttributeProto>} attribute
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.attribute = $util.emptyArray;

        /**
         * NodeProto docString.
         * @member {string} docString
         * @memberof onnx.NodeProto
         * @instance
         */
        NodeProto.prototype.docString = "";

        /**
         * Creates a new NodeProto instance using the specified properties.
         * @function create
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.INodeProto=} [properties] Properties to set
         * @returns {onnx.NodeProto} NodeProto instance
         */
        NodeProto.create = function create(properties) {
            return new NodeProto(properties);
        };

        /**
         * Encodes the specified NodeProto message. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.INodeProto} message NodeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.input != null && message.input.length)
                for (var i = 0; i < message.input.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.input[i]);
            if (message.output != null && message.output.length)
                for (var i = 0; i < message.output.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.output[i]);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.opType != null && message.hasOwnProperty("opType"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.opType);
            if (message.attribute != null && message.attribute.length)
                for (var i = 0; i < message.attribute.length; ++i)
                    $root.onnx.AttributeProto.encode(message.attribute[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.domain);
            return writer;
        };

        /**
         * Encodes the specified NodeProto message, length delimited. Does not implicitly {@link onnx.NodeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.INodeProto} message NodeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.NodeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.NodeProto} NodeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.input && message.input.length))
                        message.input = [];
                    message.input.push(reader.string());
                    break;
                case 2:
                    if (!(message.output && message.output.length))
                        message.output = [];
                    message.output.push(reader.string());
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.opType = reader.string();
                    break;
                case 7:
                    message.domain = reader.string();
                    break;
                case 5:
                    if (!(message.attribute && message.attribute.length))
                        message.attribute = [];
                    message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.docString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.NodeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.NodeProto} NodeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeProto message.
         * @function verify
         * @memberof onnx.NodeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.input != null && message.hasOwnProperty("input")) {
                if (!Array.isArray(message.input))
                    return "input: array expected";
                for (var i = 0; i < message.input.length; ++i)
                    if (!$util.isString(message.input[i]))
                        return "input: string[] expected";
            }
            if (message.output != null && message.hasOwnProperty("output")) {
                if (!Array.isArray(message.output))
                    return "output: array expected";
                for (var i = 0; i < message.output.length; ++i)
                    if (!$util.isString(message.output[i]))
                        return "output: string[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.opType != null && message.hasOwnProperty("opType"))
                if (!$util.isString(message.opType))
                    return "opType: string expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.attribute != null && message.hasOwnProperty("attribute")) {
                if (!Array.isArray(message.attribute))
                    return "attribute: array expected";
                for (var i = 0; i < message.attribute.length; ++i) {
                    var error = $root.onnx.AttributeProto.verify(message.attribute[i]);
                    if (error)
                        return "attribute." + error;
                }
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            return null;
        };

        /**
         * Creates a NodeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.NodeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.NodeProto} NodeProto
         */
        NodeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.NodeProto)
                return object;
            var message = new $root.onnx.NodeProto();
            if (object.input) {
                if (!Array.isArray(object.input))
                    throw TypeError(".onnx.NodeProto.input: array expected");
                message.input = [];
                for (var i = 0; i < object.input.length; ++i)
                    message.input[i] = String(object.input[i]);
            }
            if (object.output) {
                if (!Array.isArray(object.output))
                    throw TypeError(".onnx.NodeProto.output: array expected");
                message.output = [];
                for (var i = 0; i < object.output.length; ++i)
                    message.output[i] = String(object.output[i]);
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.opType != null)
                message.opType = String(object.opType);
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.attribute) {
                if (!Array.isArray(object.attribute))
                    throw TypeError(".onnx.NodeProto.attribute: array expected");
                message.attribute = [];
                for (var i = 0; i < object.attribute.length; ++i) {
                    if (typeof object.attribute[i] !== "object")
                        throw TypeError(".onnx.NodeProto.attribute: object expected");
                    message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);
                }
            }
            if (object.docString != null)
                message.docString = String(object.docString);
            return message;
        };

        /**
         * Creates a plain object from a NodeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.NodeProto
         * @static
         * @param {onnx.NodeProto} message NodeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.input = [];
                object.output = [];
                object.attribute = [];
            }
            if (options.defaults) {
                object.name = "";
                object.opType = "";
                object.docString = "";
                object.domain = "";
            }
            if (message.input && message.input.length) {
                object.input = [];
                for (var j = 0; j < message.input.length; ++j)
                    object.input[j] = message.input[j];
            }
            if (message.output && message.output.length) {
                object.output = [];
                for (var j = 0; j < message.output.length; ++j)
                    object.output[j] = message.output[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.opType != null && message.hasOwnProperty("opType"))
                object.opType = message.opType;
            if (message.attribute && message.attribute.length) {
                object.attribute = [];
                for (var j = 0; j < message.attribute.length; ++j)
                    object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            return object;
        };

        /**
         * Converts this NodeProto to JSON.
         * @function toJSON
         * @memberof onnx.NodeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeProto;
    })();

    onnx.ModelProto = (function() {

        /**
         * Properties of a ModelProto.
         * @memberof onnx
         * @interface IModelProto
         * @property {number|Long|null} [irVersion] ModelProto irVersion
         * @property {Array.<onnx.IOperatorSetIdProto>|null} [opsetImport] ModelProto opsetImport
         * @property {string|null} [producerName] ModelProto producerName
         * @property {string|null} [producerVersion] ModelProto producerVersion
         * @property {string|null} [domain] ModelProto domain
         * @property {number|Long|null} [modelVersion] ModelProto modelVersion
         * @property {string|null} [docString] ModelProto docString
         * @property {onnx.IGraphProto|null} [graph] ModelProto graph
         * @property {Array.<onnx.IStringStringEntryProto>|null} [metadataProps] ModelProto metadataProps
         */

        /**
         * Constructs a new ModelProto.
         * @memberof onnx
         * @classdesc Represents a ModelProto.
         * @implements IModelProto
         * @constructor
         * @param {onnx.IModelProto=} [properties] Properties to set
         */
        function ModelProto(properties) {
            this.opsetImport = [];
            this.metadataProps = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModelProto irVersion.
         * @member {number|Long} irVersion
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ModelProto opsetImport.
         * @member {Array.<onnx.IOperatorSetIdProto>} opsetImport
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.opsetImport = $util.emptyArray;

        /**
         * ModelProto producerName.
         * @member {string} producerName
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.producerName = "";

        /**
         * ModelProto producerVersion.
         * @member {string} producerVersion
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.producerVersion = "";

        /**
         * ModelProto domain.
         * @member {string} domain
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.domain = "";

        /**
         * ModelProto modelVersion.
         * @member {number|Long} modelVersion
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ModelProto docString.
         * @member {string} docString
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.docString = "";

        /**
         * ModelProto graph.
         * @member {onnx.IGraphProto|null|undefined} graph
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.graph = null;

        /**
         * ModelProto metadataProps.
         * @member {Array.<onnx.IStringStringEntryProto>} metadataProps
         * @memberof onnx.ModelProto
         * @instance
         */
        ModelProto.prototype.metadataProps = $util.emptyArray;

        /**
         * Creates a new ModelProto instance using the specified properties.
         * @function create
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.IModelProto=} [properties] Properties to set
         * @returns {onnx.ModelProto} ModelProto instance
         */
        ModelProto.create = function create(properties) {
            return new ModelProto(properties);
        };

        /**
         * Encodes the specified ModelProto message. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.IModelProto} message ModelProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModelProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.irVersion);
            if (message.producerName != null && message.hasOwnProperty("producerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.producerName);
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.producerVersion);
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.domain);
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.modelVersion);
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.docString);
            if (message.graph != null && message.hasOwnProperty("graph"))
                $root.onnx.GraphProto.encode(message.graph, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.opsetImport != null && message.opsetImport.length)
                for (var i = 0; i < message.opsetImport.length; ++i)
                    $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.metadataProps != null && message.metadataProps.length)
                for (var i = 0; i < message.metadataProps.length; ++i)
                    $root.onnx.StringStringEntryProto.encode(message.metadataProps[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ModelProto message, length delimited. Does not implicitly {@link onnx.ModelProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.IModelProto} message ModelProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModelProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModelProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.ModelProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.ModelProto} ModelProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModelProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.irVersion = reader.int64();
                    break;
                case 8:
                    if (!(message.opsetImport && message.opsetImport.length))
                        message.opsetImport = [];
                    message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.producerName = reader.string();
                    break;
                case 3:
                    message.producerVersion = reader.string();
                    break;
                case 4:
                    message.domain = reader.string();
                    break;
                case 5:
                    message.modelVersion = reader.int64();
                    break;
                case 6:
                    message.docString = reader.string();
                    break;
                case 7:
                    message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());
                    break;
                case 14:
                    if (!(message.metadataProps && message.metadataProps.length))
                        message.metadataProps = [];
                    message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModelProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.ModelProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.ModelProto} ModelProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModelProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModelProto message.
         * @function verify
         * @memberof onnx.ModelProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModelProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
                if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))
                    return "irVersion: integer|Long expected";
            if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(message.opsetImport))
                    return "opsetImport: array expected";
                for (var i = 0; i < message.opsetImport.length; ++i) {
                    var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
                    if (error)
                        return "opsetImport." + error;
                }
            }
            if (message.producerName != null && message.hasOwnProperty("producerName"))
                if (!$util.isString(message.producerName))
                    return "producerName: string expected";
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
                if (!$util.isString(message.producerVersion))
                    return "producerVersion: string expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
                if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))
                    return "modelVersion: integer|Long expected";
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.graph != null && message.hasOwnProperty("graph")) {
                var error = $root.onnx.GraphProto.verify(message.graph);
                if (error)
                    return "graph." + error;
            }
            if (message.metadataProps != null && message.hasOwnProperty("metadataProps")) {
                if (!Array.isArray(message.metadataProps))
                    return "metadataProps: array expected";
                for (var i = 0; i < message.metadataProps.length; ++i) {
                    var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);
                    if (error)
                        return "metadataProps." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ModelProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.ModelProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.ModelProto} ModelProto
         */
        ModelProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.ModelProto)
                return object;
            var message = new $root.onnx.ModelProto();
            if (object.irVersion != null)
                if ($util.Long)
                    (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;
                else if (typeof object.irVersion === "string")
                    message.irVersion = parseInt(object.irVersion, 10);
                else if (typeof object.irVersion === "number")
                    message.irVersion = object.irVersion;
                else if (typeof object.irVersion === "object")
                    message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();
            if (object.opsetImport) {
                if (!Array.isArray(object.opsetImport))
                    throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                message.opsetImport = [];
                for (var i = 0; i < object.opsetImport.length; ++i) {
                    if (typeof object.opsetImport[i] !== "object")
                        throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                    message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
                }
            }
            if (object.producerName != null)
                message.producerName = String(object.producerName);
            if (object.producerVersion != null)
                message.producerVersion = String(object.producerVersion);
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.modelVersion != null)
                if ($util.Long)
                    (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;
                else if (typeof object.modelVersion === "string")
                    message.modelVersion = parseInt(object.modelVersion, 10);
                else if (typeof object.modelVersion === "number")
                    message.modelVersion = object.modelVersion;
                else if (typeof object.modelVersion === "object")
                    message.modelVersion = new $util.LongBits(object.modelVersion.low >>> 0, object.modelVersion.high >>> 0).toNumber();
            if (object.docString != null)
                message.docString = String(object.docString);
            if (object.graph != null) {
                if (typeof object.graph !== "object")
                    throw TypeError(".onnx.ModelProto.graph: object expected");
                message.graph = $root.onnx.GraphProto.fromObject(object.graph);
            }
            if (object.metadataProps) {
                if (!Array.isArray(object.metadataProps))
                    throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                message.metadataProps = [];
                for (var i = 0; i < object.metadataProps.length; ++i) {
                    if (typeof object.metadataProps[i] !== "object")
                        throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                    message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ModelProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.ModelProto
         * @static
         * @param {onnx.ModelProto} message ModelProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModelProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.opsetImport = [];
                object.metadataProps = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.irVersion = options.longs === String ? "0" : 0;
                object.producerName = "";
                object.producerVersion = "";
                object.domain = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.modelVersion = options.longs === String ? "0" : 0;
                object.docString = "";
                object.graph = null;
            }
            if (message.irVersion != null && message.hasOwnProperty("irVersion"))
                if (typeof message.irVersion === "number")
                    object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;
                else
                    object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;
            if (message.producerName != null && message.hasOwnProperty("producerName"))
                object.producerName = message.producerName;
            if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
                object.producerVersion = message.producerVersion;
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
                if (typeof message.modelVersion === "number")
                    object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;
                else
                    object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.graph != null && message.hasOwnProperty("graph"))
                object.graph = $root.onnx.GraphProto.toObject(message.graph, options);
            if (message.opsetImport && message.opsetImport.length) {
                object.opsetImport = [];
                for (var j = 0; j < message.opsetImport.length; ++j)
                    object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
            }
            if (message.metadataProps && message.metadataProps.length) {
                object.metadataProps = [];
                for (var j = 0; j < message.metadataProps.length; ++j)
                    object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);
            }
            return object;
        };

        /**
         * Converts this ModelProto to JSON.
         * @function toJSON
         * @memberof onnx.ModelProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModelProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModelProto;
    })();

    onnx.StringStringEntryProto = (function() {

        /**
         * Properties of a StringStringEntryProto.
         * @memberof onnx
         * @interface IStringStringEntryProto
         * @property {string|null} [key] StringStringEntryProto key
         * @property {string|null} [value] StringStringEntryProto value
         */

        /**
         * Constructs a new StringStringEntryProto.
         * @memberof onnx
         * @classdesc Represents a StringStringEntryProto.
         * @implements IStringStringEntryProto
         * @constructor
         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set
         */
        function StringStringEntryProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringStringEntryProto key.
         * @member {string} key
         * @memberof onnx.StringStringEntryProto
         * @instance
         */
        StringStringEntryProto.prototype.key = "";

        /**
         * StringStringEntryProto value.
         * @member {string} value
         * @memberof onnx.StringStringEntryProto
         * @instance
         */
        StringStringEntryProto.prototype.value = "";

        /**
         * Creates a new StringStringEntryProto instance using the specified properties.
         * @function create
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.IStringStringEntryProto=} [properties] Properties to set
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto instance
         */
        StringStringEntryProto.create = function create(properties) {
            return new StringStringEntryProto(properties);
        };

        /**
         * Encodes the specified StringStringEntryProto message. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringStringEntryProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified StringStringEntryProto message, length delimited. Does not implicitly {@link onnx.StringStringEntryProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.IStringStringEntryProto} message StringStringEntryProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StringStringEntryProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringStringEntryProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StringStringEntryProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StringStringEntryProto message.
         * @function verify
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StringStringEntryProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a StringStringEntryProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.StringStringEntryProto} StringStringEntryProto
         */
        StringStringEntryProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.StringStringEntryProto)
                return object;
            var message = new $root.onnx.StringStringEntryProto();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a StringStringEntryProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.StringStringEntryProto
         * @static
         * @param {onnx.StringStringEntryProto} message StringStringEntryProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StringStringEntryProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this StringStringEntryProto to JSON.
         * @function toJSON
         * @memberof onnx.StringStringEntryProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StringStringEntryProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StringStringEntryProto;
    })();

    onnx.TensorAnnotation = (function() {

        /**
         * Properties of a TensorAnnotation.
         * @memberof onnx
         * @interface ITensorAnnotation
         * @property {string|null} [tensorName] TensorAnnotation tensorName
         * @property {Array.<onnx.IStringStringEntryProto>|null} [quantParameterTensorNames] TensorAnnotation quantParameterTensorNames
         */

        /**
         * Constructs a new TensorAnnotation.
         * @memberof onnx
         * @classdesc Represents a TensorAnnotation.
         * @implements ITensorAnnotation
         * @constructor
         * @param {onnx.ITensorAnnotation=} [properties] Properties to set
         */
        function TensorAnnotation(properties) {
            this.quantParameterTensorNames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorAnnotation tensorName.
         * @member {string} tensorName
         * @memberof onnx.TensorAnnotation
         * @instance
         */
        TensorAnnotation.prototype.tensorName = "";

        /**
         * TensorAnnotation quantParameterTensorNames.
         * @member {Array.<onnx.IStringStringEntryProto>} quantParameterTensorNames
         * @memberof onnx.TensorAnnotation
         * @instance
         */
        TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;

        /**
         * Creates a new TensorAnnotation instance using the specified properties.
         * @function create
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.ITensorAnnotation=} [properties] Properties to set
         * @returns {onnx.TensorAnnotation} TensorAnnotation instance
         */
        TensorAnnotation.create = function create(properties) {
            return new TensorAnnotation(properties);
        };

        /**
         * Encodes the specified TensorAnnotation message. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.
         * @function encode
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorAnnotation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.tensorName);
            if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)
                for (var i = 0; i < message.quantParameterTensorNames.length; ++i)
                    $root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TensorAnnotation message, length delimited. Does not implicitly {@link onnx.TensorAnnotation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.ITensorAnnotation} message TensorAnnotation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorAnnotation message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TensorAnnotation} TensorAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorAnnotation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tensorName = reader.string();
                    break;
                case 2:
                    if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))
                        message.quantParameterTensorNames = [];
                    message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorAnnotation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TensorAnnotation} TensorAnnotation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorAnnotation message.
         * @function verify
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorAnnotation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
                if (!$util.isString(message.tensorName))
                    return "tensorName: string expected";
            if (message.quantParameterTensorNames != null && message.hasOwnProperty("quantParameterTensorNames")) {
                if (!Array.isArray(message.quantParameterTensorNames))
                    return "quantParameterTensorNames: array expected";
                for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {
                    var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);
                    if (error)
                        return "quantParameterTensorNames." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TensorAnnotation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TensorAnnotation} TensorAnnotation
         */
        TensorAnnotation.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorAnnotation)
                return object;
            var message = new $root.onnx.TensorAnnotation();
            if (object.tensorName != null)
                message.tensorName = String(object.tensorName);
            if (object.quantParameterTensorNames) {
                if (!Array.isArray(object.quantParameterTensorNames))
                    throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                message.quantParameterTensorNames = [];
                for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {
                    if (typeof object.quantParameterTensorNames[i] !== "object")
                        throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                    message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorAnnotation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TensorAnnotation
         * @static
         * @param {onnx.TensorAnnotation} message TensorAnnotation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorAnnotation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.quantParameterTensorNames = [];
            if (options.defaults)
                object.tensorName = "";
            if (message.tensorName != null && message.hasOwnProperty("tensorName"))
                object.tensorName = message.tensorName;
            if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {
                object.quantParameterTensorNames = [];
                for (var j = 0; j < message.quantParameterTensorNames.length; ++j)
                    object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j], options);
            }
            return object;
        };

        /**
         * Converts this TensorAnnotation to JSON.
         * @function toJSON
         * @memberof onnx.TensorAnnotation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorAnnotation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TensorAnnotation;
    })();

    onnx.GraphProto = (function() {

        /**
         * Properties of a GraphProto.
         * @memberof onnx
         * @interface IGraphProto
         * @property {Array.<onnx.INodeProto>|null} [node] GraphProto node
         * @property {string|null} [name] GraphProto name
         * @property {Array.<onnx.ITensorProto>|null} [initializer] GraphProto initializer
         * @property {string|null} [docString] GraphProto docString
         * @property {Array.<onnx.IValueInfoProto>|null} [input] GraphProto input
         * @property {Array.<onnx.IValueInfoProto>|null} [output] GraphProto output
         * @property {Array.<onnx.IValueInfoProto>|null} [valueInfo] GraphProto valueInfo
         * @property {Array.<onnx.ITensorAnnotation>|null} [quantizationAnnotation] GraphProto quantizationAnnotation
         */

        /**
         * Constructs a new GraphProto.
         * @memberof onnx
         * @classdesc Represents a GraphProto.
         * @implements IGraphProto
         * @constructor
         * @param {onnx.IGraphProto=} [properties] Properties to set
         */
        function GraphProto(properties) {
            this.node = [];
            this.initializer = [];
            this.input = [];
            this.output = [];
            this.valueInfo = [];
            this.quantizationAnnotation = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphProto node.
         * @member {Array.<onnx.INodeProto>} node
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.node = $util.emptyArray;

        /**
         * GraphProto name.
         * @member {string} name
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.name = "";

        /**
         * GraphProto initializer.
         * @member {Array.<onnx.ITensorProto>} initializer
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.initializer = $util.emptyArray;

        /**
         * GraphProto docString.
         * @member {string} docString
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.docString = "";

        /**
         * GraphProto input.
         * @member {Array.<onnx.IValueInfoProto>} input
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.input = $util.emptyArray;

        /**
         * GraphProto output.
         * @member {Array.<onnx.IValueInfoProto>} output
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.output = $util.emptyArray;

        /**
         * GraphProto valueInfo.
         * @member {Array.<onnx.IValueInfoProto>} valueInfo
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.valueInfo = $util.emptyArray;

        /**
         * GraphProto quantizationAnnotation.
         * @member {Array.<onnx.ITensorAnnotation>} quantizationAnnotation
         * @memberof onnx.GraphProto
         * @instance
         */
        GraphProto.prototype.quantizationAnnotation = $util.emptyArray;

        /**
         * Creates a new GraphProto instance using the specified properties.
         * @function create
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.IGraphProto=} [properties] Properties to set
         * @returns {onnx.GraphProto} GraphProto instance
         */
        GraphProto.create = function create(properties) {
            return new GraphProto(properties);
        };

        /**
         * Encodes the specified GraphProto message. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.node != null && message.node.length)
                for (var i = 0; i < message.node.length; ++i)
                    $root.onnx.NodeProto.encode(message.node[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.initializer != null && message.initializer.length)
                for (var i = 0; i < message.initializer.length; ++i)
                    $root.onnx.TensorProto.encode(message.initializer[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.docString);
            if (message.input != null && message.input.length)
                for (var i = 0; i < message.input.length; ++i)
                    $root.onnx.ValueInfoProto.encode(message.input[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.output != null && message.output.length)
                for (var i = 0; i < message.output.length; ++i)
                    $root.onnx.ValueInfoProto.encode(message.output[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.valueInfo != null && message.valueInfo.length)
                for (var i = 0; i < message.valueInfo.length; ++i)
                    $root.onnx.ValueInfoProto.encode(message.valueInfo[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)
                for (var i = 0; i < message.quantizationAnnotation.length; ++i)
                    $root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphProto message, length delimited. Does not implicitly {@link onnx.GraphProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.IGraphProto} message GraphProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.GraphProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.GraphProto} GraphProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.node && message.node.length))
                        message.node = [];
                    message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 5:
                    if (!(message.initializer && message.initializer.length))
                        message.initializer = [];
                    message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.docString = reader.string();
                    break;
                case 11:
                    if (!(message.input && message.input.length))
                        message.input = [];
                    message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                    break;
                case 12:
                    if (!(message.output && message.output.length))
                        message.output = [];
                    message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.valueInfo && message.valueInfo.length))
                        message.valueInfo = [];
                    message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))
                        message.quantizationAnnotation = [];
                    message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.GraphProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.GraphProto} GraphProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphProto message.
         * @function verify
         * @memberof onnx.GraphProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
                if (!Array.isArray(message.node))
                    return "node: array expected";
                for (var i = 0; i < message.node.length; ++i) {
                    var error = $root.onnx.NodeProto.verify(message.node[i]);
                    if (error)
                        return "node." + error;
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.initializer != null && message.hasOwnProperty("initializer")) {
                if (!Array.isArray(message.initializer))
                    return "initializer: array expected";
                for (var i = 0; i < message.initializer.length; ++i) {
                    var error = $root.onnx.TensorProto.verify(message.initializer[i]);
                    if (error)
                        return "initializer." + error;
                }
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.input != null && message.hasOwnProperty("input")) {
                if (!Array.isArray(message.input))
                    return "input: array expected";
                for (var i = 0; i < message.input.length; ++i) {
                    var error = $root.onnx.ValueInfoProto.verify(message.input[i]);
                    if (error)
                        return "input." + error;
                }
            }
            if (message.output != null && message.hasOwnProperty("output")) {
                if (!Array.isArray(message.output))
                    return "output: array expected";
                for (var i = 0; i < message.output.length; ++i) {
                    var error = $root.onnx.ValueInfoProto.verify(message.output[i]);
                    if (error)
                        return "output." + error;
                }
            }
            if (message.valueInfo != null && message.hasOwnProperty("valueInfo")) {
                if (!Array.isArray(message.valueInfo))
                    return "valueInfo: array expected";
                for (var i = 0; i < message.valueInfo.length; ++i) {
                    var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);
                    if (error)
                        return "valueInfo." + error;
                }
            }
            if (message.quantizationAnnotation != null && message.hasOwnProperty("quantizationAnnotation")) {
                if (!Array.isArray(message.quantizationAnnotation))
                    return "quantizationAnnotation: array expected";
                for (var i = 0; i < message.quantizationAnnotation.length; ++i) {
                    var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);
                    if (error)
                        return "quantizationAnnotation." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.GraphProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.GraphProto} GraphProto
         */
        GraphProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.GraphProto)
                return object;
            var message = new $root.onnx.GraphProto();
            if (object.node) {
                if (!Array.isArray(object.node))
                    throw TypeError(".onnx.GraphProto.node: array expected");
                message.node = [];
                for (var i = 0; i < object.node.length; ++i) {
                    if (typeof object.node[i] !== "object")
                        throw TypeError(".onnx.GraphProto.node: object expected");
                    message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
                }
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.initializer) {
                if (!Array.isArray(object.initializer))
                    throw TypeError(".onnx.GraphProto.initializer: array expected");
                message.initializer = [];
                for (var i = 0; i < object.initializer.length; ++i) {
                    if (typeof object.initializer[i] !== "object")
                        throw TypeError(".onnx.GraphProto.initializer: object expected");
                    message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);
                }
            }
            if (object.docString != null)
                message.docString = String(object.docString);
            if (object.input) {
                if (!Array.isArray(object.input))
                    throw TypeError(".onnx.GraphProto.input: array expected");
                message.input = [];
                for (var i = 0; i < object.input.length; ++i) {
                    if (typeof object.input[i] !== "object")
                        throw TypeError(".onnx.GraphProto.input: object expected");
                    message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);
                }
            }
            if (object.output) {
                if (!Array.isArray(object.output))
                    throw TypeError(".onnx.GraphProto.output: array expected");
                message.output = [];
                for (var i = 0; i < object.output.length; ++i) {
                    if (typeof object.output[i] !== "object")
                        throw TypeError(".onnx.GraphProto.output: object expected");
                    message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);
                }
            }
            if (object.valueInfo) {
                if (!Array.isArray(object.valueInfo))
                    throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                message.valueInfo = [];
                for (var i = 0; i < object.valueInfo.length; ++i) {
                    if (typeof object.valueInfo[i] !== "object")
                        throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                    message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);
                }
            }
            if (object.quantizationAnnotation) {
                if (!Array.isArray(object.quantizationAnnotation))
                    throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                message.quantizationAnnotation = [];
                for (var i = 0; i < object.quantizationAnnotation.length; ++i) {
                    if (typeof object.quantizationAnnotation[i] !== "object")
                        throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                    message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.GraphProto
         * @static
         * @param {onnx.GraphProto} message GraphProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.node = [];
                object.initializer = [];
                object.input = [];
                object.output = [];
                object.valueInfo = [];
                object.quantizationAnnotation = [];
            }
            if (options.defaults) {
                object.name = "";
                object.docString = "";
            }
            if (message.node && message.node.length) {
                object.node = [];
                for (var j = 0; j < message.node.length; ++j)
                    object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.initializer && message.initializer.length) {
                object.initializer = [];
                for (var j = 0; j < message.initializer.length; ++j)
                    object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.input && message.input.length) {
                object.input = [];
                for (var j = 0; j < message.input.length; ++j)
                    object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);
            }
            if (message.output && message.output.length) {
                object.output = [];
                for (var j = 0; j < message.output.length; ++j)
                    object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);
            }
            if (message.valueInfo && message.valueInfo.length) {
                object.valueInfo = [];
                for (var j = 0; j < message.valueInfo.length; ++j)
                    object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);
            }
            if (message.quantizationAnnotation && message.quantizationAnnotation.length) {
                object.quantizationAnnotation = [];
                for (var j = 0; j < message.quantizationAnnotation.length; ++j)
                    object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphProto to JSON.
         * @function toJSON
         * @memberof onnx.GraphProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphProto;
    })();

    onnx.TensorProto = (function() {

        /**
         * Properties of a TensorProto.
         * @memberof onnx
         * @interface ITensorProto
         * @property {Array.<number|Long>|null} [dims] TensorProto dims
         * @property {number|null} [dataType] TensorProto dataType
         * @property {onnx.TensorProto.ISegment|null} [segment] TensorProto segment
         * @property {Array.<number>|null} [floatData] TensorProto floatData
         * @property {Array.<number>|null} [int32Data] TensorProto int32Data
         * @property {Array.<Uint8Array>|null} [stringData] TensorProto stringData
         * @property {Array.<number|Long>|null} [int64Data] TensorProto int64Data
         * @property {string|null} [name] TensorProto name
         * @property {string|null} [docString] TensorProto docString
         * @property {Uint8Array|null} [rawData] TensorProto rawData
         * @property {Array.<onnx.IStringStringEntryProto>|null} [externalData] TensorProto externalData
         * @property {onnx.TensorProto.DataLocation|null} [dataLocation] TensorProto dataLocation
         * @property {Array.<number>|null} [doubleData] TensorProto doubleData
         * @property {Array.<number|Long>|null} [uint64Data] TensorProto uint64Data
         */

        /**
         * Constructs a new TensorProto.
         * @memberof onnx
         * @classdesc Represents a TensorProto.
         * @implements ITensorProto
         * @constructor
         * @param {onnx.ITensorProto=} [properties] Properties to set
         */
        function TensorProto(properties) {
            this.dims = [];
            this.floatData = [];
            this.int32Data = [];
            this.stringData = [];
            this.int64Data = [];
            this.externalData = [];
            this.doubleData = [];
            this.uint64Data = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorProto dims.
         * @member {Array.<number|Long>} dims
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.dims = $util.emptyArray;

        /**
         * TensorProto dataType.
         * @member {number} dataType
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.dataType = 0;

        /**
         * TensorProto segment.
         * @member {onnx.TensorProto.ISegment|null|undefined} segment
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.segment = null;

        /**
         * TensorProto floatData.
         * @member {Array.<number>} floatData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.floatData = $util.emptyArray;

        /**
         * TensorProto int32Data.
         * @member {Array.<number>} int32Data
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.int32Data = $util.emptyArray;

        /**
         * TensorProto stringData.
         * @member {Array.<Uint8Array>} stringData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.stringData = $util.emptyArray;

        /**
         * TensorProto int64Data.
         * @member {Array.<number|Long>} int64Data
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.int64Data = $util.emptyArray;

        /**
         * TensorProto name.
         * @member {string} name
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.name = "";

        /**
         * TensorProto docString.
         * @member {string} docString
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.docString = "";

        /**
         * TensorProto rawData.
         * @member {Uint8Array} rawData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.rawData = $util.newBuffer([]);

        /**
         * TensorProto externalData.
         * @member {Array.<onnx.IStringStringEntryProto>} externalData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.externalData = $util.emptyArray;

        /**
         * TensorProto dataLocation.
         * @member {onnx.TensorProto.DataLocation} dataLocation
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.dataLocation = 0;

        /**
         * TensorProto doubleData.
         * @member {Array.<number>} doubleData
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.doubleData = $util.emptyArray;

        /**
         * TensorProto uint64Data.
         * @member {Array.<number|Long>} uint64Data
         * @memberof onnx.TensorProto
         * @instance
         */
        TensorProto.prototype.uint64Data = $util.emptyArray;

        /**
         * Creates a new TensorProto instance using the specified properties.
         * @function create
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.ITensorProto=} [properties] Properties to set
         * @returns {onnx.TensorProto} TensorProto instance
         */
        TensorProto.create = function create(properties) {
            return new TensorProto(properties);
        };

        /**
         * Encodes the specified TensorProto message. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dims != null && message.dims.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.dims.length; ++i)
                    writer.int64(message.dims[i]);
                writer.ldelim();
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dataType);
            if (message.segment != null && message.hasOwnProperty("segment"))
                $root.onnx.TensorProto.Segment.encode(message.segment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.floatData != null && message.floatData.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.floatData.length; ++i)
                    writer.float(message.floatData[i]);
                writer.ldelim();
            }
            if (message.int32Data != null && message.int32Data.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.int32Data.length; ++i)
                    writer.int32(message.int32Data[i]);
                writer.ldelim();
            }
            if (message.stringData != null && message.stringData.length)
                for (var i = 0; i < message.stringData.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.stringData[i]);
            if (message.int64Data != null && message.int64Data.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.int64Data.length; ++i)
                    writer.int64(message.int64Data[i]);
                writer.ldelim();
            }
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.rawData);
            if (message.doubleData != null && message.doubleData.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (var i = 0; i < message.doubleData.length; ++i)
                    writer.double(message.doubleData[i]);
                writer.ldelim();
            }
            if (message.uint64Data != null && message.uint64Data.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (var i = 0; i < message.uint64Data.length; ++i)
                    writer.uint64(message.uint64Data[i]);
                writer.ldelim();
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.docString);
            if (message.externalData != null && message.externalData.length)
                for (var i = 0; i < message.externalData.length; ++i)
                    $root.onnx.StringStringEntryProto.encode(message.externalData[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.dataLocation);
            return writer;
        };

        /**
         * Encodes the specified TensorProto message, length delimited. Does not implicitly {@link onnx.TensorProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.ITensorProto} message TensorProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TensorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TensorProto} TensorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dims && message.dims.length))
                        message.dims = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dims.push(reader.int64());
                    } else
                        message.dims.push(reader.int64());
                    break;
                case 2:
                    message.dataType = reader.int32();
                    break;
                case 3:
                    message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.floatData && message.floatData.length))
                        message.floatData = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.floatData.push(reader.float());
                    } else
                        message.floatData.push(reader.float());
                    break;
                case 5:
                    if (!(message.int32Data && message.int32Data.length))
                        message.int32Data = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.int32Data.push(reader.int32());
                    } else
                        message.int32Data.push(reader.int32());
                    break;
                case 6:
                    if (!(message.stringData && message.stringData.length))
                        message.stringData = [];
                    message.stringData.push(reader.bytes());
                    break;
                case 7:
                    if (!(message.int64Data && message.int64Data.length))
                        message.int64Data = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.int64Data.push(reader.int64());
                    } else
                        message.int64Data.push(reader.int64());
                    break;
                case 8:
                    message.name = reader.string();
                    break;
                case 12:
                    message.docString = reader.string();
                    break;
                case 9:
                    message.rawData = reader.bytes();
                    break;
                case 13:
                    if (!(message.externalData && message.externalData.length))
                        message.externalData = [];
                    message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.dataLocation = reader.int32();
                    break;
                case 10:
                    if (!(message.doubleData && message.doubleData.length))
                        message.doubleData = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.doubleData.push(reader.double());
                    } else
                        message.doubleData.push(reader.double());
                    break;
                case 11:
                    if (!(message.uint64Data && message.uint64Data.length))
                        message.uint64Data = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.uint64Data.push(reader.uint64());
                    } else
                        message.uint64Data.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TensorProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TensorProto} TensorProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorProto message.
         * @function verify
         * @memberof onnx.TensorProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dims != null && message.hasOwnProperty("dims")) {
                if (!Array.isArray(message.dims))
                    return "dims: array expected";
                for (var i = 0; i < message.dims.length; ++i)
                    if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                        return "dims: integer|Long[] expected";
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
                if (!$util.isInteger(message.dataType))
                    return "dataType: integer expected";
            if (message.segment != null && message.hasOwnProperty("segment")) {
                var error = $root.onnx.TensorProto.Segment.verify(message.segment);
                if (error)
                    return "segment." + error;
            }
            if (message.floatData != null && message.hasOwnProperty("floatData")) {
                if (!Array.isArray(message.floatData))
                    return "floatData: array expected";
                for (var i = 0; i < message.floatData.length; ++i)
                    if (typeof message.floatData[i] !== "number")
                        return "floatData: number[] expected";
            }
            if (message.int32Data != null && message.hasOwnProperty("int32Data")) {
                if (!Array.isArray(message.int32Data))
                    return "int32Data: array expected";
                for (var i = 0; i < message.int32Data.length; ++i)
                    if (!$util.isInteger(message.int32Data[i]))
                        return "int32Data: integer[] expected";
            }
            if (message.stringData != null && message.hasOwnProperty("stringData")) {
                if (!Array.isArray(message.stringData))
                    return "stringData: array expected";
                for (var i = 0; i < message.stringData.length; ++i)
                    if (!(message.stringData[i] && typeof message.stringData[i].length === "number" || $util.isString(message.stringData[i])))
                        return "stringData: buffer[] expected";
            }
            if (message.int64Data != null && message.hasOwnProperty("int64Data")) {
                if (!Array.isArray(message.int64Data))
                    return "int64Data: array expected";
                for (var i = 0; i < message.int64Data.length; ++i)
                    if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))
                        return "int64Data: integer|Long[] expected";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.docString != null && message.hasOwnProperty("docString"))
                if (!$util.isString(message.docString))
                    return "docString: string expected";
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
                    return "rawData: buffer expected";
            if (message.externalData != null && message.hasOwnProperty("externalData")) {
                if (!Array.isArray(message.externalData))
                    return "externalData: array expected";
                for (var i = 0; i < message.externalData.length; ++i) {
                    var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);
                    if (error)
                        return "externalData." + error;
                }
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
                switch (message.dataLocation) {
                default:
                    return "dataLocation: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.doubleData != null && message.hasOwnProperty("doubleData")) {
                if (!Array.isArray(message.doubleData))
                    return "doubleData: array expected";
                for (var i = 0; i < message.doubleData.length; ++i)
                    if (typeof message.doubleData[i] !== "number")
                        return "doubleData: number[] expected";
            }
            if (message.uint64Data != null && message.hasOwnProperty("uint64Data")) {
                if (!Array.isArray(message.uint64Data))
                    return "uint64Data: array expected";
                for (var i = 0; i < message.uint64Data.length; ++i)
                    if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))
                        return "uint64Data: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a TensorProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TensorProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TensorProto} TensorProto
         */
        TensorProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorProto)
                return object;
            var message = new $root.onnx.TensorProto();
            if (object.dims) {
                if (!Array.isArray(object.dims))
                    throw TypeError(".onnx.TensorProto.dims: array expected");
                message.dims = [];
                for (var i = 0; i < object.dims.length; ++i)
                    if ($util.Long)
                        (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
                    else if (typeof object.dims[i] === "string")
                        message.dims[i] = parseInt(object.dims[i], 10);
                    else if (typeof object.dims[i] === "number")
                        message.dims[i] = object.dims[i];
                    else if (typeof object.dims[i] === "object")
                        message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
            }
            if (object.dataType != null)
                message.dataType = object.dataType | 0;
            if (object.segment != null) {
                if (typeof object.segment !== "object")
                    throw TypeError(".onnx.TensorProto.segment: object expected");
                message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);
            }
            if (object.floatData) {
                if (!Array.isArray(object.floatData))
                    throw TypeError(".onnx.TensorProto.floatData: array expected");
                message.floatData = [];
                for (var i = 0; i < object.floatData.length; ++i)
                    message.floatData[i] = Number(object.floatData[i]);
            }
            if (object.int32Data) {
                if (!Array.isArray(object.int32Data))
                    throw TypeError(".onnx.TensorProto.int32Data: array expected");
                message.int32Data = [];
                for (var i = 0; i < object.int32Data.length; ++i)
                    message.int32Data[i] = object.int32Data[i] | 0;
            }
            if (object.stringData) {
                if (!Array.isArray(object.stringData))
                    throw TypeError(".onnx.TensorProto.stringData: array expected");
                message.stringData = [];
                for (var i = 0; i < object.stringData.length; ++i)
                    if (typeof object.stringData[i] === "string")
                        $util.base64.decode(object.stringData[i], message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])), 0);
                    else if (object.stringData[i].length)
                        message.stringData[i] = object.stringData[i];
            }
            if (object.int64Data) {
                if (!Array.isArray(object.int64Data))
                    throw TypeError(".onnx.TensorProto.int64Data: array expected");
                message.int64Data = [];
                for (var i = 0; i < object.int64Data.length; ++i)
                    if ($util.Long)
                        (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;
                    else if (typeof object.int64Data[i] === "string")
                        message.int64Data[i] = parseInt(object.int64Data[i], 10);
                    else if (typeof object.int64Data[i] === "number")
                        message.int64Data[i] = object.int64Data[i];
                    else if (typeof object.int64Data[i] === "object")
                        message.int64Data[i] = new $util.LongBits(object.int64Data[i].low >>> 0, object.int64Data[i].high >>> 0).toNumber();
            }
            if (object.name != null)
                message.name = String(object.name);
            if (object.docString != null)
                message.docString = String(object.docString);
            if (object.rawData != null)
                if (typeof object.rawData === "string")
                    $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);
                else if (object.rawData.length)
                    message.rawData = object.rawData;
            if (object.externalData) {
                if (!Array.isArray(object.externalData))
                    throw TypeError(".onnx.TensorProto.externalData: array expected");
                message.externalData = [];
                for (var i = 0; i < object.externalData.length; ++i) {
                    if (typeof object.externalData[i] !== "object")
                        throw TypeError(".onnx.TensorProto.externalData: object expected");
                    message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);
                }
            }
            switch (object.dataLocation) {
            case "DEFAULT":
            case 0:
                message.dataLocation = 0;
                break;
            case "EXTERNAL":
            case 1:
                message.dataLocation = 1;
                break;
            }
            if (object.doubleData) {
                if (!Array.isArray(object.doubleData))
                    throw TypeError(".onnx.TensorProto.doubleData: array expected");
                message.doubleData = [];
                for (var i = 0; i < object.doubleData.length; ++i)
                    message.doubleData[i] = Number(object.doubleData[i]);
            }
            if (object.uint64Data) {
                if (!Array.isArray(object.uint64Data))
                    throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                message.uint64Data = [];
                for (var i = 0; i < object.uint64Data.length; ++i)
                    if ($util.Long)
                        (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;
                    else if (typeof object.uint64Data[i] === "string")
                        message.uint64Data[i] = parseInt(object.uint64Data[i], 10);
                    else if (typeof object.uint64Data[i] === "number")
                        message.uint64Data[i] = object.uint64Data[i];
                    else if (typeof object.uint64Data[i] === "object")
                        message.uint64Data[i] = new $util.LongBits(object.uint64Data[i].low >>> 0, object.uint64Data[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TensorProto
         * @static
         * @param {onnx.TensorProto} message TensorProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.dims = [];
                object.floatData = [];
                object.int32Data = [];
                object.stringData = [];
                object.int64Data = [];
                object.doubleData = [];
                object.uint64Data = [];
                object.externalData = [];
            }
            if (options.defaults) {
                object.dataType = 0;
                object.segment = null;
                object.name = "";
                if (options.bytes === String)
                    object.rawData = "";
                else {
                    object.rawData = [];
                    if (options.bytes !== Array)
                        object.rawData = $util.newBuffer(object.rawData);
                }
                object.docString = "";
                object.dataLocation = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.dims && message.dims.length) {
                object.dims = [];
                for (var j = 0; j < message.dims.length; ++j)
                    if (typeof message.dims[j] === "number")
                        object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
                    else
                        object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
            }
            if (message.dataType != null && message.hasOwnProperty("dataType"))
                object.dataType = message.dataType;
            if (message.segment != null && message.hasOwnProperty("segment"))
                object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);
            if (message.floatData && message.floatData.length) {
                object.floatData = [];
                for (var j = 0; j < message.floatData.length; ++j)
                    object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];
            }
            if (message.int32Data && message.int32Data.length) {
                object.int32Data = [];
                for (var j = 0; j < message.int32Data.length; ++j)
                    object.int32Data[j] = message.int32Data[j];
            }
            if (message.stringData && message.stringData.length) {
                object.stringData = [];
                for (var j = 0; j < message.stringData.length; ++j)
                    object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];
            }
            if (message.int64Data && message.int64Data.length) {
                object.int64Data = [];
                for (var j = 0; j < message.int64Data.length; ++j)
                    if (typeof message.int64Data[j] === "number")
                        object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];
                    else
                        object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.rawData != null && message.hasOwnProperty("rawData"))
                object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
            if (message.doubleData && message.doubleData.length) {
                object.doubleData = [];
                for (var j = 0; j < message.doubleData.length; ++j)
                    object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];
            }
            if (message.uint64Data && message.uint64Data.length) {
                object.uint64Data = [];
                for (var j = 0; j < message.uint64Data.length; ++j)
                    if (typeof message.uint64Data[j] === "number")
                        object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];
                    else
                        object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];
            }
            if (message.docString != null && message.hasOwnProperty("docString"))
                object.docString = message.docString;
            if (message.externalData && message.externalData.length) {
                object.externalData = [];
                for (var j = 0; j < message.externalData.length; ++j)
                    object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);
            }
            if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
                object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;
            return object;
        };

        /**
         * Converts this TensorProto to JSON.
         * @function toJSON
         * @memberof onnx.TensorProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * DataType enum.
         * @name onnx.TensorProto.DataType
         * @enum {string}
         * @property {number} UNDEFINED=0 UNDEFINED value
         * @property {number} FLOAT=1 FLOAT value
         * @property {number} UINT8=2 UINT8 value
         * @property {number} INT8=3 INT8 value
         * @property {number} UINT16=4 UINT16 value
         * @property {number} INT16=5 INT16 value
         * @property {number} INT32=6 INT32 value
         * @property {number} INT64=7 INT64 value
         * @property {number} STRING=8 STRING value
         * @property {number} BOOL=9 BOOL value
         * @property {number} FLOAT16=10 FLOAT16 value
         * @property {number} DOUBLE=11 DOUBLE value
         * @property {number} UINT32=12 UINT32 value
         * @property {number} UINT64=13 UINT64 value
         * @property {number} COMPLEX64=14 COMPLEX64 value
         * @property {number} COMPLEX128=15 COMPLEX128 value
         * @property {number} BFLOAT16=16 BFLOAT16 value
         */
        TensorProto.DataType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNDEFINED"] = 0;
            values[valuesById[1] = "FLOAT"] = 1;
            values[valuesById[2] = "UINT8"] = 2;
            values[valuesById[3] = "INT8"] = 3;
            values[valuesById[4] = "UINT16"] = 4;
            values[valuesById[5] = "INT16"] = 5;
            values[valuesById[6] = "INT32"] = 6;
            values[valuesById[7] = "INT64"] = 7;
            values[valuesById[8] = "STRING"] = 8;
            values[valuesById[9] = "BOOL"] = 9;
            values[valuesById[10] = "FLOAT16"] = 10;
            values[valuesById[11] = "DOUBLE"] = 11;
            values[valuesById[12] = "UINT32"] = 12;
            values[valuesById[13] = "UINT64"] = 13;
            values[valuesById[14] = "COMPLEX64"] = 14;
            values[valuesById[15] = "COMPLEX128"] = 15;
            values[valuesById[16] = "BFLOAT16"] = 16;
            return values;
        })();

        TensorProto.Segment = (function() {

            /**
             * Properties of a Segment.
             * @memberof onnx.TensorProto
             * @interface ISegment
             * @property {number|Long|null} [begin] Segment begin
             * @property {number|Long|null} [end] Segment end
             */

            /**
             * Constructs a new Segment.
             * @memberof onnx.TensorProto
             * @classdesc Represents a Segment.
             * @implements ISegment
             * @constructor
             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set
             */
            function Segment(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Segment begin.
             * @member {number|Long} begin
             * @memberof onnx.TensorProto.Segment
             * @instance
             */
            Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Segment end.
             * @member {number|Long} end
             * @memberof onnx.TensorProto.Segment
             * @instance
             */
            Segment.prototype.end = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Segment instance using the specified properties.
             * @function create
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.ISegment=} [properties] Properties to set
             * @returns {onnx.TensorProto.Segment} Segment instance
             */
            Segment.create = function create(properties) {
                return new Segment(properties);
            };

            /**
             * Encodes the specified Segment message. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.
             * @function encode
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Segment.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.begin != null && message.hasOwnProperty("begin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.begin);
                if (message.end != null && message.hasOwnProperty("end"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.end);
                return writer;
            };

            /**
             * Encodes the specified Segment message, length delimited. Does not implicitly {@link onnx.TensorProto.Segment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.ISegment} message Segment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Segment.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Segment message from the specified reader or buffer.
             * @function decode
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {onnx.TensorProto.Segment} Segment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Segment.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.begin = reader.int64();
                        break;
                    case 2:
                        message.end = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Segment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {onnx.TensorProto.Segment} Segment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Segment.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Segment message.
             * @function verify
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Segment.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.begin != null && message.hasOwnProperty("begin"))
                    if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))
                        return "begin: integer|Long expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                        return "end: integer|Long expected";
                return null;
            };

            /**
             * Creates a Segment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {onnx.TensorProto.Segment} Segment
             */
            Segment.fromObject = function fromObject(object) {
                if (object instanceof $root.onnx.TensorProto.Segment)
                    return object;
                var message = new $root.onnx.TensorProto.Segment();
                if (object.begin != null)
                    if ($util.Long)
                        (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;
                    else if (typeof object.begin === "string")
                        message.begin = parseInt(object.begin, 10);
                    else if (typeof object.begin === "number")
                        message.begin = object.begin;
                    else if (typeof object.begin === "object")
                        message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();
                if (object.end != null)
                    if ($util.Long)
                        (message.end = $util.Long.fromValue(object.end)).unsigned = false;
                    else if (typeof object.end === "string")
                        message.end = parseInt(object.end, 10);
                    else if (typeof object.end === "number")
                        message.end = object.end;
                    else if (typeof object.end === "object")
                        message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Segment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof onnx.TensorProto.Segment
             * @static
             * @param {onnx.TensorProto.Segment} message Segment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Segment.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.begin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.end = options.longs === String ? "0" : 0;
                }
                if (message.begin != null && message.hasOwnProperty("begin"))
                    if (typeof message.begin === "number")
                        object.begin = options.longs === String ? String(message.begin) : message.begin;
                    else
                        object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;
                if (message.end != null && message.hasOwnProperty("end"))
                    if (typeof message.end === "number")
                        object.end = options.longs === String ? String(message.end) : message.end;
                    else
                        object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
                return object;
            };

            /**
             * Converts this Segment to JSON.
             * @function toJSON
             * @memberof onnx.TensorProto.Segment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Segment.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Segment;
        })();

        /**
         * DataLocation enum.
         * @name onnx.TensorProto.DataLocation
         * @enum {string}
         * @property {number} DEFAULT=0 DEFAULT value
         * @property {number} EXTERNAL=1 EXTERNAL value
         */
        TensorProto.DataLocation = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "DEFAULT"] = 0;
            values[valuesById[1] = "EXTERNAL"] = 1;
            return values;
        })();

        return TensorProto;
    })();

    onnx.TensorShapeProto = (function() {

        /**
         * Properties of a TensorShapeProto.
         * @memberof onnx
         * @interface ITensorShapeProto
         * @property {Array.<onnx.TensorShapeProto.IDimension>|null} [dim] TensorShapeProto dim
         */

        /**
         * Constructs a new TensorShapeProto.
         * @memberof onnx
         * @classdesc Represents a TensorShapeProto.
         * @implements ITensorShapeProto
         * @constructor
         * @param {onnx.ITensorShapeProto=} [properties] Properties to set
         */
        function TensorShapeProto(properties) {
            this.dim = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TensorShapeProto dim.
         * @member {Array.<onnx.TensorShapeProto.IDimension>} dim
         * @memberof onnx.TensorShapeProto
         * @instance
         */
        TensorShapeProto.prototype.dim = $util.emptyArray;

        /**
         * Creates a new TensorShapeProto instance using the specified properties.
         * @function create
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.ITensorShapeProto=} [properties] Properties to set
         * @returns {onnx.TensorShapeProto} TensorShapeProto instance
         */
        TensorShapeProto.create = function create(properties) {
            return new TensorShapeProto(properties);
        };

        /**
         * Encodes the specified TensorShapeProto message. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorShapeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dim != null && message.dim.length)
                for (var i = 0; i < message.dim.length; ++i)
                    $root.onnx.TensorShapeProto.Dimension.encode(message.dim[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TensorShapeProto message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.ITensorShapeProto} message TensorShapeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TensorShapeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TensorShapeProto} TensorShapeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorShapeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dim && message.dim.length))
                        message.dim = [];
                    message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TensorShapeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TensorShapeProto} TensorShapeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TensorShapeProto message.
         * @function verify
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TensorShapeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dim != null && message.hasOwnProperty("dim")) {
                if (!Array.isArray(message.dim))
                    return "dim: array expected";
                for (var i = 0; i < message.dim.length; ++i) {
                    var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);
                    if (error)
                        return "dim." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TensorShapeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TensorShapeProto} TensorShapeProto
         */
        TensorShapeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorShapeProto)
                return object;
            var message = new $root.onnx.TensorShapeProto();
            if (object.dim) {
                if (!Array.isArray(object.dim))
                    throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                message.dim = [];
                for (var i = 0; i < object.dim.length; ++i) {
                    if (typeof object.dim[i] !== "object")
                        throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                    message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TensorShapeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TensorShapeProto
         * @static
         * @param {onnx.TensorShapeProto} message TensorShapeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TensorShapeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dim = [];
            if (message.dim && message.dim.length) {
                object.dim = [];
                for (var j = 0; j < message.dim.length; ++j)
                    object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);
            }
            return object;
        };

        /**
         * Converts this TensorShapeProto to JSON.
         * @function toJSON
         * @memberof onnx.TensorShapeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TensorShapeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TensorShapeProto.Dimension = (function() {

            /**
             * Properties of a Dimension.
             * @memberof onnx.TensorShapeProto
             * @interface IDimension
             * @property {number|Long|null} [dimValue] Dimension dimValue
             * @property {string|null} [dimParam] Dimension dimParam
             * @property {string|null} [denotation] Dimension denotation
             */

            /**
             * Constructs a new Dimension.
             * @memberof onnx.TensorShapeProto
             * @classdesc Represents a Dimension.
             * @implements IDimension
             * @constructor
             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set
             */
            function Dimension(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Dimension dimValue.
             * @member {number|Long} dimValue
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Dimension.prototype.dimValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Dimension dimParam.
             * @member {string} dimParam
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Dimension.prototype.dimParam = "";

            /**
             * Dimension denotation.
             * @member {string} denotation
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Dimension.prototype.denotation = "";

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Dimension value.
             * @member {"dimValue"|"dimParam"|undefined} value
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             */
            Object.defineProperty(Dimension.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["dimValue", "dimParam"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Dimension instance using the specified properties.
             * @function create
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.IDimension=} [properties] Properties to set
             * @returns {onnx.TensorShapeProto.Dimension} Dimension instance
             */
            Dimension.create = function create(properties) {
                return new Dimension(properties);
            };

            /**
             * Encodes the specified Dimension message. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.
             * @function encode
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dimension.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dimValue != null && message.hasOwnProperty("dimValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.dimValue);
                if (message.dimParam != null && message.hasOwnProperty("dimParam"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.dimParam);
                if (message.denotation != null && message.hasOwnProperty("denotation"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.denotation);
                return writer;
            };

            /**
             * Encodes the specified Dimension message, length delimited. Does not implicitly {@link onnx.TensorShapeProto.Dimension.verify|verify} messages.
             * @function encodeDelimited
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.IDimension} message Dimension message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Dimension.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Dimension message from the specified reader or buffer.
             * @function decode
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {onnx.TensorShapeProto.Dimension} Dimension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dimension.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dimValue = reader.int64();
                        break;
                    case 2:
                        message.dimParam = reader.string();
                        break;
                    case 3:
                        message.denotation = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Dimension message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {onnx.TensorShapeProto.Dimension} Dimension
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Dimension.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Dimension message.
             * @function verify
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Dimension.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                    properties.value = 1;
                    if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))
                        return "dimValue: integer|Long expected";
                }
                if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isString(message.dimParam))
                        return "dimParam: string expected";
                }
                if (message.denotation != null && message.hasOwnProperty("denotation"))
                    if (!$util.isString(message.denotation))
                        return "denotation: string expected";
                return null;
            };

            /**
             * Creates a Dimension message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {onnx.TensorShapeProto.Dimension} Dimension
             */
            Dimension.fromObject = function fromObject(object) {
                if (object instanceof $root.onnx.TensorShapeProto.Dimension)
                    return object;
                var message = new $root.onnx.TensorShapeProto.Dimension();
                if (object.dimValue != null)
                    if ($util.Long)
                        (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;
                    else if (typeof object.dimValue === "string")
                        message.dimValue = parseInt(object.dimValue, 10);
                    else if (typeof object.dimValue === "number")
                        message.dimValue = object.dimValue;
                    else if (typeof object.dimValue === "object")
                        message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();
                if (object.dimParam != null)
                    message.dimParam = String(object.dimParam);
                if (object.denotation != null)
                    message.denotation = String(object.denotation);
                return message;
            };

            /**
             * Creates a plain object from a Dimension message. Also converts values to other types if specified.
             * @function toObject
             * @memberof onnx.TensorShapeProto.Dimension
             * @static
             * @param {onnx.TensorShapeProto.Dimension} message Dimension
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Dimension.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.denotation = "";
                if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
                    if (typeof message.dimValue === "number")
                        object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;
                    else
                        object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;
                    if (options.oneofs)
                        object.value = "dimValue";
                }
                if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
                    object.dimParam = message.dimParam;
                    if (options.oneofs)
                        object.value = "dimParam";
                }
                if (message.denotation != null && message.hasOwnProperty("denotation"))
                    object.denotation = message.denotation;
                return object;
            };

            /**
             * Converts this Dimension to JSON.
             * @function toJSON
             * @memberof onnx.TensorShapeProto.Dimension
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Dimension.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Dimension;
        })();

        return TensorShapeProto;
    })();

    onnx.TypeProto = (function() {

        /**
         * Properties of a TypeProto.
         * @memberof onnx
         * @interface ITypeProto
         * @property {onnx.TypeProto.ITensor|null} [tensorType] TypeProto tensorType
         * @property {string|null} [denotation] TypeProto denotation
         */

        /**
         * Constructs a new TypeProto.
         * @memberof onnx
         * @classdesc Represents a TypeProto.
         * @implements ITypeProto
         * @constructor
         * @param {onnx.ITypeProto=} [properties] Properties to set
         */
        function TypeProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TypeProto tensorType.
         * @member {onnx.TypeProto.ITensor|null|undefined} tensorType
         * @memberof onnx.TypeProto
         * @instance
         */
        TypeProto.prototype.tensorType = null;

        /**
         * TypeProto denotation.
         * @member {string} denotation
         * @memberof onnx.TypeProto
         * @instance
         */
        TypeProto.prototype.denotation = "";

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * TypeProto value.
         * @member {"tensorType"|undefined} value
         * @memberof onnx.TypeProto
         * @instance
         */
        Object.defineProperty(TypeProto.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["tensorType"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new TypeProto instance using the specified properties.
         * @function create
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.ITypeProto=} [properties] Properties to set
         * @returns {onnx.TypeProto} TypeProto instance
         */
        TypeProto.create = function create(properties) {
            return new TypeProto(properties);
        };

        /**
         * Encodes the specified TypeProto message. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypeProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tensorType != null && message.hasOwnProperty("tensorType"))
                $root.onnx.TypeProto.Tensor.encode(message.tensorType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.denotation != null && message.hasOwnProperty("denotation"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.denotation);
            return writer;
        };

        /**
         * Encodes the specified TypeProto message, length delimited. Does not implicitly {@link onnx.TypeProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.ITypeProto} message TypeProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypeProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TypeProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.TypeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.TypeProto} TypeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypeProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.denotation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TypeProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.TypeProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.TypeProto} TypeProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypeProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TypeProto message.
         * @function verify
         * @memberof onnx.TypeProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TypeProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
                properties.value = 1;
                {
                    var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);
                    if (error)
                        return "tensorType." + error;
                }
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
                if (!$util.isString(message.denotation))
                    return "denotation: string expected";
            return null;
        };

        /**
         * Creates a TypeProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.TypeProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.TypeProto} TypeProto
         */
        TypeProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto)
                return object;
            var message = new $root.onnx.TypeProto();
            if (object.tensorType != null) {
                if (typeof object.tensorType !== "object")
                    throw TypeError(".onnx.TypeProto.tensorType: object expected");
                message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);
            }
            if (object.denotation != null)
                message.denotation = String(object.denotation);
            return message;
        };

        /**
         * Creates a plain object from a TypeProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.TypeProto
         * @static
         * @param {onnx.TypeProto} message TypeProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TypeProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.denotation = "";
            if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
                object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);
                if (options.oneofs)
                    object.value = "tensorType";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
                object.denotation = message.denotation;
            return object;
        };

        /**
         * Converts this TypeProto to JSON.
         * @function toJSON
         * @memberof onnx.TypeProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TypeProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TypeProto.Tensor = (function() {

            /**
             * Properties of a Tensor.
             * @memberof onnx.TypeProto
             * @interface ITensor
             * @property {number|null} [elemType] Tensor elemType
             * @property {onnx.ITensorShapeProto|null} [shape] Tensor shape
             */

            /**
             * Constructs a new Tensor.
             * @memberof onnx.TypeProto
             * @classdesc Represents a Tensor.
             * @implements ITensor
             * @constructor
             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set
             */
            function Tensor(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Tensor elemType.
             * @member {number} elemType
             * @memberof onnx.TypeProto.Tensor
             * @instance
             */
            Tensor.prototype.elemType = 0;

            /**
             * Tensor shape.
             * @member {onnx.ITensorShapeProto|null|undefined} shape
             * @memberof onnx.TypeProto.Tensor
             * @instance
             */
            Tensor.prototype.shape = null;

            /**
             * Creates a new Tensor instance using the specified properties.
             * @function create
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.ITensor=} [properties] Properties to set
             * @returns {onnx.TypeProto.Tensor} Tensor instance
             */
            Tensor.create = function create(properties) {
                return new Tensor(properties);
            };

            /**
             * Encodes the specified Tensor message. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.
             * @function encode
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tensor.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elemType != null && message.hasOwnProperty("elemType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.elemType);
                if (message.shape != null && message.hasOwnProperty("shape"))
                    $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Tensor message, length delimited. Does not implicitly {@link onnx.TypeProto.Tensor.verify|verify} messages.
             * @function encodeDelimited
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.ITensor} message Tensor message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Tensor.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Tensor message from the specified reader or buffer.
             * @function decode
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {onnx.TypeProto.Tensor} Tensor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tensor.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.elemType = reader.int32();
                        break;
                    case 2:
                        message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Tensor message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {onnx.TypeProto.Tensor} Tensor
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Tensor.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Tensor message.
             * @function verify
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Tensor.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.elemType != null && message.hasOwnProperty("elemType"))
                    if (!$util.isInteger(message.elemType))
                        return "elemType: integer expected";
                if (message.shape != null && message.hasOwnProperty("shape")) {
                    var error = $root.onnx.TensorShapeProto.verify(message.shape);
                    if (error)
                        return "shape." + error;
                }
                return null;
            };

            /**
             * Creates a Tensor message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {onnx.TypeProto.Tensor} Tensor
             */
            Tensor.fromObject = function fromObject(object) {
                if (object instanceof $root.onnx.TypeProto.Tensor)
                    return object;
                var message = new $root.onnx.TypeProto.Tensor();
                if (object.elemType != null)
                    message.elemType = object.elemType | 0;
                if (object.shape != null) {
                    if (typeof object.shape !== "object")
                        throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                    message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
                }
                return message;
            };

            /**
             * Creates a plain object from a Tensor message. Also converts values to other types if specified.
             * @function toObject
             * @memberof onnx.TypeProto.Tensor
             * @static
             * @param {onnx.TypeProto.Tensor} message Tensor
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Tensor.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.elemType = 0;
                    object.shape = null;
                }
                if (message.elemType != null && message.hasOwnProperty("elemType"))
                    object.elemType = message.elemType;
                if (message.shape != null && message.hasOwnProperty("shape"))
                    object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
                return object;
            };

            /**
             * Converts this Tensor to JSON.
             * @function toJSON
             * @memberof onnx.TypeProto.Tensor
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Tensor.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Tensor;
        })();

        return TypeProto;
    })();

    onnx.OperatorSetIdProto = (function() {

        /**
         * Properties of an OperatorSetIdProto.
         * @memberof onnx
         * @interface IOperatorSetIdProto
         * @property {string|null} [domain] OperatorSetIdProto domain
         * @property {number|Long|null} [version] OperatorSetIdProto version
         */

        /**
         * Constructs a new OperatorSetIdProto.
         * @memberof onnx
         * @classdesc Represents an OperatorSetIdProto.
         * @implements IOperatorSetIdProto
         * @constructor
         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set
         */
        function OperatorSetIdProto(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OperatorSetIdProto domain.
         * @member {string} domain
         * @memberof onnx.OperatorSetIdProto
         * @instance
         */
        OperatorSetIdProto.prototype.domain = "";

        /**
         * OperatorSetIdProto version.
         * @member {number|Long} version
         * @memberof onnx.OperatorSetIdProto
         * @instance
         */
        OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new OperatorSetIdProto instance using the specified properties.
         * @function create
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.IOperatorSetIdProto=} [properties] Properties to set
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto instance
         */
        OperatorSetIdProto.create = function create(properties) {
            return new OperatorSetIdProto(properties);
        };

        /**
         * Encodes the specified OperatorSetIdProto message. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.
         * @function encode
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OperatorSetIdProto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.domain != null && message.hasOwnProperty("domain"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.version);
            return writer;
        };

        /**
         * Encodes the specified OperatorSetIdProto message, length delimited. Does not implicitly {@link onnx.OperatorSetIdProto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.IOperatorSetIdProto} message OperatorSetIdProto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OperatorSetIdProto message from the specified reader or buffer.
         * @function decode
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OperatorSetIdProto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.domain = reader.string();
                    break;
                case 2:
                    message.version = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OperatorSetIdProto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OperatorSetIdProto message.
         * @function verify
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OperatorSetIdProto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.domain != null && message.hasOwnProperty("domain"))
                if (!$util.isString(message.domain))
                    return "domain: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
                    return "version: integer|Long expected";
            return null;
        };

        /**
         * Creates an OperatorSetIdProto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {onnx.OperatorSetIdProto} OperatorSetIdProto
         */
        OperatorSetIdProto.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.OperatorSetIdProto)
                return object;
            var message = new $root.onnx.OperatorSetIdProto();
            if (object.domain != null)
                message.domain = String(object.domain);
            if (object.version != null)
                if ($util.Long)
                    (message.version = $util.Long.fromValue(object.version)).unsigned = false;
                else if (typeof object.version === "string")
                    message.version = parseInt(object.version, 10);
                else if (typeof object.version === "number")
                    message.version = object.version;
                else if (typeof object.version === "object")
                    message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an OperatorSetIdProto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof onnx.OperatorSetIdProto
         * @static
         * @param {onnx.OperatorSetIdProto} message OperatorSetIdProto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OperatorSetIdProto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.domain = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.version = options.longs === String ? "0" : 0;
            }
            if (message.domain != null && message.hasOwnProperty("domain"))
                object.domain = message.domain;
            if (message.version != null && message.hasOwnProperty("version"))
                if (typeof message.version === "number")
                    object.version = options.longs === String ? String(message.version) : message.version;
                else
                    object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
            return object;
        };

        /**
         * Converts this OperatorSetIdProto to JSON.
         * @function toJSON
         * @memberof onnx.OperatorSetIdProto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OperatorSetIdProto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OperatorSetIdProto;
    })();

    return onnx;
})();

module.exports = $root;


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof __webpack_require__.g !== "undefined"
                   && __webpack_require__.g
                   && __webpack_require__.g.process
                   && __webpack_require__.g.process.versions
                   && __webpack_require__.g.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && __webpack_require__.g
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./lib/backend-onnxjs.ts":
/*!*******************************!*\
  !*** ./lib/backend-onnxjs.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onnxjsBackend = void 0;
const session_1 = __webpack_require__(/*! ./onnxjs/session */ "./lib/onnxjs/session.ts");
const session_handler_1 = __webpack_require__(/*! ./onnxjs/session-handler */ "./lib/onnxjs/session-handler.ts");
class OnnxjsBackend {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    createSessionHandler(pathOrBuffer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // NOTE: Session.Config(from onnx.js) is not compatible with InferenceSession.SessionOptions(from
            // onnxruntime-common).
            //       In future we should remove Session.Config and use InferenceSession.SessionOptions.
            //       Currently we allow this to happen to make test runner work.
            const session = new session_1.Session(options);
            // typescript cannot merge method override correctly (so far in 4.2.3). need if-else to call the method.
            if (typeof pathOrBuffer === 'string') {
                yield session.loadModel(pathOrBuffer);
            }
            else {
                yield session.loadModel(pathOrBuffer);
            }
            return new session_handler_1.OnnxjsSessionHandler(session);
        });
    }
}
exports.onnxjsBackend = new OnnxjsBackend();


/***/ }),

/***/ "./lib/backend-wasm.ts":
/*!*****************************!*\
  !*** ./lib/backend-wasm.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wasmBackend = exports.initializeFlags = void 0;
const fs_1 = __webpack_require__(/*! fs */ "?d87b");
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const os_1 = __webpack_require__(/*! os */ "?0757");
const util_1 = __webpack_require__(/*! util */ "?334c");
const session_handler_1 = __webpack_require__(/*! ./wasm/session-handler */ "./lib/wasm/session-handler.ts");
const wasm_factory_1 = __webpack_require__(/*! ./wasm/wasm-factory */ "./lib/wasm/wasm-factory.ts");
/**
 * This function initializes all flags for WebAssembly.
 *
 * Those flags are accessible from `ort.env.wasm`. Users are allow to set those flags before the first inference session
 * being created, to override default value.
 */
const initializeFlags = () => {
    if (typeof onnxruntime_common_1.env.wasm.initTimeout !== 'number' || onnxruntime_common_1.env.wasm.initTimeout < 0) {
        onnxruntime_common_1.env.wasm.initTimeout = 0;
    }
    if (typeof onnxruntime_common_1.env.wasm.simd !== 'boolean') {
        onnxruntime_common_1.env.wasm.simd = true;
    }
    if (typeof onnxruntime_common_1.env.wasm.numThreads !== 'number' || !Number.isInteger(onnxruntime_common_1.env.wasm.numThreads) || onnxruntime_common_1.env.wasm.numThreads <= 0) {
        const numCpuLogicalCores = typeof navigator === 'undefined' ? os_1.cpus().length : navigator.hardwareConcurrency;
        onnxruntime_common_1.env.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
    }
};
exports.initializeFlags = initializeFlags;
class OnnxruntimeWebAssemblyBackend {
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            // populate wasm flags
            exports.initializeFlags();
            // init wasm
            yield wasm_factory_1.initializeWebAssembly();
        });
    }
    createSessionHandler(pathOrBuffer, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let buffer;
            if (typeof pathOrBuffer === 'string') {
                if (typeof fetch === 'undefined') {
                    // node
                    buffer = yield util_1.promisify(fs_1.readFile)(pathOrBuffer);
                }
                else {
                    // browser
                    const response = yield fetch(pathOrBuffer);
                    const arrayBuffer = yield response.arrayBuffer();
                    buffer = new Uint8Array(arrayBuffer);
                }
            }
            else {
                buffer = pathOrBuffer;
            }
            const handler = new session_handler_1.OnnxruntimeWebAssemblySessionHandler();
            handler.loadModel(buffer, options);
            return Promise.resolve(handler);
        });
    }
}
exports.wasmBackend = new OnnxruntimeWebAssemblyBackend();


/***/ }),

/***/ "./lib/index.ts":
/*!**********************!*\
  !*** ./lib/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! onnxruntime-common */ "onnxruntime-common"), exports);
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const backend_onnxjs_1 = __webpack_require__(/*! ./backend-onnxjs */ "./lib/backend-onnxjs.ts");
const backend_wasm_1 = __webpack_require__(/*! ./backend-wasm */ "./lib/backend-wasm.ts");
onnxruntime_common_1.registerBackend('webgl', backend_onnxjs_1.onnxjsBackend, 1);
onnxruntime_common_1.registerBackend('wasm', backend_wasm_1.wasmBackend, 2);


/***/ }),

/***/ "./lib/onnxjs/attribute.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/attribute.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Attribute = void 0;
const onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
const ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
const tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
const util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
class Attribute {
    constructor(attributes) {
        this._attributes = new Map();
        if (attributes !== null && attributes !== undefined) {
            for (const attr of attributes) {
                if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                    this._attributes.set(attr.name, [Attribute.getValue(attr), Attribute.getType(attr)]);
                }
                else if (attr instanceof ortFbs.Attribute) {
                    this._attributes.set(attr.name(), [Attribute.getValue(attr), Attribute.getType(attr)]);
                }
            }
            if (this._attributes.size < attributes.length) {
                throw new Error('duplicated attribute names');
            }
        }
    }
    set(key, type, value) {
        this._attributes.set(key, [value, type]);
    }
    delete(key) {
        this._attributes.delete(key);
    }
    getFloat(key, defaultValue) {
        return this.get(key, 'float', defaultValue);
    }
    getInt(key, defaultValue) {
        return this.get(key, 'int', defaultValue);
    }
    getString(key, defaultValue) {
        return this.get(key, 'string', defaultValue);
    }
    getTensor(key, defaultValue) {
        return this.get(key, 'tensor', defaultValue);
    }
    getFloats(key, defaultValue) {
        return this.get(key, 'floats', defaultValue);
    }
    getInts(key, defaultValue) {
        return this.get(key, 'ints', defaultValue);
    }
    getStrings(key, defaultValue) {
        return this.get(key, 'strings', defaultValue);
    }
    getTensors(key, defaultValue) {
        return this.get(key, 'tensors', defaultValue);
    }
    get(key, type, defaultValue) {
        const valueAndType = this._attributes.get(key);
        if (valueAndType === undefined) {
            if (defaultValue !== undefined) {
                return defaultValue;
            }
            throw new Error(`required attribute not found: ${key}`);
        }
        if (valueAndType[1] !== type) {
            throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);
        }
        return valueAndType[0];
    }
    static getType(attr) {
        const type = attr instanceof onnx_proto_1.onnx.AttributeProto ? (attr).type : attr.type();
        switch (type) {
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOAT:
                return 'float';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INT:
                return 'int';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRING:
                return 'string';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSOR:
                return 'tensor';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOATS:
                return 'floats';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INTS:
                return 'ints';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRINGS:
                return 'strings';
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSORS:
                return 'tensors';
            default:
                throw new Error(`attribute type is not supported yet: ${onnx_proto_1.onnx.AttributeProto.AttributeType[type]}`);
        }
    }
    static getValue(attr) {
        const attrType = attr instanceof onnx_proto_1.onnx.AttributeProto ? attr.type : attr.type();
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPH || attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPHS) {
            throw new Error('graph attribute is not supported yet');
        }
        const value = this.getValueNoCheck(attr);
        // cast LONG to number
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.INT && util_1.LongUtil.isLong(value)) {
            return util_1.LongUtil.longToNumber(value);
        }
        // cast LONG[] to number[]
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.INTS) {
            const arr = value;
            const numberValue = new Array(arr.length);
            for (let i = 0; i < arr.length; i++) {
                const maybeLong = arr[i];
                numberValue[i] = util_1.LongUtil.longToNumber(maybeLong);
            }
            return numberValue;
        }
        // cast onnx.TensorProto to onnxjs.Tensor
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.TENSOR) {
            return attr instanceof onnx_proto_1.onnx.AttributeProto ? tensor_1.Tensor.fromProto(value) :
                tensor_1.Tensor.fromOrtTensor(value);
        }
        // cast onnx.TensorProto[] to onnxjs.Tensor[]
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.TENSORS) {
            if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                const tensorProtos = value;
                return tensorProtos.map(value => tensor_1.Tensor.fromProto(value));
            }
            else if (attr instanceof ortFbs.Attribute) {
                const tensorProtos = value;
                return tensorProtos.map(value => tensor_1.Tensor.fromOrtTensor(value));
            }
        }
        // cast Uint8Array to string
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.STRING) {
            // string in onnx attribute is of uint8array type, so we need to convert it to string below. While in ort format,
            // string attributes are returned as string, so no conversion is needed.
            if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                const utf8String = value;
                return Buffer.from(utf8String.buffer, utf8String.byteOffset, utf8String.byteLength).toString();
            }
        }
        // cast Uint8Array[] to string[]
        if (attrType === onnx_proto_1.onnx.AttributeProto.AttributeType.STRINGS) {
            // strings in onnx attribute is returned as uint8array[], so we need to convert it to string[] below. While in ort
            // format strings attributes are returned as string[], so no conversion is needed.
            if (attr instanceof onnx_proto_1.onnx.AttributeProto) {
                const utf8Strings = value;
                return utf8Strings.map(utf8String => Buffer.from(utf8String.buffer, utf8String.byteOffset, utf8String.byteLength).toString());
            }
        }
        return value;
    }
    static getValueNoCheck(attr) {
        return attr instanceof (onnx_proto_1.onnx.AttributeProto) ? this.getValueNoCheckFromOnnxFormat(attr) :
            this.getValueNoCheckFromOrtFormat(attr);
    }
    static getValueNoCheckFromOnnxFormat(attr) {
        switch (attr.type) {
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOAT:
                return attr.f;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INT:
                return attr.i;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRING:
                return attr.s;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSOR:
                return attr.t;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPH:
                return attr.g;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.FLOATS:
                return attr.floats;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.INTS:
                return attr.ints;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.STRINGS:
                return attr.strings;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.TENSORS:
                return attr.tensors;
            case onnx_proto_1.onnx.AttributeProto.AttributeType.GRAPHS:
                return attr.graphs;
            default:
                throw new Error(`unsupported attribute type: ${onnx_proto_1.onnx.AttributeProto.AttributeType[attr.type]}`);
        }
    }
    static getValueNoCheckFromOrtFormat(attr) {
        switch (attr.type()) {
            case ortFbs.AttributeType.FLOAT:
                return attr.f();
            case ortFbs.AttributeType.INT:
                return attr.i();
            case ortFbs.AttributeType.STRING:
                return attr.s();
            case ortFbs.AttributeType.TENSOR:
                return attr.t();
            case ortFbs.AttributeType.GRAPH:
                return attr.g();
            case ortFbs.AttributeType.FLOATS:
                return attr.floatsArray();
            case ortFbs.AttributeType.INTS: {
                const ints = [];
                for (let i = 0; i < attr.intsLength(); i++) {
                    ints.push(attr.ints(i));
                }
                return ints;
            }
            case ortFbs.AttributeType.STRINGS: {
                const strings = [];
                for (let i = 0; i < attr.stringsLength(); i++) {
                    strings.push(attr.strings(i));
                }
                return strings;
            }
            case ortFbs.AttributeType.TENSORS: {
                const tensors = [];
                for (let i = 0; i < attr.tensorsLength(); i++) {
                    tensors.push(attr.tensors(i));
                }
                return tensors;
            }
            // case ortFbs.AttributeType.GRAPHS:
            // TODO: Subgraph not supported yet.
            // const graphs = [];
            // for (let i = 0; i < attr.graphsLength(); i++) {
            //   graphs.push(attr.graphs(i)!);
            // }
            // return graphs;
            default:
                throw new Error(`unsupported attribute type: ${ortFbs.AttributeType[attr.type()]}`);
        }
    }
}
exports.Attribute = Attribute;


/***/ }),

/***/ "./lib/onnxjs/backend.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/backend.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveBackend = exports.backend = void 0;
const backend_webgl_1 = __webpack_require__(/*! ./backends/backend-webgl */ "./lib/onnxjs/backends/backend-webgl.ts");
// caches all initialized backend instances
const backendsCache = new Map();
exports.backend = {
    webgl: new backend_webgl_1.WebGLBackend(),
};
/**
 * Resolve a reference to the backend. If a hint is specified, the corresponding
 * backend will be used.
 */
function resolveBackend(hint) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!hint) {
            return resolveBackend(['webgl']);
        }
        else {
            const hints = typeof hint === 'string' ? [hint] : hint;
            for (const backendHint of hints) {
                const cache = backendsCache.get(backendHint);
                if (cache) {
                    return cache;
                }
                const backend = yield tryLoadBackend(backendHint);
                if (backend) {
                    return backend;
                }
            }
        }
        throw new Error('no available backend to use');
    });
}
exports.resolveBackend = resolveBackend;
function tryLoadBackend(backendHint) {
    return __awaiter(this, void 0, void 0, function* () {
        const backendObj = exports.backend;
        if (typeof backendObj[backendHint] !== 'undefined' && isBackend(backendObj[backendHint])) {
            const backend = backendObj[backendHint];
            let init = backend.initialize();
            if (typeof init === 'object' && 'then' in init) {
                init = yield init;
            }
            if (init) {
                backendsCache.set(backendHint, backend);
                return backend;
            }
        }
        return undefined;
    });
}
function isBackend(obj) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const o = obj;
    // check if an object is a Backend instance
    if ('initialize' in o && typeof o.initialize === 'function' && // initialize()
        'createSessionHandler' in o && typeof o.createSessionHandler === 'function' && // createSessionHandler()
        'dispose' in o && typeof o.dispose === 'function' // dispose()
    ) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./lib/onnxjs/backends/backend-webgl.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/backend-webgl.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLBackend = void 0;
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const instrument_1 = __webpack_require__(/*! ../instrument */ "./lib/onnxjs/instrument.ts");
const session_handler_1 = __webpack_require__(/*! ./webgl/session-handler */ "./lib/onnxjs/backends/webgl/session-handler.ts");
const webgl_context_factory_1 = __webpack_require__(/*! ./webgl/webgl-context-factory */ "./lib/onnxjs/backends/webgl/webgl-context-factory.ts");
/**
 * WebGLBackend is the entry point for all WebGL opeartions
 * When it starts it created the WebGLRenderingContext
 * and other main framework components such as Program and Texture Managers
 */
class WebGLBackend {
    get contextId() {
        return onnxruntime_common_1.env.webgl.contextId;
    }
    set contextId(value) {
        onnxruntime_common_1.env.webgl.contextId = value;
    }
    get matmulMaxBatchSize() {
        return onnxruntime_common_1.env.webgl.matmulMaxBatchSize;
    }
    set matmulMaxBatchSize(value) {
        onnxruntime_common_1.env.webgl.matmulMaxBatchSize = value;
    }
    get textureCacheMode() {
        return onnxruntime_common_1.env.webgl.textureCacheMode;
    }
    set textureCacheMode(value) {
        onnxruntime_common_1.env.webgl.textureCacheMode = value;
    }
    get pack() {
        return onnxruntime_common_1.env.webgl.pack;
    }
    set pack(value) {
        onnxruntime_common_1.env.webgl.pack = value;
    }
    initialize() {
        try {
            this.glContext = webgl_context_factory_1.createWebGLContext(this.contextId);
            if (typeof this.matmulMaxBatchSize !== 'number') {
                this.matmulMaxBatchSize = 16;
            }
            if (typeof this.textureCacheMode !== 'string') {
                this.textureCacheMode = 'full';
            }
            if (typeof this.pack !== 'boolean') {
                this.pack = false;
            }
            instrument_1.Logger.setWithEnv(onnxruntime_common_1.env);
            instrument_1.Logger.verbose('WebGLBackend', `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}.`);
            return true;
        }
        catch (e) {
            instrument_1.Logger.warning('WebGLBackend', `Unable to initialize WebGLBackend. ${e}`);
            return false;
        }
    }
    createSessionHandler(context) {
        return new session_handler_1.WebGLSessionHandler(this, context);
    }
    dispose() {
        this.glContext.dispose();
    }
}
exports.WebGLBackend = WebGLBackend;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts":
/*!**********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoordsGlslLib = void 0;
const util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
const glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
const glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const texture_layout_strategy_1 = __webpack_require__(/*! ./texture-layout-strategy */ "./lib/onnxjs/backends/webgl/texture-layout-strategy.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const utils_2 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const utils_3 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
/**
 * GLSL Library responsible for data types and routines for manipulating
 * coordinates and mapping to/from tensor indices
 */
class CoordsGlslLib extends glsl_definitions_1.GlslLib {
    constructor(context) {
        super(context);
    }
    getFunctions() {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
    }
    getCustomTypes() {
        return {};
    }
    /**
     * Produces a function that can map from
     * 2D normalzied coordinates (s,t) to a flat offset
     */
    offsetToCoords() {
        const funcName = 'offsetToCoords';
        return {
            offsetToCoords: new glsl_definitions_1.GlslLibRoutine(`
      vec2 ${funcName}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)
        };
    }
    /**
     * Produces a function that can map from
     * 2D normalzied coordinates (s,t) to a flat offset
     */
    coordsToOffset() {
        const funcName = 'coordsToOffset';
        return {
            coordsToOffset: new glsl_definitions_1.GlslLibRoutine(`
      int ${funcName}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)
        };
    }
    /**
     * Generates code for output sampler.
     */
    getOutputSamplingSnippet() {
        const outputLayout = this.context.programInfo.outputLayout;
        if (outputLayout.isPacked) {
            return this.getPackedOutputSamplingSnippet(outputLayout);
        }
        else {
            return this.getUnpackedOutputSamplingSnippet(outputLayout);
        }
    }
    /**
     * Generates code for packed output sampler.
     */
    getPackedOutputSamplingSnippet(outputLayout) {
        const outShape = outputLayout.unpackedShape;
        const outTexShape = [outputLayout.width, outputLayout.height];
        const result = {};
        const funcName = 'getOutputCoords';
        switch (outShape.length) {
            case 0:
                result[funcName] = this.getOutputScalarCoords();
                break;
            case 1:
                result[funcName] = this.getOutputPacked1DCoords(outShape, outTexShape);
                break;
            case 2:
                result[funcName] = this.getOutputPacked2DCoords(outShape, outTexShape);
                break;
            case 3:
                result[funcName] =
                    this.getOutputPacked3DCoords(outShape, outTexShape);
                break;
            default:
                result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape);
        }
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        // TODO we need this to properly return a packed vec4 from kernels.
        // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.
        const floatTextureSetRGBASource = `
      void setOutput(vec4 val) {
        ${glsl.output} = val;
      }
    `;
        const floatTextureSetRGBAFuncName = 'floatTextureSetRGBA';
        result[floatTextureSetRGBAFuncName] = new glsl_definitions_1.GlslLibRoutine(floatTextureSetRGBASource);
        return result;
    }
    /**
     * Generates code for unpacked output sampler.
     */
    getUnpackedOutputSamplingSnippet(outputLayout) {
        const outShape = outputLayout.unpackedShape;
        const outTexShape = [outputLayout.width, outputLayout.height];
        const result = {};
        const funcName = 'getOutputCoords';
        switch (outShape.length) {
            case 0:
                result[funcName] = this.getOutputScalarCoords();
                break;
            case 1:
                result[funcName] = this.getOutputUnpacked1DCoords(outShape, outTexShape);
                break;
            case 2:
                result[funcName] =
                    this.getOutputUnpacked2DCoords(outShape, outTexShape);
                break;
            case 3:
                result[funcName] =
                    this.getOutputUnpacked3DCoords(outShape, outTexShape);
                break;
            case 4:
                result[funcName] = this.getOutputUnpacked4DCoords(outShape, outTexShape);
                break;
            case 5:
                result[funcName] = this.getOutputUnpacked5DCoords(outShape, outTexShape);
                break;
            case 6:
                result[funcName] = this.getOutputUnpacked6DCoords(outShape, outTexShape);
                break;
            default:
                throw new Error(`Unsupported output dimensionality: ${outShape.length}`);
        }
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        // TODO we need this to properly return a packed vec4 from kernels.
        // Replace all '{glsl.output} = result' with 'setOutput(result)' in all kernels.
        const floatTextureSetRSource = `
        void setOutput(float val) {
          ${glsl.output} = vec4(val, 0, 0, 0);
        }
    `;
        const floatTextureSetRFuncName = 'floatTextureSetR';
        result[floatTextureSetRFuncName] = new glsl_definitions_1.GlslLibRoutine(floatTextureSetRSource);
        return result;
    }
    /**
     * Scalar output coordinates.
     */
    getOutputScalarCoords() {
        return new glsl_definitions_1.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `);
    }
    /**
     * 1D packed output coordinates.
     */
    getOutputPacked1DCoords(shape, texShape) {
        const packedTexShape = texShape;
        let source = '';
        if (packedTexShape[0] === 1) {
            source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source);
        }
        if (packedTexShape[1] === 1) {
            source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source);
        }
        source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * 2D packed output coordinates.
     */
    getOutputPacked2DCoords(shape, texShape) {
        let source = '';
        if (util_1.ArrayUtil.arraysEqual(shape, texShape)) {
            source = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));
        }
      `;
            return new glsl_definitions_1.GlslLibRoutine(source);
        }
        const packedTexShape = texShape;
        // texels needed to accommodate a logical row
        const texelsInLogicalRow = Math.ceil(shape[1] / 2);
        /**
         * getOutputCoords
         *
         * resTexRC: The rows and columns of the texels. If you move over one
         * texel to the right in the packed texture, you are moving over one column
         * (not two).
         *
         * index: The texel index
         */
        source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec2(r, c);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * 3D packed output coordinates.
     */
    getOutputPacked3DCoords(shape, texShape) {
        const packedTexShape = [texShape[0], texShape[1]];
        const texelsInLogicalRow = Math.ceil(shape[2] / 2);
        const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
        const source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          int b = index / ${texelsInBatch};
          index -= b * ${texelsInBatch};

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec3(b, r, c);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * ND packed output coordinates.
     */
    getOutputPackedNDCoords(shape, texShape) {
        const packedTexShape = [texShape[0], texShape[1]];
        const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
        const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
        let texelsInBatchN = texelsInBatch;
        let batches = '';
        let coords = 'b, r, c';
        for (let b = 2; b < shape.length - 1; b++) {
            texelsInBatchN *= shape[shape.length - b - 1];
            batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
            coords = `b${b}, ` + coords;
        }
        const source = `
      ivec${shape.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

        ${batches}

        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};

        // reverse r and c order for packed texture
        int r = imod(index, ${texelsInLogicalRow}) * 2;
        int c = 2 * (index / ${texelsInLogicalRow});

        return ivec${shape.length}(${coords});
      }
    `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked 1D output coordinates.
     */
    getOutputUnpacked1DCoords(shape, texShape) {
        const source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          return resTexRC.y * ${texShape[0]} + resTexRC.x;
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked 2D output coordinates.
     */
    getOutputUnpacked2DCoords(shape, texShape) {
        const source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          int r = index / ${shape[1]};
          int c = index - r * ${shape[1]};
          return ivec2(r, c);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked 3D output coordinates.
     */
    getOutputUnpacked3DCoords(shape, texShape) {
        let source = '';
        const rank = shape.length;
        let strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        const coordsToCompute = ['r', 'c', 'd'];
        const coordsFromIndexSnippet = strides
            .map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ?
                `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :
                `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
        })
            .join('');
        source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec3(r, c, d);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked 4D output coordinates.
     */
    getOutputUnpacked4DCoords(shape, texShape) {
        let source = '';
        const rank = shape.length;
        let strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        const coordsToCompute = ['r', 'c', 'd', 'd2'];
        const coordsFromIndexSnippet = strides
            .map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ?
                `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :
                `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
        })
            .join('');
        source = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec4(r, c, d, d2);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked 5D output coordinates.
     */
    getOutputUnpacked5DCoords(shape, texShape) {
        let source = '';
        const rank = shape.length;
        let strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3'];
        const coordsFromIndexSnippet = strides
            .map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ?
                `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :
                `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
        })
            .join('');
        source = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec5(r, c, d, d2, d3);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked 6D output coordinates.
     */
    getOutputUnpacked6DCoords(shape, texShape) {
        let source = '';
        const rank = shape.length;
        let strides = null;
        if (rank < 2) {
            strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        const coordsToCompute = ['r', 'c', 'd', 'd2', 'd3', 'd4'];
        const coordsFromIndexSnippet = strides
            .map((stride, i) => {
            const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
            const line2 = i === strides.length - 1 ?
                `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` :
                `index -= ${coordsToCompute[i]} * ${stride}`;
            return `${line1}; ${line2};`;
        })
            .join('');
        source = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${texShape[0]}, ${texShape[1]}));
         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
         ${coordsFromIndexSnippet}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Generates code for common UV coords computation utility functions.
     */
    getCommonUtilFuncs() {
        const result = {};
        let funcName = 'uvFromFlat';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `);
        funcName = 'packedUVfrom1D';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = 'packedUVfrom2D';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = 'packedUVfrom3D';
        result[funcName] = new glsl_definitions_1.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = 'sampleTexture';
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        result[funcName] = new glsl_definitions_1.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${glsl.texture2D}(textureSampler, uv).r;
        }`);
        return result;
    }
    /**
     * Constructing snippets for inputs
     */
    getInputsSamplingSnippets() {
        const result = {};
        const outputLayout = this.context.programInfo.outputLayout;
        this.context.programInfo.samplers.forEach((samplerName, i) => {
            const inputLayout = this.context.programInfo.inputLayouts[i];
            const funcName = utils_1.generateShaderFuncNameFromInputSamplerName(samplerName);
            if (inputLayout.isPacked) {
                result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);
            }
            else {
                result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);
            }
            const outCoordFuncName = utils_2.generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);
            if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {
                if (inputLayout.isPacked) {
                    result[outCoordFuncName] =
                        this.getPackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
                }
                else {
                    result[outCoordFuncName] =
                        this.getUnpackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
                }
            }
        });
        return result;
    }
    /**
     * Constructing snippets for output coordinates of samplers
     */
    getPackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name) {
        const inShape = inputLayout.unpackedShape;
        const outShape = outputLayout.unpackedShape;
        const texName = name;
        const texFuncSnippet = utils_1.generateShaderFuncNameFromInputSamplerName(texName);
        const inRank = inShape.length;
        const outRank = outShape.length;
        const broadcastDims = util_1.BroadcastUtil.getBroadcastDims(inShape, outShape);
        const type = utils_3.getCoordsDataType(outRank);
        const rankDiff = outRank - inRank;
        let coordsSnippet;
        const fields = ['x', 'y', 'z', 'w', 'u', 'v'];
        if (inRank === 0) {
            coordsSnippet = '';
        }
        else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = 'coords = 0;';
        }
        else {
            coordsSnippet = broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`).join('\n');
        }
        let unpackedCoordsSnippet = '';
        if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = 'coords';
        }
        else {
            unpackedCoordsSnippet = inShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(', ');
        }
        let output = 'return outputValue;';
        const inSize = util_1.ShapeUtil.size(inShape);
        const isInputScalar = inSize === 1;
        const outSize = util_1.ShapeUtil.size(outShape);
        const isOutputScalar = outSize === 1;
        if (inRank === 1 && !isInputScalar && !isOutputScalar) {
            output = `
        return vec4(outputValue.xx, outputValue.yy);
      `;
        }
        else if (isInputScalar && !isOutputScalar) {
            if (outRank === 1) {
                output = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `;
            }
            else {
                output = `
          return vec4(outputValue.x);
        `;
            }
        }
        else if (broadcastDims.length) {
            const rows = inRank - 2;
            const cols = inRank - 1;
            if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
                output = 'return vec4(outputValue.x);';
            }
            else if (broadcastDims.indexOf(rows) > -1) {
                output = 'return vec4(outputValue.x, outputValue.y, ' +
                    'outputValue.x, outputValue.y);';
            }
            else if (broadcastDims.indexOf(cols) > -1) {
                output = 'return vec4(outputValue.xx, outputValue.zz);';
            }
        }
        const source = `
      vec4 ${funcName}() {
        ${type} coords = getOutputCoords();
        ${coordsSnippet}
        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});
        ${output}
      }
    `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.getOutputCoords']);
    }
    /**
     * Constructing snippets for unpacked output coordinates of samplers
     */
    getUnpackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name) {
        const outTexShape = [outputLayout.width, outputLayout.height];
        const inTexShape = [inputLayout.width, inputLayout.height];
        const inRank = inputLayout.unpackedShape.length;
        const outRank = outputLayout.unpackedShape.length;
        const inShape = inputLayout.unpackedShape;
        const outShape = outputLayout.unpackedShape;
        const texFuncSnippet = utils_1.generateShaderFuncNameFromInputSamplerName(name);
        if (inRank === outRank && util_1.ArrayUtil.arraysEqual(inTexShape, outTexShape)) {
            const source = `
          float ${funcName}() {
            return sampleTexture(${name}, TexCoords);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        const type = utils_3.getCoordsDataType(outRank);
        const broadcastDims = util_1.BroadcastUtil.getBroadcastDims(inShape, outShape);
        const rankDiff = outRank - inRank;
        let coordsSnippet;
        const fields = ['x', 'y', 'z', 'w', 'u', 'v'];
        if (inRank === 0) {
            coordsSnippet = '';
        }
        else if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = 'coords = 0;';
        }
        else {
            coordsSnippet = broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`).join('\n');
        }
        let unpackedCoordsSnippet = '';
        if (outRank < 2 && inRank > 0) {
            unpackedCoordsSnippet = 'coords';
        }
        else {
            unpackedCoordsSnippet = inputLayout.unpackedShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(', ');
        }
        const source = `
        float ${funcName}() {
          ${type} coords = getOutputCoords();
          ${coordsSnippet}
          return ${texFuncSnippet}(${unpackedCoordsSnippet});
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.getOutputCoords']);
    }
    /**
     * Constructing snippets for packed operations.
     */
    getPackedSamplerFromInput(funcName, name, inputLayout) {
        switch (inputLayout.unpackedShape.length) {
            case 0:
                return this.getPackedSamplerScalar(funcName, name);
            case 1:
                return this.getPackedSampler1D(funcName, name, inputLayout);
            case 2:
                return this.getPackedSampler2D(funcName, name, inputLayout);
            case 3:
                return this.getPackedSampler3D(funcName, name, inputLayout);
            default:
                return this.getPackedSamplerND(funcName, name, inputLayout);
        }
    }
    /**
     * Constructing snippets for unpacked operations.
     */
    getUnpackedSamplerFromInput(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        switch (shape.length) {
            case 0:
                return this.getUnpackedSamplerScalar(funcName, name, inputLayout);
            case 1:
                return this.getUnpackedSampler1D(funcName, name, inputLayout);
            case 2:
                return this.getUnpackedSampler2D(funcName, name, inputLayout);
            case 3:
                return this.getUnpackedSampler3D(funcName, name, inputLayout);
            case 4:
                return this.getUnpackedSampler4D(funcName, name, inputLayout);
            case 5:
                return this.getUnpackedSampler5D(funcName, name, inputLayout);
            case 6:
                return this.getUnpackedSampler6D(funcName, name, inputLayout);
            default:
                // TODO support more dimensionalities
                throw new Error(`Unsupported dimension ${shape.length}-D`);
        }
    }
    /**
     * Packed scalar snippet.
     */
    getPackedSamplerScalar(funcName, name) {
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        const source = `
          vec4 ${funcName}() {
            return ${glsl.texture2D}(${name}, halfCR);
          }
        `;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Packed 1D snippet.
     */
    getPackedSampler1D(funcName, name, inputLayout) {
        const texShape = [inputLayout.width, inputLayout.height];
        const packedTexShape = [texShape[1], texShape[0]];
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        const packedSampler = `vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
      ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${name}, uv);
    }`;
        const source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.packedUVfrom1D']);
    }
    /**
     * Packed 2D snippet.
     */
    getPackedSampler2D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const texShape = [inputLayout.width, inputLayout.height];
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        const texNumR = texShape[0];
        const texNumC = texShape[1];
        if (texShape != null && util_1.ArrayUtil.arraysEqual(shape, texShape)) {
            const packedSampler = `vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
        return ${glsl.texture2D}(${name}, uv);
      }`;
            return new glsl_definitions_1.GlslLibRoutine(packedSampler);
        }
        const packedTexShape = texShape;
        const valuesPerRow = Math.ceil(shape[1] / 2);
        const packedSampler = `vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);
      return ${glsl.texture2D}(${name}, uv);
    }`;
        const source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.packedUVfrom2D']);
    }
    /**
     * Packed 3D snippet.
     */
    getPackedSampler3D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const texShape = [inputLayout.width, inputLayout.height];
        const packedTexShape = [texShape[0], texShape[1]];
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        if (shape[0] === 1) {
            const squeezedShape = shape.slice(1);
            const keptDims = [1, 2];
            const newInputShape = utils_3.squeezeInputShape(shape, squeezedShape);
            const params = ['b', 'row', 'col'];
            // Deep copy of input texture layout.
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const samplerRoutine = this.getPackedSamplerFromInput(funcName, name, newInputLayout);
            const packedSampler = `${samplerRoutine.routineBody}
      vec4 ${funcName}(int b, int row, int col) {
        return ${funcName}(${utils_3.getSqueezedParams(params, keptDims)});
      } `;
            const source = packedSampler;
            return new glsl_definitions_1.GlslLibRoutine(source, samplerRoutine.dependencies);
        }
        const texNumR = packedTexShape[0];
        const texNumC = packedTexShape[1];
        const valuesPerRow = Math.ceil(shape[2] / 2);
        const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
        const packedSampler = `vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${name}, uv);}`;
        const source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.packedUVfrom3D']);
    }
    /*
     * Packed ND snippet.
     */
    getPackedSamplerND(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const rank = shape.length;
        const texShape = [inputLayout.width, inputLayout.height];
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        const packedTexShape = [texShape[0], texShape[1]];
        const texNumR = packedTexShape[1];
        const texNumC = packedTexShape[0];
        const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
        let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
        let params = 'int b, int row, int col';
        let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
        for (let b = 2; b < rank - 1; b++) {
            params = `int b${b}, ` + params;
            texelsInBatch *= shape[rank - b - 1];
            index = `b${b} * ${texelsInBatch} + ` + index;
        }
        const packedSampler = `vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${name}, uv);
    }`;
        const source = packedSampler;
        return new glsl_definitions_1.GlslLibRoutine(source);
    }
    /**
     * Unpacked scalar snippet.
     */
    getUnpackedSamplerScalar(funcName, name, inputLayout) {
        const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];
        if (texNumR === 1 && texNumC === 1) {
            const source = `
          float ${funcName}() {
            return sampleTexture(${name}, halfCR);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        const source = `
        float ${funcName}() {
          int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name});
          return sampleTexture(${name}, uv);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    }
    /**
     * Unpacked 1D snippet.
     */
    getUnpackedSampler1D(funcName, name, inputLayout) {
        const tNumR = inputLayout.width;
        const tNumC = inputLayout.height;
        if (tNumC === 1 && tNumR === 1) {
            const source = `
        float ${funcName}(int index) {
          return sampleTexture(${name}, halfCR);
        }
      `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        if (tNumC === 1) {
            const source = `
          float ${funcName}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);
            return sampleTexture(${name}, uv);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        if (tNumR === 1) {
            const source = `
          float ${funcName}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);
            return sampleTexture(${name}, uv);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        const source = `
        float ${funcName}(int index) {
          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);
          return sampleTexture(${name}, uv);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);
    }
    /**
     * Unpacked 2D snippet.
     */
    getUnpackedSampler2D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        // TODO: modify row/col order for other dimensions.
        const texShape = [inputLayout.height, inputLayout.width];
        if (texShape != null && util_1.ArrayUtil.arraysEqual(shape, texShape)) {
            const texNumR = texShape[1];
            const texNumC = texShape[0];
            const source = `
          float ${funcName}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR}.0, ${texNumC}.0);
            return sampleTexture(${name}, uv);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        const { newShape, keptDims } = texture_layout_strategy_1.squeezeShape(shape);
        const squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            const newInputShape = utils_3.squeezeInputShape(shape, squeezedShape);
            // Deep copy of input texture layout.
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const params = ['col', 'row'];
            const source = `
          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}
          float ${funcName}(int row, int col) {
            return ${funcName}(${utils_3.getSqueezedParams(params, keptDims)});
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture']);
        }
        const texNumR = texShape[1];
        const texNumC = texShape[0];
        if (texNumC === 1) {
            const source = `
          float ${funcName}(int row, int col) {
            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
            return sampleTexture(${name}, uv);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);
        }
        if (texNumR === 1) {
            const source = `
          float ${funcName}(int row, int col) {
            int offset_${name} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name}), vec3(${shape[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
            return sampleTexture(${name}, uv);
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.coordsToOffset']);
        }
        const source = `
        float ${funcName}(int row, int col) {
          int index = col * ${shape[1]} + row;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name}, uv);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    }
    /**
     * Unpacked 3D snippet.
     */
    getUnpackedSampler3D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const stride0 = shape[1] * shape[2];
        const stride1 = shape[2];
        const { newShape, keptDims } = texture_layout_strategy_1.squeezeShape(shape);
        const squeezedShape = newShape;
        if (squeezedShape.length < shape.length) {
            const newInputShape = utils_3.squeezeInputShape(shape, squeezedShape);
            const params = ['batch', 'col', 'row'];
            // Deep copy of input texture layout.
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const routine = this.getUnpackedSamplerFromInput(funcName, name, newInputLayout);
            // TODO: revisit the logic here to make it simpler
            const revDims = keptDims.reverse();
            const source = `
          ${routine.routineBody}
          float ${funcName}(int batch, int row, int col) {
            return ${funcName}(${utils_3.getSqueezedParams(params, revDims)});
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, routine.dependencies);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
          float ${funcName}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${stride0} + col * ${stride1} + row;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name}, uv);
          }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    }
    /**
     * Unpacked 4D snippet.
     */
    getUnpackedSampler4D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const stride2 = shape[3];
        const stride1 = shape[2] * stride2;
        const stride0 = shape[1] * stride1;
        //
        // TODO: re-enable this shortcut once the index calculation bug is fixed.
        //
        // const {newShape, keptDims} = squeezeShape(shape as number[]);
        // if (newShape.length < shape.length) {
        //   const newInputShape = squeezeInputShape(shape, newShape);
        //   const params = ['row', 'col', 'depth', 'depth2'];
        //   // Deep copy of input texture layout.
        //   const newInputLayout: TextureLayout = JSON.parse(JSON.stringify(inputLayout));
        //   newInputLayout.unpackedShape = newInputShape;
        //   const source = `
        //       ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}
        //       float ${funcName}(int row, int col, int depth, int depth2) {
        //         return ${funcName}(${getSqueezedParams(params, keptDims)});
        //       }
        //     `;
        //   return new GlslLibRoutine(
        //       source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
        // }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
        float ${funcName}(int row, int col, int depth, int depth2) {
          int index = row * ${stride0} + col * ${stride1} +
              depth2 * ${stride2} + depth;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name}, uv);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture']);
    }
    /**
     * Unpacked 5D snippet.
     */
    getUnpackedSampler5D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const stride3 = shape[4];
        const stride2 = shape[3] * stride3;
        const stride1 = shape[2] * stride2;
        const stride0 = shape[1] * stride1;
        const { newShape, keptDims } = texture_layout_strategy_1.squeezeShape(shape);
        if (newShape.length < shape.length) {
            const newInputShape = utils_3.squeezeInputShape(shape, newShape);
            const params = ['row', 'col', 'depth', 'depth2', 'depth3'];
            // Deep copy of input texture layout.
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const source = `
          ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}
          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
            return ${funcName}(${utils_3.getSqueezedParams(params, keptDims)});
          }
        `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth3 * ${stride3} + depth2;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name}, uv);
        }
      `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);
    }
    /**
     * Unpacked 6D snippet.
     */
    getUnpackedSampler6D(funcName, name, inputLayout) {
        const shape = inputLayout.unpackedShape;
        const stride4 = shape[5];
        const stride3 = shape[4] * stride4;
        const stride2 = shape[3] * stride3;
        const stride1 = shape[2] * stride2;
        const stride0 = shape[1] * stride1;
        const { newShape, keptDims } = texture_layout_strategy_1.squeezeShape(shape);
        if (newShape.length < shape.length) {
            const newInputShape = utils_3.squeezeInputShape(shape, newShape);
            const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];
            // Deep copy of input texture layout.
            const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
            newInputLayout.unpackedShape = newInputShape;
            const source = `
            ${this.getUnpackedSamplerFromInput(funcName, name, newInputLayout).routineBody}
            float ${funcName}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${funcName}(${utils_3.getSqueezedParams(params, keptDims)});
            }
          `;
            return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.sampleTexture', 'coordinates.uvFromFlat']);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
          float ${funcName}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 * ${stride4} + depth4;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name}, uv);
          }
        `;
        return new glsl_definitions_1.GlslLibRoutine(source, ['coordinates.uvFromFlat', 'coordinates.sampleTexture', 'coordinates.coordsToOffset']);
    }
    /**
     * This is the main function to map from the given texture coordiantes (s,t)
     * to logical indices for the output
     * There will only be one single variation of this
     * Also see coordsToOffset and offsetToIndices for input-specific versions
     */
    toVec() {
        const output = this.context.programInfo.outputLayout;
        const rank = output.shape.length;
        const strides = output.strides;
        const xScale = output.width;
        const yScale = output.height;
        const stridesBlock = [];
        for (let i = 0; i < rank - 1; ++i) {
            stridesBlock.push(`
        c[${i}] = offset / ${strides[i]};`);
            stridesBlock.push(`
        offset -= c[${i}] * ${strides[i]};`);
        }
        stridesBlock.push(`
        c[${rank - 1}] = offset;`);
        const body = `
      void toVec(vec2 texCoords, out int c[${rank}]) {
        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});
        ${stridesBlock.join('')}
      }
      void toVec(int offset, out int c[${rank}]) {
        ${stridesBlock.join('')}
      }
    `;
        return { toVec: new glsl_definitions_1.GlslLibRoutine(body, ['coordinates.coordsToOffset']) };
    }
    /**
     * These are value getter functions generated for each input
     * Each function is hardwired to the name and dimensions of the input
     * An '_T' variation is also produced which accesses values as if the
     * input was transposed
     */
    valueFrom() {
        const programInfo = this.context.programInfo;
        const result = {};
        this.context.programInfo.samplers.forEach((name, i) => {
            const layout = programInfo.inputLayouts[i];
            const shape = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;
            const rank = shape.length;
            let funcName = `_${name}`;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(this.getValueFromSingle(name, rank, layout.width, layout.height, false), [`shapeUtils.indicesToOffset${funcName}`, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);
            funcName = funcName + '_T';
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(this.getValueFromSingle(name, rank, layout.width, layout.height, true), [`shapeUtils.indicesToOffset${funcName}`, 'coordinates.offsetToCoords', 'fragcolor.getColorAsFloat']);
        });
        return result;
    }
    /**
     * Produces one value getter function for the name and rank given
     * If a transpose is set proper offsetToCoords mapping will be used
     * @param name name of the function
     * @param rank rank of the input
     * @param transpose whether or not should generate a transpose variation
     */
    getValueFromSingle(varName, rank, width, height, transpose) {
        let name = `_${varName}`;
        if (transpose) {
            name = name + '_T';
        }
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        return `
        float ${name}(int m[${rank}]) {
          int offset = indicesToOffset${name}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));
          return value;
        }
        `;
    }
    /**
     * Produces a packed value getter function for the name and rank given
     * If a transpose is set proper offsetToCoords mapping will be used
     * @param name name of the function
     * @param rank rank of the input
     * @param transpose whether or not should generate a transpose variation
     */
    getPackedValueFrom(varName, rank, width, height, transpose) {
        let name = `_${varName}_Pack`;
        if (transpose) {
            name = name + '_T';
        }
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        return `
        vec4 ${name}(int m[${rank}]) {
          int offset = indicesToOffset_${varName}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          return ${glsl.texture2D}(${varName}, coords);
        }
        `;
    }
}
exports.CoordsGlslLib = CoordsGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-definitions.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-definitions.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TopologicalSortGlslRoutines = exports.GlslLibRoutineNode = exports.GlslLibRoutine = exports.GlslLib = exports.GlslContext = exports.FunctionType = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
var FunctionType;
(function (FunctionType) {
    FunctionType[FunctionType["ValueBased"] = 0] = "ValueBased";
    FunctionType[FunctionType["Positional"] = 1] = "Positional";
})(FunctionType = exports.FunctionType || (exports.FunctionType = {}));
class GlslContext {
    constructor(glContext, programInfo) {
        this.glContext = glContext;
        this.programInfo = programInfo;
    }
}
exports.GlslContext = GlslContext;
class GlslLib {
    constructor(context) {
        this.context = context;
    }
}
exports.GlslLib = GlslLib;
// abstraction to represent a GLSL library routine and it's dependencies
class GlslLibRoutine {
    constructor(routineBody, dependencies) {
        this.routineBody = routineBody;
        this.dependencies = dependencies;
    }
}
exports.GlslLibRoutine = GlslLibRoutine;
// abstraction to represent a GLSL library routine and it's dependencies AS GRAPH Nodes
// this level of abstraction is used to topologically sort routines before fragment shade inclusion
class GlslLibRoutineNode {
    constructor(name, routineBody, dependencies) {
        this.name = name;
        if (dependencies) {
            this.dependencies = dependencies;
        }
        else {
            this.dependencies = [];
        }
        if (routineBody) {
            this.routineBody = routineBody;
        }
    }
    addDependency(node) {
        if (node) {
            this.dependencies.push(node);
        }
    }
}
exports.GlslLibRoutineNode = GlslLibRoutineNode;
// topologically sort GLSL library routines (graph nodes abstraction) before shader script inclusion
class TopologicalSortGlslRoutines {
    static returnOrderedNodes(nodes) {
        if (!nodes || nodes.length === 0) {
            return [];
        }
        if (nodes.length === 1) {
            return nodes;
        }
        const cycleCheck = new Set();
        const alreadyTraversed = new Set();
        const result = new Array();
        this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);
        return result;
    }
    static createOrderedNodes(graphNodes, cycleCheck, alreadyTraversed, result) {
        for (let i = 0; i < graphNodes.length; ++i) {
            this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);
        }
    }
    static dfsTraverse(root, cycleCheck, alreadyTraversed, result) {
        // if this root has already been traversed return
        if (!root || alreadyTraversed.has(root.name)) {
            return;
        }
        // cyclic dependency has been detected
        if (cycleCheck.has(root.name)) {
            throw new Error('Cyclic dependency detected. Can\'t topologically sort routines needed for shader.');
        }
        // hold this node to detect cycles if any
        cycleCheck.add(root.name);
        // traverse children in a dfs fashion
        const dependencies = root.dependencies;
        if (dependencies && dependencies.length > 0) {
            for (let i = 0; i < dependencies.length; ++i) {
                this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);
            }
        }
        // add to result holder
        result.push(root);
        // mark this node as traversed so that we don't traverse from this again
        alreadyTraversed.add(root.name);
        // release the hold
        cycleCheck.delete(root.name);
    }
}
exports.TopologicalSortGlslRoutines = TopologicalSortGlslRoutines;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EncodingGlslLib = void 0;
const glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
/**
 * This GLSL library handles routines converting
 * float32 to/from Unsigned byte or float 16
 */
class EncodingGlslLib extends glsl_definitions_1.GlslLib {
    constructor(context) {
        super(context);
    }
    getFunctions() {
        return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
    }
    getCustomTypes() {
        return {};
    }
    encodeFloat32() {
        return {
            encode: new glsl_definitions_1.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)
        };
    }
    decodeFloat32() {
        return {
            decode: new glsl_definitions_1.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)
        };
    }
    /**
     * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)
     * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
     */
    encodeUint8() {
        const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';
        return {
            encode: new glsl_definitions_1.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${endianness}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)
        };
    }
    /**
     * returns the routine to encode a vec4 of unsigned bytes to float32
     * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
     */
    decodeUint8() {
        const endianness = EncodingGlslLib.isLittleEndian() ? 'rgba.rgba=rgba.abgr;' : '';
        return {
            decode: new glsl_definitions_1.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${endianness}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)
        };
    }
    /**
     * Determines if the machine is little endian or not
     * @credit: https://gist.github.com/TooTallNate/4750953
     */
    static isLittleEndian() {
        const b = new ArrayBuffer(4);
        const a = new Uint32Array(b);
        const c = new Uint8Array(b);
        a[0] = 0xdeadbeef;
        if (c[0] === 0xef) {
            return true;
        }
        if (c[0] === 0xde) {
            return false;
        }
        throw new Error('unknown endianness');
    }
}
exports.EncodingGlslLib = EncodingGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts":
/*!*********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FragColorGlslLib = void 0;
const glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
const glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
/**
 * This GLSL library handles routines around reading a texlet and writing to it
 * Reading and writing could be more than just dealing with one channel
 * It may require encoding/decoding to/from 4 channels into one
 */
class FragColorGlslLib extends glsl_definitions_1.GlslLib {
    constructor(context) {
        super(context);
    }
    getFunctions() {
        return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
    }
    getCustomTypes() {
        return {};
    }
    setFragColor() {
        const glsl = glsl_source_1.getGlsl(this.context.glContext.version);
        return {
            setFragColor: new glsl_definitions_1.GlslLibRoutine(`
        void setFragColor(float value) {
            ${glsl.output} = encode(value);
        }
        `, ['encoding.encode'])
        };
    }
    getColorAsFloat() {
        return {
            getColorAsFloat: new glsl_definitions_1.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `, ['encoding.decode'])
        };
    }
}
exports.FragColorGlslLib = FragColorGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-function-inliner.ts":
/*!************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-function-inliner.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceInlines = void 0;
const INLINE_FUNC_DEF_REGEX = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
const FUNC_CALL_REGEX = '(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;';
/**
 * GLSL preprocessor responsible for resolving @inline directives
 */
function replaceInlines(script) {
    const inlineDefs = {};
    let match;
    while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {
        const params = match[3]
            .split(',')
            .map(s => {
            const tokens = s.trim().split(' ');
            if (tokens && tokens.length === 2) {
                return { type: tokens[0], name: tokens[1] };
            }
            return null;
        })
            .filter(v => v !== null);
        inlineDefs[match[2]] = { params, body: match[4] };
    }
    for (const name in inlineDefs) {
        const regexString = FUNC_CALL_REGEX.replace('__FUNC__', name);
        const regex = new RegExp(regexString, 'gm');
        while ((match = regex.exec(script)) !== null) {
            const type = match[1];
            const variable = match[2];
            const params = match[3].split(',');
            const declLine = (type) ? `${type} ${variable};` : '';
            let newBody = inlineDefs[name].body;
            let paramRedecLine = '';
            inlineDefs[name].params.forEach((v, i) => {
                if (v) {
                    paramRedecLine += `${v.type} ${v.name} = ${params[i]};\n`;
                }
            });
            newBody = `${paramRedecLine}\n ${newBody}`;
            newBody = newBody.replace('return', `${variable} = `);
            const replacement = `
      ${declLine}
      {
        ${newBody}
      }
      `;
            script = script.replace(match[0], replacement);
        }
    }
    script = script.replace(INLINE_FUNC_DEF_REGEX, '');
    return script;
}
exports.replaceInlines = replaceInlines;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-preprocessor.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-preprocessor.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlslPreprocessor = void 0;
const glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
const glsl_function_inliner_1 = __webpack_require__(/*! ./glsl-function-inliner */ "./lib/onnxjs/backends/webgl/glsl-function-inliner.ts");
const glsl_registered_libs_1 = __webpack_require__(/*! ./glsl-registered-libs */ "./lib/onnxjs/backends/webgl/glsl-registered-libs.ts");
const glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
/**
 * Preprocessor for the additions to the GLSL language
 * It deals with:
 *  @include directives
 *  @inline
 *  Loop unrolling (not implemented)
 *  Macro resolution (not implemented)
 */
class GlslPreprocessor {
    constructor(glContext, programInfo) {
        this.libs = {};
        this.glslLibRoutineDependencyGraph = {};
        this.context = new glsl_definitions_1.GlslContext(glContext, programInfo);
        // construct GlslLibs
        Object.keys(glsl_registered_libs_1.glslRegistry).forEach((name) => {
            const lib = new glsl_registered_libs_1.glslRegistry[name](this.context);
            this.libs[name] = lib;
        });
        // construct GlslRoutineDependencyGraph
        const map = this.glslLibRoutineDependencyGraph;
        for (const libName in this.libs) {
            const lib = this.libs[libName];
            const routinesInLib = lib.getFunctions();
            for (const routine in routinesInLib) {
                const key = libName + '.' + routine;
                let currentNode;
                if (map[key]) {
                    currentNode = map[key];
                    currentNode.routineBody = routinesInLib[routine].routineBody;
                }
                else {
                    currentNode = new glsl_definitions_1.GlslLibRoutineNode(key, routinesInLib[routine].routineBody);
                    map[key] = currentNode;
                }
                const dependencies = routinesInLib[routine].dependencies;
                if (dependencies) {
                    for (let i = 0; i < dependencies.length; ++i) {
                        if (!map[dependencies[i]]) {
                            const node = new glsl_definitions_1.GlslLibRoutineNode(dependencies[i]);
                            map[dependencies[i]] = node;
                            currentNode.addDependency(node);
                        }
                        else {
                            currentNode.addDependency(map[dependencies[i]]);
                        }
                    }
                }
            }
        }
    }
    preprocess() {
        const programInfo = this.context.programInfo;
        let source = programInfo.shaderSource;
        // append main() function
        if (!this.context.programInfo.hasMain) {
            source = `${source}
      ${glsl_source_1.getDefaultFragShaderMain(this.context.glContext.version, programInfo.outputLayout.shape.length)}`;
        }
        // replace inlines
        source = glsl_function_inliner_1.replaceInlines(source);
        // concat final source string
        return `${glsl_source_1.getFragShaderPreamble(this.context.glContext.version)}
    ${this.getUniforms(programInfo.samplers, programInfo.variables)}
    ${this.getImports(source)}
    ${source}`;
    }
    getImports(script) {
        const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);
        if (routinesIncluded.length === 0) {
            return '';
        }
        let routines = '';
        for (let i = 0; i < routinesIncluded.length; ++i) {
            if (routinesIncluded[i].routineBody) {
                routines += routinesIncluded[i].routineBody + '\n';
            }
            else {
                throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);
            }
        }
        return routines;
    }
    selectGlslLibRoutinesToBeIncluded(script) {
        const nodes = [];
        Object.keys(this.glslLibRoutineDependencyGraph).forEach(classAndRoutine => {
            const routine = classAndRoutine.split('.')[1];
            if (script.indexOf(routine) !== -1) {
                nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);
            }
        });
        return glsl_definitions_1.TopologicalSortGlslRoutines.returnOrderedNodes(nodes);
    }
    getUniforms(samplers, variables) {
        const uniformLines = [];
        if (samplers) {
            for (const sampler of samplers) {
                uniformLines.push(`uniform sampler2D ${sampler};`);
            }
        }
        if (variables) {
            for (const variable of variables) {
                uniformLines.push(`uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ''};`);
            }
        }
        return uniformLines.join('\n');
    }
}
exports.GlslPreprocessor = GlslPreprocessor;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-registered-libs.ts":
/*!***********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-registered-libs.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.glslRegistry = void 0;
const glsl_coordinate_lib_1 = __webpack_require__(/*! ./glsl-coordinate-lib */ "./lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts");
const glsl_encoding_lib_1 = __webpack_require__(/*! ./glsl-encoding-lib */ "./lib/onnxjs/backends/webgl/glsl-encoding-lib.ts");
const glsl_fragcolor_lib_1 = __webpack_require__(/*! ./glsl-fragcolor-lib */ "./lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts");
const glsl_shape_utils_lib_1 = __webpack_require__(/*! ./glsl-shape-utils-lib */ "./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts");
const glsl_vec_lib_1 = __webpack_require__(/*! ./glsl-vec-lib */ "./lib/onnxjs/backends/webgl/glsl-vec-lib.ts");
exports.glslRegistry = {
    'encoding': glsl_encoding_lib_1.EncodingGlslLib,
    'fragcolor': glsl_fragcolor_lib_1.FragColorGlslLib,
    'vec': glsl_vec_lib_1.VecGlslLib,
    'shapeUtils': glsl_shape_utils_lib_1.ShapeUtilsGlslLib,
    'coordinates': glsl_coordinate_lib_1.CoordsGlslLib,
    //  'arrays': ArrayGlslSLib
};


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts":
/*!***********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShapeUtilsGlslLib = void 0;
const glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
/**
 * GLSL Library responsible for data types and routines for manipulating
 * coordinates and mapping to/from tensor indices
 */
class ShapeUtilsGlslLib extends glsl_definitions_1.GlslLib {
    constructor(context) {
        super(context);
    }
    getFunctions() {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
    }
    getCustomTypes() {
        return {};
    }
    bcastIndex() {
        const programInfo = this.context.programInfo;
        const outputRank = programInfo.outputLayout.shape.length;
        const result = {};
        this.context.programInfo.samplers.forEach((name, i) => {
            const shape = programInfo.inputLayouts[i].shape;
            if (shape.length <= outputRank) {
                const rank = shape.length;
                const dimOffset = outputRank - rank;
                const funcName = `bcastIndices_${name}`;
                let block = '';
                for (let i = 0; i < rank; ++i) {
                    block += `
          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );
          `;
                }
                const body = `
        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
        }
        `;
                result[funcName] = new glsl_definitions_1.GlslLibRoutine(body);
            }
        });
        return result;
    }
    bcastMatmulIndex() {
        const programInfo = this.context.programInfo;
        const outputRank = programInfo.outputLayout.shape.length;
        const result = {};
        this.context.programInfo.samplers.forEach((name, i) => {
            const shape = programInfo.inputLayouts[i].shape;
            if (!(shape.length < 2 || shape.length > outputRank)) {
                const rank = shape.length;
                const dimOffset = outputRank - rank;
                const funcName = `bcastMatmulIndices_${name}`;
                let block = '';
                for (let i = 0; i < rank - 2; ++i) {
                    block += `
          realIndices[${i}] = int( mod(float(bcastedIndices[${dimOffset + i}]), ${shape[i]}.0) );
          `;
                }
                const body = `
        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];
          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];
        }
        `;
                result[funcName] = new glsl_definitions_1.GlslLibRoutine(body);
            }
        });
        return result;
    }
    indicesToOffset() {
        const programInfo = this.context.programInfo;
        const result = {};
        this.context.programInfo.samplers.forEach((name, i) => {
            const shape = programInfo.inputLayouts[i].shape;
            const strides = programInfo.inputLayouts[i].strides;
            const rank = shape.length;
            let funcName = `indicesToOffset_${name}`;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));
            funcName = `indicesToOffset_${name}_T`;
            result[funcName] =
                new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
    }
    static indexToOffsetSingle(name, rank, strides) {
        let block = '';
        for (let i = rank - 1; i >= 0; --i) {
            block += `
        offset += indices[${i}] * ${strides[i]};
        `;
        }
        return `
      int ${name}(int indices[${rank}]) {
        int offset = 0;
        ${block}
        return offset;
      }
      `;
    }
    offsetToIndices() {
        const programInfo = this.context.programInfo;
        const result = {};
        this.context.programInfo.samplers.forEach((name, i) => {
            const shape = programInfo.inputLayouts[i].shape;
            const strides = programInfo.inputLayouts[i].strides;
            const rank = shape.length;
            let funcName = `offsetToIndices_${name}`;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));
            funcName = `offsetToIndices_${name}_T`;
            result[funcName] =
                new glsl_definitions_1.GlslLibRoutine(ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
    }
    static offsetToIndicesSingle(name, rank, strides) {
        const stridesBlock = [];
        for (let i = 0; i < rank - 1; ++i) {
            stridesBlock.push(`
      indices[${i}] = offset / ${strides[i]};`);
            stridesBlock.push(`
        offset -= indices[${i}] * ${strides[i]};`);
        }
        stridesBlock.push(`
      indices[${rank - 1}] = offset;`);
        return `
      void ${name}(int offset, out int indices[${rank}]) {
        ${stridesBlock.join('')}
      }
      `;
    }
    incrementIndices() {
        const programInfo = this.context.programInfo;
        const result = {};
        this.context.programInfo.samplers.forEach((name, i) => {
            const shape = programInfo.inputLayouts[i].shape;
            const rank = shape.length;
            const funcName = `incrementIndices_${name}`;
            let shapeInit = '';
            for (let i = 0; i < rank; ++i) {
                shapeInit += `
        shape[${i}] = ${shape[i]};`;
            }
            const body = `
        void ${funcName}(int axis, out int indices[${rank}]) {
          int shape[${rank}];
          ${shapeInit};
          for(int i = ${rank} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
            result[funcName] = new glsl_definitions_1.GlslLibRoutine(body);
        });
        return result;
    }
}
exports.ShapeUtilsGlslLib = ShapeUtilsGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-source.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-source.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultFragShaderMain = exports.getFragShaderPreamble = exports.getVertexShaderSource = exports.getGlsl = void 0;
const GLSL_ES_2_0 = {
    version: '',
    attribute: 'attribute',
    varyingVertex: 'varying',
    varyingFrag: 'varying',
    texture2D: 'texture2D',
    output: 'gl_FragColor',
    outputDeclaration: '',
};
const GLSL_ES_3_0 = {
    version: '#version 300 es',
    attribute: 'in',
    varyingVertex: 'out',
    varyingFrag: 'in',
    texture2D: 'texture',
    output: 'outputColor',
    outputDeclaration: 'out vec4 outputColor;',
};
function getGlsl(version) {
    return version === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;
}
exports.getGlsl = getGlsl;
function getVertexShaderSource(version) {
    const glsl = getGlsl(version);
    return `${glsl.version}
      precision highp float;
      ${glsl.attribute} vec3 position;
      ${glsl.attribute} vec2 textureCoord;

      ${glsl.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
}
exports.getVertexShaderSource = getVertexShaderSource;
function getFragShaderPreamble(version) {
    const glsl = getGlsl(version);
    return `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFrag} vec2 TexCoords;
    ${glsl.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
}
exports.getFragShaderPreamble = getFragShaderPreamble;
function getDefaultFragShaderMain(version, outputShapeLength) {
    const glsl = getGlsl(version);
    return `
  void main() {
    int indices[${outputShapeLength}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${glsl.output} = result;
  }
  `;
}
exports.getDefaultFragShaderMain = getDefaultFragShaderMain;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/glsl-vec-lib.ts":
/*!***************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/glsl-vec-lib.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VecGlslLib = void 0;
const glsl_definitions_1 = __webpack_require__(/*! ./glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
/**
 * GLSL Library responsible for vec routines
 * Vec is an varible length int array. The length is fixed at the time of
 * generating the library functions from the dimensions of the output.
 */
class VecGlslLib extends glsl_definitions_1.GlslLib {
    constructor(context) {
        super(context);
    }
    getCustomTypes() {
        return {};
    }
    getFunctions() {
        return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
    }
    binaryVecFunctions() {
        const outputLayout = this.context.programInfo.outputLayout;
        const rank = outputLayout.shape.length;
        const nameOp = { add: '+=', sub: '-=', mul: '*=', div: '/=' };
        const result = {};
        for (const name in nameOp) {
            const fname = `${name}Vec`;
            let assignmentBlock = '';
            for (let i = 0; i < rank; ++i) {
                assignmentBlock += `
          dest[${i}] ${nameOp[name]} src[${i}];
          `;
            }
            const body = `
        void ${fname}(int src[${rank}], out int dest[${rank}]) {
          ${assignmentBlock}
        }
        `;
            result[fname] = new glsl_definitions_1.GlslLibRoutine(body);
        }
        return result;
    }
    copyVec() {
        const outputLayout = this.context.programInfo.outputLayout;
        const rank = outputLayout.shape.length;
        let assignmentBlock = '';
        for (let i = 0; i < rank; ++i) {
            assignmentBlock += `
        dest[${i}] = src[${i}];
        `;
        }
        const body = `
      void copyVec(int src[${rank}], out int dest[${rank}]) {
        ${assignmentBlock}
      }
      `;
        return { copyVec: new glsl_definitions_1.GlslLibRoutine(body) };
    }
    setVecItem() {
        const outputLayout = this.context.programInfo.outputLayout;
        const rank = outputLayout.shape.length;
        let block = `
        if(index < 0)
            index =${rank} + index;
        if (index == 0)
            m[0] = value;
        `;
        for (let i = 1; i < rank - 1; ++i) {
            block += `
        else if (index == ${i})
            m[${i}] = value;
            `;
        }
        block += `
        else
            m[${rank - 1}] = value;
        `;
        const body = `
      void setVecItem(out int m[${rank}], int index, int value) {
        ${block}
      }
        `;
        return { setVecItem: new glsl_definitions_1.GlslLibRoutine(body) };
    }
    getVecItem() {
        const outputLayout = this.context.programInfo.outputLayout;
        const rank = outputLayout.shape.length;
        let block = `
        if(index < 0)
            index = ${rank} + index;
        if (index == 0)
            return m[0];
      `;
        for (let i = 1; i < rank - 1; ++i) {
            block += `
        else if (index == ${i})
            return m[${i}];
      `;
        }
        block += `
        else
            return m[${rank - 1}];
        `;
        const body = `
      int getVecItem(int m[${rank}], int index) {
        ${block}
      }
    `;
        return { getVecItem: new glsl_definitions_1.GlslLibRoutine(body) };
    }
}
exports.VecGlslLib = VecGlslLib;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/inference-handler.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/inference-handler.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLInferenceHandler = void 0;
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
const tensor_1 = __webpack_require__(/*! ../../tensor */ "./lib/onnxjs/tensor.ts");
const util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
const pack_1 = __webpack_require__(/*! ./ops/pack */ "./lib/onnxjs/backends/webgl/ops/pack.ts");
const uint8_encode_1 = __webpack_require__(/*! ./ops/uint8-encode */ "./lib/onnxjs/backends/webgl/ops/uint8-encode.ts");
const unpack_1 = __webpack_require__(/*! ./ops/unpack */ "./lib/onnxjs/backends/webgl/ops/unpack.ts");
const utils_1 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
class WebGLInferenceHandler {
    constructor(session) {
        this.session = session;
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache = new Map();
        this.pack2unpackMap = new Map();
        this.unpack2packMap = new Map();
    }
    run(op, inputs) {
        var _a;
        let artifact = this.session.programManager.getArtifact(op);
        if (!artifact) {
            const programInfo = op.createProgramInfo(this, inputs);
            if (!programInfo.name) {
                programInfo.name = (_a = op.constructor) === null || _a === void 0 ? void 0 : _a.name;
            }
            artifact = this.session.programManager.build(programInfo);
            this.session.programManager.setArtifact(op, artifact);
        }
        const runData = op.createRunData(this, artifact.programInfo, inputs);
        this.runProgram(artifact, runData);
        return [runData.outputTextureData.tensor];
    }
    checkAndUpdateTextureForm(artifact, runData) {
        // pack/unpack inputs
        for (let i = 0; i < runData.inputTextureDatas.length; ++i) {
            const input = runData.inputTextureDatas[i];
            if (input.isPacked && !artifact.programInfo.expectPackedInputs) {
                runData.inputTextureDatas[i] = this.unpack(input);
            }
            else if (!input.isPacked && artifact.programInfo.expectPackedInputs) {
                runData.inputTextureDatas[i] = this.pack(input);
            }
        }
    }
    runProgram(artifact, runData) {
        this.checkAndUpdateTextureForm(artifact, runData);
        // output should match
        if (!!runData.outputTextureData.isPacked !== !!artifact.programInfo.expectPackedOutputs) {
            throw new Error('output property packed inconsistent');
        }
        this.session.programManager.run(artifact, runData);
    }
    /**
     * Create a TextureData object from a tensor.
     * Usage = Encoder.Usage.UploadOnly.
     * If a related texture data is found in cache, returns it;
     * Otherwise:
     *   Creates a new texture layout if not provided;
     *   Creates WebGLTexture with the layout;
     *   Upload tensor data to the texture;
     *   Creates a texture data object associated with the given tensor.
     * @param tensor the tensor with data to upload
     */
    getOrCreateTextureData(tensor, layout, isPacked = false) {
        let td = this.getTextureData(tensor.dataId, isPacked);
        if (!td) {
            instrument_1.Logger.verbose('InferenceHandler', `Creating new TextureData for dims: [${tensor.dims}]`);
            if (!layout) {
                layout = this.createTextureLayoutFromShape(tensor.dims.slice());
            }
            // if we don't find the texture data with specific pack mode in the cache, try with the different
            // pack mode to see if the tensor is cached using that pack mode. If succeed, we can return this
            // tensor data and later apply a pack/unpack op on this texture, no need to create a new one here.
            td = this.getTextureData(tensor.dataId, !isPacked);
            if (!td) {
                if (isPacked) {
                    const unpackedTextureLayout = this.getOrCreateTextureLayout(tensor, 1, false, [], true);
                    const unpackedTextureData = this.createTextureData(unpackedTextureLayout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
                    td = this.pack(unpackedTextureData);
                }
                else {
                    td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
                }
            }
        }
        else {
            instrument_1.Logger.verbose('InferenceHandler', `Retrieving TextureData from cache: [${tensor.dims}]`);
        }
        return td;
    }
    /**
     * Create a TextureData object from the given data type and texture layout.
     * Usage = Encoder.Usage.Default.
     * @param dataType the tensor data type
     */
    createTextureDataFromLayout(layout, dataType) {
        return this.createTextureData(layout, dataType);
    }
    /**
     * Create a TextureData object using the given data and bind to the given tensor.
     * Usage = Encoder.Usage.UploadOnly.
     * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv
     * implementation by Graph.Transformer
     * @param dataType the tensor data type
     * @param data the actual data to upload
     * @param tensor the tensor to bind. tensor's data is ignored.
     */
    createTextureDataFromLayoutBindTensor(layout, dataType, data, tensor) {
        return this.createTextureData(layout, dataType, data, tensor, 1 /* UploadOnly */);
    }
    createTextureData(layout, dataType, data, tensor, usage) {
        instrument_1.Logger.verbose('InferenceHandler', `Creating TextureData: layout:[${JSON.stringify(layout)}]`);
        const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);
        return this.createTextureDataFromTexture(layout, dataType, texture, tensor);
    }
    /**
     * Create a TextureData object, using the given texture.
     * This function does not create new texture. Usually used in scenarios using texture sharing. (eg. Reshape)
     * @param dataType the tensor data type
     * @param texture the WebGLTexture object to share
     * @param tensorId the tensor ID of the shared tensor data
     */
    createSharedTextureData(layout, dataType, texture, tensorId) {
        return this.createTextureDataFromTexture(layout, dataType, texture, undefined, tensorId);
    }
    createTextureDataFromTexture(layout, dataType, texture, tensor, tensorId) {
        const textureData = Object.assign(Object.assign({}, layout), { tensor: tensor ||
                new tensor_1.Tensor(layout.unpackedShape, dataType, (_id) => this.readTexture(textureData), undefined, undefined, tensorId), texture });
        this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);
        return textureData;
    }
    getTextureData(tensorId, isPacked = false) {
        return this.session.isInitializer(tensorId) ?
            this.session.getTextureData(tensorId, isPacked) :
            isPacked ? this.packedTextureDataCache.get(tensorId) : this.unpackedTextureDataCache.get(tensorId);
    }
    setTextureData(tensorId, td, isPacked = false) {
        if (this.session.isInitializer(tensorId)) {
            this.session.setTextureData(tensorId, td, isPacked);
        }
        else {
            (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);
        }
    }
    isTextureLayoutCached(tensor, isPacked = false) {
        return !!this.getTextureData(tensor.dataId, isPacked);
    }
    /**
     * Create a TextureLayout object from a tensor. If a related texture data is found, returns the cached texture layout.
     */
    getOrCreateTextureLayout(tensor, channels = 1, isPacked = false, unpackedShape, reverseWH = false) {
        const td = this.getTextureData(tensor.dataId, isPacked);
        if (td) {
            return td;
        }
        return this.createTextureLayoutFromShape(channels === 1 || isPacked ? tensor.dims : utils_1.getPackedShape(tensor.dims), channels, unpackedShape, isPacked || reverseWH ? { isPacked, reverseWH } : undefined);
    }
    /**
     * Create a TextureLayout object from shape.
     */
    createTextureLayoutFromShape(shape, channels = 1, unpackedShape, prefs) {
        const isPacked = !!(prefs && prefs.isPacked);
        const [texWidth, texHeight] = this.session.layoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape : shape, prefs);
        let [width, height] = [texWidth, texHeight];
        if (prefs && prefs.reverseWH) {
            width = texHeight;
            height = texWidth;
        }
        const rank = shape.length;
        let inferredDims = shape.slice(0);
        if (rank === 0) {
            inferredDims = [1];
        }
        if (channels === 1) {
            // unpackedShape will take `shape` and not `inferredDims` so as to create a scalar Tensor if need be
            unpackedShape = shape;
        }
        else if (isPacked) {
            if (channels !== 4) {
                throw new Error('a packed texture must be 4-channel');
            }
            unpackedShape = shape;
            if (rank > 0) {
                inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);
            }
            if (rank > 1) {
                inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);
            }
        }
        else if (!unpackedShape) {
            throw new Error('Unpacked shape is needed when using channels > 1');
        }
        return {
            width,
            height,
            channels,
            isPacked,
            shape: inferredDims,
            strides: util_1.ShapeUtil.computeStrides(inferredDims),
            unpackedShape,
            reversedWH: (prefs && prefs.reverseWH)
        };
    }
    dispose() {
        this.session.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach(td => this.session.textureManager.releaseTexture(td));
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache.forEach(td => this.session.textureManager.releaseTexture(td));
        this.unpackedTextureDataCache = new Map();
    }
    readTexture(textureData) {
        if (textureData.isPacked) {
            return this.readTexture(this.unpack(textureData));
        }
        if (!this.session.backend.glContext.isFloat32DownloadSupported) {
            const op = new uint8_encode_1.WebGLUint8Encode();
            const uint8TD = op.runInternal(this, textureData);
            return this.session.textureManager.readUint8TextureAsFloat(uint8TD);
        }
        return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);
    }
    pack(input) {
        const cachedId = this.unpack2packMap.get(input.tensor.dataId);
        if (cachedId) {
            return this.packedTextureDataCache.get(cachedId);
        }
        const key = `${input.shape}`;
        let op = this.session.packOpCache.get(key);
        if (!op) {
            op = new pack_1.WebGLPack();
            this.session.packOpCache.set(key, op);
        }
        let artifact = this.session.programManager.getArtifact(op);
        if (!artifact) {
            const programInfo = op.createProgramInfo(this, [input.tensor]);
            artifact = this.session.programManager.build(programInfo);
            this.session.programManager.setArtifact(op, artifact);
        }
        const runData = op.createRunData(this, artifact.programInfo, [input.tensor]);
        this.runProgram(artifact, runData);
        this.unpack2packMap.set(input.tensor.dataId, runData.outputTextureData.tensor.dataId);
        return runData.outputTextureData;
    }
    unpack(input) {
        const cachedId = this.pack2unpackMap.get(input.tensor.dataId);
        if (cachedId) {
            return this.unpackedTextureDataCache.get(cachedId);
        }
        // For unpacked kernel, cache it by using input's unpackedShape as cache key.
        // Note that we need to use input.unpackedShape instead of input.shape here,
        // as the shape infers the packed texture shape. Different unpackedShape can have the
        // same packed texture shape. For example, for unpacked shape, both [2, 3] and
        // [2, 4] has the same packed shape [1, 2], but those two shapes should have different
        // unpack shaders.
        const key = `${input.unpackedShape}`;
        let op = this.session.unpackOpCache.get(key);
        if (!op) {
            op = new unpack_1.WebGLUnpack();
            this.session.unpackOpCache.set(key, op);
        }
        let artifact = this.session.programManager.getArtifact(op);
        if (!artifact) {
            const programInfo = op.createProgramInfo(this, [input.tensor]);
            artifact = this.session.programManager.build(programInfo);
            this.session.programManager.setArtifact(op, artifact);
        }
        const runData = op.createRunData(this, artifact.programInfo, [input.tensor]);
        this.runProgram(artifact, runData);
        this.pack2unpackMap.set(input.tensor.dataId, runData.outputTextureData.tensor.dataId);
        return runData.outputTextureData;
    }
}
exports.WebGLInferenceHandler = WebGLInferenceHandler;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/op-resolve-rules.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/op-resolve-rules.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WEBGL_OP_RESOLVE_RULES = void 0;
const operators_1 = __webpack_require__(/*! ../../operators */ "./lib/onnxjs/operators.ts");
const batch_normalization_1 = __webpack_require__(/*! ./ops/batch-normalization */ "./lib/onnxjs/backends/webgl/ops/batch-normalization.ts");
const binaryOps = __importStar(__webpack_require__(/*! ./ops/binary-op */ "./lib/onnxjs/backends/webgl/ops/binary-op.ts"));
const clip_1 = __webpack_require__(/*! ./ops/clip */ "./lib/onnxjs/backends/webgl/ops/clip.ts");
const concat_1 = __webpack_require__(/*! ./ops/concat */ "./lib/onnxjs/backends/webgl/ops/concat.ts");
const conv_1 = __webpack_require__(/*! ./ops/conv */ "./lib/onnxjs/backends/webgl/ops/conv.ts");
const depth_to_space_1 = __webpack_require__(/*! ./ops/depth-to-space */ "./lib/onnxjs/backends/webgl/ops/depth-to-space.ts");
const dropout_1 = __webpack_require__(/*! ./ops/dropout */ "./lib/onnxjs/backends/webgl/ops/dropout.ts");
const elu_1 = __webpack_require__(/*! ./ops/elu */ "./lib/onnxjs/backends/webgl/ops/elu.ts");
const flatten_1 = __webpack_require__(/*! ./ops/flatten */ "./lib/onnxjs/backends/webgl/ops/flatten.ts");
const gather_1 = __webpack_require__(/*! ./ops/gather */ "./lib/onnxjs/backends/webgl/ops/gather.ts");
const gemm_1 = __webpack_require__(/*! ./ops/gemm */ "./lib/onnxjs/backends/webgl/ops/gemm.ts");
const image_scaler_1 = __webpack_require__(/*! ./ops/image-scaler */ "./lib/onnxjs/backends/webgl/ops/image-scaler.ts");
const instance_normalization_1 = __webpack_require__(/*! ./ops/instance-normalization */ "./lib/onnxjs/backends/webgl/ops/instance-normalization.ts");
const leaky_relu_1 = __webpack_require__(/*! ./ops/leaky-relu */ "./lib/onnxjs/backends/webgl/ops/leaky-relu.ts");
const matmul_1 = __webpack_require__(/*! ./ops/matmul */ "./lib/onnxjs/backends/webgl/ops/matmul.ts");
const pad_1 = __webpack_require__(/*! ./ops/pad */ "./lib/onnxjs/backends/webgl/ops/pad.ts");
const pool_1 = __webpack_require__(/*! ./ops/pool */ "./lib/onnxjs/backends/webgl/ops/pool.ts");
const reduceOps = __importStar(__webpack_require__(/*! ./ops/reduce */ "./lib/onnxjs/backends/webgl/ops/reduce.ts"));
const reshape_1 = __webpack_require__(/*! ./ops/reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
const resize_packed_1 = __webpack_require__(/*! ./ops/resize-packed */ "./lib/onnxjs/backends/webgl/ops/resize-packed.ts");
const shape_1 = __webpack_require__(/*! ./ops/shape */ "./lib/onnxjs/backends/webgl/ops/shape.ts");
const slice_1 = __webpack_require__(/*! ./ops/slice */ "./lib/onnxjs/backends/webgl/ops/slice.ts");
const softmax_1 = __webpack_require__(/*! ./ops/softmax */ "./lib/onnxjs/backends/webgl/ops/softmax.ts");
const split_1 = __webpack_require__(/*! ./ops/split */ "./lib/onnxjs/backends/webgl/ops/split.ts");
const squeeze_1 = __webpack_require__(/*! ./ops/squeeze */ "./lib/onnxjs/backends/webgl/ops/squeeze.ts");
const sum_1 = __webpack_require__(/*! ./ops/sum */ "./lib/onnxjs/backends/webgl/ops/sum.ts");
const tile_1 = __webpack_require__(/*! ./ops/tile */ "./lib/onnxjs/backends/webgl/ops/tile.ts");
const transpose_1 = __webpack_require__(/*! ./ops/transpose */ "./lib/onnxjs/backends/webgl/ops/transpose.ts");
const unaryOps = __importStar(__webpack_require__(/*! ./ops/unary-op */ "./lib/onnxjs/backends/webgl/ops/unary-op.ts"));
const unsqueeze_1 = __webpack_require__(/*! ./ops/unsqueeze */ "./lib/onnxjs/backends/webgl/ops/unsqueeze.ts");
const upsample_1 = __webpack_require__(/*! ./ops/upsample */ "./lib/onnxjs/backends/webgl/ops/upsample.ts");
exports.WEBGL_OP_RESOLVE_RULES = [
    ['Abs', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.NUMBER_TYPES, unaryOps.glslAbs())],
    ['Acos', '', '7+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslAcos())],
    ['Add', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslAdd())],
    ['And', '', '7+', () => new binaryOps.WebGLBinaryOp(['bool'], binaryOps.glslAnd())],
    ['Asin', '', '7+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslAsin())],
    ['Atan', '', '7+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslAtan())],
    ['AveragePool', '', '7-10', () => new pool_1.WebGLAveragePool()],
    ['BatchNormalization', '', '7+', () => new batch_normalization_1.WebGLBatchNormalization()],
    ['Ceil', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslCeil())],
    ['Clip', '', '6-10', () => new clip_1.WebGLClip()],
    ['Concat', '', '4+', () => new concat_1.WebGLConcat()],
    ['Conv', '', '1+', () => new conv_1.WebGLConv()],
    ['Cos', '', '7+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslCos())],
    ['Div', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslDiv())],
    ['Dropout', '', '7+', () => new dropout_1.WebGLDropout()],
    ['DepthToSpace', '', '1+', () => new depth_to_space_1.WebGLDepthToSpace()],
    ['Equal', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslEqual(), undefined, 'bool')],
    ['Elu', '', '6+', () => new elu_1.WebGLElu()],
    ['Exp', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslExp())],
    ['Flatten', '', '1+', () => new flatten_1.WebGLFlatten()],
    ['Floor', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslFloor())],
    ['Gather', '', '1+', () => new gather_1.WebGLGather()],
    ['Gemm', '', '7-10', () => new gemm_1.WebGLGemm(false)],
    ['Gemm', '', '11+', () => new gemm_1.WebGLGemm(true)],
    ['GlobalAveragePool', '', '1+', () => new pool_1.WebGLGlobalAveragePool()],
    ['GlobalMaxPool', '', '1+', () => new pool_1.WebGLGlobalMaxPool()],
    ['Greater', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslGreater(), undefined, 'bool')],
    ['Identity', '', '1+', () => new unaryOps.WebGLUnaryOp(operators_1.NUMBER_TYPES, unaryOps.glslIdentity())],
    ['ImageScaler', '', '1+', () => new image_scaler_1.WebGLImageScaler()],
    ['InstanceNormalization', '', '6+', () => new instance_normalization_1.WebGLInstanceNormalization()],
    ['LeakyRelu', '', '6+', () => new leaky_relu_1.WebGLLeakyRelu()],
    ['Less', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslLess(), undefined, 'bool')],
    ['Log', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslLog())],
    ['MatMul', '', '1+', () => new matmul_1.WebGLMatMul()],
    ['MaxPool', '', '1-9', () => new pool_1.WebGLMaxPool()],
    ['Mul', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslMul())],
    ['Neg', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.NUMBER_TYPES, unaryOps.glslNeg())],
    ['Not', '', '1+', () => new unaryOps.WebGLUnaryOp(['bool'], unaryOps.glslNot())],
    ['Or', '', '7+', () => new binaryOps.WebGLBinaryOp(['bool'], binaryOps.glslOr())],
    ['Pad', '', '2-10', () => new pad_1.WebGLPad()],
    ['Pow', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.FLOAT_TYPES, binaryOps.glslPow())],
    ['PRelu', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.FLOAT_TYPES, binaryOps.glslPRelu())],
    ['ReduceLogSum', '', '1+', () => new reduceOps.WebGLReduceLogSum()],
    ['ReduceMax', '', '1+', () => new reduceOps.WebGLReduceMax()],
    ['ReduceMean', '', '1+', () => new reduceOps.WebGLReduceMean()],
    ['ReduceMin', '', '1+', () => new reduceOps.WebGLReduceMin()],
    ['ReduceProd', '', '1+', () => new reduceOps.WebGLReduceProd()],
    ['ReduceSum', '', '1+', () => new reduceOps.WebGLReduceSum()],
    ['ReduceSumSquare', '', '1+', () => new reduceOps.WebGLReduceSumSquare()],
    ['Relu', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslRelu())],
    ['Reshape', '', '5+', () => new reshape_1.WebGLReshape()],
    ['Resize', '', '10', () => new resize_packed_1.WebGLResizePacked(10)],
    ['Resize', '', '11+', () => new resize_packed_1.WebGLResizePacked(11)],
    ['Shape', '', '1+', () => new shape_1.WebGLShape()],
    ['Sigmoid', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslSigmoid())],
    ['Sin', '', '7+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslSin())],
    ['Slice', '', '10+', () => new slice_1.WebGLSliceV10()],
    ['Slice', '', '1-9', () => new slice_1.WebGLSlice()],
    ['Softmax', '', '1+', () => new softmax_1.WebGLSoftmax()],
    // 'Split' operator has an optional attribute 'split'
    // this attribute determines how the specified axis of input data
    // is split. When the attribute is missing, we need the count of number of outputs
    // so that we can determine the 'split' attribute from the runtime input to the Operator
    ['Split', '', '2+', (node) => new split_1.WebGLSplit(node.outputs.length)],
    ['Sqrt', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslSqrt())],
    ['Squeeze', '', '1+', () => new squeeze_1.WebGLSqueeze()],
    ['Sub', '', '7+', () => new binaryOps.WebGLBinaryOp(operators_1.NUMBER_TYPES, binaryOps.glslSub())],
    ['Sum', '', '6+', () => new sum_1.WebGLSum()],
    ['Tan', '', '7+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslTan())],
    ['Tanh', '', '6+', () => new unaryOps.WebGLUnaryOp(operators_1.FLOAT_TYPES, unaryOps.glslTanh())],
    ['Tile', '', '6+', () => new tile_1.WebGLTile()],
    ['Transpose', '', '1+', () => new transpose_1.WebGLTranspose()],
    ['Upsample', '', '7-8', () => new upsample_1.WebGLUpsample(7)],
    ['Upsample', '', '9', () => new upsample_1.WebGLUpsample(9)],
    ['Unsqueeze', '', '1+', () => new unsqueeze_1.WebGLUnsqueeze()],
    ['Xor', '', '7+', () => new binaryOps.WebGLBinaryOp(['bool'], binaryOps.glslXor())],
];


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/batch-normalization.ts":
/*!**************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/batch-normalization.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLBatchNormalization = void 0;
const batch_normalization_1 = __webpack_require__(/*! ../../../ops/batch-normalization */ "./lib/onnxjs/ops/batch-normalization.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLBatchNormalization extends batch_normalization_1.BatchNormalization {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputLayouts = inputs.map(t => handler.getOrCreateTextureLayout(t));
        const outputShape = inputs[0].dims.slice();
        const rank = outputShape.length;
        const scale = inputLayouts[1];
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      float process(int[${rank}] indices) {
        vec2 position = offsetToCoords(indices[1], ${scale.width}, ${scale.height});
        float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));
        float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));
        float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));
        float b = getColorAsFloat(${glsl.texture2D}(B, position));

        return scale * ( (_A(indices) - mean) / sqrt(variance + float(${this.epsilon})) ) + b;
      }`;
        return {
            inputLayouts,
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'Scale', 'B', 'Mean', 'Variance'],
            shaderSource
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        inputs.slice(1).forEach(t => inputTDs.push(handler.getOrCreateTextureData(t)));
        const outputTD = handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type);
        return { inputTextureDatas: inputTDs, outputTextureData: outputTD, uniformData: {} };
    }
}
exports.WebGLBatchNormalization = WebGLBatchNormalization;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/binary-op.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/binary-op.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.glslPRelu = exports.glslPow = exports.glslXor = exports.glslOr = exports.glslAnd = exports.glslLess = exports.glslGreater = exports.glslEqual = exports.glslSub = exports.glslMul = exports.glslDiv = exports.glslAdd = exports.WebGLBinaryOp = void 0;
const binary_op_1 = __webpack_require__(/*! ../../../ops/binary-op */ "./lib/onnxjs/ops/binary-op.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_definitions_1 = __webpack_require__(/*! ../glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLBinaryOp extends binary_op_1.BinaryOp {
    constructor(typeConstraint, glslFunc, opType, resultType) {
        super(typeConstraint, opType, resultType);
        this.glslFunc = glslFunc;
    }
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const isBroadcast = !util_1.ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
        // TODO fix bcast in packed mode.
        if (this.usePackedTexture === undefined) {
            this.usePackedTexture = !isBroadcast && handler.session.pack;
        }
        const inputLayouts = this.usePackedTexture ?
            inputs.map(t => handler.getOrCreateTextureLayout(t, 4, true, t.dims, true)) :
            inputs.map(t => handler.getOrCreateTextureLayout(t));
        const ouputLayout = this.usePackedTexture ?
            handler.createTextureLayoutFromShape(inputs[0].dims, 4, inputs[0].dims, { isPacked: true, reverseWH: true }) :
            handler.createTextureLayoutFromShape(inputs[0].dims);
        if (isBroadcast) {
            const outputShape = util_1.BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);
            if (!outputShape) {
                throw new Error('Can\'t perform binary op on the given tensors');
            }
            const outputRank = outputShape.length;
            const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;
            const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;
            const aBcast = inputs[0].dims.length !== 0 ? 'bcastIndices_A(indices, aindices);' : 'aindices[0] = 0;';
            const bBcast = inputs[1].dims.length !== 0 ? 'bcastIndices_B(indices, bindices);' : 'bindices[0] = 0;';
            // TODO: for packed tensors, we need to implement logic to caculate textCoords for broadcast tensor
            const shaderSource = `
      ${this.glslFunc.body}
      float process(int indices[${outputRank}]) {
        int aindices[${aRank}];
        int bindices[${bRank}];
        ${aBcast}
        ${bBcast}
        return ${this.glslFunc.name}(_A(aindices), _B(bindices));
    }`;
            const outputLayout = this.usePackedTexture ?
                handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }) :
                handler.createTextureLayoutFromShape(outputShape);
            return {
                inputLayouts,
                outputLayout,
                samplers: ['A', 'B'],
                shaderSource,
                expectPackedInputs: this.usePackedTexture,
                expectPackedOutputs: this.usePackedTexture
            };
        }
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
    ${this.glslFunc.body}
    void main() {
      vec4 v1 = ${glsl.texture2D}(A, TexCoords);
      vec4 v2 = ${glsl.texture2D}(B, TexCoords);
      vec4 result = ${this.glslFunc.name}(v1, v2);
      ${glsl.output} = result;
    }
    `;
        if (this.usePackedTexture) {
            return {
                hasMain: true,
                inputLayouts,
                outputLayout: ouputLayout,
                samplers: ['A', 'B'],
                shaderSource,
                expectPackedInputs: true,
                expectPackedOutputs: true
            };
        }
        else {
            return {
                hasMain: true,
                inputLayouts,
                outputLayout: handler.createTextureLayoutFromShape(inputs[0].dims),
                samplers: ['A', 'B'],
                shaderSource,
            };
        }
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = this.usePackedTexture ?
            inputs.map((t) => handler.getOrCreateTextureData(t, handler.getOrCreateTextureLayout(t, 1, false, [], true))) :
            inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, this.resultType ? this.resultType : inputs[0].type),
            uniformData: {}
        };
    }
}
exports.WebGLBinaryOp = WebGLBinaryOp;
function glslAdd() {
    const name = 'add_';
    const body = `
  float ${name}(float a, float b) {
    return a + b;
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslAdd = glslAdd;
function glslDiv() {
    const name = 'div_';
    const body = `
  float ${name}(float a, float b) {
    return a / b;
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslDiv = glslDiv;
function glslMul() {
    const name = 'mul_';
    const body = `
  float ${name}(float a, float b) {
    return a * b;
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslMul = glslMul;
function glslSub() {
    const name = 'sub_';
    const body = `
  float ${name}(float a, float b) {
    return a - b;
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslSub = glslSub;
function glslEqual() {
    const name = 'equal_';
    const body = `
  float ${name}(float a, float b) {
    return float(a == b);
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslEqual = glslEqual;
function glslGreater() {
    const name = 'greater_';
    const body = `
  float ${name}(float a, float b) {
    return float(a > b);
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslGreater = glslGreater;
function glslLess() {
    const name = 'less_';
    const body = `
  float ${name}(float a, float b) {
    return float(a < b);
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslLess = glslLess;
function glslAnd() {
    const name = 'and_';
    const body = `
  float ${name}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslAnd = glslAnd;
function glslOr() {
    const name = 'or_';
    const body = `
  float ${name}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslOr = glslOr;
function glslXor() {
    const name = 'xor_';
    const body = `
  float ${name}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslXor = glslXor;
function glslPow() {
    return glslBuiltinBinary('pow');
}
exports.glslPow = glslPow;
function glslPRelu() {
    const name = 'prelu_';
    const body = `
  float ${name}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslPRelu = glslPRelu;
function glslBuiltinBinary(fname) {
    const name = `${fname}_`;
    const body = `
  float ${name}(float a, float b) {
    return ${fname}(a, b);
  }
  vec4 ${name}(vec4 v1, vec4 v2) {
    return ${fname}(v1, v2);
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/clip.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/clip.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLClip = void 0;
const clip_1 = __webpack_require__(/*! ../../../ops/clip */ "./lib/onnxjs/ops/clip.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLClip extends clip_1.Clip {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const outputShape = inputs[0].dims.slice();
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      const float min = float(${this.min});
      const float max = float(${this.max});
      void main() {
        float v = ${glsl.texture2D}(A, TexCoords).r;
        ${glsl.output} = vec4(clamp(v, min, max));
      }
      `;
        return {
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
            hasMain: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLClip = WebGLClip;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/concat-packed.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/concat-packed.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLPackedConcat = void 0;
const concat_1 = __webpack_require__(/*! ../../../ops/concat */ "./lib/onnxjs/ops/concat.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
class WebGLPackedConcat extends concat_1.Concat {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputShape = inputs[0].dims.slice();
        if (this.axis >= inputShape.length || this.axis < (-1 * inputShape.length)) {
            throw new Error('axis specified for concat doesn\'t match input dimensionality');
        }
        if (this.axis < 0) {
            this.axis = inputShape.length + this.axis;
        }
        // ensure all of the non-concatenated axes match each other
        // calculate the shape of the output tensor while we do that
        const outputShape = inputShape.slice(0);
        for (let i = 1; i < inputs.length; i++) {
            const dataNShape = inputs[i].dims.slice();
            for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
                // add to the placeholder for computing output shape
                if (axisIndex === this.axis) {
                    outputShape[this.axis] += dataNShape[axisIndex];
                }
                // ensure all non-cancatenated axes match each other
                else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
                    throw new Error('non concat dimensions must match');
                }
            }
        }
        const rank = outputShape.length;
        const coords = packing_utils_1.getChannels('coords', rank);
        const dtype = utils_1.getCoordsDataType(rank);
        const unpackChannel = packing_utils_1.unpackFromChannel();
        const shapes = inputs.map(i => i.dims);
        const allGlChannels = ['x', 'y', 'z', 'w', 'u', 'v'];
        const channels = allGlChannels.slice(0, rank);
        const offsets = new Array(shapes.length - 1);
        const samplers = inputs.map((v, i) => `X${i}`);
        offsets[0] = shapes[0][this.axis];
        for (let i = 1; i < offsets.length; i++) {
            offsets[i] = offsets[i - 1] + shapes[i][this.axis];
        }
        const channel = channels[this.axis];
        const lastChannels = channels.slice(-2);
        const allChannels = channels.join();
        let getValueSnippet = `if (${channel} < ${offsets[0]}) {
      return getChannel(
          getX0(${allChannels}), vec2(${lastChannels.join()}));
      }`;
        for (let i = 1; i < offsets.length; i++) {
            const shift = offsets[i - 1];
            getValueSnippet += `
          if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
            return getChannel(
              getX${i}(${this.getShiftedChannelsSnippet(channels, channel, shift)}),
              vec2(${this.getShiftedChannelsSnippet(lastChannels, channel, shift)}));
          }`;
        }
        const lastIndex = offsets.length;
        const shift = offsets[offsets.length - 1];
        getValueSnippet += `
          return getChannel(
            getX${lastIndex}(${this.getShiftedChannelsSnippet(channels, channel, shift)}),
            vec2(${this.getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
        ${unpackChannel}
        float getValue(${channels.map(x => 'int ' + x)}) {
          ${getValueSnippet}
        }

        void main() {
          ${dtype} coords = getOutputCoords();
          int lastDim = coords.${allGlChannels[rank - 1]};
          coords.${allGlChannels[rank - 1]} = coords.${allGlChannels[rank - 2]};
          coords.${allGlChannels[rank - 2]} = lastDim;

          vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

          ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
          if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {
            result.g = getValue(${coords});
          }

          ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
          if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {
            result.a = getValue(${coords});
          }

          ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
          if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&
              ${coords[rank - 1]} < ${outputShape[rank - 1]}) {
            result.b = getValue(${coords});
          }
          ${glsl.output} = result;
        }
      `;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t, 4, true, t.dims, true)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }),
            samplers,
            shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i], true));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
    /**
     * Generates the snippet to shift a given channel in a list of channels by shift
     *
     * i.e: returns a string of the form 'x, y-[shift], z' where any one channel can
     * have the shift applied.
     */
    getShiftedChannelsSnippet(channels, channel, shift) {
        const channelIdx = channels.indexOf(channel);
        const res = channels.map((c, idx) => {
            if (idx === channelIdx) {
                return `${c} - ${shift}`;
            }
            else {
                return c;
            }
        });
        return res.join();
    }
}
exports.WebGLPackedConcat = WebGLPackedConcat;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/concat.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/concat.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnpackedConcat = exports.WebGLConcat = void 0;
const concat_1 = __webpack_require__(/*! ../../../ops/concat */ "./lib/onnxjs/ops/concat.ts");
const concat_packed_1 = __webpack_require__(/*! ./concat-packed */ "./lib/onnxjs/backends/webgl/ops/concat-packed.ts");
// We provide a wrapper class so that the kernel can switch between packed and unpacked depending on the inputs on the
// fly.
class WebGLConcat extends concat_1.Concat {
    constructor() {
        super();
        this.unpackedImpl = new WebGLUnpackedConcat();
        this.packedImpl = new concat_packed_1.WebGLPackedConcat();
    }
    // No need to call super since this class only serves as a wrapper.
    initialize(attributes) {
        this.unpackedImpl.initialize(attributes);
        this.packedImpl.initialize(attributes);
    }
    run(inferenceHandler, inputs) {
        if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {
            return inferenceHandler.run(this.packedImpl, inputs);
        }
        else {
            return inferenceHandler.run(this.unpackedImpl, inputs);
        }
    }
    createProgramInfo(handler, inputs) {
        if (handler.session.pack && inputs[0].dims.length > 1) {
            return this.packedImpl.createProgramInfo(handler, inputs);
        }
        else {
            return this.unpackedImpl.createProgramInfo(handler, inputs);
        }
    }
    createRunData(handler, programInfo, inputs) {
        if (handler.session.pack && inputs[0].dims.length > 1) {
            return this.packedImpl.createRunData(handler, programInfo, inputs);
        }
        else {
            return this.unpackedImpl.createRunData(handler, programInfo, inputs);
        }
    }
}
exports.WebGLConcat = WebGLConcat;
class WebGLUnpackedConcat extends concat_1.Concat {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputShape = inputs[0].dims.slice();
        if (this.axis >= inputShape.length || this.axis < (-1 * inputShape.length)) {
            throw new Error('axis specified for concat doesn\'t match input dimensionality');
        }
        if (this.axis < 0) {
            this.axis = inputShape.length + this.axis;
        }
        // ensure all of the non-concatenated axes match each other
        // calculate the shape of the output tensor while we do that
        const outputShape = inputShape.slice(0);
        for (let i = 1; i < inputs.length; i++) {
            const dataNShape = inputs[i].dims.slice();
            for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
                // add to the placeholder for computing output shape
                if (axisIndex === this.axis) {
                    outputShape[this.axis] += dataNShape[axisIndex];
                }
                // ensure all non-cancatenated axes match each other
                else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
                    throw new Error('non concat dimensions must match');
                }
            }
        }
        const rank = outputShape.length;
        let getTextureIndexWhereDataResidesMethod = '';
        // in most cases linear search is sufficient, as in most scenarios, only 2 tensors are concatenated
        if (inputs.length < 5) {
            getTextureIndexWhereDataResidesMethod = this.getTextureIndexWhereDataResidesLinearSearch(inputs.length);
        }
        else {
            getTextureIndexWhereDataResidesMethod = this.getTextureIndexWhereDataResidesBinarySearch(inputs.length);
        }
        const fetchDataFromCorrectTextureMethod = this.fetchDataFromCorrectTextureMethod(inputs.length, rank);
        const getValueFromArrayIndexMethod = this.getValueFromArrayIndexMethod(inputs.length);
        const samplers = inputs.map((v, i) => `X${i}`);
        const shaderSource = `
      ${fetchDataFromCorrectTextureMethod}
      ${getValueFromArrayIndexMethod}
      ${getTextureIndexWhereDataResidesMethod}
      float process(int indices[${rank}]) {
        int textureIndex = getTextureWhereDataResides (indices[${this.axis}]);

        if(textureIndex != 0) {
          indices[${this.axis}] = indices[${this.axis}] - int(getValueFromArrayIndex(sizeInConcatAxis, textureIndex-int(1)));
        }

        return fetchDataFromCorrectTexture(textureIndex, indices);
      }`;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers,
            variables: [{ name: 'sizeInConcatAxis', type: 'int', arrayLength: inputs.length }],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        const sizeInConcatAxis = new Array(programInfo.inputLayouts.length);
        let previousSum = 0;
        for (let i = 0; i < programInfo.inputLayouts.length; ++i) {
            previousSum += programInfo.inputLayouts[i].shape[this.axis];
            sizeInConcatAxis[i] = previousSum;
        }
        const uniformData = { sizeInConcatAxis };
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData
        };
    }
    getTextureIndexWhereDataResidesLinearSearch(numberOfTensors) {
        return `int getTextureWhereDataResides(int index) {
      for(int i=0; i<${numberOfTensors}; i++) {
          if(index < int(sizeInConcatAxis[i])){
              return i;
          }
        }
      }`;
    }
    // TODO: Implement BinarySearch in GLSL
    getTextureIndexWhereDataResidesBinarySearch(numberOfTensors) {
        return this.getTextureIndexWhereDataResidesLinearSearch(numberOfTensors);
    }
    fetchDataFromCorrectTextureMethod(numberOfTensors, tensorRank) {
        const codeLines = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];
        for (let i = 0; i < numberOfTensors; ++i) {
            if (i === 0) {
                codeLines.push('\t' +
                    `if (textureIndex == ${i}) { return _X${i}(indices); }`);
            }
            else if (i === numberOfTensors - 1) {
                codeLines.push('\t' +
                    `else { return _X${i}(indices); }`);
            }
            else {
                codeLines.push('\t' +
                    `else if (textureIndex == ${i}) { return _X${i}(indices); }`);
            }
        }
        codeLines.push('\t' +
            '}');
        return codeLines.join('\n');
    }
    getValueFromArrayIndexMethod(arrayRank) {
        const codeLines = [`int getValueFromArrayIndex(int arr[${arrayRank}], int index) {`];
        for (let i = 0; i < arrayRank; ++i) {
            if (i === 0) {
                codeLines.push('\t' +
                    `if (index == ${i}) { return arr[${i}]; }`);
            }
            else if (i === arrayRank - 1) {
                codeLines.push('\t' +
                    `else { return arr[${i}]; }`);
            }
            else {
                codeLines.push('\t' +
                    `else if (index == ${i}) { return arr[${i}]; }`);
            }
        }
        codeLines.push('\t' +
            '}');
        return codeLines.join('\n');
    }
}
exports.WebGLUnpackedConcat = WebGLUnpackedConcat;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/conv-pack.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/conv-pack.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLConvPacked = void 0;
const attribute_1 = __webpack_require__(/*! ../../../attribute */ "./lib/onnxjs/attribute.ts");
const instrument_1 = __webpack_require__(/*! ../../../instrument */ "./lib/onnxjs/instrument.ts");
const conv_1 = __webpack_require__(/*! ../../../ops/conv */ "./lib/onnxjs/ops/conv.ts");
const tensor_1 = __webpack_require__(/*! ../../../tensor */ "./lib/onnxjs/tensor.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const conv_2 = __webpack_require__(/*! ./conv */ "./lib/onnxjs/backends/webgl/ops/conv.ts");
const im2col_pack_1 = __webpack_require__(/*! ./im2col-pack */ "./lib/onnxjs/backends/webgl/ops/im2col-pack.ts");
const matmul_pack_1 = __webpack_require__(/*! ./matmul-pack */ "./lib/onnxjs/backends/webgl/ops/matmul-pack.ts");
const reshape_packed_1 = __webpack_require__(/*! ./reshape-packed */ "./lib/onnxjs/backends/webgl/ops/reshape-packed.ts");
class WebGLConvPacked extends conv_1.Conv {
    constructor() {
        super(...arguments);
        this.kernelReshape = new reshape_packed_1.WebGLReshapePacked();
        this.matmul = new matmul_pack_1.WebGLMatMulPacked();
        this.outputReshape = new reshape_packed_1.WebGLReshapePacked();
    }
    run(inferenceHandler, inputs) {
        const programManager = inferenceHandler.session.programManager;
        const xshape = inputs[0].dims.slice();
        const kshape = inputs[1].dims.slice();
        // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims
        if (this.kernelShape.length === 0) {
            for (let i = 2; i < kshape.length; ++i) {
                this.kernelShape.push(kshape[i]);
            }
        }
        util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims, this.strides, this.dilations, this.kernelShape, this.pads, this.autoPad);
        instrument_1.Logger.verbose('Conv', `autpPad:${this.autoPad}, dilations:${this.dilations}, group:${this.group}, kernelShape:${this.kernelShape}, pads:${this.pads}, strides:${this.strides}`);
        if (!this.outputShape) {
            this.outputShape = conv_2.WebGLConv.calcOutputShape(xshape, kshape, this.dilations, this.pads, this.strides);
        }
        if (this.im2col === undefined) {
            this.im2col = new im2col_pack_1.WebGLIm2ColPacked(this.outputShape, kshape, this.dilations, this.pads, this.strides);
        }
        if (this.activation) {
            const attributes = new attribute_1.Attribute(undefined);
            attributes.set('__internal_activation', 'string', (this.activation));
            this.matmul.initialize(attributes);
        }
        // shape for kernel reshape
        const shape = new tensor_1.Tensor([2], 'int32', undefined, undefined, new Int32Array([kshape[0], kshape[1] * kshape[2] * kshape[3]]));
        if (!this.artifacts) {
            this.artifacts = [];
            this.programInfo = [];
            this.programInfo[0] = this.im2col.createProgramInfo(inferenceHandler, [inputs[0], inputs[1]]);
            this.artifacts[0] = programManager.build(this.programInfo[0]);
            this.programInfo[1] = this.kernelReshape.createProgramInfo(inferenceHandler, [inputs[1], shape]);
            this.artifacts[1] = programManager.build(this.programInfo[1]);
        }
        // run im2col
        const runDataIm2col = this.im2col.createRunData(inferenceHandler, this.programInfo[0], [inputs[0], inputs[1]]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[0], runDataIm2col);
        programManager.run(this.artifacts[0], runDataIm2col);
        const im2colOutput = runDataIm2col.outputTextureData.tensor;
        // reshape kernel
        const runDataKernelReshape = this.kernelReshape.createRunData(inferenceHandler, this.programInfo[1], [inputs[1], shape]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[1], runDataKernelReshape);
        programManager.run(this.artifacts[1], runDataKernelReshape);
        const kernelReshaped = runDataKernelReshape.outputTextureData.tensor;
        // run matmul
        const hasBias = (inputs.length === 3);
        util_1.assert(this.artifacts.length > 1, () => 'expect at least 2 artifacts created');
        if (this.artifacts.length === 2) {
            this.programInfo[2] = this.matmul.createProgramInfo(inferenceHandler, hasBias ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput]);
            this.artifacts[2] = programManager.build(this.programInfo[2]);
        }
        const runDataMatmul = this.matmul.createRunData(inferenceHandler, this.programInfo[2], hasBias ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[2], runDataMatmul);
        programManager.run(this.artifacts[2], runDataMatmul);
        const matmulOutput = runDataMatmul.outputTextureData.tensor;
        // reshape output
        const outputShapeTensor = new tensor_1.Tensor([this.outputShape.length], 'int32', undefined, undefined, new Int32Array([this.outputShape[0], this.outputShape[1], this.outputShape[2], this.outputShape[3]]));
        util_1.assert(this.artifacts.length > 2, () => 'expect at least 3 artifacts created');
        if (this.artifacts.length === 3) {
            this.programInfo[3] = this.outputReshape.createProgramInfo(inferenceHandler, [matmulOutput, outputShapeTensor]);
            this.artifacts[3] = programManager.build(this.programInfo[3]);
        }
        const runDataOutputReshape = this.outputReshape.createRunData(inferenceHandler, this.programInfo[3], [matmulOutput, outputShapeTensor]);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[3], runDataOutputReshape);
        programManager.run(this.artifacts[3], runDataOutputReshape);
        return [runDataOutputReshape.outputTextureData.tensor];
    }
}
exports.WebGLConvPacked = WebGLConvPacked;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/conv.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/conv.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnpackedConv = exports.WebGLUnpackedGroupedConv = exports.WebGLConv = void 0;
const instrument_1 = __webpack_require__(/*! ../../../instrument */ "./lib/onnxjs/instrument.ts");
const conv_1 = __webpack_require__(/*! ../../../ops/conv */ "./lib/onnxjs/ops/conv.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const conv_pack_1 = __webpack_require__(/*! ./conv-pack */ "./lib/onnxjs/backends/webgl/ops/conv-pack.ts");
const fuse_utils_1 = __webpack_require__(/*! ./fuse-utils */ "./lib/onnxjs/backends/webgl/ops/fuse-utils.ts");
class WebGLConv extends conv_1.Conv {
    constructor() {
        super();
        this.unpackedGroupedConvImpl = new WebGLUnpackedGroupedConv();
        this.unpackedConvImpl = new WebGLUnpackedConv();
        this.packedConvImpl = new conv_pack_1.WebGLConvPacked();
    }
    initialize(attributes) {
        super.initialize(attributes);
        this.unpackedGroupedConvImpl.initialize(attributes);
        this.unpackedConvImpl.initialize(attributes);
        this.packedConvImpl.initialize(attributes);
    }
    run(inferenceHandler, inputs) {
        const packMode = inferenceHandler.session.pack;
        if (this.group > 1) {
            return this.unpackedGroupedConvImpl.run(inferenceHandler, inputs);
        }
        else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1) {
            return this.packedConvImpl.run(inferenceHandler, inputs);
        }
        else {
            return this.unpackedConvImpl.run(inferenceHandler, inputs);
        }
    }
    static calcOutputShape(inputShape, kernelShape, dilations, adjustPads, strides) {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(2);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputSpatialShape = inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));
        const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);
        return outputShape;
    }
}
exports.WebGLConv = WebGLConv;
class WebGLUnpackedGroupedConv extends conv_1.Conv {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? 'value += getBias(output_channel);' : '';
        const xShape = inputs[0].dims.slice();
        const wShape = inputs[1].dims.slice();
        const outputChannelsPerGroup = wShape[0] / this.group;
        // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims
        if (this.kernelShape.length === 0) {
            for (let i = 2; i < wShape.length; ++i) {
                this.kernelShape.push(wShape[i]);
            }
        }
        util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims, this.strides, this.dilations, this.kernelShape, this.pads, this.autoPad);
        instrument_1.Logger.verbose('Conv', `autpPad:${this.autoPad}, dilations:${this.dilations}, group:${this.group}, kernelShape:${this.kernelShape}, pads:${this.pads}, strides:${this.strides}`);
        const outputShape = WebGLConv.calcOutputShape(xShape, wShape, this.dilations, this.pads, this.strides);
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const { activationFunction, applyActivation } = fuse_utils_1.getActicationSnippet(this.activation);
        const shaderSource = `
    const ivec2 strides = ivec2(${this.strides[0]}, ${this.strides[1]});
    const ivec2 pads = ivec2(${this.pads[0]}, ${this.pads[1]});
    ${activationFunction}
    void main() {
      ivec4 coords = getOutputCoords();
      int batch = coords.x;
      int output_channel = coords.y;
      ivec2 xRCCorner = coords.zw * strides - pads;
      int group_id = output_channel / ${outputChannelsPerGroup};

      float value = 0.0;
      for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {
        int input_channel = group_id * ${wShape[1]} + wInChannel;
        for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {
          int xHeight = xRCCorner.x + wHeight * ${this.dilations[0]};

          if (xHeight < 0 || xHeight >= ${xShape[2]}) {
            continue;
          }

          for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {
            int xWidth = xRCCorner.y + wWidth * ${this.dilations[1]};
            if (xWidth < 0 || xWidth >= ${xShape[3]}) {
              continue;
            }

            float xVal = getX(batch, input_channel, xWidth, xHeight);
            float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
            value += xVal*wVal;
          }
        }
      }
      ${processBias}
      ${applyActivation}
      ${glsl.output} = vec4(value, .0, .0, .0);
    }
`;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: hasBias ? ['X', 'W', 'Bias'] : ['X', 'W'],
            shaderSource,
            hasMain: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLUnpackedGroupedConv = WebGLUnpackedGroupedConv;
class WebGLUnpackedConv extends conv_1.Conv {
    constructor() {
        super(...arguments);
        this.readSize = 8;
        this.blockSize = 64;
    }
    run(inferenceHandler, inputs) {
        const programManager = inferenceHandler.session.programManager;
        if (!this.artifacts) {
            this.artifacts = [];
            const programInfos = this.createProgramInfoArray(inferenceHandler, inputs);
            for (let i = 0; i < programInfos.length; ++i) {
                const artifact = inferenceHandler.session.programManager.build(programInfos[i]);
                this.artifacts.push(artifact);
            }
        }
        const runDataArray = this.createRunDataArray(inferenceHandler, this.artifacts.map(a => a.programInfo), inputs);
        inferenceHandler.checkAndUpdateTextureForm(this.artifacts[0], runDataArray[0]);
        programManager.run(this.artifacts[0], runDataArray[0]);
        programManager.run(this.artifacts[1], runDataArray[1]);
        return [runDataArray[1].outputTextureData.tensor];
    }
    createProgramInfoArray(inferenceHandler, inputs) {
        const xshape = inputs[0].dims.slice();
        const kshape = inputs[1].dims.slice();
        // if kernelShape is not specified in the attributes of this op, infer it from the weight tensor dims
        if (this.kernelShape.length === 0) {
            const wDims = inputs[1].dims;
            for (let i = 2; i < wDims.length; ++i) {
                this.kernelShape.push(wDims[i]);
            }
        }
        util_1.PoolConvUtil.adjustPadsBasedOnAutoPad(inputs[0].dims, this.strides, this.dilations, this.kernelShape, this.pads, this.autoPad);
        instrument_1.Logger.verbose('Conv', `autpPad:${this.autoPad}, dilations:${this.dilations}, group:${this.group}, kernelShape:${this.kernelShape}, pads:${this.pads}, strides:${this.strides}`);
        const outputShape = WebGLConv.calcOutputShape(xshape, kshape, this.dilations, this.pads, this.strides);
        const im2colProgramInfo = this.createIm2ColProgramInfo(inferenceHandler, inputs, outputShape);
        const dotProductProgramInfo = this.createDotProductProgramInfo(inferenceHandler, im2colProgramInfo.outputLayout, inputs, outputShape);
        return [im2colProgramInfo, dotProductProgramInfo];
    }
    createRunDataArray(inferenceHandler, programInfos, inputs) {
        const k = inputs[1];
        const b = inputs.length >= 3 ? inputs[2] : undefined;
        let kTD = inferenceHandler.getTextureData(k.dataId);
        if (!kTD) {
            instrument_1.Logger.verbose('Conv', 'Did not find the adjustedKernel texture in the cache. Creating rew.');
            const newKernelData = WebGLUnpackedConv.prepKernelForDotProduct(k.dims.slice(), this.group, 4, k.floatData);
            // hack: should use graph transformer to rewrite initializer K
            kTD = inferenceHandler.createTextureDataFromLayoutBindTensor(programInfos[1].inputLayouts[1], k.type, newKernelData, k);
        }
        const runtDataIm2Col = {
            inputTextureDatas: [inferenceHandler.getOrCreateTextureData(inputs[0])],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[0].outputLayout, inputs[0].type),
            uniformData: {}
        };
        const inputTDs = [runtDataIm2Col.outputTextureData, kTD];
        if (b) {
            inputTDs.push(inferenceHandler.getOrCreateTextureData(b));
        }
        const outputTD = inferenceHandler.createTextureDataFromLayout(programInfos[1].outputLayout, inputs[0].type);
        const runDataDotProduct = {
            inputTextureDatas: inputTDs,
            outputTextureData: outputTD,
            uniformData: {},
            draw: (glContext, artifact) => {
                const gl = glContext.gl;
                const sharedDim = artifact.programInfo.params.sharedDim;
                const sharedDimReadSize = artifact.programInfo.params.sharedDimReadSize;
                const sharedDimOffsetLocation = artifact.uniformLocations.find(l => l.name === 'sharedDimOffset').location;
                let blend = false;
                for (let k = 0; k < sharedDim; k += sharedDimReadSize) {
                    instrument_1.Logger.verbose('MatMul2D', `k = ${k}, sharedDim: ${sharedDim}, readSize = ${sharedDimReadSize}`);
                    if (k === sharedDimReadSize) {
                        blend = true;
                        gl.enable(gl.BLEND);
                        glContext.checkError();
                        gl.blendEquation(gl.FUNC_ADD);
                        glContext.checkError();
                        gl.blendFunc(gl.ONE, gl.ONE);
                        glContext.checkError();
                    }
                    gl.uniform1i(sharedDimOffsetLocation, k);
                    glContext.checkError();
                    glContext.draw();
                }
                if (blend) {
                    gl.disable(gl.BLEND);
                    glContext.checkError();
                }
            }
        };
        return [runtDataIm2Col, runDataDotProduct];
    }
    createIm2ColProgramInfo(inferenceHandler, inputs, outputShape) {
        const xshape = inputs[0].dims.slice();
        const kshape = inputs[1].dims.slice();
        const rank = outputShape.length;
        const im2colDims = WebGLUnpackedConv.calcIm2ColDims(xshape, kshape, outputShape, 4);
        const outputLayout = inferenceHandler.createTextureLayoutFromShape(im2colDims, 4, [im2colDims[0], im2colDims[1], im2colDims[2], im2colDims[3] * 4], { breakAxis: 3 });
        const shaderSource = `
      const int XC = ${xshape[1]};
      const int XH = ${xshape[2]};
      const int XW = ${xshape[3]};
      const int KH = ${this.kernelShape[0]};
      const int KW = ${this.kernelShape[1]};
      const int dilationH = ${this.dilations[0]};
      const int dilationW = ${this.dilations[1]};
      const int strideH = ${this.strides[0]};
      const int strideW = ${this.strides[1]};
      const int padH = ${this.pads[0]};
      const int padW = ${this.pads[1]};
      const int KHKW = KH*KW;
      const int XCKHKW = XC * KHKW;
      const int outputChannels = 4;
      vec4 process(int indices[${rank}]) {
        int b  = indices[0]; // batch size
        int oh = indices[1] * strideH - padH; //output height
        int ow = indices[2] * strideW - padW; //output width
        int p = indices[3] * outputChannels; //patch
        vec4 value = vec4(0.0);
        for(int i=0; i < outputChannels; ++i) {
          if(p < XCKHKW) {
            int patchC = p / KHKW;
            int patchH = (p - patchC*KHKW) / KW;
            int patchW = (p - patchC*KHKW) - patchH * KW;
            int xh2 = oh + patchH * dilationH;
            int xw2 = ow + patchW * dilationW;
            int x[${xshape.length}];
            x[0] = b;
            x[1] = patchC;
            x[2] = xh2;
            x[3] = xw2;
            if(xh2 >= 0 &&
                xh2 < XH &&
                xw2 >= 0 &&
                xw2 < XW) {
              value[i] = _X(x);
            }
          }
          ++p;
        }
        return value;
      }
      `;
        return {
            name: 'Im2Col',
            inputLayouts: [inferenceHandler.createTextureLayoutFromShape(xshape)],
            outputLayout,
            samplers: ['X'],
            shaderSource,
        };
    }
    createDotProductProgramInfo(inferenceHandler, im2colLayout, inputs, outputShape) {
        const xshape = inputs[0].dims.slice();
        const kshape = inputs[1].dims.slice();
        const adjustedKernelShape = [kshape[0], Math.ceil((xshape[1] * kshape[2] * kshape[3]) / 4)];
        const kLayout = inferenceHandler.createTextureLayoutFromShape(adjustedKernelShape, 4, [adjustedKernelShape[0], adjustedKernelShape[1] * 4], { breakAxis: 1 });
        let bLayout;
        const rank = outputShape.length;
        const inputLayouts = [im2colLayout, kLayout];
        if (inputs.length === 3) {
            bLayout = inferenceHandler.createTextureLayoutFromShape(inputs[2].dims.slice());
            inputLayouts.push(bLayout);
        }
        const outputLayout = inferenceHandler.createTextureLayoutFromShape(outputShape);
        const initValue = (inputs.length < 3) ? '0.0' : '_B(b)';
        const sharedDim = im2colLayout.shape[3];
        const blendEnabled = inferenceHandler.session.backend.glContext.isBlendSupported && !this.activation;
        const sharedDimReadSize = blendEnabled && inferenceHandler.session.backend.matmulMaxBatchSize ?
            this.calcSharedDimReadSize(inferenceHandler.session.backend.matmulMaxBatchSize, sharedDim) :
            sharedDim;
        const samplers = ['Im2Col', 'K'];
        if (inputs.length === 3) {
            samplers.push('B');
        }
        const { activationFunction, applyActivation } = fuse_utils_1.getActicationSnippet(this.activation);
        const glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
    ${activationFunction}
    float process(int indices[${rank}]) {
      int b[1];
      b[0] = indices[1];
      int im2col[${im2colLayout.shape.length}];
      im2col[0] = indices[0];
      im2col[1] = indices[2];
      im2col[2] = indices[3];
      int im2colOffset = im2col[0] * ${im2colLayout.strides[0]} + im2col[1] * ${im2colLayout.strides[1]} + im2col[2] * ${im2colLayout.strides[2]} + sharedDimOffset;
      int kernelOffset = indices[1] * ${kLayout.strides[0]} + sharedDimOffset;
      float value = sharedDimOffset == 0 ? ${initValue} : 0.0;
      for (int i = 0; i < ${sharedDimReadSize}; ++i) {
        vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colLayout.width}, ${im2colLayout.height});
        vec2 kernelCoords = offsetToCoords(kernelOffset, ${kLayout.width}, ${kLayout.height});
        value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));
        ++im2colOffset;
        ++kernelOffset;
      }
      ${applyActivation}
      return value;
    }`;
        return {
            name: 'dotProduct',
            inputLayouts: inputs.length === 3 ? [im2colLayout, kLayout, bLayout] : [im2colLayout, kLayout],
            outputLayout,
            shaderSource,
            samplers,
            variables: [{ name: 'sharedDimOffset', type: 'int' }],
            params: { sharedDim, sharedDimReadSize }
        };
    }
    static prepKernelForDotProduct(shape, group, channels, kernel) {
        if (group === 1 && (channels === 1 || (shape[2] * shape[3]) % channels === 0)) {
            return kernel;
        }
        const numFeatureMaps = shape[0];
        const oldRowSize = shape[1] * shape[2] * shape[3];
        const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;
        const newSize = numFeatureMaps * newRowSize;
        const buffer = new Float32Array(newSize);
        for (let f = 0; f < numFeatureMaps; ++f) {
            const oldOffset = f * oldRowSize;
            const newOffset = f * newRowSize + f % group * oldRowSize;
            buffer.set(kernel.subarray(oldOffset, oldOffset + oldRowSize), newOffset);
        }
        return buffer;
    }
    static calcIm2ColDims(inputShape, kernelShape, outputShape, channels = 1) {
        return [
            outputShape[0], outputShape[2], outputShape[3],
            Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)
        ];
    }
    calcSharedDimReadSize(preferredBatchSize, sharedDim) {
        if (preferredBatchSize <= 0 || sharedDim < preferredBatchSize || sharedDim % preferredBatchSize !== 0) {
            return sharedDim;
        }
        return preferredBatchSize;
    }
    calcBlockSize(outputLayout) {
        const preferredRowCount = 64;
        const preferredColCount = 64;
        if (outputLayout.height < preferredRowCount) {
            return undefined;
        }
        return [preferredColCount, preferredRowCount];
    }
}
exports.WebGLUnpackedConv = WebGLUnpackedConv;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/depth-to-space.ts":
/*!*********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/depth-to-space.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLDepthToSpace = void 0;
const attribute_1 = __webpack_require__(/*! ../../../attribute */ "./lib/onnxjs/attribute.ts");
const depth_to_space_1 = __webpack_require__(/*! ../../../ops/depth-to-space */ "./lib/onnxjs/ops/depth-to-space.ts");
const reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
const transpose_1 = __webpack_require__(/*! ./transpose */ "./lib/onnxjs/backends/webgl/ops/transpose.ts");
class WebGLDepthToSpace extends depth_to_space_1.DepthToSpace {
    run(inferenceHandler, inputs) {
        const programManager = inferenceHandler.session.programManager;
        const transposePerm = this.mode === 'DCR' ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        const firstReshapeShape = this.mode === 'DCR' ?
            [
                inputs[0].dims[0], this.blocksize, this.blocksize, inputs[0].dims[1] / this.blocksizeSqr, inputs[0].dims[2],
                inputs[0].dims[3]
            ] :
            [
                inputs[0].dims[0], inputs[0].dims[1] / this.blocksizeSqr, this.blocksize, this.blocksize, inputs[0].dims[2],
                inputs[0].dims[3]
            ];
        const transpose = new transpose_1.WebGLTranspose();
        const attributes = new attribute_1.Attribute(undefined);
        attributes.set('perm', 'ints', transposePerm);
        transpose.initialize(attributes);
        // First reshape
        const firstReshapedTensor = reshape_1.reshape(inferenceHandler, inputs[0], firstReshapeShape);
        // transpose
        if (!this.transposeProgramInfo) {
            this.transposeProgramInfo = transpose.createProgramInfo(inferenceHandler, [firstReshapedTensor]);
            this.transposeArtifact = programManager.build(this.transposeProgramInfo);
        }
        const runDataTranspose = transpose.createRunData(inferenceHandler, this.transposeProgramInfo, [firstReshapedTensor]);
        inferenceHandler.checkAndUpdateTextureForm(this.transposeArtifact, runDataTranspose);
        programManager.run(this.transposeArtifact, runDataTranspose);
        const transposeOutput = runDataTranspose.outputTextureData.tensor;
        // Second reshape
        const result = reshape_1.reshape(inferenceHandler, transposeOutput, [
            inputs[0].dims[0], inputs[0].dims[1] / this.blocksizeSqr, inputs[0].dims[2] * this.blocksize,
            inputs[0].dims[3] * this.blocksize
        ]);
        return [result];
    }
    getOutShape(input) {
        const batchSize = input.dims[0];
        const inputDepth = input.dims[1];
        const inputHeight = input.dims[2];
        const inputWidth = input.dims[3];
        if (inputDepth % (this.blocksizeSqr) !== 0) {
            throw new Error('Input depth must be divisible by squared blocksize.');
        }
        const outputDepth = inputDepth / this.blocksizeSqr;
        const outputHeight = inputHeight * this.blocksize;
        const outputWidth = inputWidth * this.blocksize;
        return [batchSize, outputDepth, outputHeight, outputWidth];
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLDepthToSpace = WebGLDepthToSpace;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/dropout.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/dropout.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLDropout = void 0;
const dropout_1 = __webpack_require__(/*! ../../../ops/dropout */ "./lib/onnxjs/ops/dropout.ts");
class WebGLDropout extends dropout_1.Dropout {
    run(inferenceHandler, inputs) {
        if (this.testMode) {
            return [inputs[0]];
        }
        throw new Error('Non test mode Dropout is not implemented yet');
    }
    createProgramInfo(_handler, _inputs) {
        throw new Error('Non test mode Dropout is not implemented yet');
    }
    createRunData(_handler, _programInfo, _inputs) {
        throw new Error('Non test mode Dropout is not implemented yet');
    }
}
exports.WebGLDropout = WebGLDropout;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/elu.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/elu.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLElu = void 0;
const elu_1 = __webpack_require__(/*! ../../../ops/elu */ "./lib/onnxjs/ops/elu.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLElu extends elu_1.Elu {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const outputShape = inputs[0].dims.slice();
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      void main() {
        float v = ${glsl.texture2D}(A, TexCoords).r;
        ${glsl.output} = vec4(v >= 0.0 ? v: (exp(v) - 1.0) * ${this.alpha.toExponential()}); /* float number format */
      }
      `;
        return {
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
            hasMain: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLElu = WebGLElu;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/flatten.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/flatten.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLFlatten = void 0;
const flatten_1 = __webpack_require__(/*! ../../../ops/flatten */ "./lib/onnxjs/ops/flatten.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
class WebGLFlatten extends flatten_1.Flatten {
    run(inferenceHandler, inputs) {
        const outputDims = util_1.ShapeUtil.flattenShape(inputs[0].dims, this.axis);
        return [reshape_1.reshape(inferenceHandler, inputs[0], outputDims)];
    }
}
exports.WebGLFlatten = WebGLFlatten;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/fuse-utils.ts":
/*!*****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/fuse-utils.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActicationSnippet = void 0;
const unary_op_1 = __webpack_require__(/*! ./unary-op */ "./lib/onnxjs/backends/webgl/ops/unary-op.ts");
function getActicationSnippet(activation) {
    let activationFunction = '';
    let activationName = '';
    switch (activation) {
        case 'Relu':
            activationName = unary_op_1.glslRelu().name;
            activationFunction = unary_op_1.glslRelu().body;
            break;
        case 'Sigmoid':
            activationName = unary_op_1.glslSigmoid().name;
            activationFunction = unary_op_1.glslSigmoid().body;
            break;
        default:
            // TODO: adding other activations that can be fused.
            activationName = '';
            activationFunction = '';
    }
    const applyActivation = activation ? `
  value = ${activationName}(value);` :
        '';
    return { activationFunction, applyActivation };
}
exports.getActicationSnippet = getActicationSnippet;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/gather.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/gather.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLGather = void 0;
const gather_1 = __webpack_require__(/*! ../../../ops/gather */ "./lib/onnxjs/ops/gather.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
class WebGLGather extends gather_1.Gather {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputShape = inputs[0].dims.slice();
        const indexDataShape = inputs[1].dims.slice();
        const outputShape = new Array(inputShape.length + indexDataShape.length - 1);
        const axis = util_1.ShapeUtil.normalizeAxis(this.axis, inputShape.length);
        const indexCopyOps = [];
        for (let i = 0; i < outputShape.length; i++) {
            // outputShape is divided into three parts: A, B, C
            // |0        axis|  axis + indexDataShape.length |          end|
            // |     A       |             B                 |      C      |
            //
            // inputIdx: [A, inputs[1][B], C]
            if (i < axis) { // A
                outputShape[i] = inputShape[i];
                indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);
            }
            else {
                if (i < axis + indexDataShape.length) { // B
                    outputShape[i] = indexDataShape[i - axis];
                    indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);
                }
                else { // C
                    outputShape[i] = inputShape[i - indexDataShape.length + 1]; // skip 1 for axis
                    indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);
                }
            }
        }
        const orank = outputShape.length || 1;
        const irank = inputShape.length;
        const iDrank = indexDataShape.length || 1;
        const shaderSource = `
      float process(int outputIdx[${orank}]) {
        int inputIdx[${irank}];
        int indexDataIdx[${iDrank}];
        indexDataIdx[0] = 0;
        ${indexCopyOps.join('\n        ')}
        int idx = int(_B(indexDataIdx));
        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;
        return _A(inputIdx);
      }`;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'B'],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLGather = WebGLGather;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/gemm.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/gemm.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLGemm = void 0;
const gemm_1 = __webpack_require__(/*! ../../../ops/gemm */ "./lib/onnxjs/ops/gemm.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
class WebGLGemm extends gemm_1.Gemm {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N] = util_1.GemmUtil.getShapeOfGemmResult(aShape, this.transA, bShape, this.transB, inputs.length === 3 ? inputs[2].dims : undefined);
        const oShape = [M, N];
        if (!oShape) {
            throw new Error('Can\'t use gemm on the given tensors');
        }
        let sharedDim = aShape[aShape.length - 1];
        let line = '';
        if (this.transA) {
            sharedDim = aShape[0];
        }
        if (this.transA && this.transB) {
            line = 'value += _A_T(a) * _B_T(b);';
        }
        else if (this.transA && !this.transB) {
            line = 'value += _A_T(a) * _B(b);';
        }
        else if (!this.transA && this.transB) {
            line = 'value += _A(a) * _B_T(b);';
        }
        else if (!this.transA && !this.transB) {
            line = 'value += _A(a) * _B(b);';
        }
        const rank = oShape.length;
        const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : '';
        const broadcastC = inputs.length === 3 ? 'bcastIndices_C(indices, c);' : '';
        const calculateC = inputs.length === 3 ? 'value += beta * _C(c);' : '';
        const shaderSource = `
      float process(int indices[${rank}]) {
          int a[${rank}];
          int b[${rank}];
          ${declareC}

          copyVec(indices, a);
          copyVec(indices, b);
          ${broadcastC}

          float value = 0.0;
          for (int k=0; k<${sharedDim}; ++k) {
              a[${rank - 1}] = k;
              b[${rank - 2}] = k;
              ${line}
          }

          value = value * alpha;
          ${calculateC}
          return value;
      }`;
        const inputLayouts = inputs.map(t => inferenceHandler.getOrCreateTextureLayout(t));
        return {
            inputLayouts,
            outputLayout: inferenceHandler.createTextureLayoutFromShape(oShape),
            samplers: inputs.length === 3 ? ['A', 'B', 'C'] : ['A', 'B'],
            variables: [{ name: 'alpha', type: 'float' }, { name: 'beta', type: 'float' }],
            shaderSource,
        };
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => inferenceHandler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: { 'alpha': this.alpha, 'beta': this.beta }
        };
    }
}
exports.WebGLGemm = WebGLGemm;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/im2col-pack.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/im2col-pack.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLIm2ColPacked = void 0;
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
class WebGLIm2ColPacked {
    constructor(convOutputShape, kernelShape, dilations, pads, strides) {
        this.convOutputShape = convOutputShape;
        this.kernelShape = kernelShape;
        this.dilations = dilations;
        this.pads = pads;
        this.strides = strides;
    }
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        if (inputs.length !== 2) {
            throw new Error('Im2Col kernel should have two input tensors');
        }
        const xshape = inputs[0].dims.slice();
        const wshape = inputs[1].dims.slice();
        const rowDim = 2;
        const colDim = 3;
        const rank = this.convOutputShape.length;
        const im2colShape = [wshape[1] * wshape[2] * wshape[3], this.convOutputShape[2] * this.convOutputShape[3]];
        const kernelSize = wshape[2] * wshape[3];
        const unpackChannel = packing_utils_1.unpackFromChannel();
        const glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        let unrolled = '';
        for (let row = 0; row <= 1; row++) {
            for (let col = 0; col <= 1; col++) {
                unrolled += `
          blockIndex = rc.x + ${col};
          pos = rc.y + ${row};

          if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {
            offsetY = int(blockIndex / (${this.convOutputShape[rank - 1]})) * ${this.strides[0]} - ${this.pads[0]};
            d0 = offsetY + ${this.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});

            if(d0 < ${xshape[rowDim]} && d0 >= 0) {
              offsetX = imod(blockIndex, ${this.convOutputShape[rank - 1]}) * ${this.strides[1]} - ${this.pads[1]};
              d1 = offsetX + ${this.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});

              if(d1 < ${xshape[colDim]} && d1 >= 0) {

                ch = int(float(pos)/ ${kernelSize}.);
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(0, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
              }
            }
          }

        `;
            }
        }
        const shaderSource = `
    ${unpackChannel}

    void main() {
      ivec2 rc = getOutputCoords();
        vec4 result = vec4(0.0);
        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;
        ${unrolled}
        ${glsl.output} = result;
    }
          `;
        return {
            name: 'WebGLIm2ColPacked',
            inputLayouts: [inferenceHandler.getOrCreateTextureLayout(inputs[0], 4, true, xshape, true)],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(im2colShape, 4, im2colShape, { isPacked: true, reverseWH: true }),
            samplers: ['A'],
            shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t) => handler.getOrCreateTextureData(t, handler.getOrCreateTextureLayout(t, 1, false, [], true)));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLIm2ColPacked = WebGLIm2ColPacked;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/image-scaler.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/image-scaler.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLImageScaler = void 0;
const image_scaler_1 = __webpack_require__(/*! ../../../ops/image-scaler */ "./lib/onnxjs/ops/image-scaler.ts");
class WebGLImageScaler extends image_scaler_1.ImageScaler {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const outputShape = inputs[0].dims.slice();
        const rank = outputShape.length;
        const getBiasMethod = this.createGetBiasMethod(this.bias.length);
        const shaderSource = `
      ${getBiasMethod}
      float process(int indices[${rank}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
        return {
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['X'],
            variables: [{ name: 'bias', type: 'float', arrayLength: this.bias.length }, { name: 'scale', type: 'float' }],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: { 'bias': this.bias, 'scale': this.scale }
        };
    }
    createGetBiasMethod(numChannels) {
        const codeLines = [`float getBias(float bias[${numChannels}], int channel) {`];
        for (let i = 0; i < numChannels; ++i) {
            if (i === 0) {
                codeLines.push('\t' +
                    `if (channel == ${i}) { return bias[${i}]; }`);
            }
            else if (i === numChannels - 1) {
                codeLines.push('\t' +
                    `else { return bias[${i}]; }`);
            }
            else {
                codeLines.push('\t' +
                    `else if (channel == ${i}) { return bias[${i}]; }`);
            }
        }
        codeLines.push('\t' +
            '}');
        return codeLines.join('\n');
    }
}
exports.WebGLImageScaler = WebGLImageScaler;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/instance-normalization.ts":
/*!*****************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/instance-normalization.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLInstanceNormalization = void 0;
const instance_normalization_1 = __webpack_require__(/*! ../../../ops/instance-normalization */ "./lib/onnxjs/ops/instance-normalization.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLInstanceNormalization extends instance_normalization_1.InstanceNormalization {
    run(inferenceHandler, inputs) {
        if (!this.artifacts) {
            this.artifacts = [];
            const programInfos = this.createProgramInfos(inferenceHandler, inputs);
            programInfos.forEach((programInfo) => {
                const artifact = inferenceHandler.session.programManager.build(programInfo);
                this.artifacts.push(artifact);
            });
        }
        const runDatas = this.createRunDatas(inferenceHandler, this.artifacts.map(a => a.programInfo), inputs);
        runDatas.forEach((v, i) => inferenceHandler.session.programManager.run(this.artifacts[i], v));
        return [runDatas[1].outputTextureData.tensor];
    }
    checkInputTypes(inputs) {
        if (!super.checkInputTypes(inputs)) {
            return false;
        }
        if (inputs[0].dims.length !== 4) {
            // currently webgl implementation only support 4-D input.
            return false;
        }
        return true;
    }
    createMeanAndVarianceProgramInfo(inferenceHandler, xLayout) {
        const xDims = xLayout.shape;
        const channel = xDims[1];
        const channelSize = xDims[2] * xDims[3];
        const outputShape = [xDims[0], channel];
        const outputUnpackedShape = [xDims[0], channel * 4];
        const shaderSource = `
    vec4 process(int[2] indices) {
      vec4 v = vec4(0.0);
      int a[4];
      a[0] = indices[0];
      a[1] = indices[1];
      float temp = 0.0;
      for(int a2=0; a2<${xDims[2]}; a2++) {
        a[2] = a2;
        for(int a3=0; a3<${xDims[3]}; a3++) {
          a[3] = a3;
          float x = _X(a);
          temp += x;
        }
      }
      float mean = temp / float(${channelSize});
      temp = 0.0;
      for(int a2=0; a2<${xDims[2]}; a2++) {
        a[2] = a2;
        for(int a3=0; a3<${xDims[3]}; a3++) {
          a[3] = a3;
          float x = _X(a);
          temp += (x - mean) * (x - mean);
        }
      }
      v.r = mean;
      v.g = temp / float(${channelSize});

      return v;
    }`;
        return {
            inputLayouts: [xLayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape, 4, outputUnpackedShape),
            samplers: ['X'],
            shaderSource,
            name: 'MeanAndVariance',
        };
    }
    createComputOutputProgramInfo(inferenceHandler, xLayout, scaleLayout, bLayout, meanAndVarianceLayout) {
        const glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
    vec4 get_MeanAndVariance(int[2] mv) {
      int offset = indicesToOffset_MeanAndVariance(mv);
      vec2 coords = offsetToCoords(offset, ${meanAndVarianceLayout.width}, ${meanAndVarianceLayout.height});
      return ${glsl.texture2D}(MeanAndVariance, coords);
    }

    float process(int[4] indices) {

          int mv[2];
          mv[0] = indices[0];
          mv[1] = indices[1];
          vec4 mean_and_variance = get_MeanAndVariance(mv);
          float mean = mean_and_variance.r;
          float variance = mean_and_variance.g;

          int sb[1];
          sb[0] = indices[1];
          float scale = _Scale(sb);
          float b = _B(sb);

          return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
        }`;
        return {
            inputLayouts: [xLayout, meanAndVarianceLayout, scaleLayout, bLayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(xLayout.shape),
            samplers: ['X', 'MeanAndVariance', 'Scale', 'B'],
            variables: [{ name: 'epsilon', type: 'float' }],
            shaderSource,
            name: 'ComputOutput',
        };
    }
    createProgramInfos(inferenceHandler, inputs) {
        const xLayout = inferenceHandler.getOrCreateTextureLayout(inputs[0]);
        const scaleLayout = inferenceHandler.getOrCreateTextureLayout(inputs[1]);
        const bLayout = inferenceHandler.getOrCreateTextureLayout(inputs[2]);
        const meanAndVarianceProgramInfo = this.createMeanAndVarianceProgramInfo(inferenceHandler, xLayout);
        const computeOutputProgramInfo = this.createComputOutputProgramInfo(inferenceHandler, xLayout, scaleLayout, bLayout, meanAndVarianceProgramInfo.outputLayout);
        const programInfos = [meanAndVarianceProgramInfo, computeOutputProgramInfo];
        return programInfos;
    }
    createRunDatas(inferenceHandler, programInfos, inputs) {
        const dataType = inputs[0].type;
        const inputTD = inferenceHandler.getOrCreateTextureData(inputs[0], programInfos[0].inputLayouts[0]);
        const scaleTD = inferenceHandler.getOrCreateTextureData(inputs[1], programInfos[1].inputLayouts[2]);
        const bTD = inferenceHandler.getOrCreateTextureData(inputs[2], programInfos[1].inputLayouts[3]);
        const runDatas = [];
        runDatas.push({
            inputTextureDatas: [inputTD],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[0].outputLayout, dataType),
            uniformData: {}
        });
        runDatas.push({
            inputTextureDatas: [inputTD, runDatas[0].outputTextureData, scaleTD, bTD],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[1].outputLayout, dataType),
            uniformData: { 'epsilon': this.epsilon }
        });
        return runDatas;
    }
}
exports.WebGLInstanceNormalization = WebGLInstanceNormalization;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/leaky-relu.ts":
/*!*****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/leaky-relu.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLLeakyRelu = void 0;
const leaky_relu_1 = __webpack_require__(/*! ../../../ops/leaky-relu */ "./lib/onnxjs/ops/leaky-relu.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLLeakyRelu extends leaky_relu_1.LeakyRelu {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const outputShape = inputs[0].dims.slice();
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      void main() {
        float v = ${glsl.texture2D}(A, TexCoords).r;
        ${glsl.output} = vec4(v < 0.0 ? v * float(${this.alpha}) : v);
      }
      `;
        return {
            hasMain: true,
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])],
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLLeakyRelu = WebGLLeakyRelu;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/matmul-pack.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/matmul-pack.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLMatMulPacked = void 0;
const matmul_1 = __webpack_require__(/*! ../../../ops/matmul */ "./lib/onnxjs/ops/matmul.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const fuse_utils_1 = __webpack_require__(/*! ./fuse-utils */ "./lib/onnxjs/backends/webgl/ops/fuse-utils.ts");
class WebGLMatMulPacked extends matmul_1.MatMul {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? 'result += getBiasAtOutCoords();' : '';
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outputShape = util_1.BroadcastUtil.calcShape(aShape, bShape, true);
        if (!outputShape) {
            throw new Error('Can\'t use matmul on the given tensors');
        }
        const sharedDim = aShape[aShape.length - 1];
        const sharedDimIndex = Math.ceil(sharedDim / 2);
        const aRank = aShape.length;
        const bRank = bShape.length;
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const coordsDataType = utils_1.getCoordsDataType(outputShape.length);
        const outRank = outputShape.length;
        const allGlChannels = ['x', 'y', 'z', 'w', 'u', 'v'];
        const { activationFunction, applyActivation } = fuse_utils_1.getActicationSnippet(this.activation);
        const shaderSource = `
      ${activationFunction}
      void main() {
        ${coordsDataType} rc = getOutputCoords();
        int lastDim = rc.${allGlChannels[outRank - 1]};
        rc.${allGlChannels[outRank - 1]} = rc.${allGlChannels[outRank - 2]};
        rc.${allGlChannels[outRank - 2]} = lastDim;

        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimIndex}; i++) {
          vec4 a = getA(${getA(allGlChannels, aRank)});
          vec4 b = getB(${getB(allGlChannels, bRank)});
          result += (a.rrbb * b.rgrg);
          result += (a.ggaa * b.baba);
        }
        ${processBias}
        ${applyActivation}
        ${glsl.output} = result;
      }`;
        return {
            name: 'WebGLMatMulPacked',
            inputLayouts: inputs.map((t, i) => handler.getOrCreateTextureLayout(t, 4, true, inputs[i].dims, true)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }),
            samplers: hasBias ? ['A', 'B', 'Bias'] : ['A', 'B'],
            shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t) => handler.getOrCreateTextureData(t, handler.getOrCreateTextureLayout(t, 1, false, [], true)));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLMatMulPacked = WebGLMatMulPacked;
function getA(allGlChannels, rank) {
    let res = '';
    for (let i = 0; i < rank - 2; i++) {
        res += `rc.${allGlChannels[i]}, `;
    }
    res += `rc.${allGlChannels[rank - 2]}, ` +
        'i*2';
    return res;
}
function getB(allGlChannels, rank) {
    let res = '';
    for (let i = 0; i < rank - 2; i++) {
        res += `rc.${allGlChannels[i]}, `;
    }
    res += 'i*2, ' +
        `rc.${allGlChannels[rank - 1]}`;
    return res;
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/matmul.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/matmul.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnpackedMatMul = exports.WebGLMatMul = void 0;
const matmul_1 = __webpack_require__(/*! ../../../ops/matmul */ "./lib/onnxjs/ops/matmul.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const matmul_pack_1 = __webpack_require__(/*! ./matmul-pack */ "./lib/onnxjs/backends/webgl/ops/matmul-pack.ts");
class WebGLMatMul extends matmul_1.MatMul {
    constructor() {
        super();
        this.packedImpl = new matmul_pack_1.WebGLMatMulPacked();
        this.unpackedImpl = new WebGLUnpackedMatMul();
    }
    run(inferenceHandler, inputs) {
        if (this.usePackedTexture === undefined) {
            const isBroadcast = !util_1.ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
            this.usePackedTexture = !isBroadcast && inferenceHandler.session.pack;
        }
        if (this.usePackedTexture) {
            return inferenceHandler.run(this.packedImpl, inputs);
        }
        else {
            return inferenceHandler.run(this.unpackedImpl, inputs);
        }
    }
    createProgramInfo(handler, inputs) {
        if (this.usePackedTexture === undefined) {
            const isBroadcast = !util_1.ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
            this.usePackedTexture = !isBroadcast && handler.session.pack;
        }
        if (this.usePackedTexture && inputs[0].dims.length > 1) {
            return this.packedImpl.createProgramInfo(handler, inputs);
        }
        else {
            return this.unpackedImpl.createProgramInfo(handler, inputs);
        }
    }
    createRunData(handler, programInfo, inputs) {
        if (this.usePackedTexture && inputs[0].dims.length > 1) {
            return this.packedImpl.createRunData(handler, programInfo, inputs);
        }
        else {
            return this.unpackedImpl.createRunData(handler, programInfo, inputs);
        }
    }
}
exports.WebGLMatMul = WebGLMatMul;
class WebGLUnpackedMatMul extends matmul_1.MatMul {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outputShape = util_1.BroadcastUtil.calcShape(aShape, bShape, true);
        if (!outputShape) {
            throw new Error('Can\'t use matmul on the given tensors');
        }
        const rank = outputShape.length;
        const arank = aShape.length;
        const brank = bShape.length;
        const sharedDim = aShape[aShape.length - 1];
        const shaderSource = `
      float process(int indices[${rank}]) {
          int a[${arank}];
          int b[${brank}];
          bcastMatmulIndices_A(indices, a);
          bcastMatmulIndices_B(indices, b);

          float value;
          for (int k=0; k<${sharedDim}; ++k) {
              a[${arank - 1}] = k;
              b[${brank - 2}] = k;
              value += _A(a) * _B(b);
          }
          return value;
      }`;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'B'],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLUnpackedMatMul = WebGLUnpackedMatMul;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/pack.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/pack.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLPack = void 0;
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
class WebGLPack {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        if (inputs.length !== 1) {
            throw new Error('Pack kernel should have input tensor count to 1.');
        }
        const inputShape = inputs[0].dims;
        const outputLayout = handler.createTextureLayoutFromShape(inputShape, 4, inputShape, { isPacked: true, reverseWH: true });
        const outputShape = outputLayout.shape;
        const inputRank = inputShape.length;
        const outputRank = outputShape.length;
        const coordsDataType = utils_1.getCoordsDataType(outputRank);
        const channels = packing_utils_1.getChannels('rc', outputRank);
        const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);
        let reversedInputWH;
        if (inputRank === 0) {
            reversedInputWH = [1, 1];
        }
        else if (inputRank === 1) {
            reversedInputWH = [inputShape[0], 1];
        }
        else {
            reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];
        }
        const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);
        const output = getOutput(inputShape, channels);
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
        void main() {
          ${coordsDataType} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            ${glsl.output} = vec4(0);
          } else {
            ${setup}

            ${glsl.output} = vec4(${output});
          }
        }
      `;
        return {
            name: 'WebGLPack',
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0], 1, false, [], true)],
            outputLayout,
            samplers: ['A'],
            shaderSource,
            hasMain: true,
            expectPackedInputs: false,
            expectPackedOutputs: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLPack = WebGLPack;
/**
 * check output coordinate location and return false if it is outside input's width/height boundary
 */
function getOutOfBoundsCondition(rank, shape, dims) {
    if (rank === 1) {
        return `rc > ${shape[0]}`;
    }
    let cond = '';
    for (let i = rank - 2; i < rank; i++) {
        cond += `${dims[i]} >= ${shape[i - rank + 2]}`;
        if (i < rank - 1) {
            cond += '||';
        }
    }
    return cond;
}
/**
 * code snippet to sample input texture with output coordiantes
 */
function getOutput(shape, dims) {
    const rank = shape.length;
    if (rank === 0) {
        return 'getA(), 0, 0, 0';
    }
    if (rank === 1) {
        return `getA(rc),
            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
            0, 0`;
    }
    const coord00 = 'r, c';
    const coord01 = 'r, cp1';
    const coord10 = 'rp1, c';
    const coord11 = 'rp1, cp1';
    let D = '';
    if (rank > 2) {
        for (let i = 0; i < rank - 2; ++i) {
            D = D + `${dims[i]},`;
        }
    }
    return `getA(${D}${coord00}),
          rEdge ? 0. : getA(${D}${coord10}),
          cEdge ? 0. : getA(${D}${coord01}),
          rEdge || cEdge ? 0. : getA(${D}${coord11})`;
}
/**
 * code snippet to setup 4 coordinates and edge conditions
 */
function getSetup(rank, dims, rows, cols) {
    if (rank === 0 || rank === 1) {
        return '';
    }
    // rank >= 2 for width+height pack.
    else {
        const setup = `
    int r = ${dims[rank - 2]};
    int c = ${dims[rank - 1]};
    int rp1 = ${dims[rank - 2]} + 1;
    int cp1 = ${dims[rank - 1]} + 1;
    bool rEdge = rp1 >= ${cols};
    bool cEdge = cp1 >= ${rows};
    `;
        return setup;
    }
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/packing-utils.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unpackFromChannel = exports.getChannels = exports.getVecChannels = void 0;
function getVecChannels(name, rank) {
    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);
}
exports.getVecChannels = getVecChannels;
function getChannels(name, rank) {
    if (rank === 1) {
        return [name];
    }
    return getVecChannels(name, rank);
}
exports.getChannels = getChannels;
function unpackFromChannel() {
    return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
}
exports.unpackFromChannel = unpackFromChannel;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/pad.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/pad.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPadFunction = exports.WebGLPad = void 0;
const pad_1 = __webpack_require__(/*! ../../../ops/pad */ "./lib/onnxjs/ops/pad.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLPad extends pad_1.Pad {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        const outputShape = util_1.ShapeUtil.padShape(inputs[0].dims.slice(), this.pads);
        const rank = outputShape.length;
        const alayout = inferenceHandler.getOrCreateTextureLayout(inputs[0]);
        const padFunction = getPadFunction(glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version), 'A', alayout, this.mode, this.pads, this.value);
        const shaderSource = `
      ${padFunction}
      float process(int[${rank}] indices) {
          return padA(indices);
      }`;
        return {
            inputLayouts: [alayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
        };
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLPad = WebGLPad;
function getPadFunction(glsl, name, inputLayout, mode, pads, value) {
    switch (mode) {
        case 'constant':
            return getPadConstant(glsl, name, inputLayout.shape, inputLayout.strides, inputLayout.width, inputLayout.height, pads, value);
        case 'reflect':
            return getPadReflect(glsl, name, inputLayout.shape, inputLayout.strides, inputLayout.width, inputLayout.height, pads);
        case 'edge':
            return getPadEdge(glsl, name, inputLayout.shape, inputLayout.strides, inputLayout.width, inputLayout.height, pads);
        default:
            throw new Error('Invalid mode');
    }
}
exports.getPadFunction = getPadFunction;
function getPadConstant(glsl, name, shape, strides, width, height, pads, value) {
    const rank = shape.length;
    let block = '';
    for (let i = rank - 1; i >= 0; --i) {
        block += `
          k = m[${i}] - ${pads[i]};
          if (k < 0)  return constant;
          if (k >= ${shape[i]}) return constant;
          offset += k * ${strides[i]};
          `;
    }
    return `
        float pad${name}(int m[${rank}]) {
          const float constant = float(${value});
          int offset = 0;
          int k = 0;
          ${block}
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          float value = getColorAsFloat(${glsl.texture2D}(${name}, coords));
          return value;
        }
        `;
}
function getPadReflect(glsl, name, shape, strides, width, height, pads) {
    const rank = shape.length;
    let block = '';
    for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (shape[i] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${shape[i]}) { k = _2n_1 - k; }
        }
        offset += k * ${strides[i]};
        `;
    }
    return `
      float pad${name}(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(${name}, coords));
        return value;
      }
      `;
}
function getPadEdge(glsl, name, shape, strides, width, height, pads) {
    const rank = shape.length;
    let block = '';
    for (let i = rank - 1; i >= 0; --i) {
        block += `
      k = m[${i}] - ${pads[i]};
      if (k < 0)  k = 0;
      if (k >= ${shape[i]}) k = ${shape[i] - 1};
      offset += k * ${strides[i]};
      `;
    }
    return `
    float pad${name}(int m[${rank}]) {
      int offset = 0;
      int k = 0;
      ${block}
      vec2 coords = offsetToCoords(offset, ${width}, ${height});
      float value = getColorAsFloat(${glsl.texture2D}(${name}, coords));
      return value;
    }
    `;
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/pool.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/pool.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.offsetToIndices = exports.copyArray = exports.generatePoolingCode = exports.WebGLMaxPool = exports.WebGLGlobalMaxPool = exports.WebGLAveragePool = exports.WebGLGlobalAveragePool = void 0;
const pool_1 = __webpack_require__(/*! ../../../ops/pool */ "./lib/onnxjs/ops/pool.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
class WebGLGlobalAveragePool extends pool_1.GlobalAveragePool {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        return createAveragePoolProgramInfo(inferenceHandler, inputs, true, this.kernelShape, this.autoPad, this.strides, this.pads, this.countIncludePad);
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLGlobalAveragePool = WebGLGlobalAveragePool;
class WebGLAveragePool extends pool_1.AveragePool {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        return createAveragePoolProgramInfo(inferenceHandler, inputs, false, this.kernelShape, this.autoPad, this.strides, this.pads, this.countIncludePad);
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLAveragePool = WebGLAveragePool;
function createAveragePoolProgramInfo(inferenceHandler, inputs, isGlobalOperator, kernelShape = [], autoPad = '', strides = [], pads = [], countIncludePad) {
    const inputShape = inputs[0].dims.slice();
    util_1.PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, pads);
    const outputShape = util_1.PoolConvUtil.computePoolOutputShape(isGlobalOperator, inputShape, strides, kernelShape, pads, autoPad);
    const kernelSize = util_1.ShapeUtil.size(kernelShape);
    const op1 = 'value += _X(x);';
    let op2 = '';
    if (countIncludePad) {
        op2 += `value /= float(${kernelSize});`;
    }
    else {
        op2 += `value /= float(${kernelSize} - pad);`;
    }
    const inputLayout = inferenceHandler.getOrCreateTextureLayout(inputs[0]);
    const poolingCode = generatePoolingCode(inputLayout, kernelShape, pads, strides, op1, op2, '0.0');
    const shaderSource = `
      ${poolingCode}
    `;
    return {
        inputLayouts: [inputLayout],
        outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
        samplers: ['X'],
        shaderSource,
    };
}
class WebGLGlobalMaxPool extends pool_1.GlobalMaxPool {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        return createMaxPoolProgramInfo(inferenceHandler, inputs, true, this.kernelShape, this.autoPad, this.strides, this.pads);
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLGlobalMaxPool = WebGLGlobalMaxPool;
class WebGLMaxPool extends pool_1.MaxPool {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(inferenceHandler, inputs) {
        return createMaxPoolProgramInfo(inferenceHandler, inputs, false, this.kernelShape, this.autoPad, this.strides, this.pads);
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLMaxPool = WebGLMaxPool;
function createMaxPoolProgramInfo(inferenceHandler, inputs, isGlobalOperator, kernelShape = [], autoPad = '', strides = [], pads = []) {
    const inputShape = inputs[0].dims.slice();
    util_1.PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, pads);
    const outputShape = util_1.PoolConvUtil.computePoolOutputShape(isGlobalOperator, inputShape, strides, kernelShape, pads, autoPad);
    const op1 = `
              value = max(_X(x), value);
      `;
    const op2 = '';
    const inputLayout = inferenceHandler.createTextureLayoutFromShape(inputShape);
    const poolingCode = generatePoolingCode(inputLayout, kernelShape, pads, strides, op1, op2, '-1e5');
    const shaderSource = `
    ${poolingCode}
  `;
    return {
        inputLayouts: [inputLayout],
        outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
        samplers: ['X'],
        shaderSource,
    };
}
function generatePoolingCode(x, kernelShape, pads, strides, op1, op2, startVal) {
    const inputDims = x.shape;
    const rank = x.shape.length;
    if (kernelShape.length <= 2) {
        const kw = kernelShape[kernelShape.length - 1];
        const sw = strides[strides.length - 1];
        const pwStart = pads[pads.length / 2 - 1];
        const pwEnd = pads[pads.length - 1];
        const dimW = inputDims[rank - 1];
        let codeW = '';
        let codeH = '';
        let codeHEnd = '';
        if (pwStart + pwEnd !== 0) {
            codeW = `
                for (int i = 0; i < ${kw}; i++) {
                  x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
                  if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {
                    pad++;
                    continue;
                  }
                  ${op1}
                }`;
        }
        else {
            codeW = `
                for (int i = 0; i < ${kw}; i++) {
                  x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
                  ${op1}
                }`;
        }
        if (kernelShape.length === 2) {
            const kh = kernelShape[kernelShape.length - 2];
            const sh = strides[strides.length - 2];
            const phStart = pads[pads.length / 2 - 2];
            const phEnd = pads[pads.length - 2];
            const dimH = inputDims[rank - 2];
            if (phStart + phEnd !== 0) {
                codeH = `
              for (int j = 0; j < ${kh}; j++) {
                x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
                if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {
                  pad+= ${kw};
                  continue;
                }
            `;
            }
            else {
                codeH = `
                for (int j = 0; j < ${kh}; j++) {
                  x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
                `;
            }
            codeHEnd = `
              }
            `;
        }
        const poolingCode = `
            float process(int indices[${rank}]) {
              int x[${rank}];
              copyVec(indices, x);

              float value = ${startVal};
              int pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}
              return value;
            }
          `;
        return poolingCode;
    }
    else {
        const kernelSize = util_1.ShapeUtil.size(kernelShape);
        const kernelStrides = util_1.ShapeUtil.computeStrides(kernelShape);
        const stridesRank = kernelStrides.length;
        const padsRank = pads.length;
        const offsetToIndicesFunction = offsetToIndices(stridesRank);
        const copyInputDims = copyArray(inputDims, 'inputDims');
        const copyPads = copyArray(pads, 'pads');
        const copyKernelStrides = copyArray(kernelStrides, 'kernelStrides');
        const copyStrides = copyArray(strides, 'strides');
        const hasPads = pads.reduce((sum, cur) => sum + cur);
        let padCode = '';
        if (hasPads) {
            padCode = `
                if (x[j] >= inputDims[j] || x[j] < 0) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                ${op1}
              }`;
        }
        else {
            padCode = `
                  }
                  ${op1}`;
        }
        const poolingCode = `
            ${offsetToIndicesFunction}
            float process(int indices[${rank}]) {
                int x[${rank}];
                copyVec(indices, x);
                int offset[${stridesRank}];
                int pads[${padsRank}];
                int inputDims[${rank}];
                int kernelStrides[${stridesRank}];
                int strides[${stridesRank}];
                ${copyPads}
                ${copyInputDims}
                ${copyStrides}
                ${copyKernelStrides}

                float value = ${startVal};
                int pad = 0;
                bool isPad = false;
                for (int i = 0; i < ${kernelSize}; i++) {
                    offsetToIndices(i, kernelStrides, offset);
                    isPad = false;
                    for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {
                      x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]
                        + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];
                      ${padCode}
                }
                ${op2}

                return value;
            }`;
        return poolingCode;
    }
}
exports.generatePoolingCode = generatePoolingCode;
function copyArray(array, arrayName) {
    let block = '';
    for (let i = 0; i < array.length; i++) {
        block += `
      ${arrayName}[${i}] = ${array[i]};
    `;
    }
    return block;
}
exports.copyArray = copyArray;
function offsetToIndices(rank) {
    return `
    void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {
      if (${rank} == 0) {
        return;
      }
      for (int i = 0; i < ${rank} - 1; ++i) {
        indices[i] = offset / strides[i];
        offset -= indices[i] * strides[i];
      }
      indices[${rank} - 1] = offset;
    }`;
}
exports.offsetToIndices = offsetToIndices;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/reduce.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/reduce.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLReduceSumSquare = exports.WebGLReduceLogSum = exports.WebGLReduceProd = exports.WebGLReduceMin = exports.WebGLReduceMax = exports.WebGLReduceMean = exports.WebGLReduceSum = void 0;
const reduce_op_1 = __webpack_require__(/*! ../../../ops/reduce-op */ "./lib/onnxjs/ops/reduce-op.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
class WebGLGenericReduce extends reduce_op_1.ReduceBase {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const outputShape = [];
        const iRank = inputs[0].dims.length || 1;
        const idxCopy = []; // copy output indexes to input indexes
        const axes = util_1.ShapeUtil.normalizeAxes(this.axes, inputs[0].dims.length);
        const ops = this.getOps(inputs, axes); // [init ops, reduce ops, final ops]
        let reduceOps = ops[1];
        for (let k = 0; k < inputs[0].dims.length; k++) {
            // if this axis is reduced
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                if (this.keepDims) {
                    outputShape.push(1);
                } // else { remove the axis from outputShape; }
                // loop over the d-th axis
                reduceOps = `
        for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {
          inputIdx[${k}] = j${k};
          ${reduceOps}
        }
        `;
            }
            else {
                idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);
                outputShape.push(inputs[0].dims[k]);
            }
        }
        const oRank = outputShape.length || 1;
        const shaderSource = `
      float process(int outputIdx[${oRank}]) {
        float value;                 // final result
        int inputIdx[${iRank}];      // addressing input data
        ${idxCopy.join('\n')}
        ${ops[0]}       // init ops for reduce max/min
        ${reduceOps}
        ${ops[2]}       // final computation for reduce mean
        return value;
      }`;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
class WebGLReduceSum extends WebGLGenericReduce {
    getOps(_inputs) {
        return ['value = 0.0;', 'value += _A(inputIdx);', ''];
    }
}
exports.WebGLReduceSum = WebGLReduceSum;
class WebGLReduceMean extends WebGLGenericReduce {
    getOps(inputs, axes) {
        let size = 1.0;
        for (let k = 0; k < inputs[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                size *= inputs[0].dims[k];
            }
        }
        return ['value = 0.0;', 'value += _A(inputIdx);', `value /= ${size}.;`]; // ensure real number with `.`
    }
}
exports.WebGLReduceMean = WebGLReduceMean;
class WebGLReduceMax extends WebGLGenericReduce {
    getOps(inputs, axes) {
        const idxZero = [];
        for (let k = 0; k < inputs[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                idxZero.push(`inputIdx[${k}] = 0;`); // first element
            }
        }
        return [`${idxZero.join('\n')}\nvalue = _A(inputIdx);`, 'value = max(value, _A(inputIdx));', ''];
    }
}
exports.WebGLReduceMax = WebGLReduceMax;
class WebGLReduceMin extends WebGLGenericReduce {
    getOps(inputs, axes) {
        const idxZero = [];
        for (let k = 0; k < inputs[0].dims.length; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
                idxZero.push(`inputIdx[${k}] = 0;`); // first element
            }
        }
        return [`${idxZero.join('\n')}\nvalue = _A(inputIdx);`, 'value = min(value, _A(inputIdx));', ''];
    }
}
exports.WebGLReduceMin = WebGLReduceMin;
class WebGLReduceProd extends WebGLGenericReduce {
    getOps(_inputs) {
        return ['value = 1.0;', 'value *= _A(inputIdx);', ''];
    }
}
exports.WebGLReduceProd = WebGLReduceProd;
class WebGLReduceLogSum extends WebGLGenericReduce {
    getOps(_inputs) {
        return ['value = 0.0;', 'value += _A(inputIdx);', 'value = log(value);'];
    }
}
exports.WebGLReduceLogSum = WebGLReduceLogSum;
class WebGLReduceSumSquare extends WebGLGenericReduce {
    getOps(_inputs) {
        return ['float t; value = 0.0;', 't = _A(inputIdx); value += t * t;', ''];
    }
}
exports.WebGLReduceSumSquare = WebGLReduceSumSquare;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/reshape-packed.ts":
/*!*********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/reshape-packed.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLReshapePacked = void 0;
const reshape_1 = __webpack_require__(/*! ../../../ops/reshape */ "./lib/onnxjs/ops/reshape.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
class WebGLReshapePacked extends reshape_1.Reshape {
    constructor() {
        super(...arguments);
        this.needSqueezeInputData = false;
    }
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        if (inputs.length !== 2) {
            throw new Error('resize kernel should have input tensor count to 2.');
        }
        // For packed reshape, we need to re-arrange texel data for output shape.
        // Our pack is designed to pack a 2x2 tile in last h and w dimension, so
        // for the reshaped new tensor, we just need to re-arrange the last h and
        // w dimension. For any shape that is not in 3D, i.e. [batch, W, H], we
        // first convert it to 3D by collapsing other dimension to batch dim, then
        // process with the last two dimensions.
        // Note: we only need the shape tensor to calculate output shape, so the
        // content in shape tensor is never uploaded to GPU. It is always kept in CPU.
        // TODO: optimize the algorithm -- in some cases, if the last two dims are
        // the same between input shape and output shape, the packed reshape can be
        // treated as no-op.
        // TODO: the implementation is a bit complicated due to the fact tensor shape is
        // immutable once the tensor is created, plus the tensor shape has a 1-to-1
        // mapping with texture layout. In the future, we may consider relaxing this
        // assumption.
        const originInputShape = inputs[0].dims;
        this.inputShape3D = processDims3D(inputs[0].dims);
        let inputLayout;
        inputLayout = handler.getOrCreateTextureLayout(inputs[0], 4, true, originInputShape, true);
        if (originInputShape.length !== 3) {
            const originalInputLayout = inputLayout;
            // if originShape is not a 3D shape, create texture layout from the processed shape.
            inputLayout = handler.createTextureLayoutFromShape(this.inputShape3D, 4, this.inputShape3D, { isPacked: true, reverseWH: true });
            // if the processed input shape produces texture layout differnt from the original
            // one, the run data has to use the processed (3D) input shape later.
            this.needSqueezeInputData =
                (inputLayout.height !== originalInputLayout.height) || (inputLayout.width !== originalInputLayout.width);
        }
        this.outputShape = util_1.ShapeUtil.calculateReshapedDims(originInputShape, inputs[1].integerData);
        const squeezedOutputShape = processDims3D(this.outputShape);
        this.outputLayout = handler.createTextureLayoutFromShape(squeezedOutputShape, 4, squeezedOutputShape, { isPacked: true, reverseWH: true });
        let mainLoop = '';
        for (let i = 0; i < 4; i++) {
            let outputCoords = '';
            switch (i) {
                case 0:
                    outputCoords = 'outputCoords = rc;';
                    break;
                case 1:
                    outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z);';
                    break;
                case 2:
                    outputCoords = 'outputCoords = ivec3(rc.x, rc.y, rc.z+1);';
                    break;
                case 3:
                    outputCoords = 'outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);';
                    break;
                default:
                    throw new Error();
            }
            mainLoop += `
        ${outputCoords}
        ${i > 0 ? 'if(outputCoords.y < rows && outputCoords.z < cols){' : ''}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${i > 0 ? '}' : ''}
      `;
        }
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      ${getReshapedInputCoords(this.inputShape3D)}
      ${getFlattenedIndexFrom3D(squeezedOutputShape)}
      ${packing_utils_1.unpackFromChannel()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${squeezedOutputShape[2]};
        int cols = ${squeezedOutputShape[1]};

        ${mainLoop}
        ${glsl.output} = result;
      }
    `;
        return {
            name: 'WebGLReshapePacked',
            inputLayouts: [inputLayout],
            outputLayout: this.outputLayout,
            samplers: ['A'],
            shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: true,
        };
    }
    createRunData(handler, programInfo, inputs) {
        let inputTDs;
        const originalInputLayout = handler.getOrCreateTextureLayout(inputs[0], 1, false, [], false);
        const originalInputTD = handler.getOrCreateTextureData(inputs[0], originalInputLayout, false);
        if (this.needSqueezeInputData) {
            const squeezedInputLayout = {
                channels: 1,
                height: originalInputLayout.height,
                width: originalInputLayout.width,
                shape: this.inputShape3D,
                strides: util_1.ShapeUtil.computeStrides(this.inputShape3D),
                unpackedShape: this.inputShape3D,
            };
            const squeezedInputTD = handler.createSharedTextureData(squeezedInputLayout, inputs[0].type, originalInputTD.texture);
            inputTDs = [squeezedInputTD];
        }
        else {
            inputTDs = [originalInputTD];
        }
        let outputLayout = this.outputLayout;
        // Use original output shape for runData output layout.
        outputLayout.shape = this.outputShape;
        outputLayout.unpackedShape = this.outputShape;
        if (outputLayout === undefined) {
            outputLayout = handler.createTextureLayoutFromShape(this.outputShape, 4, this.outputShape, { isPacked: true, reverseWH: true });
        }
        // return run data for reshape. Here, we use the original calculate outputLayout to create the real output layout.
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLReshapePacked = WebGLReshapePacked;
function processDims3D(shape) {
    if (shape.length === 0) {
        return [1, 1, 1];
    }
    // TODO: squeeze other shapes to 2D case
    const batchDims = shape.length >= 3 ? shape.slice(0, shape.length - 2) : [1];
    let batch = 1;
    for (let i = 0; i < batchDims.length; ++i) {
        batch *= batchDims[i];
    }
    return [batch, shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];
}
function getReshapedInputCoords(shape) {
    const strides = util_1.ShapeUtil.computeStrides(shape);
    const coords = ['b', 'r', 'c'];
    const index = 'index';
    const coordsFromIndexSnippet = strides
        .map((stride, i) => {
        const line1 = `int ${coords[i]} = ${index} / ${stride}`;
        const line2 = i === strides.length - 1 ?
            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :
            `index -= ${coords[i]} * ${stride}`;
        return `${line1}; ${line2};`;
    })
        .join('');
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(b, r, c);
    }
  `;
}
function getFlattenedIndexFrom3D(shape) {
    const strides = util_1.ShapeUtil.computeStrides(shape);
    return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;
  }
`;
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/reshape.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/reshape.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reshape = exports.WebGLReshape = void 0;
const reshape_1 = __webpack_require__(/*! ../../../ops/reshape */ "./lib/onnxjs/ops/reshape.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const reshape_packed_1 = __webpack_require__(/*! ./reshape-packed */ "./lib/onnxjs/backends/webgl/ops/reshape-packed.ts");
class WebGLReshape extends reshape_1.Reshape {
    constructor() {
        super();
        this.packedImpl = new reshape_packed_1.WebGLReshapePacked();
    }
    run(inferenceHandler, inputs) {
        if (inferenceHandler.session.pack) {
            return inferenceHandler.run(this.packedImpl, inputs);
        }
        else {
            const reshapedDims = util_1.ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);
            const reshapedTensor = reshape(inferenceHandler, inputs[0], reshapedDims);
            return [reshapedTensor];
        }
    }
}
exports.WebGLReshape = WebGLReshape;
function reshape(inferenceHandler, input, reshapedDims) {
    const inputTD = inferenceHandler.getOrCreateTextureData(input);
    let packedShape = reshapedDims;
    if (inputTD.channels === 4) {
        packedShape = utils_1.getPackedShape(reshapedDims);
    }
    const newTextureLayout = {
        channels: inputTD.channels,
        height: inputTD.height,
        width: inputTD.width,
        // handle reshaping into scalar Tensors
        shape: packedShape.length !== 0 ? packedShape : [1],
        strides: util_1.ShapeUtil.computeStrides(packedShape),
        unpackedShape: reshapedDims,
    };
    const newTextureData = inferenceHandler.createSharedTextureData(newTextureLayout, input.type, inputTD.texture);
    return newTextureData.tensor;
}
exports.reshape = reshape;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/resize-packed.ts":
/*!********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/resize-packed.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLResizePacked = void 0;
const upsample_1 = __webpack_require__(/*! ../../../ops/upsample */ "./lib/onnxjs/ops/upsample.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
class WebGLResizePacked extends upsample_1.Upsample {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputLayout = handler.getOrCreateTextureLayout(inputs[0], 4, true, inputs[0].dims, true);
        const [roi, scales, outputShape] = this.prepareInputs(inputs);
        const outputLayout = handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true });
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        return createResizeProgramInfo(glsl, this.mode, inputLayout, outputLayout, scales, roi, this.useExtrapolation, this.extrapolationValue, this.cubicCoefficientA, this.excludeOutside, this.coordinateTransformMode);
    }
    createRunData(handler, programInfo, inputs) {
        const inputTD = handler.getOrCreateTextureData(inputs[0], handler.getOrCreateTextureLayout(inputs[0], 1, false, [], true));
        const outputTD = handler.createTextureDataFromLayout(programInfo.outputLayout, inputTD.tensor.type);
        return { inputTextureDatas: [inputTD], outputTextureData: outputTD, uniformData: {} };
    }
}
exports.WebGLResizePacked = WebGLResizePacked;
function createResizeProgramInfo(glsl, mode, inputLayout, outputLayout, scales, roi, extrapolationEnabled, extrapolationValue, cubicCoefficientA, excludeOutside, coordinateTransformMode) {
    const isSame = scales.every(s => s === 1) && coordinateTransformMode !== 'tf_crop_and_resize';
    if (isSame) {
        return {
            inputLayouts: [inputLayout],
            outputLayout,
            samplers: ['X'],
            hasMain: true,
            shaderSource: `void main() {
      vec4 v = ${glsl.texture2D}(X, TexCoords);
      ${glsl.output} = v;
    }`
        };
    }
    const outputShape = outputLayout.unpackedShape;
    const dim = outputShape.length;
    if (dim < 2) {
        throw new Error(`output dimension should be at least 2, but got ${dim}`);
    }
    const outputHeight = outputShape[dim - 2];
    const outputWidth = outputShape[dim - 1];
    const inputShape = inputLayout.unpackedShape;
    if (dim !== inputShape.length) {
        throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);
    }
    const inputHeight = inputShape[dim - 2];
    const inputWidth = inputShape[dim - 1];
    const scalesHeight = scales[dim - 2];
    const scalesWidth = scales[dim - 1];
    let getSourceFracIndex = '';
    if (mode !== 'linear') {
        // TODO: support other modes
        throw new Error(`resize (packed) does not support mode: '${mode}'`);
    }
    switch (coordinateTransformMode) {
        case 'asymmetric':
            getSourceFracIndex = `
        vec4 getSourceFracIndex(ivec4 coords){
          return vec4(coords) / scaleWHWH;
        }
    `;
            break;
        case 'half_pixel':
            getSourceFracIndex = `
        vec4 getSourceFracIndex(ivec4 coords){
          return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
        }
    `;
            break;
        case 'align_corners':
            getSourceFracIndex = `
        vec4 getSourceFracIndex(ivec4 coords){
          vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0);
          vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0);
          vec4 new_scale = original / resized;
          return vec4(coords) * new_scale;
        }
      `;
            break;
        default:
            // TODO:supporting other coordinateTransformModes
            throw new Error(`resize (packed) does not support coordinateTransformMode: '${coordinateTransformMode}'`);
    }
    const coordsDataType = utils_1.getCoordsDataType(dim);
    const unpackChannel = packing_utils_1.unpackFromChannel();
    const shader = `
        const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);
        const vec4 scaleWHWH = vec4(${scalesHeight}.0, ${scalesWidth}.0, ${scalesHeight}.0, ${scalesWidth}.0);
        ${unpackChannel}
        ${getSourceFracIndex}
        float getAValue(int x10, int r, int c, int d) {
          return getChannel(getA(x10, r, c, d), vec2(c, d));
        }
        void main() {
          ${coordsDataType} rc = getOutputCoords();

          int batch = rc[0];
          int depth = rc[1];

          // retrieve the 4 coordinates that is used in the 4 packed output values.
          ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

          // calculate the source index in fraction
          vec4 sourceFrac = getSourceFracIndex(coords);

          // get the lower and upper bound of the 4 values that will be packed into one texel.
          ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
          ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
          ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
          ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

          bool hasNextRow = rc.w < ${outputHeight - 1};
          bool hasNextCol = rc.z < ${outputWidth - 1};

          // pack x00, x01, x10, x11's top-left corner into one vec4 structure
          vec4 topLeft = vec4(
            getAValue(batch, depth, x00.x, x00.y),
            hasNextCol ? getAValue(batch, depth, x01.x, x01.y)
                      : 0.0,
            hasNextRow ? getAValue(batch, depth, x10.x, x10.y)
                      : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(batch, depth, x11.x, x11.y) : 0.0);

          // pack x00, x01, x10, x11's top-right corner into one vec4 structure
          vec4 topRight = vec4(
            getAValue(batch, depth, x00.x, x00.w),
            hasNextCol ? getAValue(batch, depth, x01.x, x01.w)
                      : 0.0,
            hasNextRow ? getAValue(batch, depth, x10.x, x10.w)
                      : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(batch, depth, x11.x, x11.w) : 0.0);

          // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
          vec4 bottomLeft = vec4(
            getAValue(batch, depth, x00.z, x00.y),
            hasNextCol ? getAValue(batch, depth, x01.z, x01.y)
                      : 0.0,
            hasNextRow ? getAValue(batch, depth, x10.z, x10.y)
                      : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(batch, depth, x11.z, x11.y) : 0.0);

          // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
          vec4 bottomRight = vec4(
            getAValue(batch, depth, x00.z, x00.w),
            hasNextCol ? getAValue(batch, depth, x01.z, x01.w)
                      : 0.0,
            hasNextRow ? getAValue(batch, depth, x10.z, x10.w)
                      : 0.0,
            (hasNextRow && hasNextCol) ?
              getAValue(batch, depth, x11.z, x11.w) : 0.0);

          // calculate the interpolation fraction on u and v direction
          vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
          vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

          vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
          vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
          vec4 newValue = mix(top, bottom, clampFrac.xxzz);

          ${glsl.output} = vec4(newValue);
        }
      `;
    return {
        inputLayouts: [inputLayout],
        outputLayout,
        samplers: ['A'],
        shaderSource: shader,
        hasMain: true,
        expectPackedInputs: true,
        expectPackedOutputs: true,
    };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/shape.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/shape.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLShape = void 0;
const shape_1 = __webpack_require__(/*! ../../../ops/shape */ "./lib/onnxjs/ops/shape.ts");
const tensor_1 = __webpack_require__(/*! ../../../tensor */ "./lib/onnxjs/tensor.ts");
class WebGLShape extends shape_1.Shape {
    run(inferenceHandler, inputs) {
        return [new tensor_1.Tensor([inputs[0].dims.length], 'int32', undefined, undefined, new Int32Array(inputs[0].dims))];
    }
}
exports.WebGLShape = WebGLShape;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/slice.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/slice.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSliceV10 = exports.WebGLSlice = void 0;
const slice_1 = __webpack_require__(/*! ../../../ops/slice */ "./lib/onnxjs/ops/slice.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
class WebGLSlice extends slice_1.Slice {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        return createProgramInfo(handler, inputs[0], this.starts, this.ends, this.axes);
    }
    createRunData(handler, programInfo, inputs) {
        return createRunData(handler, programInfo, inputs);
    }
}
exports.WebGLSlice = WebGLSlice;
class WebGLSliceV10 extends slice_1.SliceV10 {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        if (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId) ||
            (inputs.length >= 4 && !handler.session.isInitializer(inputs[3].dataId)) ||
            (inputs.length >= 5 && !handler.session.isInitializer(inputs[4].dataId))) {
            throw new Error('dynamic slice attributes are not allowed');
        }
        if (inputs.length >= 5 && inputs[4].integerData.some((i) => i !== 1)) {
            throw new Error('currently non-1 steps is not supported for Slice');
        }
        const starts = Array.from(inputs[1].integerData);
        const ends = Array.from(inputs[2].integerData);
        const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];
        return createProgramInfo(handler, inputs[0], starts, ends, axes);
    }
    createRunData(handler, programInfo, inputs) {
        return createRunData(handler, programInfo, inputs);
    }
}
exports.WebGLSliceV10 = WebGLSliceV10;
function createProgramInfo(handler, x, starts, ends, axes) {
    if (axes.length === 0) {
        axes = x.dims.slice(0).map((val, ind) => ind);
    }
    axes = util_1.ShapeUtil.normalizeAxes(axes, x.dims.length);
    starts = starts.map((start, ind) => {
        if (start > x.dims[axes[ind]] - 1) {
            return x.dims[axes[ind]];
        }
        return util_1.ShapeUtil.normalizeAxis(start, x.dims[axes[ind]]);
    });
    ends = ends.map((end, ind) => {
        if (end > x.dims[axes[ind]] - 1) {
            return x.dims[axes[ind]];
        }
        return util_1.ShapeUtil.normalizeAxis(end, x.dims[axes[ind]]);
    });
    const outputShape = x.dims.slice();
    const sliceOps = [];
    for (let i = 0; i < axes.length; i++) {
        outputShape[axes[i]] = ends[i] - starts[i];
        if (starts[i] > 0) {
            sliceOps.push(`outputIdx[${axes[i]}] += ${starts[i]};`);
        } // else { sliceOps.push(`outputIdx[${axes[i]}] += 0;`); }
    }
    const rank = outputShape.length;
    const shaderSource = `
      float process(int outputIdx[${rank}]) {
        ${sliceOps.join('\n      ')}
        return _A(outputIdx);
      }`;
    return {
        inputLayouts: [handler.getOrCreateTextureLayout(x)],
        outputLayout: handler.createTextureLayoutFromShape(outputShape),
        samplers: ['A'],
        shaderSource,
    };
}
function createRunData(handler, programInfo, inputs) {
    const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
    return {
        inputTextureDatas: inputTDs,
        outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
        uniformData: {}
    };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/softmax.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/softmax.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSoftmax = void 0;
const softmax_1 = __webpack_require__(/*! ../../../ops/softmax */ "./lib/onnxjs/ops/softmax.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLSoftmax extends softmax_1.Softmax {
    constructor() {
        super();
    }
    run(inferenceHandler, inputs) {
        if (!this.artifacts) {
            this.artifacts = [];
            const programInfos = this.createProgramInfos(inferenceHandler, inputs);
            programInfos.forEach((pi) => {
                const artifact = inferenceHandler.session.programManager.build(pi);
                this.artifacts.push(artifact);
            });
        }
        const runDatas = this.createRunDatas(inferenceHandler, this.artifacts.map(a => a.programInfo), inputs);
        runDatas.forEach((v, i) => inferenceHandler.session.programManager.run(this.artifacts[i], v));
        // return only the last output
        return [runDatas[runDatas.length - 1].outputTextureData.tensor];
    }
    createSoftMaxProgramInfo(
    // eslint-disable-next-line @typescript-eslint/naming-convention
    inferenceHandler, input, N, D, maxElementPerLogicalRow, normalizationPerLogicalRow) {
        const inputShape = input.dims.slice();
        const inputLayout = inferenceHandler.createTextureLayoutFromShape(inputShape);
        const outputShape = inputShape;
        const rank = outputShape.length;
        const textureWidth = inputLayout.width;
        const textureHeight = inputLayout.height;
        if (N < 1 || D < 1) {
            throw new Error('Logical row count N and feature count D must be greater than or equal to 1');
        }
        if (maxElementPerLogicalRow.shape.length !== 1 || normalizationPerLogicalRow.shape.length !== 1) {
            throw new Error('Dimensionality of the intermediate results should be 1');
        }
        if (maxElementPerLogicalRow.shape[0] !== N || normalizationPerLogicalRow.shape[0] !== N) {
            throw new Error('Shape of the intermediate results should be equal to logical row count');
        }
        const shaderSource = `
    float process(int[${rank}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${D};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
        return {
            inputLayouts: [inputLayout, maxElementPerLogicalRow, normalizationPerLogicalRow],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'Max', 'Norm'],
            shaderSource,
            name: 'SoftMax',
        };
    }
    /**
     * Create a texture that contains the normalization factor for each of the 'N' rows
     */
    createComputScaleProgramInfo(
    // eslint-disable-next-line @typescript-eslint/naming-convention
    inferenceHandler, x, N, D, maxElementPerLogicalRow, outputShape) {
        const xlayout = inferenceHandler.createTextureLayoutFromShape(x.dims.slice());
        const rank = outputShape.length;
        const textureWidth = xlayout.width;
        const textureHeight = xlayout.height;
        if (N < 1 || D < 1) {
            throw new Error('Logical row count N and feature count D must be greater than or equal to 1');
        }
        if (outputShape.length !== 1) {
            throw new Error('Dimensionality of the output should be 1');
        }
        if (outputShape[0] !== N) {
            throw new Error('Shape of the output should be equal to logical row count');
        }
        if (maxElementPerLogicalRow.shape.length !== 1) {
            throw new Error('Dimensionality of the intermediate results should be 1');
        }
        if (maxElementPerLogicalRow.shape[0] !== N) {
            throw new Error('Shape of the intermediate results should be equal to logical row count');
        }
        const glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
    float process(int[${rank}] indices) {

      int logical_row_start_offset = indices[0] * ${D};

      float norm_factor = 0.0;
      float max = _Max(indices);
      for(int i=0; i<${D}; ++i)
      {
        norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i, ${textureWidth}, ${textureHeight}))) - max);
      }

      return norm_factor;
    }`;
        return {
            inputLayouts: [xlayout, maxElementPerLogicalRow],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A', 'Max'],
            shaderSource,
            name: 'ComputScale',
        };
    }
    /**
     * Create a texture that contains the maximum value of each of the 'N' rows
     */
    createComputeMaxProgramInfo(
    // eslint-disable-next-line @typescript-eslint/naming-convention
    inferenceHandler, x, N, D, outputShape) {
        const xlayout = inferenceHandler.createTextureLayoutFromShape(x.dims.slice());
        const rank = outputShape.length;
        const textureWidth = xlayout.width;
        const textureHeight = xlayout.height;
        if (N < 1 || D < 1) {
            throw new Error('Logical row count N and feature count D must be greater than or equal to 1');
        }
        if (outputShape.length !== 1) {
            throw new Error('Dimensionality of the output should be 1');
        }
        if (outputShape[0] !== N) {
            throw new Error('Shape of the output should be equal to logical row count');
        }
        const glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        const shaderSource = `
        float process(int[${rank}] indices) {

          int logical_row_start_offset = indices[0] * ${D};

          float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth}, ${textureHeight} )));
          for(int i=1; i<${D}; ++i)
          {
            float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i, ${textureWidth}, ${textureHeight})));
            if(current > max)
              max = current;
          }

          return max;
        }`;
        return {
            inputLayouts: [xlayout],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
            name: 'ComputeMax',
        };
    }
    createProgramInfos(inferenceHandler, inputs) {
        const inputShape = inputs[0].dims.slice();
        const axis = util_1.ShapeUtil.normalizeAxis(this.axis, inputShape.length);
        const N = util_1.ShapeUtil.sizeToDimension(inputShape, axis);
        const D = util_1.ShapeUtil.sizeFromDimension(inputShape, axis);
        const computeMaxProgramInfo = this.createComputeMaxProgramInfo(inferenceHandler, inputs[0], N, D, [N]);
        const computeScaleProgramInfo = this.createComputScaleProgramInfo(inferenceHandler, inputs[0], N, D, computeMaxProgramInfo.outputLayout, [N]);
        const softMaxProgramInfo = this.createSoftMaxProgramInfo(inferenceHandler, inputs[0], N, D, computeMaxProgramInfo.outputLayout, computeScaleProgramInfo.outputLayout);
        const programInfos = [computeMaxProgramInfo, computeScaleProgramInfo, softMaxProgramInfo];
        return programInfos;
    }
    createRunDatas(inferenceHandler, programInfos, inputs) {
        const dataType = inputs[0].type;
        const inputTD = inferenceHandler.getOrCreateTextureData(inputs[0], programInfos[0].inputLayouts[0]);
        const runDatas = [];
        runDatas.push({
            inputTextureDatas: [inputTD],
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[0].outputLayout, dataType),
            uniformData: {}
        });
        for (let i = 1; i < programInfos.length; ++i) {
            runDatas.push({
                inputTextureDatas: [...runDatas[i - 1].inputTextureDatas, runDatas[i - 1].outputTextureData],
                outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfos[i].outputLayout, dataType),
                uniformData: {}
            });
        }
        return runDatas;
    }
}
exports.WebGLSoftmax = WebGLSoftmax;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/split.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/split.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSplit = void 0;
const split_1 = __webpack_require__(/*! ../../../ops/split */ "./lib/onnxjs/ops/split.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
class WebGLSplit extends split_1.Split {
    run(inferenceHandler, inputs) {
        if (!this.artifacts) {
            this.artifacts = [];
            const axis = util_1.ShapeUtil.normalizeAxis(this.axis, inputs[0].dims.length);
            const count = this.getProgramCount(inferenceHandler, inputs, axis);
            for (let i = 0; i < count; ++i) {
                const programInfo = this.createProgramInfo(inferenceHandler, inputs[0], axis, i);
                const artifact = inferenceHandler.session.programManager.build(programInfo);
                this.artifacts.push(artifact);
            }
        }
        const results = [];
        this.artifacts.forEach(artifact => {
            const rundata = this.createRunData(inferenceHandler, artifact.programInfo, inputs);
            inferenceHandler.session.programManager.run(artifact, rundata);
            results.push(rundata.outputTextureData.tensor);
        });
        return results;
    }
    getProgramCount(inferenceHandler, inputs, axis) {
        const [, offsets] = util_1.SplitUtil.splitShape(inputs[0].dims, axis, this.split, this.numOutputs);
        return offsets.length;
    }
    createProgramInfo(inferenceHandler, input, axis, index) {
        const [shapes, offsets] = util_1.SplitUtil.splitShape(input.dims, axis, this.split, this.numOutputs);
        const offset = offsets[index];
        const outputShape = shapes[index];
        const rank = outputShape.length;
        const shaderSource = `
      float process(int indices[${rank}]) {
        indices[${axis}] += ${offset};
        return _A(indices);
      }`;
        return {
            name: 'WebGLSplit',
            inputLayouts: [inferenceHandler.getOrCreateTextureLayout(input)],
            outputLayout: inferenceHandler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
        };
    }
    createRunData(inferenceHandler, programInfo, inputs) {
        const inputTDs = [inferenceHandler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: inferenceHandler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLSplit = WebGLSplit;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/squeeze.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/squeeze.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSqueeze = void 0;
const squeeze_1 = __webpack_require__(/*! ../../../ops/squeeze */ "./lib/onnxjs/ops/squeeze.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
class WebGLSqueeze extends squeeze_1.Squeeze {
    run(inferenceHandler, inputs) {
        const outputDims = util_1.ShapeUtil.squeezeShape(inputs[0].dims, this.axes);
        return [reshape_1.reshape(inferenceHandler, inputs[0], outputDims)];
    }
}
exports.WebGLSqueeze = WebGLSqueeze;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/sum.ts":
/*!**********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/sum.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSum = void 0;
const sum_1 = __webpack_require__(/*! ../../../ops/sum */ "./lib/onnxjs/ops/sum.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLSum extends sum_1.Sum {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const outputShape = inputs[0].dims.slice();
        const sumLine = inputs.map((v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(' + ');
        const samplers = inputs.map((v, i) => `X${i}`);
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers,
            shaderSource: `
      void main() {
        vec4 result = ${sumLine};
        ${glsl.output} = result;
      }`,
            hasMain: true
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLSum = WebGLSum;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/tile.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/tile.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLTile = void 0;
const tile_1 = __webpack_require__(/*! ../../../ops/tile */ "./lib/onnxjs/ops/tile.ts");
class WebGLTile extends tile_1.Tile {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputShape = inputs[0].dims.slice();
        const outputShape = new Array(inputShape.length); // inputs[0].dims.slice();
        const tileOps = [];
        for (let i = 0; i < inputShape.length; i++) {
            outputShape[i] = inputShape[i] * inputs[1].numberData[i];
            tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);
        }
        const rank = outputShape.length;
        const shaderSource = `
    float process(int outputIdx[${rank}]) {
      int inputIdx[${rank}];
      ${tileOps.join('\n')}
      return _A(inputIdx);
    }`;
        return {
            inputLayouts: inputs.map(t => handler.getOrCreateTextureLayout(t)),
            outputLayout: handler.createTextureLayoutFromShape(outputShape),
            samplers: ['A'],
            shaderSource,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLTile = WebGLTile;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/transpose.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/transpose.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLTranspose = void 0;
const transpose_1 = __webpack_require__(/*! ../../../ops/transpose */ "./lib/onnxjs/ops/transpose.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_definitions_1 = __webpack_require__(/*! ../glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
class WebGLTranspose extends transpose_1.Transpose {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    getOutputShape(inputShapes) {
        const perm = this.getAdjustedPerm(inputShapes[0]);
        return util_1.ShapeUtil.sortBasedOnPerm(inputShapes[0], perm);
    }
    createProgramInfo(handler, inputs) {
        const inputShapes = inputs.map(t => t.dims.slice());
        const perm = this.getAdjustedPerm(inputShapes[0]);
        const unpackedOutputShape = this.getOutputShape(inputShapes);
        const rank = inputs[0].dims.length;
        // A dims=[${inputs[0].dims.toString()}]
        // out Dims=[${unpackedOutputShape.toString()}]
        // based on perm=[${perm.toString()}]
        const shaderSource = `
      ${this.getPermFunctionBody('perm', perm, rank)}
      float process(int indices[${rank}]) {
        int a[${rank}];
        perm(a, indices);
        return _A(a);
      }`;
        const outputLayout = handler.createTextureLayoutFromShape(unpackedOutputShape, 1, unpackedOutputShape);
        return { inputLayouts: [handler.getOrCreateTextureLayout(inputs[0])], outputLayout, samplers: ['A'], shaderSource };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0])];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
    getPositionalFunction(handler, inputShape, name) {
        const outputShape = this.getOutputShape([inputShape]);
        if (!name) {
            name = 'perm';
        }
        return {
            name,
            body: this.getPermFunctionBody(name, this.getAdjustedPerm(inputShape), outputShape.length),
            type: glsl_definitions_1.FunctionType.Positional,
            inputShape,
            outputShape
        };
    }
    getAdjustedPerm(inputShape) {
        let perm = this.perm;
        if (perm && perm.length !== inputShape.length) {
            perm = [...(inputShape.keys())].reverse();
        }
        return perm;
    }
    getPermFunctionBody(name, perm, rank) {
        const reverseFunc = [];
        reverseFunc.push(`void ${name}(out int a[${rank}], int src[${rank}]) {`);
        for (let i = 0; i < rank; ++i) {
            reverseFunc.push(`\ta[${perm[i]}]=src[${i}];`);
        }
        reverseFunc.push('\t}');
        return reverseFunc.join('\n');
    }
}
exports.WebGLTranspose = WebGLTranspose;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/uint8-encode.ts":
/*!*******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/uint8-encode.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUint8Encode = void 0;
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLUint8Encode {
    runInternal(inferenceHandler, input) {
        const outputShape = input.shape;
        const [width, height] = inferenceHandler.session.layoutStrategy.computeTextureWH(input.shape);
        const outputLayout = {
            width,
            height,
            channels: 4,
            shape: outputShape,
            strides: util_1.ShapeUtil.computeStrides(outputShape),
            unpackedShape: outputShape
        };
        const glsl = glsl_source_1.getGlsl(inferenceHandler.session.backend.glContext.version);
        // TODO: remove this special script. Use graph transformer instead.
        /**
         * https://github.com/tensorflow/tfjs-core/blob/master/src/kernels/webgl/encode_float_gpu.ts
         */
        const shaderSource = `
      const float FLOAT_MAX = 1.70141184e38;
      const float FLOAT_MIN = 1.17549435e-38;

      bool isNaN(float val) {
        return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
      }

      highp vec4 encodeAsUint8(highp float v) {
        if (isNaN(v)) {
          return vec4(255, 255, 255, 255);
        }

        highp float av = abs(v);

        if(av < FLOAT_MIN) {
          return vec4(0.0, 0.0, 0.0, 0.0);
        } else if(v > FLOAT_MAX) {
          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
        } else if(v < -FLOAT_MAX) {
          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
        }

        highp vec4 c = vec4(0,0,0,0);

        highp float e = floor(log2(av));
        highp float m = exp2(fract(log2(av))) - 1.0;

        c[2] = floor(128.0 * m);
        m -= c[2] / 128.0;
        c[1] = floor(32768.0 * m);
        m -= c[1] / 32768.0;
        c[0] = floor(8388608.0 * m);

        highp float ebias = e + 127.0;
        c[3] = floor(ebias / 2.0);
        ebias -= c[3] * 2.0;
        c[2] += floor(ebias) * 128.0;

        c[3] += 128.0 * step(0.0, -v);

        return c / 255.0;
      }

      void main() {
        float value = ${glsl.texture2D}(X,TexCoords).r;
        ${glsl.output} = encodeAsUint8(value);
      }`;
        const programInfo = { name: 'Uint8Encode', inputLayouts: [input], outputLayout, samplers: ['X'], shaderSource, hasMain: true };
        const artifact = inferenceHandler.session.programManager.build(programInfo);
        const encoder = inferenceHandler.session.backend.glContext.getEncoder('byte', 4);
        const texture = inferenceHandler.session.backend.glContext.allocateTexture(outputLayout.width, outputLayout.height, encoder);
        const outputTextureData = inferenceHandler.createSharedTextureData(outputLayout, 'uint8', texture);
        const runData = { inputTextureDatas: [input], outputTextureData, uniformData: {} };
        inferenceHandler.session.programManager.run(artifact, runData);
        return runData.outputTextureData;
    }
}
exports.WebGLUint8Encode = WebGLUint8Encode;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/unary-op.ts":
/*!***************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/unary-op.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.glslTanh = exports.glslTan = exports.glslSqrt = exports.glslSigmoid = exports.glslRelu = exports.glslSin = exports.glslNot = exports.glslNeg = exports.glslLog = exports.glslIdentity = exports.glslFloor = exports.glslExp = exports.glslCos = exports.glslCeil = exports.glslAtan = exports.glslAsin = exports.glslAcos = exports.glslAbs = exports.WebGLUnaryOp = void 0;
const unary_op_1 = __webpack_require__(/*! ../../../ops/unary-op */ "./lib/onnxjs/ops/unary-op.ts");
const glsl_definitions_1 = __webpack_require__(/*! ../glsl-definitions */ "./lib/onnxjs/backends/webgl/glsl-definitions.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLUnaryOp extends unary_op_1.UnaryOp {
    constructor(typeConstraint, glslFunc) {
        super(typeConstraint);
        this.typeConstraint = typeConstraint;
        this.glslFunc = glslFunc;
    }
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const outputShape = inputs[0].dims.slice();
        const inputLayout = handler.session.pack ?
            handler.getOrCreateTextureLayout(inputs[0], 4, true, inputs[0].dims, true) :
            handler.getOrCreateTextureLayout(inputs[0]);
        const outputLayout = handler.session.pack ?
            handler.createTextureLayoutFromShape(outputShape, 4, outputShape, { isPacked: true, reverseWH: true }) :
            handler.createTextureLayoutFromShape(outputShape);
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
      ${this.glslFunc.body}
      void main() {
        vec4 v = ${glsl.texture2D}(A, TexCoords);
        v = ${this.glslFunc.name}(v);
        ${glsl.output} = v;
      }
      `;
        if (handler.session.pack) {
            return {
                inputLayouts: [inputLayout],
                outputLayout,
                samplers: ['A'],
                shaderSource,
                hasMain: true,
                expectPackedInputs: true,
                expectPackedOutputs: true
            };
        }
        else {
            return { inputLayouts: [inputLayout], outputLayout, samplers: ['A'], shaderSource, hasMain: true };
        }
    }
    createRunData(handler, programInfo, inputs) {
        const inputTD = handler.session.pack ?
            handler.getOrCreateTextureData(inputs[0], handler.getOrCreateTextureLayout(inputs[0], 1, false, [], true)) :
            handler.getOrCreateTextureData(inputs[0]);
        return {
            inputTextureDatas: [inputTD],
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTD.tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLUnaryOp = WebGLUnaryOp;
function glslAbs() {
    return glslBuiltinUnary('abs');
}
exports.glslAbs = glslAbs;
function glslAcos() {
    return glslBuiltinUnary('acos');
}
exports.glslAcos = glslAcos;
function glslAsin() {
    return glslBuiltinUnary('asin');
}
exports.glslAsin = glslAsin;
function glslAtan() {
    return glslBuiltinUnary('atan');
}
exports.glslAtan = glslAtan;
function glslCeil() {
    return glslBuiltinUnary('ceil');
}
exports.glslCeil = glslCeil;
function glslCos() {
    return glslBuiltinUnary('cos');
}
exports.glslCos = glslCos;
function glslExp() {
    return glslBuiltinUnary('exp');
}
exports.glslExp = glslExp;
function glslFloor() {
    return glslBuiltinUnary('floor');
}
exports.glslFloor = glslFloor;
function glslIdentity() {
    const name = 'indentity_';
    const body = `
  float ${name}(float a) {
    return a;
  }
  vec4 ${name}(vec4 v) {
    return v;
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslIdentity = glslIdentity;
function glslLog() {
    return glslBuiltinUnary('log');
}
exports.glslLog = glslLog;
function glslNeg() {
    const name = 'neg_';
    const body = `
  float ${name}(float a) {
    return -a;
  }
  vec4 ${name}(vec4 v) {
    return -v;
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslNeg = glslNeg;
function glslNot() {
    const name = 'not_';
    const body = `
  float ${name}(float a) {
    return float( ! bool(a) );
  }
  bool ${name}(bool a) {
    return !a;
  }
  vec4 ${name}(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${name}(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslNot = glslNot;
function glslSin() {
    return glslBuiltinUnary('sin');
}
exports.glslSin = glslSin;
function glslRelu() {
    const name = 'relu_';
    const body = `
  float ${name}(float a) {
    return max( a, 0.0 );
  }
  vec4 ${name}(vec4 v) {
    return max( v, 0.0 );
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslRelu = glslRelu;
function glslSigmoid() {
    const name = 'sigmoid_';
    const body = `
  float ${name}(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${name}(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslSigmoid = glslSigmoid;
function glslSqrt() {
    return glslBuiltinUnary('sqrt');
}
exports.glslSqrt = glslSqrt;
function glslTan() {
    return glslBuiltinUnary('tan');
}
exports.glslTan = glslTan;
function glslTanh() {
    const name = 'tanh_';
    const body = `
  float ${name}(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${name}(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}
exports.glslTanh = glslTanh;
function glslBuiltinUnary(fname) {
    const name = `${fname}_`;
    const body = `
  float ${name}(float a) {
    return ${fname}(a);
  }
  vec4 ${name}(vec4 v) {
    return ${fname}(v);
  }
  `;
    return { body, name, type: glsl_definitions_1.FunctionType.ValueBased };
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/unpack.ts":
/*!*************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/unpack.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSourceCoords = exports.WebGLUnpack = void 0;
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./lib/onnxjs/backends/webgl/utils.ts");
const packing_utils_1 = __webpack_require__(/*! ./packing-utils */ "./lib/onnxjs/backends/webgl/ops/packing-utils.ts");
class WebGLUnpack {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        if (inputs.length !== 1) {
            throw new Error('Pack kernel should have input tensor count to 1.');
        }
        const inputTexture = handler.getTextureData(inputs[0].dataId, true);
        if (!inputTexture) {
            throw new Error('packed input texture must exist');
        }
        const inputLayout = handler.getOrCreateTextureLayout(inputs[0], 4, true);
        const isScalar = (inputLayout.unpackedShape.length === 0);
        const outputLayout = handler.createTextureLayoutFromShape(inputTexture.unpackedShape);
        const outputShape = outputLayout.shape;
        const rank = outputShape.length;
        const channels = packing_utils_1.getChannels('rc', rank);
        const innerDims = channels.slice(-2);
        const coordsDataType = utils_1.getCoordsDataType(rank);
        const unpackChannel = packing_utils_1.unpackFromChannel();
        const sourceCoords = isScalar ? '' : getSourceCoords(rank, channels);
        const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const shaderSource = `
    ${unpackChannel}
    void main() {
      ${coordsDataType} rc = getOutputCoords();

      // Sample the texture with the coords to get the rgba channel value.
      vec4 packedInput = getA(${sourceCoords});

      ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);
    }
  `;
        return {
            name: 'WebGLUnpack',
            inputLayouts: [handler.getOrCreateTextureLayout(inputs[0], 4, true, inputs[0].dims, true)],
            outputLayout,
            samplers: ['A'],
            shaderSource,
            hasMain: true,
            expectPackedInputs: true,
            expectPackedOutputs: false,
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = [handler.getOrCreateTextureData(inputs[0], programInfo.inputLayouts[0], true)];
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: {}
        };
    }
}
exports.WebGLUnpack = WebGLUnpack;
function getSourceCoords(rank, dims) {
    if (rank === 1) {
        return 'rc';
    }
    let coords = '';
    for (let i = 0; i < rank; i++) {
        coords += dims[i];
        if (i < rank - 1) {
            coords += ',';
        }
    }
    return coords;
}
exports.getSourceCoords = getSourceCoords;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/unsqueeze.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/unsqueeze.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUnsqueeze = void 0;
const unsqueeze_1 = __webpack_require__(/*! ../../../ops/unsqueeze */ "./lib/onnxjs/ops/unsqueeze.ts");
const util_1 = __webpack_require__(/*! ../../../util */ "./lib/onnxjs/util.ts");
const reshape_1 = __webpack_require__(/*! ./reshape */ "./lib/onnxjs/backends/webgl/ops/reshape.ts");
class WebGLUnsqueeze extends unsqueeze_1.Unsqueeze {
    run(inferenceHandler, inputs) {
        const outputDims = util_1.ShapeUtil.unsqueezeShape(inputs[0].dims, this.axes);
        return [reshape_1.reshape(inferenceHandler, inputs[0], outputDims)];
    }
}
exports.WebGLUnsqueeze = WebGLUnsqueeze;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/ops/upsample.ts":
/*!***************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/ops/upsample.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLUpsample = void 0;
const upsample_1 = __webpack_require__(/*! ../../../ops/upsample */ "./lib/onnxjs/ops/upsample.ts");
const glsl_source_1 = __webpack_require__(/*! ../glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
class WebGLUpsample extends upsample_1.Upsample {
    run(inferenceHandler, inputs) {
        return inferenceHandler.run(this, inputs);
    }
    createProgramInfo(handler, inputs) {
        const inputLayout = handler.getOrCreateTextureLayout(inputs[0]);
        const outputShape = inputs[0].dims.map((dim, i) => Math.floor(dim * this.scales[i]));
        const outputLayout = handler.createTextureLayoutFromShape(outputShape);
        const dim = outputShape.length;
        const glsl = glsl_source_1.getGlsl(handler.session.backend.glContext.version);
        const outputPitches = new Array(dim);
        const inputPitches = new Array(dim);
        let precalculatedPitches = `
      int output_pitches[${dim}];
      int input_pitches[${dim}];
      `;
        for (let d = dim - 1; d >= 0; d--) {
            outputPitches[d] = (d === dim - 1) ? 1 : outputPitches[d + 1] * outputShape[d + 1];
            inputPitches[d] = (d === dim - 1) ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];
            precalculatedPitches += `
      output_pitches[${d}] = ${outputPitches[d]};
      input_pitches[${d}] = ${inputPitches[d]};
      `;
        }
        const getInputFloatFunction = `
    float getInputFloat(int index) {
      vec2 coords = offsetToCoords(index, ${inputLayout.width}, ${inputLayout.height});
      float value = getColorAsFloat(${glsl.texture2D}(X, coords));
      return value;
    }
    `;
        const shaderSource = this.mode === 'nearest' ?
            // nearest
            `
      ${getInputFloatFunction}
      float process(int indices[${dim}]) {
        int input_index = 0;
        int output_index = coordsToOffset(TexCoords, ${outputLayout.width}, ${outputLayout.height});

        ${precalculatedPitches}

        int d, m;
        for (int dim = 0; dim < ${dim}; ++dim) {
          d = output_index / output_pitches[dim];
          m = output_index - d * output_pitches[dim];
          output_index = m;

          if (scales[dim] != 1 && d > 0) {
            int d2 = d / scales[dim];
            m = d - d2 * scales[dim];
            d = d2;
          }
          input_index += input_pitches[dim] * d;
        }

        return getInputFloat(input_index);
      }` :
            dim === 4 ?
                // bilinear 4D
                `
      ${getInputFloatFunction}
      float process(int indices[4]) {
        int input_index = 0;
        int output_index = coordsToOffset(TexCoords, ${outputLayout.width}, ${outputLayout.height});

        ${precalculatedPitches}

        int m;
        int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
        index_of_dim0 = output_index / output_pitches[0];
        m = output_index - index_of_dim0 * output_pitches[0];
        index_of_dim1 = m / output_pitches[1];
        m = m - index_of_dim1 * output_pitches[1];
        index_of_dim2 = m / output_pitches[2];
        m = m - index_of_dim2 * output_pitches[2];
        index_of_dim3 = m;

        int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
        index_of_input_dim2 = index_of_dim2 / scales[2];
        y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
        index_of_input_dim3 = index_of_dim3 / scales[3];
        x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

        input_index = index_of_dim0 * input_pitches[0] +
                      index_of_dim1 * input_pitches[1] +
                      index_of_input_dim2 * input_pitches[2] +
                      index_of_input_dim3;

        float x00 = getInputFloat(input_index);
        float x10, x01, x11;

        bool end_of_dim2 = false;
        if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {
          // It's the end in dimension 2
          x01 = x00;
          end_of_dim2 = true;
        } else {
          x01 = getInputFloat(input_index + input_pitches[2]);
        }

        if (index_of_input_dim3 == (input_pitches[2] - 1)) {
          // It's the end in dimension 3
          x10 = x00;
          x11 = x01;
        }
        else {
          x10 = getInputFloat(input_index + 1);
          x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
        }

        float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
        float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
        return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
      }` :
                // bilinear 2D
                `
      ${getInputFloatFunction}
      float process(int indices[2]) {
        int input_index = 0;
        int output_index = coordsToOffset(TexCoords, ${outputLayout.width}, ${outputLayout.height});

        ${precalculatedPitches}

        int m;
        int index_of_dim0, index_of_dim1;
        index_of_dim0 = output_index / output_pitches[0];
        m = output_index - index_of_dim0 * output_pitches[0];
        index_of_dim1 = m;

        int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
        index_of_input_dim0 = index_of_dim0 / scales[0];
        y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
        index_of_input_dim1 = index_of_dim1 / scales[1];
        x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

        input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

        float x00 = getInputFloat(input_index);
        float x10, x01, x11;

        bool end_of_dim0 = false;
        if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {
          // It's the end in dimension 0
          x01 = x00;
          end_of_dim0 = true;
        } else {
          x01 = getInputFloat(input_index + input_pitches[0]);
        }

        if (index_of_input_dim1 == (input_pitches[0] - 1)) {
          // It's the end in dimension 1
          x10 = x00;
          x11 = x01;
        }
        else {
          x10 = getInputFloat(input_index + 1);
          x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
        }

        float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
        float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
        return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
      }`;
        return {
            inputLayouts: [inputLayout],
            outputLayout,
            samplers: ['X'],
            shaderSource,
            variables: [{ name: 'scales', type: 'int', arrayLength: this.scales.length }]
        };
    }
    createRunData(handler, programInfo, inputs) {
        const inputTDs = inputs.map((t, i) => handler.getOrCreateTextureData(t, programInfo.inputLayouts[i]));
        return {
            inputTextureDatas: inputTDs,
            outputTextureData: handler.createTextureDataFromLayout(programInfo.outputLayout, inputTDs[0].tensor.type),
            uniformData: { scales: this.scales.map(x => Math.ceil(x)) }
        };
    }
}
exports.WebGLUpsample = WebGLUpsample;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/program-manager.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/program-manager.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgramManager = void 0;
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
const glsl_preprocessor_1 = __webpack_require__(/*! ./glsl-preprocessor */ "./lib/onnxjs/backends/webgl/glsl-preprocessor.ts");
const glsl_source_1 = __webpack_require__(/*! ./glsl-source */ "./lib/onnxjs/backends/webgl/glsl-source.ts");
/**
 * ProgramManager is the main class behind running computations
 * It builds ProgramInfo's into Artifacts
 * It compiles given ProgramInfo's into WebGL Prorams (cached as Artifacts)
 * Uses the artifact to run the computation by calling Draw on
 * the WebGL drawing buffer
 * ProgramManager automatically maps (binds) input variables to their
 * corresponding Location's in the binary program
 */
class ProgramManager {
    constructor(profiler, glContext, textureLayoutStrategy) {
        this.profiler = profiler;
        this.glContext = glContext;
        this.textureLayoutStrategy = textureLayoutStrategy;
        this.repo = new Map();
        this.attributesBound = false;
    }
    getArtifact(key) {
        return this.repo.get(key);
    }
    setArtifact(key, artifact) {
        this.repo.set(key, artifact);
    }
    run(buildArtifact, runData) {
        var _a;
        this.profiler.event('op', `ProgramManager.run ${(_a = buildArtifact.programInfo.name) !== null && _a !== void 0 ? _a : 'unknown kernel'}`, () => {
            const gl = this.glContext.gl;
            const program = buildArtifact.program;
            gl.useProgram(program);
            try {
                this.bindOutput(runData.outputTextureData);
                if (!this.attributesBound) {
                    this.bindAttributes(buildArtifact.attribLocations);
                }
                this.bindUniforms(buildArtifact.uniformLocations, runData.uniformData, runData.inputTextureDatas);
            }
            catch (err) {
                instrument_1.Logger.error('ProgramManager', buildArtifact.programInfo.shaderSource);
                throw err;
            }
            this.profiler.event('backend', 'GlContext.draw()', () => {
                this.doDraw(buildArtifact, runData);
            });
        }, this.glContext);
    }
    dispose() {
        if (this.vertexShader) {
            this.glContext.deleteShader(this.vertexShader);
        }
        this.repo.forEach(a => this.glContext.deleteProgram(a.program));
    }
    build(programInfo) {
        return this.profiler.event('backend', 'ProgramManager.build', () => {
            const preprocessor = new glsl_preprocessor_1.GlslPreprocessor(this.glContext, programInfo);
            const fragScript = preprocessor.preprocess();
            const program = this.compile(fragScript);
            const artifact = {
                programInfo,
                program,
                uniformLocations: this.getUniformLocations(program, preprocessor.context.programInfo.samplers, preprocessor.context.programInfo.variables),
                attribLocations: this.getAttribLocations(program)
            };
            return artifact;
        });
    }
    doDraw(artifact, runData) {
        if (runData.draw) {
            instrument_1.Logger.verbose('ProgramManager', 'Custom draw function');
            runData.draw(this.glContext, artifact);
        }
        else {
            this.glContext.draw();
        }
    }
    compile(fragShaderScript) {
        if (!this.vertexShader) {
            instrument_1.Logger.verbose('ProrgramManager', 'Compiling and caching Vertex shader for the first time');
            const vertexShaderScript = glsl_source_1.getVertexShaderSource(this.glContext.version);
            this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);
        }
        if (onnxruntime_common_1.env.debug) {
            instrument_1.Logger.verbose('ProrgramManager', `FragShader:
${fragShaderScript}
`);
        }
        const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);
        const program = this.glContext.createProgram(this.vertexShader, fragShader);
        this.glContext.deleteShader(fragShader);
        return program;
    }
    bindOutput(td) {
        const width = td.width;
        const height = td.height;
        instrument_1.Logger.verbose('ProrgramManager', `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`);
        this.glContext.attachFramebuffer(td.texture, width, height);
    }
    bindAttributes(attribLocations) {
        const positionHandle = attribLocations.position;
        const textureCoordHandle = attribLocations.textureCoord;
        this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);
        this.attributesBound = true;
    }
    bindUniforms(uniformLocations, uniformData, textures) {
        const gl = this.glContext.gl;
        let texturePosition = 0;
        for (const { name, type, location, arrayLength } of uniformLocations) {
            switch (type) {
                case 'sampler2D':
                    this.bindTexture(textures[texturePosition], location, texturePosition);
                    texturePosition++;
                    break;
                case 'float':
                    if (arrayLength) {
                        gl.uniform1fv(location, uniformData[name]);
                    }
                    else {
                        gl.uniform1f(location, uniformData[name]);
                    }
                    break;
                case 'int':
                    if (arrayLength) {
                        gl.uniform1iv(location, uniformData[name]);
                    }
                    else {
                        gl.uniform1i(location, uniformData[name]);
                    }
                    break;
                default:
                    throw new Error(`Uniform not implemented: ${type}`);
            }
        }
    }
    bindTexture(td, uniformHandle, position) {
        this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);
    }
    getAttribLocations(program) {
        return {
            position: this.getAttribLocation(program, 'position'),
            textureCoord: this.getAttribLocation(program, 'textureCoord')
        };
    }
    getUniformLocations(program, samplers, variables) {
        const uniformLocations = [];
        if (samplers) {
            for (const sampler of samplers) {
                uniformLocations.push({ name: sampler, type: 'sampler2D', location: this.getUniformLocation(program, sampler) });
            }
        }
        if (variables) {
            for (const variable of variables) {
                uniformLocations.push(Object.assign(Object.assign({}, variable), { location: this.getUniformLocation(program, variable.name) }));
            }
        }
        return uniformLocations;
    }
    getUniformLocation(program, name) {
        const gl = this.glContext.gl;
        const reference = gl.getUniformLocation(program, name);
        if (reference === null) {
            throw new Error(`Uniform ${name} not found.`);
        }
        return reference;
    }
    getAttribLocation(program, name) {
        const gl = this.glContext.gl;
        const attributeLocation = gl.getAttribLocation(program, name);
        return attributeLocation;
    }
}
exports.ProgramManager = ProgramManager;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/session-handler.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/session-handler.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLSessionHandler = void 0;
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
const opset_1 = __webpack_require__(/*! ../../opset */ "./lib/onnxjs/opset.ts");
const inference_handler_1 = __webpack_require__(/*! ./inference-handler */ "./lib/onnxjs/backends/webgl/inference-handler.ts");
const op_resolve_rules_1 = __webpack_require__(/*! ./op-resolve-rules */ "./lib/onnxjs/backends/webgl/op-resolve-rules.ts");
const program_manager_1 = __webpack_require__(/*! ./program-manager */ "./lib/onnxjs/backends/webgl/program-manager.ts");
const texture_layout_strategy_1 = __webpack_require__(/*! ./texture-layout-strategy */ "./lib/onnxjs/backends/webgl/texture-layout-strategy.ts");
const texture_manager_1 = __webpack_require__(/*! ./texture-manager */ "./lib/onnxjs/backends/webgl/texture-manager.ts");
class WebGLSessionHandler {
    constructor(backend, context) {
        this.backend = backend;
        this.context = context;
        this.layoutStrategy = new texture_layout_strategy_1.PreferLogicalStrategy(backend.glContext.maxTextureSize);
        this.programManager = new program_manager_1.ProgramManager(this.context.profiler, backend.glContext, this.layoutStrategy);
        this.textureManager = new texture_manager_1.TextureManager(backend.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: backend.textureCacheMode === 'full' });
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache = new Map();
        this.packOpCache = new Map();
        this.unpackOpCache = new Map();
        this.pack = backend.pack;
        this.pack2unpackMap = new Map();
        this.unpack2packMap = new Map();
    }
    createInferenceHandler() {
        return new inference_handler_1.WebGLInferenceHandler(this);
    }
    onGraphInitialized(graph) {
        const initializers = graph.getValues().filter(v => v.from === -1 && v.tensor).map(v => v.tensor.dataId);
        this.initializers = new Set(initializers);
    }
    isInitializer(tensorId) {
        return this.initializers ? this.initializers.has(tensorId) : false;
    }
    addInitializer(tensorId) {
        this.initializers.add(tensorId);
    }
    getTextureData(tensorId, isPacked) {
        if (isPacked) {
            return this.packedTextureDataCache.get(tensorId);
        }
        else {
            return this.unpackedTextureDataCache.get(tensorId);
        }
    }
    setTextureData(tensorId, textureData, isPacked = false) {
        instrument_1.Logger.verbose('WebGLSessionHandler', 'Storing Texture data in cache');
        if (isPacked) {
            this.packedTextureDataCache.set(tensorId, textureData);
        }
        else {
            this.unpackedTextureDataCache.set(tensorId, textureData);
        }
    }
    dispose() {
        this.programManager.dispose();
        this.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach(td => this.textureManager.releaseTexture(td, true));
        this.packedTextureDataCache = new Map();
        this.unpackedTextureDataCache.forEach(td => this.textureManager.releaseTexture(td, true));
        this.unpackedTextureDataCache = new Map();
    }
    resolve(node, opsets, graph) {
        const op = opset_1.resolveOperator(node, opsets, op_resolve_rules_1.WEBGL_OP_RESOLVE_RULES);
        op.initialize(node.attributes, node, graph);
        return op;
    }
}
exports.WebGLSessionHandler = WebGLSessionHandler;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/texture-data-encoder.ts":
/*!***********************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/texture-data-encoder.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint8DataEncoder = exports.RGBAFloatDataEncoder = exports.RedFloat32DataEncoder = void 0;
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
/**
 * WebGL2 data encoder
 * Uses R32F as the format for texlet
 */
class RedFloat32DataEncoder {
    constructor(gl, channels = 1) {
        if (channels === 1) {
            this.internalFormat = gl.R32F;
            this.format = gl.RED;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
        }
        else if (channels === 4) {
            this.internalFormat = gl.RGBA32F;
            this.format = gl.RGBA;
            this.textureType = gl.FLOAT;
            this.channelSize = channels;
        }
        else {
            throw new Error(`Invalid number of channels: ${channels}`);
        }
    }
    encode(src, textureSize) {
        let result;
        let source;
        if (src.constructor !== Float32Array) {
            instrument_1.Logger.warning('Encoder', 'data was not of type Float32; creating new Float32Array');
            source = new Float32Array(src);
        }
        if (textureSize * this.channelSize > src.length) {
            instrument_1.Logger.warning('Encoder', 'Source data too small. Allocating larger array');
            source = src;
            result = this.allocate(textureSize * this.channelSize);
            source.forEach((v, i) => result[i] = v);
        }
        else {
            source = src;
            result = source;
        }
        return result;
    }
    allocate(size) {
        return new Float32Array(size * 4);
    }
    decode(buffer, dataSize) {
        if (this.channelSize === 1) {
            const filteredData = buffer.filter((value, index) => index % 4 === 0).subarray(0, dataSize);
            return filteredData;
        }
        return buffer.subarray(0, dataSize);
    }
}
exports.RedFloat32DataEncoder = RedFloat32DataEncoder;
/**
 * Data encoder for WebGL 1 with support for floating point texture
 */
class RGBAFloatDataEncoder {
    constructor(gl, channels = 1, textureType) {
        if (channels !== 1 && channels !== 4) {
            throw new Error(`Invalid number of channels: ${channels}`);
        }
        this.internalFormat = gl.RGBA;
        this.format = gl.RGBA;
        this.channelSize = channels;
        this.textureType = textureType || gl.FLOAT;
    }
    encode(src, textureSize) {
        let dest = src;
        if (this.channelSize === 1) {
            instrument_1.Logger.verbose('Encoder', 'Exploding into a larger array');
            dest = this.allocate(textureSize);
            src.forEach((v, i) => dest[i * 4] = v);
        }
        return dest;
    }
    allocate(size) {
        return new Float32Array(size * 4);
    }
    decode(buffer, dataSize) {
        if (this.channelSize === 1) {
            const filteredData = buffer.filter((value, index) => index % 4 === 0).subarray(0, dataSize);
            return filteredData;
        }
        return buffer.subarray(0, dataSize);
    }
}
exports.RGBAFloatDataEncoder = RGBAFloatDataEncoder;
class Uint8DataEncoder {
    constructor(gl, channels = 1) {
        this.channelSize = 4;
        if (channels === 1) {
            this.internalFormat = gl.ALPHA;
            this.format = gl.ALPHA; // not tested
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
        }
        else if (channels === 4) {
            this.internalFormat = gl.RGBA;
            this.format = gl.RGBA;
            this.textureType = gl.UNSIGNED_BYTE;
            this.channelSize = channels;
        }
        else {
            throw new Error(`Invalid number of channels: ${channels}`);
        }
    }
    encode(src, _textureSize) {
        return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);
    }
    allocate(size) {
        return new Uint8Array(size * this.channelSize);
    }
    decode(buffer, dataSize) {
        if (buffer instanceof Uint8Array) {
            return buffer.subarray(0, dataSize);
        }
        throw new Error(`Invalid array type: ${buffer.constructor}`);
    }
}
exports.Uint8DataEncoder = Uint8DataEncoder;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/texture-layout-strategy.ts":
/*!**************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/texture-layout-strategy.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBatchDim = exports.sizeToSquarishShape = exports.getRowsCols = exports.sizeFromShape = exports.isInt = exports.parseAxisParam = exports.squeezeShape = exports.PreferLogicalStrategy = exports.AlwaysKeepOriginalSizeStrategy = void 0;
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
const util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
/**
 * This strategy try to find the minimal max(W,H) that fulfills (W * H == totalSize)
 */
class AlwaysKeepOriginalSizeStrategy {
    constructor(maxTextureSize) {
        this.maxTextureSize = maxTextureSize;
    }
    computeTextureWH(shape, prefs) {
        // scalar tensor
        if (shape.length === 0) {
            return [1, 1];
        }
        const maxTextureSize = this.maxTextureSize;
        if (prefs && prefs.breakAxis !== undefined) {
            // check to see if dims fit
            const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);
            const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);
            if (wsize > maxTextureSize || hsize > maxTextureSize) {
                // ignore preferences
                // continue with default layout
                instrument_1.Logger.verbose('TextureLayout', `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`);
            }
            else {
                return [wsize, hsize];
            }
        }
        const totalSize = shape.reduce((a, b) => a * b);
        let width = Math.floor(Math.sqrt(totalSize));
        for (; width < maxTextureSize && width < totalSize; width++) {
            if (totalSize % width === 0) {
                break;
            }
        }
        if (width >= maxTextureSize || totalSize % width !== 0) {
            throw new Error(`The given dimensions are outside this GPU's boundaries: ${shape}`);
        }
        return [width, totalSize / width];
    }
}
exports.AlwaysKeepOriginalSizeStrategy = AlwaysKeepOriginalSizeStrategy;
class PreferLogicalStrategy {
    constructor(maxTextureSize) {
        this.maxTextureSize = maxTextureSize;
    }
    computeTextureWH(shape, prefs) {
        const wh = this.computeTexture(shape, prefs);
        if (prefs && prefs.isPacked) {
            wh[0] /= 2;
            wh[1] /= 2;
        }
        return wh;
    }
    computeTexture(shape, prefs) {
        const isPacked = prefs && prefs.isPacked;
        // scalar tensor
        if (shape.length === 0) {
            return isPacked ? [2, 2] : [1, 1];
        }
        let maxTextureSize = this.maxTextureSize;
        if (prefs && prefs.breakAxis !== undefined) {
            // check to see if dims fit
            const wsize = prefs.breakAxis >= shape.length ? 1 : shape.slice(prefs.breakAxis).reduce((a, b) => a * b);
            const hsize = prefs.breakAxis <= 0 ? 1 : shape.slice(0, prefs.breakAxis).reduce((a, b) => a * b);
            if (wsize > maxTextureSize || hsize > maxTextureSize) {
                // ignore preferences
                // continue with default layout
                instrument_1.Logger.verbose('TextureLayout', `Given width/height preferences were unattainable: shape:${shape}, breakAxis:${prefs.breakAxis}`);
            }
            else {
                return [wsize, hsize];
            }
        }
        let logShape = shape.slice(0);
        if (isPacked) {
            maxTextureSize = maxTextureSize * 2;
            // This logic ensures we accurately count the number of packed texels needed
            // to accommodate the tensor. We can only pack values in the same texel if
            // they are from adjacent pairs of rows/cols within the same batch. So if a
            // tensor has 3 rows, we pretend it has 4 rows in order to account for the
            // fact that the texels containing the third row are half empty.
            logShape = logShape.map((d, i) => i >= logShape.length - 2 ? (logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1) : logShape[i]);
            // Packed texture height is at least 2 (the channel height of a single
            // texel).
            if (logShape.length === 1) {
                logShape = [2, logShape[0]];
            }
        }
        // If logical shape is 2, we don't squeeze, since we want to match physical.
        if (logShape.length !== 2) {
            const squeezeResult = squeezeShape(logShape);
            logShape = squeezeResult.newShape;
        }
        const size = sizeFromShape(logShape);
        if (logShape.length <= 1 && size <= maxTextureSize) {
            return [1, size];
        }
        else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {
            return logShape;
        }
        else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {
            return [logShape[0] * logShape[1], logShape[2]];
        }
        else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2]];
        }
        else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize &&
            logShape[3] <= maxTextureSize) {
            return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
        }
        else if (logShape.length === 4 && logShape[0] <= maxTextureSize &&
            logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {
            return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
        }
        else {
            if (isPacked) {
                // For packed textures size equals the number of channels required to
                // accommodate the texture data. However in order to squarify such that
                // inner dimensions stay even, we rewrite size to equal the number of
                // texels. Then in the return statement we rehydrate the squarified
                // dimensions to channel units.
                return sizeToSquarishShape(size / 4).map(d => d * 2);
            }
            return sizeToSquarishShape(size);
        }
    }
}
exports.PreferLogicalStrategy = PreferLogicalStrategy;
function squeezeShape(shape, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = (axis == null || isEmptyArray) ? null : parseAxisParam(axis, shape).sort();
    let j = 0;
    for (let i = 0; i < shape.length; ++i) {
        if (axes != null) {
            if (axes[j] === i && shape[i] !== 1) {
                throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
            }
            if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axes[j] <= i) {
                j++;
            }
        }
        if (shape[i] !== 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape, keptDims };
}
exports.squeezeShape = squeezeShape;
function parseAxisParam(axis, shape) {
    const rank = shape.length;
    // Normalize input
    axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
    // Check for valid range
    util_1.assert(axis.every(ax => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but ` +
        `got axis ${axis}`);
    // Check for only integers
    util_1.assert(axis.every(isInt), () => 'All values in axis param must be integers but ' +
        `got axis ${axis}`);
    // Handle negative axis.
    return axis.map(a => a < 0 ? rank + a : a);
}
exports.parseAxisParam = parseAxisParam;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        // Scalar.
        return 1;
    }
    let size = shape[0];
    for (let i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function getRowsCols(shape) {
    if (shape.length === 0) {
        throw Error('Cannot get rows and columns of an empty shape array.');
    }
    return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];
}
exports.getRowsCols = getRowsCols;
function sizeToSquarishShape(size) {
    const width = Math.ceil(Math.sqrt(size));
    return [width, Math.ceil(size / width)];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function getBatchDim(shape, dimsToSkip = 2) {
    return sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
}
exports.getBatchDim = getBatchDim;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/texture-manager.ts":
/*!******************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/texture-manager.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextureManager = void 0;
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
/**
 * TextureManager is the mainly responsible for caching Textures
 * Textures are cached in 2 levels:
 *   1. the texures which are associated with a dataId (from Tensor)
 *    Caching these is crucial to performance. These are In-use Textures
 *   2. textures which are not in use by any current ProgramInfo/Tensor
 *     These are called Free Textures
 * TextureManager is also used to help creating textures. For this it
 * uses WebGLContext and TextureLayoutStrategy
 */
class TextureManager {
    constructor(glContext, layoutStrategy, profiler, config) {
        this.glContext = glContext;
        this.layoutStrategy = layoutStrategy;
        this.profiler = profiler;
        this.config = config;
        if (config.reuseTextures) {
            this.inUseTextures = new Map();
            this.idleTextures = new Map();
            this.textureLookup = new Map();
        }
    }
    createTextureFromLayout(dataType, layout, data, usage) {
        const textureDataType = this.toEncoderType(dataType);
        const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);
        if (layout.isPacked && usage === 1 /* UploadOnly */) {
            throw new Error('not implemented');
        }
        const width = layout.width;
        const height = layout.height;
        let key;
        let inUseTextures;
        if (this.config.reuseTextures) {
            key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;
            inUseTextures = this.inUseTextures.get(key);
            if (!inUseTextures) {
                inUseTextures = [];
                this.inUseTextures.set(key, inUseTextures);
            }
            const idleTextures = this.idleTextures.get(key);
            if (idleTextures && idleTextures.length > 0) {
                const texture = idleTextures.pop();
                inUseTextures.push(texture);
                if (usage === 1 /* UploadOnly */) {
                    this.glContext.updateTexture(texture, width, height, encoder, this.toTextureData(dataType, data));
                }
                return texture;
            }
        }
        instrument_1.Logger.verbose('TextureManager', `Creating new texture of size ${layout.width}x${layout.height}`);
        const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));
        if (this.config.reuseTextures) {
            inUseTextures.push(texture);
            this.textureLookup.set(texture, key);
        }
        return texture;
    }
    readTexture(td, dataType, channels) {
        if (!channels) {
            channels = 1;
        }
        return this.profiler.event('backend', 'TextureManager.readTexture', () => {
            const dataSize = td.shape.reduce((a, b) => a * b) * channels;
            const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize, this.toEncoderType(dataType), channels);
            return this.toTensorData(dataType, data);
        });
    }
    readUint8TextureAsFloat(td) {
        return this.profiler.event('backend', 'TextureManager.readUint8TextureAsFloat', () => {
            const dataSize = td.shape.reduce((a, b) => a * b);
            const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, 'byte', 4);
            return new Float32Array(data.buffer, data.byteOffset, dataSize);
        });
    }
    releaseTexture(textureData, deleteTexture) {
        let key;
        if (this.config.reuseTextures) {
            key = this.textureLookup.get(textureData.texture);
            if (key) {
                if (deleteTexture) {
                    this.textureLookup.delete(key);
                }
                const inUseTextures = this.inUseTextures.get(key);
                if (inUseTextures) {
                    const index = inUseTextures.indexOf(textureData.texture);
                    if (index !== -1) {
                        inUseTextures.splice(index, 1);
                        let idleTextures = this.idleTextures.get(key);
                        if (!idleTextures) {
                            idleTextures = [];
                            this.idleTextures.set(key, idleTextures);
                        }
                        idleTextures.push(textureData.texture);
                    }
                }
            }
        }
        if (!key || deleteTexture) {
            instrument_1.Logger.verbose('TextureManager', `Deleting texture of size ${textureData.width}x${textureData.height}`);
            this.glContext.deleteTexture(textureData.texture);
        }
    }
    toTensorData(dataType, data) {
        switch (dataType) {
            case 'int16':
                return data instanceof Int16Array ? data : Int16Array.from(data);
            case 'int32':
                return data instanceof Int32Array ? data : Int32Array.from(data);
            case 'int8':
                return data instanceof Int8Array ? data : Int8Array.from(data);
            case 'uint16':
                return data instanceof Uint16Array ? data : Uint16Array.from(data);
            case 'uint32':
                return data instanceof Uint32Array ? data : Uint32Array.from(data);
            case 'uint8':
            case 'bool':
                return data instanceof Uint8Array ? data : Uint8Array.from(data);
            case 'float32':
                return data instanceof Float32Array ? data : Float32Array.from(data);
            case 'float64':
                return data instanceof Float64Array ? data : Float64Array.from(data);
            default:
                throw new Error(`TensorData type ${dataType} is not supported`);
        }
    }
    toTextureData(dataType, data) {
        if (!data) {
            return undefined;
        }
        return (data instanceof Float32Array) ? data : new Float32Array(data);
        /*
        switch (dataType) {
          case 'int16':
          case 'int32':
          case 'uint16':
          case 'uint32':
            return (data.constructor === Uint32Array) ? data as Uint32Array : new Uint32Array(data);
          case 'int8':
          case 'uint8':
          case 'bool':
            return (data.constructor === Uint8Array) ? data as Uint8Array : new Uint8Array(data);
          case 'float32':
          case 'float64':
            return (data.constructor === Float32Array) ? data as Float32Array : new Float32Array(data);
          default:
            throw new Error(`TensorData type ${dataType} is not supported`);
        }
        */
    }
    toEncoderType(_dataType) {
        return 'float';
        // switch (dataType) {
        //   case 'int16':
        //   case 'int32':
        //   case 'uint16':
        //   case 'uint32':
        //     return 'int';
        //   case 'uint8':
        //   case 'bool':
        //     return 'byte';
        //   case 'float32':
        //   case 'float64':
        //     return 'float';
        //   default:
        //     throw new Error(`TensorData type ${dataType} is not supported`);
        // }
    }
    clearActiveTextures() {
        this.glContext.clearActiveTextures();
    }
}
exports.TextureManager = TextureManager;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/utils.ts":
/*!********************************************!*\
  !*** ./lib/onnxjs/backends/webgl/utils.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCoordsDataType = exports.getSqueezedParams = exports.squeezeInputShape = exports.generateShaderFuncNameFromInputSamplerNameAtOutCoords = exports.generateShaderFuncNameFromInputSamplerName = exports.repeatedTry = exports.getPackedShape = void 0;
const util_1 = __webpack_require__(/*! ../../util */ "./lib/onnxjs/util.ts");
/**
 * Given a non RGBA shape calculate the R version
 * It is assumed that the dimensions are multiples of given channels
 * NOTE: it is always the last dim that gets packed.
 * @param unpackedShape original shape to create a packed version from
 */
function getPackedShape(unpackedShape) {
    const len = unpackedShape.length;
    return unpackedShape.slice(0, len - 1).concat(unpackedShape[len - 1] / 4);
}
exports.getPackedShape = getPackedShape;
function repeatedTry(checkFn, delayFn = (_counter) => 0, maxCounter) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let tryCount = 0;
            const tryFn = () => {
                if (checkFn()) {
                    resolve();
                    return;
                }
                tryCount++;
                const nextBackoff = delayFn(tryCount);
                if (maxCounter != null && tryCount >= maxCounter) {
                    reject();
                    return;
                }
                setTimeout(tryFn, nextBackoff);
            };
            tryFn();
        });
    });
}
exports.repeatedTry = repeatedTry;
/**
 * Generates the function name from an input sampler name.
 * @param samplerName Name of the sampler.
 */
function generateShaderFuncNameFromInputSamplerName(samplerName) {
    util_1.assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');
    return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);
}
exports.generateShaderFuncNameFromInputSamplerName = generateShaderFuncNameFromInputSamplerName;
/**
 * Generates the function name from an input sampler name at output coordinates.
 * @param samplerName Name of the sampler.
 */
function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName) {
    util_1.assert(typeof samplerName !== 'undefined' && samplerName.length !== 0, () => 'empty string found for sampler name');
    return 'get' + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + 'AtOutCoords';
}
exports.generateShaderFuncNameFromInputSamplerNameAtOutCoords = generateShaderFuncNameFromInputSamplerNameAtOutCoords;
/** Returns a new input shape (a copy) that has a squeezed logical shape. */
function squeezeInputShape(inputShape, squeezedShape) {
    // Deep copy.
    let newInputShape = JSON.parse(JSON.stringify(inputShape));
    newInputShape = squeezedShape;
    return newInputShape;
}
exports.squeezeInputShape = squeezeInputShape;
/** Returns a list of squeezed parameters for shader functions */
function getSqueezedParams(params, keptDims) {
    return keptDims.map(d => params[d]).join(', ');
}
exports.getSqueezedParams = getSqueezedParams;
/** Returns the data type for different ranks. */
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else if (rank === 5) {
        return 'ivec5';
    }
    else if (rank === 6) {
        return 'ivec6';
    }
    else {
        throw Error(`GPU for rank ${rank} is not yet supported`);
    }
}
exports.getCoordsDataType = getCoordsDataType;


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/webgl-context-factory.ts":
/*!************************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/webgl-context-factory.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNewWebGLContext = exports.createWebGLContext = void 0;
const instrument_1 = __webpack_require__(/*! ../../instrument */ "./lib/onnxjs/instrument.ts");
const webgl_context_1 = __webpack_require__(/*! ./webgl-context */ "./lib/onnxjs/backends/webgl/webgl-context.ts");
const cache = {};
/**
 * This factory function creates proper WebGLRenderingContext based on
 * the current browsers capabilities
 * The order is from higher/most recent versions to most basic
 */
function createWebGLContext(contextId) {
    let context;
    if ((!contextId || contextId === 'webgl2') && 'webgl2' in cache) {
        context = cache.webgl2;
    }
    else if ((!contextId || contextId === 'webgl') && 'webgl' in cache) {
        context = cache.webgl;
    }
    context = context || createNewWebGLContext(contextId);
    contextId = contextId || context.version === 1 ? 'webgl' : 'webgl2';
    const gl = context.gl;
    cache[contextId] = context;
    if (gl.isContextLost()) {
        delete cache[contextId];
        return createWebGLContext(contextId);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return context;
}
exports.createWebGLContext = createWebGLContext;
function createNewWebGLContext(contextId) {
    const canvas = createCanvas();
    const contextAttributes = {
        alpha: false,
        depth: false,
        antialias: false,
        stencil: false,
        preserveDrawingBuffer: false,
        premultipliedAlpha: false,
        failIfMajorPerformanceCaveat: false
    };
    let gl;
    const ca = contextAttributes;
    if (!contextId || contextId === 'webgl2') {
        gl = canvas.getContext('webgl2', ca);
        if (gl) {
            try {
                return new webgl_context_1.WebGLContext(gl, 2);
            }
            catch (err) {
                instrument_1.Logger.warning('GlContextFactory', `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);
            }
        }
    }
    if (!contextId || contextId === 'webgl') {
        gl = canvas.getContext('webgl', ca) || canvas.getContext('experimental-webgl', ca);
        if (gl) {
            try {
                return new webgl_context_1.WebGLContext(gl, 1);
            }
            catch (err) {
                instrument_1.Logger.warning('GlContextFactory', `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`);
            }
        }
    }
    throw new Error('WebGL is not supported');
}
exports.createNewWebGLContext = createNewWebGLContext;
function createCanvas() {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas;
}


/***/ }),

/***/ "./lib/onnxjs/backends/webgl/webgl-context.ts":
/*!****************************************************!*\
  !*** ./lib/onnxjs/backends/webgl/webgl-context.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebGLContext = void 0;
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const DataEncoders = __importStar(__webpack_require__(/*! ./texture-data-encoder */ "./lib/onnxjs/backends/webgl/texture-data-encoder.ts"));
const utils_1 = __webpack_require__(/*! ./utils */ "./lib/onnxjs/backends/webgl/utils.ts");
/**
 * Abstraction and wrapper around WebGLRenderingContext and its operations
 */
class WebGLContext {
    constructor(gl, version) {
        this.frameBufferBound = false;
        this.gl = gl;
        this.version = version;
        this.getExtensions();
        this.vertexbuffer = this.createVertexbuffer();
        this.framebuffer = this.createFramebuffer();
        this.queryVitalParameters();
    }
    allocateTexture(width, height, encoder, data) {
        const gl = this.gl;
        // create the texture
        const texture = gl.createTexture();
        // bind the texture so the following methods effect this texture.
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        const buffer = data ? encoder.encode(data, width * height) : null;
        gl.texImage2D(gl.TEXTURE_2D, 0, // Level of detail.
        encoder.internalFormat, width, height, 0, // Always 0 in OpenGL ES.
        encoder.format, encoder.textureType, buffer);
        this.checkError();
        return texture;
    }
    updateTexture(texture, width, height, encoder, data) {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const buffer = encoder.encode(data, width * height);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, // level
        0, // xoffset
        0, // yoffset
        width, height, encoder.format, encoder.textureType, buffer);
        this.checkError();
    }
    attachFramebuffer(texture, width, height) {
        const gl = this.gl;
        // Make it the target for framebuffer operations - including rendering.
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs
        this.checkError();
        gl.viewport(0, 0, width, height);
        gl.scissor(0, 0, width, height);
    }
    readTexture(texture, width, height, dataSize, dataType, channels) {
        const gl = this.gl;
        if (!channels) {
            channels = 1;
        }
        if (!this.frameBufferBound) {
            this.attachFramebuffer(texture, width, height);
        }
        const encoder = this.getEncoder(dataType, channels);
        const buffer = encoder.allocate(width * height);
        // bind texture to framebuffer
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // 0, we aren't using MIPMAPs
        // TODO: Check if framebuffer is ready
        gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);
        this.checkError();
        // unbind FB
        return encoder.decode(buffer, dataSize);
    }
    isFramebufferReady() {
        // TODO: Implement logic to check if the framebuffer is ready
        return true;
    }
    getActiveTexture() {
        const gl = this.gl;
        const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);
        return `TEXTURE${(n - gl.TEXTURE0)}`;
    }
    getTextureBinding() {
        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
    }
    getFramebufferBinding() {
        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
    }
    setVertexAttributes(positionHandle, textureCoordHandle) {
        const gl = this.gl;
        gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(positionHandle);
        if (textureCoordHandle !== -1) {
            gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);
            gl.enableVertexAttribArray(textureCoordHandle);
        }
        this.checkError();
    }
    createProgram(vertexShader, fragShader) {
        const gl = this.gl;
        const program = gl.createProgram();
        // the program consists of our shaders
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        return program;
    }
    compileShader(shaderSource, shaderType) {
        const gl = this.gl;
        const shader = gl.createShader(shaderType);
        if (!shader) {
            throw new Error(`createShader() returned null with type ${shaderType}`);
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}
Shader source:
${shaderSource}`);
        }
        return shader;
    }
    deleteShader(shader) {
        this.gl.deleteShader(shader);
    }
    bindTextureToUniform(texture, position, uniformHandle) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + position);
        this.checkError();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.checkError();
        gl.uniform1i(uniformHandle, position);
        this.checkError();
    }
    draw() {
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        this.checkError();
    }
    checkError() {
        if (onnxruntime_common_1.env.debug) {
            const gl = this.gl;
            const error = gl.getError();
            let label = '';
            switch (error) {
                case (gl.NO_ERROR):
                    return;
                case (gl.INVALID_ENUM):
                    label = 'INVALID_ENUM';
                    break;
                case (gl.INVALID_VALUE):
                    label = 'INVALID_VALUE';
                    break;
                case (gl.INVALID_OPERATION):
                    label = 'INVALID_OPERATION';
                    break;
                case (gl.INVALID_FRAMEBUFFER_OPERATION):
                    label = 'INVALID_FRAMEBUFFER_OPERATION';
                    break;
                case (gl.OUT_OF_MEMORY):
                    label = 'OUT_OF_MEMORY';
                    break;
                case (gl.CONTEXT_LOST_WEBGL):
                    label = 'CONTEXT_LOST_WEBGL';
                    break;
                default:
                    label = `Unknown WebGL Error: ${error.toString(16)}`;
            }
            throw new Error(label);
        }
    }
    deleteTexture(texture) {
        this.gl.deleteTexture(texture);
    }
    deleteProgram(program) {
        this.gl.deleteProgram(program);
    }
    getEncoder(dataType, channels, usage = 0 /* Default */) {
        if (this.version === 2) {
            return new DataEncoders.RedFloat32DataEncoder(this.gl, channels);
        }
        switch (dataType) {
            case 'float':
                if (usage === 1 /* UploadOnly */ || this.isRenderFloat32Supported) {
                    return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels);
                }
                else {
                    return new DataEncoders.RGBAFloatDataEncoder(this.gl, channels, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                }
            case 'int':
                throw new Error('not implemented');
            case 'byte':
                return new DataEncoders.Uint8DataEncoder(this.gl, channels);
            default:
                throw new Error(`Invalid dataType: ${dataType}`);
        }
    }
    clearActiveTextures() {
        const gl = this.gl;
        for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
    }
    dispose() {
        if (this.disposed) {
            return;
        }
        const gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(this.framebuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.deleteBuffer(this.vertexbuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.finish();
        this.disposed = true;
    }
    createDefaultGeometry() {
        // Sets of x,y,z(=0),s,t coordinates.
        return new Float32Array([
            -1.0, 1.0, 0.0, 0.0, 1.0,
            -1.0, -1.0, 0.0, 0.0, 0.0,
            1.0, 1.0, 0.0, 1.0, 1.0,
            1.0, -1.0, 0.0, 1.0, 0.0 // lower right
        ]);
    }
    createVertexbuffer() {
        const gl = this.gl;
        const buffer = gl.createBuffer();
        if (!buffer) {
            throw new Error('createBuffer() returned null');
        }
        const geometry = this.createDefaultGeometry();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);
        this.checkError();
        return buffer;
    }
    createFramebuffer() {
        const fb = this.gl.createFramebuffer();
        if (!fb) {
            throw new Error('createFramebuffer returned null');
        }
        return fb;
    }
    queryVitalParameters() {
        const gl = this.gl;
        this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();
        this.isRenderFloat32Supported = this.checkRenderFloat32();
        this.isFloat32DownloadSupported = this.checkFloat32Download();
        if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {
            throw new Error('both float32 and float16 TextureType are not supported');
        }
        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();
        // this.maxCombinedTextureImageUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        // this.maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        // this.shadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
        // this.webglVendor = gl.getParameter(gl.VENDOR);
        // this.webglVersion = gl.getParameter(gl.VERSION);
        if (this.version === 2) {
            // this.max3DTextureSize = gl.getParameter(WebGL2RenderingContext.MAX_3D_TEXTURE_SIZE);
            // this.maxArrayTextureLayers = gl.getParameter(WebGL2RenderingContext.MAX_ARRAY_TEXTURE_LAYERS);
            // this.maxColorAttachments = gl.getParameter(WebGL2RenderingContext.MAX_COLOR_ATTACHMENTS);
            // this.maxDrawBuffers = gl.getParameter(WebGL2RenderingContext.MAX_DRAW_BUFFERS);
        }
    }
    getExtensions() {
        if (this.version === 2) {
            this.colorBufferFloatExtension = this.gl.getExtension('EXT_color_buffer_float');
            this.disjointTimerQueryWebgl2Extension = this.gl.getExtension('EXT_disjoint_timer_query_webgl2');
        }
        else {
            this.textureFloatExtension = this.gl.getExtension('OES_texture_float');
            this.textureHalfFloatExtension = this.gl.getExtension('OES_texture_half_float');
        }
    }
    checkFloatTextureAttachableToFrameBuffer() {
        // test whether Float32 texture is supported:
        // STEP.1 create a float texture
        const gl = this.gl;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
        // STEP.2 bind a frame buffer
        const frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        // STEP.3 attach texture to framebuffer
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        // STEP.4 test whether framebuffer is complete
        const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(frameBuffer);
        return isComplete;
    }
    checkRenderFloat32() {
        if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
                return false;
            }
        }
        else {
            if (!this.textureFloatExtension) {
                return false;
            }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
    }
    checkFloat32Download() {
        if (this.version === 2) {
            if (!this.colorBufferFloatExtension) {
                return false;
            }
        }
        else {
            if (!this.textureFloatExtension) {
                return false;
            }
            if (!this.gl.getExtension('WEBGL_color_buffer_float')) {
                return false;
            }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
    }
    /**
     * Check whether GL_BLEND is supported
     */
    checkFloat32Blend() {
        // it looks like currently (2019-05-08) there is no easy way to detect whether BLEND is supported
        // https://github.com/microsoft/onnxjs/issues/145
        const gl = this.gl;
        let texture;
        let frameBuffer;
        let vertexShader;
        let fragmentShader;
        let program;
        try {
            texture = gl.createTexture();
            frameBuffer = gl.createFramebuffer();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // eslint-disable-next-line @typescript-eslint/naming-convention
            const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.enable(gl.BLEND);
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            if (!vertexShader) {
                return false;
            }
            gl.shaderSource(vertexShader, 'void main(){}');
            gl.compileShader(vertexShader);
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            if (!fragmentShader) {
                return false;
            }
            gl.shaderSource(fragmentShader, 'precision highp float;void main(){gl_FragColor=vec4(0.5);}');
            gl.compileShader(fragmentShader);
            program = gl.createProgram();
            if (!program) {
                return false;
            }
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.useProgram(program);
            gl.drawArrays(gl.POINTS, 0, 1);
            return gl.getError() === gl.NO_ERROR;
        }
        finally {
            gl.disable(gl.BLEND);
            if (program) {
                gl.deleteProgram(program);
            }
            if (vertexShader) {
                gl.deleteShader(vertexShader);
            }
            if (fragmentShader) {
                gl.deleteShader(fragmentShader);
            }
            if (frameBuffer) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.deleteFramebuffer(frameBuffer);
            }
            if (texture) {
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        }
    }
    beginTimer() {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            const query = gl2.createQuery();
            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
            return query;
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported.');
        }
    }
    endTimer() {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            gl2.endQuery(ext.TIME_ELAPSED_EXT);
            return;
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported');
        }
    }
    isTimerResultAvailable(query) {
        let available = false, disjoint = false;
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
            const gl2 = this.gl;
            const ext = this.disjointTimerQueryWebgl2Extension;
            available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported');
        }
        return available && !disjoint;
    }
    getTimerResult(query) {
        let timeElapsed = 0;
        if (this.version === 2) {
            const gl2 = this.gl;
            timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            gl2.deleteQuery(query);
        }
        else {
            // TODO: add webgl 1 handling.
            throw new Error('WebGL1 profiling currently not supported');
        }
        // return miliseconds
        return timeElapsed / 1000000;
    }
    waitForQueryAndGetTime(query) {
        return __awaiter(this, void 0, void 0, function* () {
            yield utils_1.repeatedTry(() => this.isTimerResultAvailable(query));
            return this.getTimerResult(query);
        });
    }
}
exports.WebGLContext = WebGLContext;


/***/ }),

/***/ "./lib/onnxjs/execution-plan.ts":
/*!**************************************!*\
  !*** ./lib/onnxjs/execution-plan.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecutionPlan = void 0;
const instrument_1 = __webpack_require__(/*! ./instrument */ "./lib/onnxjs/instrument.ts");
class KernelOp {
    constructor(op, node) {
        this.op = op;
        this.node = node;
    }
}
class ExecutionPlan {
    constructor(graph, ops, profiler) {
        this.graph = graph;
        this.profiler = profiler;
        this.initialize(ops);
    }
    initialize(ops) {
        this.profiler.event('session', 'ExecutionPlan.initialize', () => {
            const graphNodes = this.graph.getNodes();
            if (graphNodes.length !== ops.length) {
                throw new Error('The size of nodes and OPs do not match.');
            }
            this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));
            this.reset();
            // look for starter node(s)
            this._starter = [];
            this._ops.forEach((op, i) => {
                let resolved = true;
                for (const input of op.node.inputs) {
                    if (!this._values[input] // not an initialized input
                        && this.graph.getInputIndices().indexOf(input) === -1 // not model input
                    ) {
                        resolved = false;
                        break;
                    }
                }
                if (resolved) {
                    this._starter.push(i);
                }
            });
        });
    }
    reset() {
        this._values = this.graph.getValues().map(i => i.tensor);
    }
    execute(sessionHandler, modelInputs) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.profiler.event('session', 'ExecutionPlan.execute', () => __awaiter(this, void 0, void 0, function* () {
                // reset mediem result
                this.reset();
                // create inference handler
                const inferenceHandler = sessionHandler.createInferenceHandler();
                // populate inputs value
                const graphInputs = this.graph.getInputIndices();
                if (modelInputs.length !== graphInputs.length) {
                    throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${modelInputs.length} expected: ${graphInputs.length}`);
                }
                modelInputs.forEach((input, i) => {
                    const index = graphInputs[i];
                    this._values[index] = input;
                });
                // prepare running sequence
                const sequence = this._starter.slice(0);
                // execution iterations
                const graphValues = this.graph.getValues();
                const graphNodes = this.graph.getNodes();
                let rear = 0;
                while (rear < sequence.length) {
                    const thisOpIndex = sequence[rear++];
                    const thisOp = this._ops[thisOpIndex];
                    // check input
                    const inputList = thisOp.node.inputs.map(i => this._values[i]);
                    if (inputList.indexOf(undefined) !== -1) {
                        throw new Error(`unresolved input detected: op: ${thisOp.node}`);
                    }
                    // run
                    const inputTensors = inputList;
                    instrument_1.Logger.verbose('ExecPlan', `Runing op:${thisOp.node.name} (${inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(',')}]`).join(', ')})`);
                    const execNodeFn = () => __awaiter(this, void 0, void 0, function* () {
                        const op = thisOp.op;
                        if (!op.checkInputs(inputTensors)) {
                            throw new Error(`invalid inputs detected; op: ${thisOp.node.name}`);
                        }
                        const result = op.run(inferenceHandler, inputTensors);
                        return result;
                    });
                    const outputList = yield this.profiler.event('node', thisOp.node.name, execNodeFn);
                    // check output
                    if (outputList.length !== thisOp.node.outputs.length) {
                        throw new Error('the size of output does not match model definition.');
                    }
                    // fill value
                    outputList.forEach((output, i) => {
                        const j = thisOp.node.outputs[i];
                        if (this._values[j]) {
                            throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);
                        }
                        this._values[j] = output;
                    });
                    // resolve downstream nodes
                    const downstreamNodes = new Set();
                    outputList.forEach((output, i) => {
                        const j = thisOp.node.outputs[i];
                        for (const currentDownstreamNodeIndex of graphValues[j].to) {
                            const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];
                            let resolved = true;
                            for (const k of currentDownstreamNode.inputs) {
                                if (!this._values[k]) {
                                    resolved = false;
                                    break;
                                }
                            }
                            if (resolved) {
                                downstreamNodes.add(currentDownstreamNodeIndex);
                            }
                        }
                    });
                    sequence.push(...downstreamNodes);
                }
                const output = [];
                this.graph.getOutputIndices().forEach((outputIndex) => {
                    const thisValue = this._values[outputIndex];
                    if (thisValue === undefined) {
                        throw new Error(`required output [${outputIndex}] does not have value`);
                    }
                    // eslint-disable-next-line no-unused-expressions
                    thisValue.data;
                    output.push(thisValue);
                });
                instrument_1.Logger.verbose('ExecPlan', 'disposing of inferenceHandler');
                inferenceHandler.dispose();
                return output;
            }));
        });
    }
}
exports.ExecutionPlan = ExecutionPlan;


/***/ }),

/***/ "./lib/onnxjs/graph.ts":
/*!*****************************!*\
  !*** ./lib/onnxjs/graph.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Graph = void 0;
const onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
const attribute_1 = __webpack_require__(/*! ./attribute */ "./lib/onnxjs/attribute.ts");
const ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
const tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
const util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-redeclare
exports.Graph = {
    /**
     * construct a graph from a graph protobuf type
     */
    from: (graphProto, initializer) => new GraphImpl(graphProto, initializer),
};
class Value {
    constructor(valueInfo) {
        this._from = undefined;
        this._to = [];
        this.tensor = undefined;
        this.type = undefined;
        if (valueInfo) {
            this.type = util_1.ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType);
        }
    }
    get from() {
        return this._from;
    }
    get to() {
        return this._to;
    }
}
class Node {
    constructor(_nodeProto, name) {
        if (_nodeProto instanceof onnx_proto_1.onnx.NodeProto) {
            this.name = _nodeProto.name;
            this.opType = _nodeProto.opType;
            this.attributes = new attribute_1.Attribute(_nodeProto.attribute);
        }
        else if (_nodeProto instanceof ortFbs.Node) {
            this.name = name !== null && name !== void 0 ? name : _nodeProto.name();
            this.opType = _nodeProto.opType();
            this.attributes = new attribute_1.Attribute(util_1.ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));
        }
        this.inputs = [];
        this.outputs = [];
        this.executeNode = true;
    }
}
class GraphImpl {
    constructor(graph, graphInitializer) {
        if (!graph) {
            throw new TypeError('graph is empty');
        }
        // build the graph - will throw exceptions if something fatal is detected
        this.buildGraph(graph);
        // execute any transformation logic for the graph (if applicable)
        this.transformGraph(graphInitializer);
        // check for cycles and other inconsistencies - will throw exceptions if something fatal is detected
        this.checkIsAcyclic();
    }
    getInputIndices() {
        return this._allInputIndices;
    }
    getInputNames() {
        return this._allInputNames;
    }
    getOutputIndices() {
        return this._allOutputIndices;
    }
    getOutputNames() {
        return this._allOutputNames;
    }
    getValues() {
        return this._allData;
    }
    getNodes() {
        return this._nodes;
    }
    buildGraph(graph) {
        // build the graph - will throw exceptions if something fatal is detected
        if (graph instanceof onnx_proto_1.onnx.GraphProto) {
            this.buildGraphFromOnnxFormat(graph);
        }
        else if (graph instanceof ortFbs.Graph) {
            this.buildGraphFromOrtFormat(graph);
        }
        else {
            throw new TypeError('Graph type is not supported.');
        }
    }
    buildGraphFromOnnxFormat(graph) {
        const dataIndices = new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        const nodesIndices = new Map();
        // scan all inputs
        if (!graph.input) {
            throw new Error('missing information in graph: input');
        }
        const inputValueNames = [];
        for (const i of graph.input) {
            if (dataIndices.has(i.name)) {
                throw new Error(`duplicated input name: ${i.name}`);
            }
            const currentIndex = this._allData.push(new Value(i)) - 1;
            dataIndices.set(i.name, currentIndex);
            inputValueNames.push(i.name);
        }
        // scan all initializers
        if (!graph.initializer) {
            throw new Error('missing information in graph: initializer');
        }
        for (const i of graph.initializer) {
            let index = dataIndices.get(i.name);
            if (index === undefined) {
                const value = new Value();
                value.type = {
                    shape: { dims: util_1.ProtoUtil.tensorDimsFromProto(i.dims) },
                    tensorType: util_1.ProtoUtil.tensorDataTypeFromProto(i.dataType)
                };
                index = this._allData.push(value) - 1;
                dataIndices.set(i.name, index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = tensor_1.Tensor.fromProto(i);
        }
        // filter out input indices
        for (let i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
                this._allInputIndices.push(i);
                this._allInputNames.push(inputValueNames[i]);
            }
        }
        // scan all outputs
        if (!graph.output) {
            throw new Error('missing information in graph: output');
        }
        for (const i of graph.output) {
            if (dataIndices.has(i.name)) {
                throw new Error(`duplicated output name: ${i.name}`);
            }
            const currentIndex = this._allData.push(new Value(i)) - 1;
            dataIndices.set(i.name, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(i.name);
        }
        // scan all nodes
        if (!graph.node) {
            throw new Error('missing information in graph: node');
        }
        for (const nodeProto of graph.node) {
            if (!nodeProto.name) {
                // assign a name to the node if it doesn't have one
                for (let pick = 0;; pick++) {
                    const name = `unnamed_${nodeProto.opType}_${pick}`;
                    if (!nodesIndices.has(name)) {
                        nodeProto.name = name;
                        break;
                    }
                }
            }
            if (nodesIndices.has(nodeProto.name)) {
                throw new Error(`duplicated node name: ${nodeProto.name}`);
            }
            const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;
            nodesIndices.set(nodeProto.name, currentIndex);
        }
        // scan node's outputs
        for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.node[i];
            if (!nodeProto.output) {
                throw new Error(`missing output for node: ${nodeProto.name}`);
            }
            for (const output of nodeProto.output) {
                let dataIndex = dataIndices.get(output);
                if (typeof dataIndex === 'undefined') {
                    dataIndex = this._allData.push(new Value()) - 1;
                    dataIndices.set(output, dataIndex);
                }
                node.outputs.push(dataIndex);
                if (this._allData[dataIndex]._from !== undefined) {
                    throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
                }
                this._allData[dataIndex]._from = i;
                // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the
                // operator and ignore the node from the graph
                if (nodeProto.opType === 'Constant') {
                    if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {
                        throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');
                    }
                    if (!nodeProto.output || nodeProto.output.length !== 1) {
                        throw new Error('missing output or incorrect number of outputs for this Constant operator');
                    }
                    node.outputs.pop();
                    node.executeNode = false;
                    this._allData[dataIndex]._from = -1;
                    this._allData[dataIndex].tensor = tensor_1.Tensor.fromProto(nodeProto.attribute[0].t);
                }
            }
        }
        // scan node's inputs
        for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.node[i];
            if (!nodeProto.input) {
                throw new Error(`missing input for node: ${nodeProto.name}`);
            }
            for (const input of nodeProto.input) {
                const dataIndex = dataIndices.get(input);
                if (typeof dataIndex === 'undefined') {
                    throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);
                }
                node.inputs.push(dataIndex);
                this._allData[dataIndex]._to.push(i);
            }
        }
        return true;
    }
    buildGraphFromOrtFormat(graph) {
        var _a, _b, _c;
        const dataIndices = new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        const nodesIndices = new Map();
        // scan all inputs
        const inputValueNames = [];
        for (let i = 0; i < graph.inputsLength(); i++) {
            const inputName = graph.inputs(i);
            if (dataIndices.has(inputName)) {
                throw new Error(`duplicated input name: ${inputName}`);
            }
            // Find the input typeInfo from nodeargs
            for (let j = 0; j < graph.nodeArgsLength(); j++) {
                if (((_a = graph.nodeArgs(j)) === null || _a === void 0 ? void 0 : _a.name()) === inputName) {
                    const value = new Value();
                    const valueType = (_c = (_b = graph.nodeArgs(j)) === null || _b === void 0 ? void 0 : _b.type()) === null || _c === void 0 ? void 0 : _c.valueType();
                    if (valueType !== ortFbs.TypeInfoValue.tensor_type) {
                        throw new Error('Unexpected value type for the nodeArg.');
                    }
                    const valueInfo = graph.nodeArgs(j).type().value(new ortFbs.TensorTypeAndShape());
                    const type = util_1.ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());
                    const shape = valueInfo.shape();
                    const dims = [];
                    for (let k = 0; k < shape.dimLength(); k++) {
                        dims.push(util_1.LongUtil.longToNumber(shape.dim(k).value().dimValue()));
                    }
                    value.type = { shape: { dims }, tensorType: type };
                    const currentIndex = this._allData.push(value) - 1;
                    dataIndices.set(inputName, currentIndex);
                    inputValueNames.push(inputName);
                }
            }
        }
        // check initializers
        for (let i = 0; i < graph.initializersLength(); i++) {
            const initializer = graph.initializers(i);
            let index = dataIndices.get(initializer.name());
            if (index === undefined) {
                const value = new Value();
                const dims = util_1.ProtoUtil.tensorDimsFromORTFormat(initializer);
                const type = util_1.ProtoUtil.tensorDataTypeFromProto(initializer.dataType());
                value.type = { shape: { dims }, tensorType: type };
                index = this._allData.push(value) - 1;
                dataIndices.set(initializer.name(), index);
            }
            this._allData[index]._from = -1;
            this._allData[index].tensor = tensor_1.Tensor.fromOrtTensor(initializer);
        }
        // filter out input indices
        for (let i = 0; i < this._allData.length; i++) {
            if (!this._allData[i].tensor) {
                this._allInputIndices.push(i);
                this._allInputNames.push(inputValueNames[i]);
            }
        }
        // scan all outputs
        for (let i = 0; i < graph.outputsLength(); i++) {
            const outputName = graph.outputs(i);
            if (dataIndices.has(outputName)) {
                throw new Error(`duplicated output name: ${outputName}`);
            }
            const currentIndex = this._allData.push(new Value()) - 1;
            dataIndices.set(outputName, currentIndex);
            this._allOutputIndices.push(currentIndex);
            this._allOutputNames.push(outputName);
        }
        // scan all nodes
        if (!graph.nodes) {
            throw new Error('missing information in graph: node');
        }
        for (let i = 0; i < graph.nodesLength(); i++) {
            const nodeProto = graph.nodes(i);
            let name = nodeProto.name();
            if (!name) {
                // assign a name to the node if it doesn't have one
                for (let pick = 0;; pick++) {
                    name = `unnamed_${nodeProto.opType()}_${pick}`;
                    if (!nodesIndices.has(name)) {
                        // an unique name is found. break.
                        break;
                    }
                }
            }
            if (nodesIndices.has(name)) {
                throw new Error(`duplicated node name: ${name}`);
            }
            const currentIndex = this._nodes.push(new Node(nodeProto, name)) - 1;
            nodesIndices.set(name, currentIndex);
        }
        // scan node's outputs
        for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.nodes(i);
            if (nodeProto == null) {
                throw new Error(`No node exists at index ${i}`);
            }
            if ((nodeProto === null || nodeProto === void 0 ? void 0 : nodeProto.outputsLength()) === 0) {
                throw new Error(`missing output for node: ${nodeProto.name}`);
            }
            for (let j = 0; j < (nodeProto === null || nodeProto === void 0 ? void 0 : nodeProto.outputsLength()); j++) {
                const output = nodeProto === null || nodeProto === void 0 ? void 0 : nodeProto.outputs(j);
                let dataIndex = dataIndices.get(output);
                if (typeof dataIndex === 'undefined') {
                    dataIndex = this._allData.push(new Value()) - 1;
                    dataIndices.set(output, dataIndex);
                }
                node.outputs.push(dataIndex);
                if (this._allData[dataIndex]._from !== undefined) {
                    throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
                }
                this._allData[dataIndex]._from = i;
                // for the 'Constant' operator, just create a new edge in the graph corresponding to the 'output' of the
                // operator and ignore the node from the graph
                if (nodeProto.opType() === 'Constant') {
                    if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0).t()) {
                        throw new Error('missing attributes or missing tensor value in attributes for this Constant operator');
                    }
                    if (nodeProto.outputsLength() !== 1) {
                        throw new Error('missing output or incorrect number of outputs for this Constant operator');
                    }
                    node.outputs.pop();
                    node.executeNode = false;
                    this._allData[dataIndex]._from = -1;
                    this._allData[dataIndex].tensor = tensor_1.Tensor.fromOrtTensor(nodeProto.attributes(0).t());
                }
            }
        }
        // scan node's inputs
        for (let i = 0; i < this._nodes.length; i++) {
            const node = this._nodes[i];
            const nodeProto = graph.nodes(i);
            if (nodeProto.inputsLength() === 0) {
                throw new Error(`missing input for node: ${nodeProto.name}`);
            }
            for (let j = 0; j < nodeProto.inputsLength(); j++) {
                const input = nodeProto.inputs(j);
                const dataIndex = dataIndices.get(input);
                if (typeof dataIndex === 'undefined') {
                    throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name()}`);
                }
                node.inputs.push(dataIndex);
                this._allData[dataIndex]._to.push(i);
            }
        }
    }
    checkIsAcyclic() {
        // go through the graph and check for cycles or other fatal inconsistencies
        const starters = new Set();
        this._allInputIndices.forEach(i => {
            const data = this._allData[i];
            data._to.forEach(j => {
                starters.add(j);
            });
        });
        // Iterative DFS to check for cycles
        const nodesStack = Array.from(starters);
        const nodesState = new Array(this._nodes.length).fill('white');
        while (nodesStack.length > 0) {
            const nodeIndex = nodesStack.pop();
            // this node has now been processed completely. Mark this node 'black' to denote this.
            if (nodesState[nodeIndex] === 'gray') {
                nodesState[nodeIndex] = 'black';
            }
            else {
                // this node is under processing stage. mark this node 'gray' to denote this.
                nodesStack.push(nodeIndex);
                nodesState[nodeIndex] = 'gray';
                this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {
                    const data = this._allData[outgoingEdgeIndex];
                    if (typeof data.tensor !== 'undefined') {
                        throw new Error('node outputs should not be initialized');
                    }
                    if (data._from !== nodeIndex) {
                        throw new Error('from property of the Value object doesn\'t match index of Node being processed');
                    }
                    data._to.forEach((downstreamNodeIndex) => {
                        // back edge found - cyclic
                        if (nodesState[downstreamNodeIndex] === 'gray') {
                            throw new Error('model graph is cyclic');
                        }
                        // tree edge found - continue processing by adding it to stack
                        else if (nodesState[downstreamNodeIndex] === 'white') {
                            nodesStack.push(downstreamNodeIndex);
                        }
                    });
                });
            }
        }
    }
    transformGraph(graphInitializer) {
        // apply common transform
        this.removeAllIdentityNodes();
        this.removeAllDropoutNodes();
        // apply initializer specific transform
        if (graphInitializer) {
            graphInitializer.transformGraph(this);
        }
        // finalize graph
        this.finalizeGraph();
    }
    /**
     * finalize the graph.
     *
     * this function should be called after all the transformation completed.
     * this function removes all unnecessary nodes and values from the graph
     */
    finalizeGraph() {
        let offset = 0;
        // delete all nodes that are not being executed
        for (let i = 0; i < this._nodes.length; i++) {
            if (!this._nodes[i].executeNode) {
                // delete this node and shift all subsequent nodes up
                offset++;
                // delete all output values
                this._nodes[i].outputs.forEach(ind => {
                    this._allData[ind]._from = -2;
                });
                this._nodes.splice(i, 1);
                i--;
                continue;
            }
            if (offset > 0) {
                // update the value table
                this._nodes[i].inputs.forEach(value => {
                    const ind = this._allData[value]._to.indexOf(i + offset);
                    if (ind !== -1) {
                        this._allData[value]._to[ind] = i;
                    }
                });
                this._nodes[i].outputs.forEach(value => {
                    if (this._allData[value]._from && this._allData[value]._from === i + offset) {
                        this._allData[value]._from = i;
                    }
                });
            }
        }
        offset = 0;
        // delete all values that are not being referenced
        for (let i = 0; i < this._allData.length; i++) {
            // if current value is neither linked to next node, nor an output value, remove it.
            if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {
                offset++;
                this._allData.splice(i, 1);
                i--;
                continue;
            }
            if (offset > 0) {
                let ind = -1;
                // if current value is neither an input value nor an initializer, find the node it's
                // coming from and update the corresponding node output
                if (this._allData[i].from !== undefined && this._allData[i].from !== -1) {
                    ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);
                    if (ind !== -1) {
                        this._nodes[this._allData[i].from].outputs[ind] = i;
                    }
                }
                else {
                    // if current value is an input value, update its reference in inputIndices
                    ind = this._allInputIndices.indexOf(i + offset);
                    if (ind !== -1) {
                        this._allInputIndices[ind] = i;
                    }
                }
                // find the node that the current value is linking to and update its input reference
                this._allData[i].to.forEach(node => {
                    ind = this._nodes[node].inputs.indexOf(i + offset);
                    if (ind !== -1) {
                        this._nodes[node].inputs[ind] = i;
                    }
                });
                if (this._allData[i].to.length === 0) {
                    // if current value is a graph output, update its reference in outputIndices
                    ind = this._allOutputIndices.indexOf(i + offset);
                    if (ind !== -1) {
                        this._allOutputIndices[ind] = i;
                    }
                }
            }
        }
    }
    /**
     * Delete the specifed node. Assume the node has only one input and the first output connected to other nodes
     * @param nodeIndex The index of node to be deleted
     */
    deleteNode(nodeIndex) {
        const node = this._nodes[nodeIndex];
        if (node.inputs.length > 1) {
            throw new Error('Node deletion with multiple inputs is not supported. ');
        }
        if (node.outputs.length > 1) {
            for (let i = 1; i < node.outputs.length; i++) {
                if (this._allData[node.outputs[i]].to.length > 0) {
                    throw new Error('Node deletion with more than one output connected to other nodes is not supported. ');
                }
            }
        }
        // this node wil not be executed
        node.executeNode = false;
        const inputValueIndex = node.inputs[0];
        const outputValueIndex = node.outputs[0];
        const nodesConsumingOutput = this._allData[outputValueIndex].to;
        // remove this node from the to property of the input Value
        const delIndex = this._allData[inputValueIndex].to.indexOf(nodeIndex);
        // should not happen
        if (delIndex === -1) {
            throw new Error('The Value object doesn\'t have the current Node in it\'s \'to\' property ');
        }
        this._allData[inputValueIndex].to.splice(delIndex, 1);
        // clear node indices consuming this output Value
        this._allData[outputValueIndex]._to = [];
        // if the output of this node is a graph output, adjust the index appropriately
        const index = this._allOutputIndices.indexOf(outputValueIndex);
        if (index !== -1) {
            this._allOutputIndices[index] = inputValueIndex;
        }
        // override the inputs for nodes consuming this node's output with the input to this node
        if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {
            for (const nodeIndex of nodesConsumingOutput) {
                const replaceIndex = this._nodes[nodeIndex].inputs.indexOf(outputValueIndex);
                // should not happen
                if (replaceIndex === -1) {
                    throw new Error('The Node object doesn\'t have the output Value in it\'s \'inputs\' property ');
                }
                this._nodes[nodeIndex].inputs[replaceIndex] = inputValueIndex;
                this._allData[inputValueIndex].to.push(nodeIndex);
            }
        }
    }
    removeAllDropoutNodes() {
        let nodeIndex = 0;
        for (const node of this._nodes) {
            // weed out 'Dropout' nodes so that no time is wasted in execution
            if (node.opType === 'Dropout') {
                // the node should have exactly 1 input and 1 or 2 outputs
                if (node.inputs.length !== 1) {
                    throw new Error('Dropout nodes should only contain one input. ');
                }
                if (node.outputs.length !== 1 && node.outputs.length !== 2) {
                    throw new Error('Dropout nodes should contain either 1 or 2 output(s)');
                }
                // the second output should not be referenced by any other node
                if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {
                    throw new Error('Dropout nodes\'s second output should not be referenced by other nodes');
                }
                this.deleteNode(nodeIndex);
            }
            nodeIndex++;
        }
    }
    removeAllIdentityNodes() {
        let nodeIndex = 0;
        for (const node of this._nodes) {
            // weed out 'Identity' nodes so that no time is wasted in execution
            if (node.opType === 'Identity') {
                this.deleteNode(nodeIndex);
            }
            nodeIndex++;
        }
    }
    isActivation(n) {
        switch (n.opType) {
            // TODO: add other activation methods
            case 'Relu':
            case 'Sigmoid':
                return true;
            default:
                return false;
        }
    }
    fuseConvActivationNodes() {
        for (const node of this._nodes) {
            if (node.opType === 'Conv') {
                const next = this._allData[node.outputs[0]]._to;
                if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {
                    node.attributes.set('__internal_activation', 'string', (this._nodes[next[0]].opType));
                    this.deleteNode(next[0]);
                }
            }
        }
    }
}


/***/ }),

/***/ "./lib/onnxjs/instrument.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/instrument.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.now = exports.Profiler = exports.Logger = void 0;
class NoOpLoggerProvider {
    log(_severity, _content, _category) {
        // do nothing
    }
}
class ConsoleLoggerProvider {
    log(severity, content, category) {
        // eslint-disable-next-line no-console
        console.log(`${this.color(severity)} ${category ? '\x1b[35m' + category + '\x1b[0m ' : ''}${content}`);
    }
    color(severity) {
        switch (severity) {
            case 'verbose':
                return '\x1b[34;40mv\x1b[0m';
            case 'info':
                return '\x1b[32mi\x1b[0m';
            case 'warning':
                return '\x1b[30;43mw\x1b[0m';
            case 'error':
                return '\x1b[31;40me\x1b[0m';
            case 'fatal':
                return '\x1b[101mf\x1b[0m';
            default:
                throw new Error(`unsupported severity: ${severity}`);
        }
    }
}
const SEVERITY_VALUE = {
    verbose: 1000,
    info: 2000,
    warning: 4000,
    error: 5000,
    fatal: 6000
};
const LOGGER_PROVIDER_MAP = {
    ['none']: new NoOpLoggerProvider(),
    ['console']: new ConsoleLoggerProvider()
};
const LOGGER_DEFAULT_CONFIG = {
    provider: 'console',
    minimalSeverity: 'warning',
    logDateTime: true,
    logSourceLocation: false
};
let LOGGER_CONFIG_MAP = { ['']: LOGGER_DEFAULT_CONFIG };
function log(arg0, arg1, arg2, arg3) {
    if (arg1 === undefined) {
        // log(category: string): Logger.CategorizedLogger;
        return createCategorizedLogger(arg0);
    }
    else if (arg2 === undefined) {
        // log(severity, content);
        logInternal(arg0, arg1, 1);
    }
    else if (typeof arg2 === 'number' && arg3 === undefined) {
        // log(severity, content, stack)
        logInternal(arg0, arg1, arg2);
    }
    else if (typeof arg2 === 'string' && arg3 === undefined) {
        // log(severity, category, content)
        logInternal(arg0, arg2, 1, arg1);
    }
    else if (typeof arg2 === 'string' && typeof arg3 === 'number') {
        // log(severity, category, content, stack)
        logInternal(arg0, arg2, arg3, arg1);
    }
    else {
        throw new TypeError('input is valid');
    }
}
function createCategorizedLogger(category) {
    return {
        verbose: log.verbose.bind(null, category),
        info: log.info.bind(null, category),
        warning: log.warning.bind(null, category),
        error: log.error.bind(null, category),
        fatal: log.fatal.bind(null, category)
    };
}
// NOTE: argument 'category' is put the last parameter beacause typescript
// doesn't allow optional argument put in front of required argument. This
// order is different from a usual logging API.
function logInternal(severity, content, stack, category) {
    const config = LOGGER_CONFIG_MAP[category || ''] || LOGGER_CONFIG_MAP[''];
    if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {
        return;
    }
    if (config.logDateTime) {
        content = `${new Date().toISOString()}|${content}`;
    }
    if (config.logSourceLocation) {
        // TODO: calculate source location from 'stack'
    }
    LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);
}
// eslint-disable-next-line @typescript-eslint/no-namespace
(function (log) {
    function verbose(arg0, arg1) {
        log('verbose', arg0, arg1);
    }
    log.verbose = verbose;
    function info(arg0, arg1) {
        log('info', arg0, arg1);
    }
    log.info = info;
    function warning(arg0, arg1) {
        log('warning', arg0, arg1);
    }
    log.warning = warning;
    function error(arg0, arg1) {
        log('error', arg0, arg1);
    }
    log.error = error;
    function fatal(arg0, arg1) {
        log('fatal', arg0, arg1);
    }
    log.fatal = fatal;
    function reset(config) {
        LOGGER_CONFIG_MAP = {};
        set('', config || {});
    }
    log.reset = reset;
    function set(category, config) {
        if (category === '*') {
            reset(config);
        }
        else {
            const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;
            LOGGER_CONFIG_MAP[category] = {
                provider: config.provider || previousConfig.provider,
                minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,
                logDateTime: (config.logDateTime === undefined) ? previousConfig.logDateTime : config.logDateTime,
                logSourceLocation: (config.logSourceLocation === undefined) ? previousConfig.logSourceLocation :
                    config.logSourceLocation
            };
        }
        // TODO: we want to support wildcard or regex?
    }
    log.set = set;
    function setWithEnv(env) {
        const config = {};
        if (env.logLevel) {
            config.minimalSeverity = env.logLevel;
        }
        set('', config);
    }
    log.setWithEnv = setWithEnv;
})(log || (log = {}));
// eslint-disable-next-line @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention
exports.Logger = log;
// TODO
// class WebGLEvent implements Profiler.Event {}
class Event {
    constructor(category, name, startTime, endCallback, timer, ctx) {
        this.category = category;
        this.name = name;
        this.startTime = startTime;
        this.endCallback = endCallback;
        this.timer = timer;
        this.ctx = ctx;
    }
    end() {
        return this.endCallback(this);
    }
    checkTimer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ctx === undefined || this.timer === undefined) {
                throw new Error('No webgl timer found');
            }
            else {
                this.ctx.endTimer();
                return this.ctx.waitForQueryAndGetTime(this.timer);
            }
        });
    }
}
class EventRecord {
    constructor(category, name, startTime, endTime) {
        this.category = category;
        this.name = name;
        this.startTime = startTime;
        this.endTime = endTime;
    }
}
class Profiler {
    constructor(maxNumberEvents, flushBatchSize, flushIntervalInMilliseconds) {
        this._started = false;
        this._flushPointer = 0;
        this._started = false;
        this._maxNumberEvents = maxNumberEvents === undefined ? 10000 : maxNumberEvents;
        this._flushBatchSize = flushBatchSize === undefined ? 10 : flushBatchSize;
        this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === undefined ? 5000 : flushIntervalInMilliseconds;
    }
    static create(config) {
        if (config === undefined) {
            return new this();
        }
        return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);
    }
    // start profiling
    start() {
        this._started = true;
        this._timingEvents = [];
        this._flushTime = exports.now();
        this._flushPointer = 0;
    }
    // stop profiling
    stop() {
        this._started = false;
        for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {
            this.logOneEvent(this._timingEvents[this._flushPointer]);
        }
    }
    event(category, name, func, ctx) {
        const event = this._started ? this.begin(category, name, ctx) : undefined;
        let isPromise = false;
        const res = func();
        // we consider a then-able object is a promise
        if (res && typeof res.then === 'function') {
            isPromise = true;
            return new Promise((resolve, reject) => {
                res
                    .then((value) => __awaiter(this, void 0, void 0, function* () {
                    if (event) {
                        yield event.end();
                    }
                    resolve(value);
                }), (reason) => __awaiter(this, void 0, void 0, function* () {
                    if (event) {
                        yield event.end();
                    }
                    reject(reason);
                }));
            });
        }
        if (!isPromise && event) {
            const eventRes = event.end();
            if (eventRes && typeof eventRes.then === 'function') {
                return new Promise((resolve, reject) => {
                    (eventRes).then(() => {
                        resolve(res);
                    }, (reason) => {
                        reject(reason);
                    });
                });
            }
        }
        return res;
    }
    // begin an event
    begin(category, name, ctx) {
        if (!this._started) {
            throw new Error('profiler is not started yet');
        }
        if (ctx === undefined) {
            const startTime = exports.now();
            this.flush(startTime);
            return new Event(category, name, startTime, e => this.endSync(e));
        }
        else {
            const timer = ctx.beginTimer();
            return new Event(category, name, 0, (e) => __awaiter(this, void 0, void 0, function* () { return this.end(e); }), timer, ctx);
        }
    }
    // end the specific event
    end(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const endTime = yield event.checkTimer();
            if (this._timingEvents.length < this._maxNumberEvents) {
                this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
                this.flush(endTime);
            }
        });
    }
    endSync(event) {
        const endTime = exports.now();
        if (this._timingEvents.length < this._maxNumberEvents) {
            this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
            this.flush(endTime);
        }
    }
    logOneEvent(event) {
        exports.Logger.verbose(`Profiler.${event.category}`, `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`);
    }
    flush(currentTime) {
        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize ||
            currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {
            // should flush when either batch size accumlated or interval elepsed
            for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize &&
                this._flushPointer < this._timingEvents.length; this._flushPointer++) {
                this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            this._flushTime = exports.now();
        }
    }
    get started() {
        return this._started;
    }
}
exports.Profiler = Profiler;
/**
 * returns a number to represent the current timestamp in a resolution as high as possible.
 */
exports.now = (typeof performance !== 'undefined' && performance.now) ? () => performance.now() : Date.now;


/***/ }),

/***/ "./lib/onnxjs/model.ts":
/*!*****************************!*\
  !*** ./lib/onnxjs/model.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Model = void 0;
const flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/js/flatbuffers.mjs");
const onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
const graph_1 = __webpack_require__(/*! ./graph */ "./lib/onnxjs/graph.ts");
const ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
const util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
class Model {
    // empty model
    constructor() { }
    load(buf, graphInitializer, isOrtFormat) {
        if (!isOrtFormat) {
            // isOrtFormat === false || isOrtFormat === undefined
            try {
                this.loadFromOnnxFormat(buf, graphInitializer);
                return;
            }
            catch (e) {
                if (isOrtFormat !== undefined) {
                    throw e;
                }
            }
        }
        this.loadFromOrtFormat(buf, graphInitializer);
    }
    loadFromOnnxFormat(buf, graphInitializer) {
        const modelProto = onnx_proto_1.onnx.ModelProto.decode(buf);
        const irVersion = util_1.LongUtil.longToNumber(modelProto.irVersion);
        if (irVersion < 3) {
            throw new Error('only support ONNX model with IR_VERSION>=3');
        }
        this._opsets =
            modelProto.opsetImport.map(i => ({ domain: i.domain, version: util_1.LongUtil.longToNumber(i.version) }));
        this._graph = graph_1.Graph.from(modelProto.graph, graphInitializer);
    }
    loadFromOrtFormat(buf, graphInitializer) {
        const fb = new flatbuffers_1.flatbuffers.ByteBuffer(buf);
        const ortModel = ortFbs.InferenceSession.getRootAsInferenceSession(fb).model();
        const irVersion = util_1.LongUtil.longToNumber(ortModel.irVersion());
        if (irVersion < 3) {
            throw new Error('only support ONNX model with IR_VERSION>=3');
        }
        this._opsets = [];
        for (let i = 0; i < ortModel.opsetImportLength(); i++) {
            const opsetId = ortModel.opsetImport(i);
            this._opsets.push({ domain: opsetId === null || opsetId === void 0 ? void 0 : opsetId.domain(), version: util_1.LongUtil.longToNumber(opsetId.version()) });
        }
        this._graph = graph_1.Graph.from(ortModel.graph(), graphInitializer);
    }
    get graph() {
        return this._graph;
    }
    get opsets() {
        return this._opsets;
    }
}
exports.Model = Model;


/***/ }),

/***/ "./lib/onnxjs/operators.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/operators.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FLOAT_TYPES = exports.INT_TYPES = exports.NUMBER_TYPES = void 0;
exports.NUMBER_TYPES = ['float32', 'float64', 'int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];
exports.INT_TYPES = ['int32', 'int16', 'int8', 'uint16', 'uint32', 'uint8'];
exports.FLOAT_TYPES = ['float32', 'float64'];


/***/ }),

/***/ "./lib/onnxjs/ops/batch-normalization.ts":
/*!***********************************************!*\
  !*** ./lib/onnxjs/ops/batch-normalization.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchNormalization = void 0;
// currently this operator supports ONLY 'test' mode
// inputs/outputs and parameters will reflect that
// the operator implementation only supports test mode
class BatchNormalization {
    initialize(attributes) {
        this.epsilon = attributes.getFloat('epsilon', 1e-5);
        this.momentum = attributes.getFloat('momentum', 0.9);
        this.spatial = attributes.getInt('spatial', 1);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 5) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        const X = inputs[0];
        const scale = inputs[1];
        const B = inputs[2];
        const mean = inputs[3];
        const var_ = inputs[4];
        // input should atleast have three dimensions - N,C,dim1,...,dimn
        // other inputs can have only one dimensions
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 ||
            var_.dims.length !== 1) {
            return false;
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] ||
            var_.dims[0] !== X.dims[1]) {
            return false;
        }
        if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||
            (B.type !== 'float32' && B.type !== 'float64') || (mean.type !== 'float32' && mean.type !== 'float64') ||
            (var_.type !== 'float32' && var_.type !== 'float64')) {
            return false;
        }
        return true;
    }
}
exports.BatchNormalization = BatchNormalization;


/***/ }),

/***/ "./lib/onnxjs/ops/binary-op.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/binary-op.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinaryOp = void 0;
class BinaryOp {
    constructor(typeConstraint, opType, resultType) {
        this.typeConstraint = typeConstraint;
        this.opType = opType;
        this.resultType = resultType;
    }
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (this.typeConstraint.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[0].type !== inputs[1].type) {
            return false;
        }
        return true;
    }
}
exports.BinaryOp = BinaryOp;


/***/ }),

/***/ "./lib/onnxjs/ops/clip.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/clip.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Clip = void 0;
class Clip {
    initialize(attributes) {
        this.min = attributes.getFloat('min', -3.4028234663852886e+38);
        this.max = attributes.getFloat('max', 3.4028234663852886e+38);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.Clip = Clip;


/***/ }),

/***/ "./lib/onnxjs/ops/concat.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/ops/concat.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Concat = void 0;
class Concat {
    initialize(attributes) {
        this.axis = attributes.getInt('axis');
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length < 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        const inputType = inputs[0].type;
        const inputDimensionality = inputs[0].dims.length;
        // TODO: Support string concat
        if (inputType === 'string') {
            return false;
        }
        for (const input of inputs) {
            // make sure types of all inputs match
            if (input.type !== inputType) {
                return false;
            }
            // make sure the dimensionality of all inputs are the same
            if (input.dims.length !== inputDimensionality) {
                return false;
            }
        }
        return true;
    }
}
exports.Concat = Concat;


/***/ }),

/***/ "./lib/onnxjs/ops/conv.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/conv.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Conv = void 0;
class Conv {
    initialize(attributes) {
        // TODO : Make this generic enough to compute default attributes for multi-dimensional conv
        this.autoPad = attributes.getString('auto_pad', 'NOTSET');
        this.dilations = attributes.getInts('dilations', [1, 1]);
        this.group = attributes.getInt('group', 1);
        this.kernelShape = attributes.getInts('kernel_shape', []);
        this.pads = attributes.getInts('pads', [0, 0, 0, 0]);
        this.strides = attributes.getInts('strides', [1, 1]);
        this.activation = attributes.getString('__internal_activation', '');
    }
    checkInputs(inputs) {
        // Refer to the below link for all input checks
        // https://github.com/onnx/onnx/blob/master/docs/Operators.md#Conv
        if (!inputs || (inputs.length !== 2 && inputs.length !== 3)) {
            return false;
        }
        // TODO : Need to add support for multi-dimensional conv
        // currently only support 2-dimensional conv
        if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
            return false;
        }
        // FILTER_IN_CHANNEL should be equal to DATA_CHANNEL
        const dataChannel = inputs[0].dims[1];
        const filterInChannel = inputs[1].dims[1] * this.group;
        if (dataChannel !== filterInChannel) {
            return false;
        }
        // if bias is provided it should be 1D and the number of elements should be equal to the number of feature maps
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
            return false;
        }
        const spatialRank = inputs[0].dims.length - 2;
        // wrong dilations dimension
        if (this.dilations.length !== spatialRank) {
            return false;
        }
        // Wrong strides dimension
        if (this.strides.length !== spatialRank) {
            return false;
        }
        // Wrong pads dimension
        if (this.pads.length !== spatialRank * 2) {
            return false;
        }
        // if kernelShape is specified, it's data length must be 2 less than dims length of the weights tensor
        // (the first 2 dims are batch_size and channels)
        if (this.kernelShape.length !== 0 && this.kernelShape.length !== inputs[1].dims.length - 2) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        // TODO : Need to add support for float64
        if (inputs[0].type !== 'float32' || inputs[1].type !== 'float32') {
            return false;
        }
        if (inputs.length === 3 && inputs[2].type !== 'float32') {
            return false;
        }
        return true;
    }
}
exports.Conv = Conv;


/***/ }),

/***/ "./lib/onnxjs/ops/depth-to-space.ts":
/*!******************************************!*\
  !*** ./lib/onnxjs/ops/depth-to-space.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DepthToSpace = void 0;
class DepthToSpace {
    constructor() { }
    initialize(attributes) {
        // processing node attributes
        this.blocksize = attributes.getInt('blocksize');
        if (this.blocksize < 1) {
            throw new Error(`blocksize must be >= 1, but got : ${this.blocksize} for DepthToSpace`);
        }
        this.blocksizeSqr = this.blocksize * this.blocksize;
        this.mode = attributes.getString('mode', 'DCR');
        if (DepthToSpace.supportedModes.indexOf(this.mode) < 0) {
            throw new Error(`unrecognized mode: ${this.mode} for DepthToSpace`);
        }
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        const inputType = inputs[0].type;
        const inputDimensionality = inputs[0].dims.length;
        // Input has to be a 4-D tensor
        // TODO: Support string depth-to-space.
        if (inputType === 'string' || inputDimensionality !== 4) {
            return false;
        }
        return true;
    }
}
exports.DepthToSpace = DepthToSpace;
DepthToSpace.supportedModes = ['DCR', 'CRD'];


/***/ }),

/***/ "./lib/onnxjs/ops/dropout.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/dropout.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dropout = void 0;
class Dropout {
    initialize(attributes) {
        this.ratio = attributes.getFloat('ratio', 0.5);
        this.testMode = true; // this is a hack to reflect that test mode is hardcoded
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.Dropout = Dropout;


/***/ }),

/***/ "./lib/onnxjs/ops/elu.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/ops/elu.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Elu = void 0;
class Elu {
    initialize(attributes) {
        this.alpha = attributes.getFloat('alpha', 1.0);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.Elu = Elu;


/***/ }),

/***/ "./lib/onnxjs/ops/flatten.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/flatten.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Flatten = void 0;
class Flatten {
    initialize(attributes) {
        this.axis = attributes.getInt('axis', 1); // default axis is 1
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        const r = inputs[0].dims.length;
        if (r === 0) {
            return false; // scalar tensor is not supported
        }
        if (this.axis < -r || this.axis > r) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        // TODO: Support string type
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    }
}
exports.Flatten = Flatten;


/***/ }),

/***/ "./lib/onnxjs/ops/gather.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/ops/gather.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gather = void 0;
const operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
class Gather {
    initialize(attributes) {
        this.axis = attributes.getInt('axis', 0);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        const tensorRank = inputs[0].dims.length;
        if (tensorRank < 1) {
            return false;
        }
        if (this.axis < -tensorRank || this.axis > tensorRank - 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {
            return false;
        }
        return true;
    }
}
exports.Gather = Gather;


/***/ }),

/***/ "./lib/onnxjs/ops/gemm.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/gemm.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Gemm = void 0;
class Gemm {
    constructor(isOptionalC) {
        this.isOptionalC = isOptionalC;
    }
    initialize(attributes) {
        this.transA = attributes.getInt('transA', 0) !== 0;
        this.transB = attributes.getInt('transB', 0) !== 0;
        this.alpha = attributes.getFloat('alpha', 1);
        this.beta = attributes.getFloat('beta', 1);
    }
    checkInputs(inputs) {
        if (!inputs) {
            return false;
        }
        if (this.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {
            return false;
        }
        if (!this.isOptionalC && inputs.length !== 3) {
            return false;
        }
        // 'C' can be of dimensionality 1 or 2 only
        if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if ((inputs[0].type !== 'float32' && inputs[0].type !== 'float64') ||
            (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') ||
            (inputs.length === 3 && inputs[2].type !== 'float32' && inputs[2].type !== 'float64')) {
            return false;
        }
        if ((inputs[0].type !== inputs[1].type) || (inputs.length === 3 && inputs[0].type !== inputs[2].type)) {
            return false;
        }
        return true;
    }
}
exports.Gemm = Gemm;


/***/ }),

/***/ "./lib/onnxjs/ops/image-scaler.ts":
/*!****************************************!*\
  !*** ./lib/onnxjs/ops/image-scaler.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageScaler = void 0;
class ImageScaler {
    initialize(attributes) {
        this.scale = attributes.getFloat('scale');
        this.bias = attributes.getFloats('bias');
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        if (inputs[0].dims.length !== 4) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.ImageScaler = ImageScaler;


/***/ }),

/***/ "./lib/onnxjs/ops/instance-normalization.ts":
/*!**************************************************!*\
  !*** ./lib/onnxjs/ops/instance-normalization.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstanceNormalization = void 0;
class InstanceNormalization {
    initialize(attributes) {
        this.epsilon = attributes.getFloat('epsilon', 1e-5);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 3) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        const X = inputs[0];
        const scale = inputs[1];
        const B = inputs[2];
        // input should atleast have three dimensions - N,C,dim1,...,dimn
        // other inputs can have only one dimensions
        if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {
            return false;
        }
        if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {
            return false;
        }
        if ((X.type !== 'float32' && X.type !== 'float64') || (scale.type !== 'float32' && scale.type !== 'float64') ||
            (B.type !== 'float32' && B.type !== 'float64')) {
            return false;
        }
        return true;
    }
}
exports.InstanceNormalization = InstanceNormalization;


/***/ }),

/***/ "./lib/onnxjs/ops/leaky-relu.ts":
/*!**************************************!*\
  !*** ./lib/onnxjs/ops/leaky-relu.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LeakyRelu = void 0;
class LeakyRelu {
    initialize(attributes) {
        this.alpha = attributes.getFloat('alpha', 0.01);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.LeakyRelu = LeakyRelu;


/***/ }),

/***/ "./lib/onnxjs/ops/matmul.ts":
/*!**********************************!*\
  !*** ./lib/onnxjs/ops/matmul.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatMul = void 0;
class MatMul {
    initialize(attributes) {
        this.activation = attributes.getString('__internal_activation', '');
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        if (inputs[1].type !== 'float32' && inputs[1].type !== 'float64') {
            return false;
        }
        if (inputs[0].type !== inputs[1].type) {
            return false;
        }
        return true;
    }
}
exports.MatMul = MatMul;


/***/ }),

/***/ "./lib/onnxjs/ops/pad.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/ops/pad.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pad = void 0;
class Pad {
    initialize(attributes) {
        this.mode = attributes.getString('mode', 'constant');
        this.value = attributes.getFloat('value', 0.0);
        this.pads = attributes.getInts('pads');
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.Pad = Pad;


/***/ }),

/***/ "./lib/onnxjs/ops/pool.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/pool.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalMaxPool = exports.MaxPool = exports.GlobalAveragePool = exports.AveragePool = void 0;
class PoolBase {
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
class AveragePool extends PoolBase {
    initialize(attributes) {
        this.autoPad = attributes.getString('auto_pad', 'NOTSET');
        this.kernelShape = attributes.getInts('kernel_shape');
        this.strides = attributes.getInts('strides', []);
        this.pads = attributes.getInts('pads', []);
        this.countIncludePad = (attributes.getInt('count_include_pad', 0) === 0 ? false : true);
        this.ceilMode = attributes.getInt('ceil_mode', 0);
        // TODO: support attribute 'ceil_mode'
        if (this.ceilMode !== 0) {
            throw new Error('using ceil() in shape computation is not yet supported for AveragePool');
        }
    }
}
exports.AveragePool = AveragePool;
class GlobalAveragePool extends PoolBase {
    initialize(attributes) {
        this.countIncludePad = (attributes.getInt('count_include_pad', 0) === 0 ? false : true);
    }
}
exports.GlobalAveragePool = GlobalAveragePool;
class MaxPool extends PoolBase {
    initialize(attributes) {
        this.autoPad = attributes.getString('auto_pad', 'NOTSET');
        this.kernelShape = attributes.getInts('kernel_shape');
        this.strides = attributes.getInts('strides', []);
        this.pads = attributes.getInts('pads', []);
        this.ceilMode = attributes.getInt('ceil_mode', 0);
        this.storageOrder = attributes.getInt('storage_order', 0);
        // TODO: support attribute 'ceil_mode' and 'storage_order'
        if (this.storageOrder !== 0) {
            throw new Error('column major storage order is not yet supported for MaxPool');
        }
        if (this.ceilMode !== 0) {
            throw new Error('using ceil() in shape computation is not yet supported for MaxPool');
        }
    }
}
exports.MaxPool = MaxPool;
class GlobalMaxPool extends PoolBase {
    initialize(_attributes) { }
}
exports.GlobalMaxPool = GlobalMaxPool;


/***/ }),

/***/ "./lib/onnxjs/ops/reduce-op.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/reduce-op.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceBase = void 0;
const operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
class ReduceBase {
    initialize(attributes) {
        this.axes = attributes.getInts('axes', []);
        this.keepDims = attributes.getInt('keepdims', 1) === 1;
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        return true;
    }
}
exports.ReduceBase = ReduceBase;


/***/ }),

/***/ "./lib/onnxjs/ops/reshape.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/reshape.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reshape = void 0;
const operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
class Reshape {
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 2 || inputs[1].dims.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[1].type !== 'int32') {
            return false;
        }
        return true;
    }
}
exports.Reshape = Reshape;


/***/ }),

/***/ "./lib/onnxjs/ops/shape.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/ops/shape.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shape = void 0;
class Shape {
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return true;
    }
}
exports.Shape = Shape;


/***/ }),

/***/ "./lib/onnxjs/ops/slice.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/ops/slice.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SliceV10 = exports.Slice = void 0;
const operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
class Slice {
    initialize(attributes) {
        this.starts = attributes.getInts('starts');
        this.ends = attributes.getInts('ends');
        this.axes = attributes.getInts('axes', []);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        return true;
    }
}
exports.Slice = Slice;
class SliceV10 {
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length < 3 || inputs.length > 5) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[1].type !== 'int32' || inputs[1].dims.length !== 1) {
            return false;
        }
        if (inputs[2].type !== 'int32' || inputs[2].dims.length !== 1) {
            return false;
        }
        if (inputs.length >= 4 && (inputs[3].type !== 'int32' || inputs[3].dims.length !== 1)) {
            return false;
        }
        if (inputs.length >= 5 && (inputs[4].type !== 'int32' || inputs[4].dims.length !== 1)) {
            return false;
        }
        return true;
    }
}
exports.SliceV10 = SliceV10;


/***/ }),

/***/ "./lib/onnxjs/ops/softmax.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/softmax.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Softmax = void 0;
class Softmax {
    initialize(attributes) {
        this.axis = attributes.getInt('axis', 1);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.Softmax = Softmax;


/***/ }),

/***/ "./lib/onnxjs/ops/split.ts":
/*!*********************************!*\
  !*** ./lib/onnxjs/ops/split.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Split = void 0;
class Split {
    constructor(numOutputs) {
        this.numOutputs = numOutputs;
    }
    initialize(attributes) {
        this.axis = attributes.getInt('axis', 0);
        this.split = attributes.getInts('split', []);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'int8' && inputs[0].type !== 'uint8' && inputs[0].type !== 'int16' &&
            inputs[0].type !== 'uint16' && inputs[0].type !== 'int32' && inputs[0].type !== 'uint32' &&
            inputs[0].type !== 'float32' && inputs[0].type !== 'float64' && inputs[0].type !== 'bool') {
            return false;
        }
        return true;
    }
}
exports.Split = Split;


/***/ }),

/***/ "./lib/onnxjs/ops/squeeze.ts":
/*!***********************************!*\
  !*** ./lib/onnxjs/ops/squeeze.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Squeeze = void 0;
class Squeeze {
    initialize(attributes) {
        this.axes = attributes.getInts('axes');
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        // TODO: Support string type
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    }
}
exports.Squeeze = Squeeze;


/***/ }),

/***/ "./lib/onnxjs/ops/sum.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/ops/sum.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sum = void 0;
class Sum {
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length === 0) {
            return false;
        }
        const length = inputs[0].dims.length;
        for (let i = 1; i < inputs.length; i++) {
            if (length !== inputs[i].dims.length) {
                return false;
            }
            for (let j = 0; j < length; j++) {
                if (inputs[0].dims[j] !== inputs[i].dims[j]) {
                    return false;
                }
            }
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        for (let i = 1; i < inputs.length; i++) {
            if (inputs[0].type !== inputs[i].type) {
                return false;
            }
        }
        return true;
    }
}
exports.Sum = Sum;


/***/ }),

/***/ "./lib/onnxjs/ops/tile.ts":
/*!********************************!*\
  !*** ./lib/onnxjs/ops/tile.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tile = void 0;
const operators_1 = __webpack_require__(/*! ../operators */ "./lib/onnxjs/operators.ts");
class Tile {
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 2) {
            return false;
        }
        if (inputs[1].dims.length !== 1) {
            return false;
        }
        if (inputs[1].dims[0] !== inputs[0].dims.length) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (operators_1.NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
            return false;
        }
        if (inputs[1].type !== 'int32' && inputs[1].type !== 'int16') {
            return false;
        }
        return true;
    }
}
exports.Tile = Tile;


/***/ }),

/***/ "./lib/onnxjs/ops/transpose.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/transpose.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transpose = void 0;
class Transpose {
    initialize(attributes) {
        this.perm = attributes.getInts('perm', []);
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type !== 'float32' && inputs[0].type !== 'float64') {
            return false;
        }
        return true;
    }
}
exports.Transpose = Transpose;


/***/ }),

/***/ "./lib/onnxjs/ops/unary-op.ts":
/*!************************************!*\
  !*** ./lib/onnxjs/ops/unary-op.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnaryOp = void 0;
class UnaryOp {
    constructor(typeConstraint, resultType) {
        this.typeConstraint = typeConstraint;
        this.resultType = resultType;
    }
    initialize(_attributes) { }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (this.typeConstraint.indexOf(inputs[0].type) === -1) {
            return false;
        }
        return true;
    }
}
exports.UnaryOp = UnaryOp;


/***/ }),

/***/ "./lib/onnxjs/ops/unsqueeze.ts":
/*!*************************************!*\
  !*** ./lib/onnxjs/ops/unsqueeze.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unsqueeze = void 0;
class Unsqueeze {
    initialize(attributes) {
        this.axes = attributes.getInts('axes');
    }
    checkInputs(inputs) {
        if (!inputs || inputs.length !== 1) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        // TODO: Support string type
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    }
}
exports.Unsqueeze = Unsqueeze;


/***/ }),

/***/ "./lib/onnxjs/ops/upsample.ts":
/*!************************************!*\
  !*** ./lib/onnxjs/ops/upsample.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeOutputShape = exports.parseScalesDataFromOutputSize = exports.parseScalesData = exports.parseRoiData = exports.Upsample = void 0;
class Upsample {
    constructor(opset) {
        this.opset = opset;
    }
    initialize(attributes, _node, _graph) {
        this.isResize = (this.opset >= 10);
        // processing node attributes
        this.mode = attributes.getString('mode', 'nearest');
        if (this.mode !== 'nearest' && this.mode !== 'linear' && (this.opset < 11 || this.mode !== 'cubic')) {
            throw new Error(`unrecognized mode: ${this.mode}`);
        }
        if (this.opset < 9) {
            this.scales = attributes.getFloats('scales');
            scalesValidataion(this.scales, this.mode, this.isResize);
        }
        this.extrapolationValue = attributes.getFloat('extrapolation_value', 0.0);
        this.coordinateTransformMode =
            this.opset > 10 ? attributes.getString('coordinate_transformation_mode', 'half_pixel') : 'asymmetric';
        if ([
            'asymmetric', 'pytorch_half_pixel', 'tf_half_pixel_for_nn', 'align_corners', 'tf_crop_and_resize',
            'half_pixel'
        ].indexOf(this.coordinateTransformMode) === -1) {
            throw new Error(`coordinate_transform_mode '${this.coordinateTransformMode}' is not supported`);
        }
        this.useExtrapolation = this.needRoiInput = (this.coordinateTransformMode === 'tf_crop_and_resize');
        this.nearestMode =
            (this.mode === 'nearest' && this.opset >= 11) ? attributes.getString('nearest_mode', 'round_prefer_floor') : '';
        if (['round_prefer_floor', 'round_prefer_ceil', 'floor', 'ceil', ''].indexOf(this.nearestMode) === -1) {
            throw new Error(`nearest_mode '${this.nearestMode}' is not supported`);
        }
        this.cubicCoefficientA = attributes.getFloat('cubic_coeff_a', -0.75);
        this.excludeOutside = attributes.getInt('exclude_outside', 0) !== 0;
        if (this.excludeOutside && this.mode !== 'cubic') {
            throw new Error('exclude_outside can be set to 1 only when mode is CUBIC.');
        }
        this.useNearest2xOptimization = (this.opset < 11) ?
            true :
            (this.mode === 'nearest' && this.coordinateTransformMode === 'asymmetric' && this.nearestMode === 'floor');
        if (this.opset > 10) {
            this.roiInputIdx = 1;
            this.scalesInputIdx = 2;
            this.sizesInputIdx = 3;
        }
        else if (this.opset === 9) {
            this.scalesInputIdx = 1;
        }
    }
    checkInputs(inputs) {
        if (!inputs || (this.opset < 9 && inputs.length !== 1) ||
            (this.opset >= 9 && this.opset < 11 && inputs.length !== 2) ||
            (this.opset >= 11 && inputs.length !== 3 && inputs.length !== 4)) {
            return false;
        }
        if (this.scales && inputs[0].dims.length !== this.scales.length) {
            return false;
        }
        return this.checkInputTypes(inputs);
    }
    checkInputTypes(inputs) {
        if (inputs[0].type === 'string') {
            return false;
        }
        return true;
    }
    prepareInputs(inputs) {
        const x = inputs[0];
        const xDims = x.dims;
        // get roi data
        let roi = this.roi;
        if (!roi) {
            if (this.needRoiInput) {
                if (this.roiInputIdx <= 0) {
                    throw new Error('Invalid roi input index.');
                }
                roi = parseRoiData(inputs[this.roiInputIdx]);
            }
            else {
                roi = new Array(xDims.length * 2).fill(0);
            }
        }
        let scales = this.scales;
        let outputSizes;
        if (!scales) {
            const scalesTensor = inputs[this.scalesInputIdx];
            if (scalesTensor && scalesTensor.size !== 0) {
                if (inputs[this.sizesInputIdx]) {
                    throw new Error('Only one of scales or sizes must be provided as input.');
                }
                scales = parseScalesData(scalesTensor, this.mode, this.isResize);
            }
            else {
                const sizesTensor = inputs[this.sizesInputIdx];
                if (!sizesTensor || sizesTensor.size === 0) {
                    throw new Error('Either scales or sizes MUST be provided as input.');
                }
                outputSizes = Array.from(sizesTensor.integerData);
                scales = parseScalesDataFromOutputSize(outputSizes, xDims, this.mode, this.isResize);
            }
        }
        else {
            if (inputs[this.sizesInputIdx]) {
                throw new Error('Only one of scales or sizes must be provided as input.');
            }
        }
        const yDims = outputSizes || computeOutputShape(scales, xDims);
        return [roi, scales, yDims];
    }
}
exports.Upsample = Upsample;
function scalesValidataion(scales, mode, isResize) {
    if (!isResize) {
        for (const scale of scales) {
            if (scale < 1) {
                throw new Error('Scale value should be greater than or equal to 1.');
            }
        }
    }
    else {
        for (const scale of scales) {
            if (scale <= 0) {
                throw new Error('Scale value should be greater than 0.');
            }
        }
    }
    if (mode === 'linear' || mode === 'cubic') {
        if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {
            throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic') or 4-D inputs\
with the corresponding outermost 2 scale values being 1 in the ${isResize ? 'Resize' : 'Upsample'} opeartor.`);
        }
    }
}
function parseRoiData(roi) {
    return roi.size > 0 ? Array.from(roi.floatData) : [];
}
exports.parseRoiData = parseRoiData;
function parseScalesData(scale, mode, isResize) {
    const scales = Array.from(scale.floatData);
    scalesValidataion(scales, mode, isResize);
    return scales;
}
exports.parseScalesData = parseScalesData;
function parseScalesDataFromOutputSize(yDims, xDims, mode, isResize) {
    const length = xDims.length;
    const scales = new Array(length);
    for (let i = 0, end = length; i < end; i++) {
        if (xDims[i] === 0) {
            if (yDims[i] !== 0) {
                throw new Error('Input dim is zero but required output dim is non-zero.');
            }
            scales[i] = 1;
        }
        else {
            scales[i] = yDims[i] / xDims[i];
        }
    }
    scalesValidataion(scales, mode, isResize);
    return scales;
}
exports.parseScalesDataFromOutputSize = parseScalesDataFromOutputSize;
function computeOutputShape(scales, inputDims) {
    return inputDims.map((dim, i) => Math.floor(dim * scales[i]));
}
exports.computeOutputShape = computeOutputShape;


/***/ }),

/***/ "./lib/onnxjs/opset.ts":
/*!*****************************!*\
  !*** ./lib/onnxjs/opset.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveOperator = void 0;
function resolveOperator(node, opsets, rules) {
    for (const rule of rules) {
        const opType = rule[0];
        const domain = rule[1];
        const versionSelector = rule[2];
        const opConstructor = rule[3];
        if (node.opType === opType) { // operator type matches
            for (const opset of opsets) {
                // opset '' and 'ai.onnx' are considered the same.
                if (opset.domain === domain || (opset.domain === 'ai.onnx' && domain === '')) { // opset domain found
                    if (matchSelector(opset.version, versionSelector)) {
                        return opConstructor(node);
                    }
                }
            }
        }
    }
    throw new TypeError(`cannot resolve operator '${node.opType}' with opsets: ${opsets.map(set => `${set.domain || 'ai.onnx'} v${set.version}`).join(', ')}`);
}
exports.resolveOperator = resolveOperator;
function matchSelector(version, selector) {
    if (selector.endsWith('+')) {
        // minimum version match ('7+' expects version>=7)
        const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);
        return !isNaN(rangeStart) && rangeStart <= version;
    }
    else if (selector.split('-').length === 2) {
        // range match ('6-8' expects 6<=version<=8)
        const pair = selector.split('-');
        const rangeStart = Number.parseInt(pair[0], 10);
        const rangeEnd = Number.parseInt(pair[1], 10);
        return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version && version <= rangeEnd;
    }
    else {
        // exact match ('7' expects version===7)
        return Number.parseInt(selector, 10) === version;
    }
}


/***/ }),

/***/ "./lib/onnxjs/ort-schema/ort-generated.ts":
/*!************************************************!*\
  !*** ./lib/onnxjs/ort-schema/ort-generated.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.onnxruntime = void 0;
const flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/js/flatbuffers.mjs");
/**
 * @enum {number}
 */
var onnxruntime;
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            let AttributeType;
            (function (AttributeType) {
                AttributeType[AttributeType["UNDEFINED"] = 0] = "UNDEFINED";
                AttributeType[AttributeType["FLOAT"] = 1] = "FLOAT";
                AttributeType[AttributeType["INT"] = 2] = "INT";
                AttributeType[AttributeType["STRING"] = 3] = "STRING";
                AttributeType[AttributeType["TENSOR"] = 4] = "TENSOR";
                AttributeType[AttributeType["GRAPH"] = 5] = "GRAPH";
                AttributeType[AttributeType["FLOATS"] = 6] = "FLOATS";
                AttributeType[AttributeType["INTS"] = 7] = "INTS";
                AttributeType[AttributeType["STRINGS"] = 8] = "STRINGS";
                AttributeType[AttributeType["TENSORS"] = 9] = "TENSORS";
                AttributeType[AttributeType["GRAPHS"] = 10] = "GRAPHS";
                AttributeType[AttributeType["SPARSE_TENSOR"] = 11] = "SPARSE_TENSOR";
                AttributeType[AttributeType["SPARSE_TENSORS"] = 12] = "SPARSE_TENSORS";
            })(AttributeType = fbs.AttributeType || (fbs.AttributeType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            let DimensionValueType;
            (function (DimensionValueType) {
                DimensionValueType[DimensionValueType["UNKNOWN"] = 0] = "UNKNOWN";
                DimensionValueType[DimensionValueType["VALUE"] = 1] = "VALUE";
                DimensionValueType[DimensionValueType["PARAM"] = 2] = "PARAM";
            })(DimensionValueType = fbs.DimensionValueType || (fbs.DimensionValueType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            let TensorDataType;
            (function (TensorDataType) {
                TensorDataType[TensorDataType["UNDEFINED"] = 0] = "UNDEFINED";
                TensorDataType[TensorDataType["FLOAT"] = 1] = "FLOAT";
                TensorDataType[TensorDataType["UINT8"] = 2] = "UINT8";
                TensorDataType[TensorDataType["INT8"] = 3] = "INT8";
                TensorDataType[TensorDataType["UINT16"] = 4] = "UINT16";
                TensorDataType[TensorDataType["INT16"] = 5] = "INT16";
                TensorDataType[TensorDataType["INT32"] = 6] = "INT32";
                TensorDataType[TensorDataType["INT64"] = 7] = "INT64";
                TensorDataType[TensorDataType["STRING"] = 8] = "STRING";
                TensorDataType[TensorDataType["BOOL"] = 9] = "BOOL";
                TensorDataType[TensorDataType["FLOAT16"] = 10] = "FLOAT16";
                TensorDataType[TensorDataType["DOUBLE"] = 11] = "DOUBLE";
                TensorDataType[TensorDataType["UINT32"] = 12] = "UINT32";
                TensorDataType[TensorDataType["UINT64"] = 13] = "UINT64";
                TensorDataType[TensorDataType["COMPLEX64"] = 14] = "COMPLEX64";
                TensorDataType[TensorDataType["COMPLEX128"] = 15] = "COMPLEX128";
                TensorDataType[TensorDataType["BFLOAT16"] = 16] = "BFLOAT16";
            })(TensorDataType = fbs.TensorDataType || (fbs.TensorDataType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            let NodeType;
            (function (NodeType) {
                NodeType[NodeType["Primitive"] = 0] = "Primitive";
                NodeType[NodeType["Fused"] = 1] = "Fused";
            })(NodeType = fbs.NodeType || (fbs.NodeType = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @enum {number}
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            let TypeInfoValue;
            (function (TypeInfoValue) {
                TypeInfoValue[TypeInfoValue["NONE"] = 0] = "NONE";
                TypeInfoValue[TypeInfoValue["tensor_type"] = 1] = "tensor_type";
                TypeInfoValue[TypeInfoValue["sequence_type"] = 2] = "sequence_type";
                TypeInfoValue[TypeInfoValue["map_type"] = 3] = "map_type";
            })(TypeInfoValue = fbs.TypeInfoValue || (fbs.TypeInfoValue = {}));
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Shape {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Shape
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Shape= obj
                 * @returns Shape
                 */
                static getRootAsShape(bb, obj) {
                    return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Shape= obj
                 * @returns Shape
                 */
                static getSizePrefixedRootAsShape(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Dimension= obj
                 * @returns onnxruntime.experimental.fbs.Dimension
                 */
                dim(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Dimension())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                dimLength() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startShape(builder) {
                    builder.startObject(1);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimOffset
                 */
                static addDim(builder, dimOffset) {
                    builder.addFieldOffset(0, dimOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createDimVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startDimVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endShape(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createShape(builder, dimOffset) {
                    Shape.startShape(builder);
                    Shape.addDim(builder, dimOffset);
                    return Shape.endShape(builder);
                }
            }
            fbs.Shape = Shape;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Dimension {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Dimension
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Dimension= obj
                 * @returns Dimension
                 */
                static getRootAsDimension(bb, obj) {
                    return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Dimension= obj
                 * @returns Dimension
                 */
                static getSizePrefixedRootAsDimension(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param onnxruntime.experimental.fbs.DimensionValue= obj
                 * @returns onnxruntime.experimental.fbs.DimensionValue|null
                 */
                value(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.DimensionValue())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                denotation(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startDimension(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valueOffset
                 */
                static addValue(builder, valueOffset) {
                    builder.addFieldOffset(0, valueOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset denotationOffset
                 */
                static addDenotation(builder, denotationOffset) {
                    builder.addFieldOffset(1, denotationOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endDimension(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createDimension(builder, valueOffset, denotationOffset) {
                    Dimension.startDimension(builder);
                    Dimension.addValue(builder, valueOffset);
                    Dimension.addDenotation(builder, denotationOffset);
                    return Dimension.endDimension(builder);
                }
            }
            fbs.Dimension = Dimension;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class DimensionValue {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns DimensionValue
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param DimensionValue= obj
                 * @returns DimensionValue
                 */
                static getRootAsDimensionValue(bb, obj) {
                    return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param DimensionValue= obj
                 * @returns DimensionValue
                 */
                static getSizePrefixedRootAsDimensionValue(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @returns onnxruntime.experimental.fbs.DimensionValueType
                 */
                dimType() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? /**  */ (this.bb.readInt8(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN;
                }
                /**
                 * @returns flatbuffers.Long
                 */
                dimValue() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                }
                dimParam(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startDimensionValue(builder) {
                    builder.startObject(3);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.DimensionValueType dimType
                 */
                static addDimType(builder, dimType) {
                    builder.addFieldInt8(0, dimType, onnxruntime.experimental.fbs.DimensionValueType.UNKNOWN);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long dimValue
                 */
                static addDimValue(builder, dimValue) {
                    builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimParamOffset
                 */
                static addDimParam(builder, dimParamOffset) {
                    builder.addFieldOffset(2, dimParamOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endDimensionValue(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createDimensionValue(builder, dimType, dimValue, dimParamOffset) {
                    DimensionValue.startDimensionValue(builder);
                    DimensionValue.addDimType(builder, dimType);
                    DimensionValue.addDimValue(builder, dimValue);
                    DimensionValue.addDimParam(builder, dimParamOffset);
                    return DimensionValue.endDimensionValue(builder);
                }
            }
            fbs.DimensionValue = DimensionValue;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class TensorTypeAndShape {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns TensorTypeAndShape
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TensorTypeAndShape= obj
                 * @returns TensorTypeAndShape
                 */
                static getRootAsTensorTypeAndShape(bb, obj) {
                    return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TensorTypeAndShape= obj
                 * @returns TensorTypeAndShape
                 */
                static getSizePrefixedRootAsTensorTypeAndShape(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @returns onnxruntime.experimental.fbs.TensorDataType
                 */
                elemType() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;
                }
                /**
                 * @param onnxruntime.experimental.fbs.Shape= obj
                 * @returns onnxruntime.experimental.fbs.Shape|null
                 */
                shape(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Shape())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startTensorTypeAndShape(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TensorDataType elemType
                 */
                static addElemType(builder, elemType) {
                    builder.addFieldInt32(0, elemType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset shapeOffset
                 */
                static addShape(builder, shapeOffset) {
                    builder.addFieldOffset(1, shapeOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endTensorTypeAndShape(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createTensorTypeAndShape(builder, elemType, shapeOffset) {
                    TensorTypeAndShape.startTensorTypeAndShape(builder);
                    TensorTypeAndShape.addElemType(builder, elemType);
                    TensorTypeAndShape.addShape(builder, shapeOffset);
                    return TensorTypeAndShape.endTensorTypeAndShape(builder);
                }
            }
            fbs.TensorTypeAndShape = TensorTypeAndShape;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class MapType {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns MapType
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param MapType= obj
                 * @returns MapType
                 */
                static getRootAsMapType(bb, obj) {
                    return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param MapType= obj
                 * @returns MapType
                 */
                static getSizePrefixedRootAsMapType(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @returns onnxruntime.experimental.fbs.TensorDataType
                 */
                keyType() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;
                }
                /**
                 * @param onnxruntime.experimental.fbs.TypeInfo= obj
                 * @returns onnxruntime.experimental.fbs.TypeInfo|null
                 */
                valueType(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startMapType(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TensorDataType keyType
                 */
                static addKeyType(builder, keyType) {
                    builder.addFieldInt32(0, keyType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valueTypeOffset
                 */
                static addValueType(builder, valueTypeOffset) {
                    builder.addFieldOffset(1, valueTypeOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endMapType(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createMapType(builder, keyType, valueTypeOffset) {
                    MapType.startMapType(builder);
                    MapType.addKeyType(builder, keyType);
                    MapType.addValueType(builder, valueTypeOffset);
                    return MapType.endMapType(builder);
                }
            }
            fbs.MapType = MapType;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class SequenceType {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SequenceType
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SequenceType= obj
                 * @returns SequenceType
                 */
                static getRootAsSequenceType(bb, obj) {
                    return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SequenceType= obj
                 * @returns SequenceType
                 */
                static getSizePrefixedRootAsSequenceType(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param onnxruntime.experimental.fbs.TypeInfo= obj
                 * @returns onnxruntime.experimental.fbs.TypeInfo|null
                 */
                elemType(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startSequenceType(builder) {
                    builder.startObject(1);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset elemTypeOffset
                 */
                static addElemType(builder, elemTypeOffset) {
                    builder.addFieldOffset(0, elemTypeOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endSequenceType(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createSequenceType(builder, elemTypeOffset) {
                    SequenceType.startSequenceType(builder);
                    SequenceType.addElemType(builder, elemTypeOffset);
                    return SequenceType.endSequenceType(builder);
                }
            }
            fbs.SequenceType = SequenceType;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class EdgeEnd {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns EdgeEnd
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @returns number
                 */
                nodeIndex() {
                    return this.bb.readUint32(this.bb_pos);
                }
                /**
                 * @returns number
                 */
                srcArgIndex() {
                    return this.bb.readInt32(this.bb_pos + 4);
                }
                /**
                 * @returns number
                 */
                dstArgIndex() {
                    return this.bb.readInt32(this.bb_pos + 8);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number node_index
                 * @param number src_arg_index
                 * @param number dst_arg_index
                 * @returns flatbuffers.Offset
                 */
                static createEdgeEnd(builder, node_index, src_arg_index, dst_arg_index) {
                    builder.prep(4, 12);
                    builder.writeInt32(dst_arg_index);
                    builder.writeInt32(src_arg_index);
                    builder.writeInt32(node_index);
                    return builder.offset();
                }
            }
            fbs.EdgeEnd = EdgeEnd;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class NodeEdge {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns NodeEdge
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param NodeEdge= obj
                 * @returns NodeEdge
                 */
                static getRootAsNodeEdge(bb, obj) {
                    return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param NodeEdge= obj
                 * @returns NodeEdge
                 */
                static getSizePrefixedRootAsNodeEdge(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @returns number
                 */
                nodeIndex() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.EdgeEnd= obj
                 * @returns onnxruntime.experimental.fbs.EdgeEnd
                 */
                inputEdges(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())
                        .__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                inputEdgesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.EdgeEnd= obj
                 * @returns onnxruntime.experimental.fbs.EdgeEnd
                 */
                outputEdges(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.EdgeEnd())
                        .__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                outputEdgesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startNodeEdge(builder) {
                    builder.startObject(3);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number nodeIndex
                 */
                static addNodeIndex(builder, nodeIndex) {
                    builder.addFieldInt32(0, nodeIndex, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputEdgesOffset
                 */
                static addInputEdges(builder, inputEdgesOffset) {
                    builder.addFieldOffset(1, inputEdgesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startInputEdgesVector(builder, numElems) {
                    builder.startVector(12, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset outputEdgesOffset
                 */
                static addOutputEdges(builder, outputEdgesOffset) {
                    builder.addFieldOffset(2, outputEdgesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startOutputEdgesVector(builder, numElems) {
                    builder.startVector(12, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endNodeEdge(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createNodeEdge(builder, nodeIndex, inputEdgesOffset, outputEdgesOffset) {
                    NodeEdge.startNodeEdge(builder);
                    NodeEdge.addNodeIndex(builder, nodeIndex);
                    NodeEdge.addInputEdges(builder, inputEdgesOffset);
                    NodeEdge.addOutputEdges(builder, outputEdgesOffset);
                    return NodeEdge.endNodeEdge(builder);
                }
            }
            fbs.NodeEdge = NodeEdge;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Node {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Node
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Node= obj
                 * @returns Node
                 */
                static getRootAsNode(bb, obj) {
                    return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Node= obj
                 * @returns Node
                 */
                static getSizePrefixedRootAsNode(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Node()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                name(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                docString(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                domain(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                sinceVersion() {
                    let offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns number
                 */
                index() {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
                }
                opType(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @returns onnxruntime.experimental.fbs.NodeType
                 */
                type() {
                    let offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.NodeType.Primitive;
                }
                executionProviderType(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                inputs(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                inputsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                outputs(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                outputsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Attribute= obj
                 * @returns onnxruntime.experimental.fbs.Attribute
                 */
                attributes(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Attribute())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                attributesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @returns number
                 */
                inputArgCounts(index) {
                    let offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
                }
                /**
                 * @returns number
                 */
                inputArgCountsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns Int32Array
                 */
                inputArgCountsArray() {
                    let offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ?
                        new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                }
                implicitInputs(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                implicitInputsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startNode(builder) {
                    builder.startObject(13);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                static addName(builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                static addDocString(builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset domainOffset
                 */
                static addDomain(builder, domainOffset) {
                    builder.addFieldOffset(2, domainOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number sinceVersion
                 */
                static addSinceVersion(builder, sinceVersion) {
                    builder.addFieldInt32(3, sinceVersion, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number index
                 */
                static addIndex(builder, index) {
                    builder.addFieldInt32(4, index, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset opTypeOffset
                 */
                static addOpType(builder, opTypeOffset) {
                    builder.addFieldOffset(5, opTypeOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.NodeType type
                 */
                static addType(builder, type) {
                    builder.addFieldInt32(6, type, onnxruntime.experimental.fbs.NodeType.Primitive);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset executionProviderTypeOffset
                 */
                static addExecutionProviderType(builder, executionProviderTypeOffset) {
                    builder.addFieldOffset(7, executionProviderTypeOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputsOffset
                 */
                static addInputs(builder, inputsOffset) {
                    builder.addFieldOffset(8, inputsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createInputsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startInputsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset outputsOffset
                 */
                static addOutputs(builder, outputsOffset) {
                    builder.addFieldOffset(9, outputsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createOutputsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startOutputsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset attributesOffset
                 */
                static addAttributes(builder, attributesOffset) {
                    builder.addFieldOffset(10, attributesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createAttributesVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startAttributesVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputArgCountsOffset
                 */
                static addInputArgCounts(builder, inputArgCountsOffset) {
                    builder.addFieldOffset(11, inputArgCountsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                static createInputArgCountsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt32(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startInputArgCountsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset implicitInputsOffset
                 */
                static addImplicitInputs(builder, implicitInputsOffset) {
                    builder.addFieldOffset(12, implicitInputsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createImplicitInputsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startImplicitInputsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endNode(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createNode(builder, nameOffset, docStringOffset, domainOffset, sinceVersion, index, opTypeOffset, type, executionProviderTypeOffset, inputsOffset, outputsOffset, attributesOffset, inputArgCountsOffset, implicitInputsOffset) {
                    Node.startNode(builder);
                    Node.addName(builder, nameOffset);
                    Node.addDocString(builder, docStringOffset);
                    Node.addDomain(builder, domainOffset);
                    Node.addSinceVersion(builder, sinceVersion);
                    Node.addIndex(builder, index);
                    Node.addOpType(builder, opTypeOffset);
                    Node.addType(builder, type);
                    Node.addExecutionProviderType(builder, executionProviderTypeOffset);
                    Node.addInputs(builder, inputsOffset);
                    Node.addOutputs(builder, outputsOffset);
                    Node.addAttributes(builder, attributesOffset);
                    Node.addInputArgCounts(builder, inputArgCountsOffset);
                    Node.addImplicitInputs(builder, implicitInputsOffset);
                    return Node.endNode(builder);
                }
            }
            fbs.Node = Node;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class ValueInfo {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns ValueInfo
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param ValueInfo= obj
                 * @returns ValueInfo
                 */
                static getRootAsValueInfo(bb, obj) {
                    return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param ValueInfo= obj
                 * @returns ValueInfo
                 */
                static getSizePrefixedRootAsValueInfo(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                name(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                docString(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.TypeInfo= obj
                 * @returns onnxruntime.experimental.fbs.TypeInfo|null
                 */
                type(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.TypeInfo())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startValueInfo(builder) {
                    builder.startObject(3);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                static addName(builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                static addDocString(builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset typeOffset
                 */
                static addType(builder, typeOffset) {
                    builder.addFieldOffset(2, typeOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endValueInfo(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createValueInfo(builder, nameOffset, docStringOffset, typeOffset) {
                    ValueInfo.startValueInfo(builder);
                    ValueInfo.addName(builder, nameOffset);
                    ValueInfo.addDocString(builder, docStringOffset);
                    ValueInfo.addType(builder, typeOffset);
                    return ValueInfo.endValueInfo(builder);
                }
            }
            fbs.ValueInfo = ValueInfo;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class TypeInfo {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns TypeInfo
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TypeInfo= obj
                 * @returns TypeInfo
                 */
                static getRootAsTypeInfo(bb, obj) {
                    return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param TypeInfo= obj
                 * @returns TypeInfo
                 */
                static getSizePrefixedRootAsTypeInfo(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                denotation(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @returns onnxruntime.experimental.fbs.TypeInfoValue
                 */
                valueType() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? /**  */ (this.bb.readUint8(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TypeInfoValue.NONE;
                }
                /**
                 * @param flatbuffers.Table obj
                 * @returns ?flatbuffers.Table
                 */
                value(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startTypeInfo(builder) {
                    builder.startObject(3);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset denotationOffset
                 */
                static addDenotation(builder, denotationOffset) {
                    builder.addFieldOffset(0, denotationOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TypeInfoValue valueType
                 */
                static addValueType(builder, valueType) {
                    builder.addFieldInt8(1, valueType, onnxruntime.experimental.fbs.TypeInfoValue.NONE);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valueOffset
                 */
                static addValue(builder, valueOffset) {
                    builder.addFieldOffset(2, valueOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endTypeInfo(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createTypeInfo(builder, denotationOffset, valueType, valueOffset) {
                    TypeInfo.startTypeInfo(builder);
                    TypeInfo.addDenotation(builder, denotationOffset);
                    TypeInfo.addValueType(builder, valueType);
                    TypeInfo.addValue(builder, valueOffset);
                    return TypeInfo.endTypeInfo(builder);
                }
            }
            fbs.TypeInfo = TypeInfo;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class OperatorSetId {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns OperatorSetId
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param OperatorSetId= obj
                 * @returns OperatorSetId
                 */
                static getRootAsOperatorSetId(bb, obj) {
                    return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param OperatorSetId= obj
                 * @returns OperatorSetId
                 */
                static getSizePrefixedRootAsOperatorSetId(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                domain(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @returns flatbuffers.Long
                 */
                version() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startOperatorSetId(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset domainOffset
                 */
                static addDomain(builder, domainOffset) {
                    builder.addFieldOffset(0, domainOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long version
                 */
                static addVersion(builder, version) {
                    builder.addFieldInt64(1, version, builder.createLong(0, 0));
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endOperatorSetId(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createOperatorSetId(builder, domainOffset, version) {
                    OperatorSetId.startOperatorSetId(builder);
                    OperatorSetId.addDomain(builder, domainOffset);
                    OperatorSetId.addVersion(builder, version);
                    return OperatorSetId.endOperatorSetId(builder);
                }
            }
            fbs.OperatorSetId = OperatorSetId;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Tensor {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Tensor
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Tensor= obj
                 * @returns Tensor
                 */
                static getRootAsTensor(bb, obj) {
                    return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Tensor= obj
                 * @returns Tensor
                 */
                static getSizePrefixedRootAsTensor(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                name(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                docString(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                dims(index) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                }
                /**
                 * @returns number
                 */
                dimsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns onnxruntime.experimental.fbs.TensorDataType
                 */
                dataType() {
                    let offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.TensorDataType.UNDEFINED;
                }
                /**
                 * @param number index
                 * @returns number
                 */
                rawData(index) {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
                }
                /**
                 * @returns number
                 */
                rawDataLength() {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns Uint8Array
                 */
                rawDataArray() {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ?
                        new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                }
                stringData(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                stringDataLength() {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startTensor(builder) {
                    builder.startObject(6);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                static addName(builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                static addDocString(builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimsOffset
                 */
                static addDims(builder, dimsOffset) {
                    builder.addFieldOffset(2, dimsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                static createDimsVector(builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startDimsVector(builder, numElems) {
                    builder.startVector(8, numElems, 8);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.TensorDataType dataType
                 */
                static addDataType(builder, dataType) {
                    builder.addFieldInt32(3, dataType, onnxruntime.experimental.fbs.TensorDataType.UNDEFINED);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset rawDataOffset
                 */
                static addRawData(builder, rawDataOffset) {
                    builder.addFieldOffset(4, rawDataOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                static createRawDataVector(builder, data) {
                    builder.startVector(1, data.length, 1);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt8(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startRawDataVector(builder, numElems) {
                    builder.startVector(1, numElems, 1);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset stringDataOffset
                 */
                static addStringData(builder, stringDataOffset) {
                    builder.addFieldOffset(5, stringDataOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createStringDataVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startStringDataVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endTensor(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createTensor(builder, nameOffset, docStringOffset, dimsOffset, dataType, rawDataOffset, stringDataOffset) {
                    Tensor.startTensor(builder);
                    Tensor.addName(builder, nameOffset);
                    Tensor.addDocString(builder, docStringOffset);
                    Tensor.addDims(builder, dimsOffset);
                    Tensor.addDataType(builder, dataType);
                    Tensor.addRawData(builder, rawDataOffset);
                    Tensor.addStringData(builder, stringDataOffset);
                    return Tensor.endTensor(builder);
                }
            }
            fbs.Tensor = Tensor;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class SparseTensor {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SparseTensor
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SparseTensor= obj
                 * @returns SparseTensor
                 */
                static getRootAsSparseTensor(bb, obj) {
                    return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SparseTensor= obj
                 * @returns SparseTensor
                 */
                static getSizePrefixedRootAsSparseTensor(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor|null
                 */
                values(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor|null
                 */
                indices(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                dims(index) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                }
                /**
                 * @returns number
                 */
                dimsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startSparseTensor(builder) {
                    builder.startObject(3);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset valuesOffset
                 */
                static addValues(builder, valuesOffset) {
                    builder.addFieldOffset(0, valuesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset indicesOffset
                 */
                static addIndices(builder, indicesOffset) {
                    builder.addFieldOffset(1, indicesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset dimsOffset
                 */
                static addDims(builder, dimsOffset) {
                    builder.addFieldOffset(2, dimsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                static createDimsVector(builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startDimsVector(builder, numElems) {
                    builder.startVector(8, numElems, 8);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endSparseTensor(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createSparseTensor(builder, valuesOffset, indicesOffset, dimsOffset) {
                    SparseTensor.startSparseTensor(builder);
                    SparseTensor.addValues(builder, valuesOffset);
                    SparseTensor.addIndices(builder, indicesOffset);
                    SparseTensor.addDims(builder, dimsOffset);
                    return SparseTensor.endSparseTensor(builder);
                }
            }
            fbs.SparseTensor = SparseTensor;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Attribute {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Attribute
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Attribute= obj
                 * @returns Attribute
                 */
                static getRootAsAttribute(bb, obj) {
                    return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Attribute= obj
                 * @returns Attribute
                 */
                static getSizePrefixedRootAsAttribute(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Attribute()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                name(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                docString(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @returns onnxruntime.experimental.fbs.AttributeType
                 */
                type() {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? /**  */ (this.bb.readInt32(this.bb_pos + offset)) :
                        onnxruntime.experimental.fbs.AttributeType.UNDEFINED;
                }
                /**
                 * @returns number
                 */
                f() {
                    let offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
                }
                /**
                 * @returns flatbuffers.Long
                 */
                i() {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                }
                s(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor|null
                 */
                t(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.Graph= obj
                 * @returns onnxruntime.experimental.fbs.Graph|null
                 */
                g(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Graph())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param number index
                 * @returns number
                 */
                floats(index) {
                    let offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
                }
                /**
                 * @returns number
                 */
                floatsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns Float32Array
                 */
                floatsArray() {
                    let offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ?
                        new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                }
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                ints(index) {
                    let offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                }
                /**
                 * @returns number
                 */
                intsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 22);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                strings(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                stringsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 24);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor
                 */
                tensors(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                tensorsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 26);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Graph= obj
                 * @returns onnxruntime.experimental.fbs.Graph
                 */
                graphs(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Graph())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                graphsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 28);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startAttribute(builder) {
                    builder.startObject(13);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nameOffset
                 */
                static addName(builder, nameOffset) {
                    builder.addFieldOffset(0, nameOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                static addDocString(builder, docStringOffset) {
                    builder.addFieldOffset(1, docStringOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param onnxruntime.experimental.fbs.AttributeType type
                 */
                static addType(builder, type) {
                    builder.addFieldInt32(2, type, onnxruntime.experimental.fbs.AttributeType.UNDEFINED);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number f
                 */
                static addF(builder, f) {
                    builder.addFieldFloat32(3, f, 0.0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long i
                 */
                static addI(builder, i) {
                    builder.addFieldInt64(4, i, builder.createLong(0, 0));
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sOffset
                 */
                static addS(builder, sOffset) {
                    builder.addFieldOffset(5, sOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset tOffset
                 */
                static addT(builder, tOffset) {
                    builder.addFieldOffset(6, tOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset gOffset
                 */
                static addG(builder, gOffset) {
                    builder.addFieldOffset(7, gOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset floatsOffset
                 */
                static addFloats(builder, floatsOffset) {
                    builder.addFieldOffset(8, floatsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                static createFloatsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addFloat32(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startFloatsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset intsOffset
                 */
                static addInts(builder, intsOffset) {
                    builder.addFieldOffset(9, intsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                static createIntsVector(builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startIntsVector(builder, numElems) {
                    builder.startVector(8, numElems, 8);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset stringsOffset
                 */
                static addStrings(builder, stringsOffset) {
                    builder.addFieldOffset(10, stringsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createStringsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startStringsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset tensorsOffset
                 */
                static addTensors(builder, tensorsOffset) {
                    builder.addFieldOffset(11, tensorsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createTensorsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startTensorsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphsOffset
                 */
                static addGraphs(builder, graphsOffset) {
                    builder.addFieldOffset(12, graphsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createGraphsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startGraphsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endAttribute(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createAttribute(builder, nameOffset, docStringOffset, type, f, i, sOffset, tOffset, gOffset, floatsOffset, intsOffset, stringsOffset, tensorsOffset, graphsOffset) {
                    Attribute.startAttribute(builder);
                    Attribute.addName(builder, nameOffset);
                    Attribute.addDocString(builder, docStringOffset);
                    Attribute.addType(builder, type);
                    Attribute.addF(builder, f);
                    Attribute.addI(builder, i);
                    Attribute.addS(builder, sOffset);
                    Attribute.addT(builder, tOffset);
                    Attribute.addG(builder, gOffset);
                    Attribute.addFloats(builder, floatsOffset);
                    Attribute.addInts(builder, intsOffset);
                    Attribute.addStrings(builder, stringsOffset);
                    Attribute.addTensors(builder, tensorsOffset);
                    Attribute.addGraphs(builder, graphsOffset);
                    return Attribute.endAttribute(builder);
                }
            }
            fbs.Attribute = Attribute;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Graph {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Graph
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Graph= obj
                 * @returns Graph
                 */
                static getRootAsGraph(bb, obj) {
                    return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Graph= obj
                 * @returns Graph
                 */
                static getSizePrefixedRootAsGraph(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Graph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Tensor= obj
                 * @returns onnxruntime.experimental.fbs.Tensor
                 */
                initializers(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Tensor())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                initializersLength() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.ValueInfo= obj
                 * @returns onnxruntime.experimental.fbs.ValueInfo
                 */
                nodeArgs(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.ValueInfo())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                nodeArgsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.Node= obj
                 * @returns onnxruntime.experimental.fbs.Node
                 */
                nodes(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Node())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                nodesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns number
                 */
                maxNodeIndex() {
                    let offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.NodeEdge= obj
                 * @returns onnxruntime.experimental.fbs.NodeEdge
                 */
                nodeEdges(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? (obj || new onnxruntime.experimental.fbs.NodeEdge())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                nodeEdgesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                inputs(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                inputsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                outputs(index, optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
                }
                /**
                 * @returns number
                 */
                outputsLength() {
                    let offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.SparseTensor= obj
                 * @returns onnxruntime.experimental.fbs.SparseTensor
                 */
                sparseInitializers(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SparseTensor())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                sparseInitializersLength() {
                    let offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startGraph(builder) {
                    builder.startObject(8);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset initializersOffset
                 */
                static addInitializers(builder, initializersOffset) {
                    builder.addFieldOffset(0, initializersOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createInitializersVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startInitializersVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodeArgsOffset
                 */
                static addNodeArgs(builder, nodeArgsOffset) {
                    builder.addFieldOffset(1, nodeArgsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createNodeArgsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startNodeArgsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodesOffset
                 */
                static addNodes(builder, nodesOffset) {
                    builder.addFieldOffset(2, nodesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createNodesVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startNodesVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number maxNodeIndex
                 */
                static addMaxNodeIndex(builder, maxNodeIndex) {
                    builder.addFieldInt32(3, maxNodeIndex, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodeEdgesOffset
                 */
                static addNodeEdges(builder, nodeEdgesOffset) {
                    builder.addFieldOffset(4, nodeEdgesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createNodeEdgesVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startNodeEdgesVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset inputsOffset
                 */
                static addInputs(builder, inputsOffset) {
                    builder.addFieldOffset(5, inputsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createInputsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startInputsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset outputsOffset
                 */
                static addOutputs(builder, outputsOffset) {
                    builder.addFieldOffset(6, outputsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createOutputsVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startOutputsVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sparseInitializersOffset
                 */
                static addSparseInitializers(builder, sparseInitializersOffset) {
                    builder.addFieldOffset(7, sparseInitializersOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createSparseInitializersVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startSparseInitializersVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endGraph(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createGraph(builder, initializersOffset, nodeArgsOffset, nodesOffset, maxNodeIndex, nodeEdgesOffset, inputsOffset, outputsOffset, sparseInitializersOffset) {
                    Graph.startGraph(builder);
                    Graph.addInitializers(builder, initializersOffset);
                    Graph.addNodeArgs(builder, nodeArgsOffset);
                    Graph.addNodes(builder, nodesOffset);
                    Graph.addMaxNodeIndex(builder, maxNodeIndex);
                    Graph.addNodeEdges(builder, nodeEdgesOffset);
                    Graph.addInputs(builder, inputsOffset);
                    Graph.addOutputs(builder, outputsOffset);
                    Graph.addSparseInitializers(builder, sparseInitializersOffset);
                    return Graph.endGraph(builder);
                }
            }
            fbs.Graph = Graph;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class Model {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns Model
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Model= obj
                 * @returns Model
                 */
                static getRootAsModel(bb, obj) {
                    return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param Model= obj
                 * @returns Model
                 */
                static getSizePrefixedRootAsModel(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @returns flatbuffers.Long
                 */
                irVersion() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.OperatorSetId= obj
                 * @returns onnxruntime.experimental.fbs.OperatorSetId
                 */
                opsetImport(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.OperatorSetId())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                opsetImportLength() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                producerName(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                producerVersion(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 10);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                domain(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 12);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @returns flatbuffers.Long
                 */
                modelVersion() {
                    let offset = this.bb.__offset(this.bb_pos, 14);
                    return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
                }
                docString(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 16);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.Graph= obj
                 * @returns onnxruntime.experimental.fbs.Graph|null
                 */
                graph(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 18);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Graph())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                graphDocString(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 20);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startModel(builder) {
                    builder.startObject(9);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long irVersion
                 */
                static addIrVersion(builder, irVersion) {
                    builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset opsetImportOffset
                 */
                static addOpsetImport(builder, opsetImportOffset) {
                    builder.addFieldOffset(1, opsetImportOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createOpsetImportVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startOpsetImportVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset producerNameOffset
                 */
                static addProducerName(builder, producerNameOffset) {
                    builder.addFieldOffset(2, producerNameOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset producerVersionOffset
                 */
                static addProducerVersion(builder, producerVersionOffset) {
                    builder.addFieldOffset(3, producerVersionOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset domainOffset
                 */
                static addDomain(builder, domainOffset) {
                    builder.addFieldOffset(4, domainOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Long modelVersion
                 */
                static addModelVersion(builder, modelVersion) {
                    builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset docStringOffset
                 */
                static addDocString(builder, docStringOffset) {
                    builder.addFieldOffset(6, docStringOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphOffset
                 */
                static addGraph(builder, graphOffset) {
                    builder.addFieldOffset(7, graphOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphDocStringOffset
                 */
                static addGraphDocString(builder, graphDocStringOffset) {
                    builder.addFieldOffset(8, graphDocStringOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endModel(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createModel(builder, irVersion, opsetImportOffset, producerNameOffset, producerVersionOffset, domainOffset, modelVersion, docStringOffset, graphOffset, graphDocStringOffset) {
                    Model.startModel(builder);
                    Model.addIrVersion(builder, irVersion);
                    Model.addOpsetImport(builder, opsetImportOffset);
                    Model.addProducerName(builder, producerNameOffset);
                    Model.addProducerVersion(builder, producerVersionOffset);
                    Model.addDomain(builder, domainOffset);
                    Model.addModelVersion(builder, modelVersion);
                    Model.addDocString(builder, docStringOffset);
                    Model.addGraph(builder, graphOffset);
                    Model.addGraphDocString(builder, graphDocStringOffset);
                    return Model.endModel(builder);
                }
            }
            fbs.Model = Model;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class KernelCreateInfos {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns KernelCreateInfos
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param KernelCreateInfos= obj
                 * @returns KernelCreateInfos
                 */
                static getRootAsKernelCreateInfos(bb, obj) {
                    return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param KernelCreateInfos= obj
                 * @returns KernelCreateInfos
                 */
                static getSizePrefixedRootAsKernelCreateInfos(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param number index
                 * @returns number
                 */
                nodeIndices(index) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
                }
                /**
                 * @returns number
                 */
                nodeIndicesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @returns Uint32Array
                 */
                nodeIndicesArray() {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ?
                        new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) :
                        null;
                }
                /**
                 * @param number index
                 * @returns flatbuffers.Long
                 */
                kernelDefHashes(index) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) :
                        this.bb.createLong(0, 0);
                }
                /**
                 * @returns number
                 */
                kernelDefHashesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startKernelCreateInfos(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset nodeIndicesOffset
                 */
                static addNodeIndices(builder, nodeIndicesOffset) {
                    builder.addFieldOffset(0, nodeIndicesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<number> data
                 * @returns flatbuffers.Offset
                 */
                static createNodeIndicesVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt32(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startNodeIndicesVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset kernelDefHashesOffset
                 */
                static addKernelDefHashes(builder, kernelDefHashesOffset) {
                    builder.addFieldOffset(1, kernelDefHashesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Long> data
                 * @returns flatbuffers.Offset
                 */
                static createKernelDefHashesVector(builder, data) {
                    builder.startVector(8, data.length, 8);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addInt64(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startKernelDefHashesVector(builder, numElems) {
                    builder.startVector(8, numElems, 8);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endKernelCreateInfos(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createKernelCreateInfos(builder, nodeIndicesOffset, kernelDefHashesOffset) {
                    KernelCreateInfos.startKernelCreateInfos(builder);
                    KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);
                    KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);
                    return KernelCreateInfos.endKernelCreateInfos(builder);
                }
            }
            fbs.KernelCreateInfos = KernelCreateInfos;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class SubGraphSessionState {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SubGraphSessionState
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SubGraphSessionState= obj
                 * @returns SubGraphSessionState
                 */
                static getRootAsSubGraphSessionState(bb, obj) {
                    return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SubGraphSessionState= obj
                 * @returns SubGraphSessionState
                 */
                static getSizePrefixedRootAsSubGraphSessionState(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                graphId(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.SessionState= obj
                 * @returns onnxruntime.experimental.fbs.SessionState|null
                 */
                sessionState(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startSubGraphSessionState(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset graphIdOffset
                 */
                static addGraphId(builder, graphIdOffset) {
                    builder.addFieldOffset(0, graphIdOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sessionStateOffset
                 */
                static addSessionState(builder, sessionStateOffset) {
                    builder.addFieldOffset(1, sessionStateOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endSubGraphSessionState(builder) {
                    let offset = builder.endObject();
                    builder.requiredField(offset, 4); // graph_id
                    return offset;
                }
                static createSubGraphSessionState(builder, graphIdOffset, sessionStateOffset) {
                    SubGraphSessionState.startSubGraphSessionState(builder);
                    SubGraphSessionState.addGraphId(builder, graphIdOffset);
                    SubGraphSessionState.addSessionState(builder, sessionStateOffset);
                    return SubGraphSessionState.endSubGraphSessionState(builder);
                }
            }
            fbs.SubGraphSessionState = SubGraphSessionState;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class SessionState {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns SessionState
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SessionState= obj
                 * @returns SessionState
                 */
                static getRootAsSessionState(bb, obj) {
                    return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param SessionState= obj
                 * @returns SessionState
                 */
                static getSizePrefixedRootAsSessionState(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj
                 * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null
                 */
                kernels(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? (obj || new onnxruntime.experimental.fbs.KernelCreateInfos())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param number index
                 * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj
                 * @returns onnxruntime.experimental.fbs.SubGraphSessionState
                 */
                subGraphSessionStates(index, obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SubGraphSessionState())
                        .__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) :
                        null;
                }
                /**
                 * @returns number
                 */
                subGraphSessionStatesLength() {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startSessionState(builder) {
                    builder.startObject(2);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset kernelsOffset
                 */
                static addKernels(builder, kernelsOffset) {
                    builder.addFieldOffset(0, kernelsOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset subGraphSessionStatesOffset
                 */
                static addSubGraphSessionStates(builder, subGraphSessionStatesOffset) {
                    builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param Array.<flatbuffers.Offset> data
                 * @returns flatbuffers.Offset
                 */
                static createSubGraphSessionStatesVector(builder, data) {
                    builder.startVector(4, data.length, 4);
                    for (let i = data.length - 1; i >= 0; i--) {
                        builder.addOffset(data[i]);
                    }
                    return builder.endVector();
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param number numElems
                 */
                static startSubGraphSessionStatesVector(builder, numElems) {
                    builder.startVector(4, numElems, 4);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endSessionState(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                static createSessionState(builder, kernelsOffset, subGraphSessionStatesOffset) {
                    SessionState.startSessionState(builder);
                    SessionState.addKernels(builder, kernelsOffset);
                    SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);
                    return SessionState.endSessionState(builder);
                }
            }
            fbs.SessionState = SessionState;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));
/**
 * @constructor
 */
(function (onnxruntime) {
    var experimental;
    (function (experimental) {
        var fbs;
        (function (fbs) {
            class InferenceSession {
                constructor() {
                    this.bb = null;
                    this.bb_pos = 0;
                }
                /**
                 * @param number i
                 * @param flatbuffers.ByteBuffer bb
                 * @returns InferenceSession
                 */
                __init(i, bb) {
                    this.bb_pos = i;
                    this.bb = bb;
                    return this;
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param InferenceSession= obj
                 * @returns InferenceSession
                 */
                static getRootAsInferenceSession(bb, obj) {
                    return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @param InferenceSession= obj
                 * @returns InferenceSession
                 */
                static getSizePrefixedRootAsInferenceSession(bb, obj) {
                    bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
                    return (obj || new InferenceSession()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
                }
                /**
                 * @param flatbuffers.ByteBuffer bb
                 * @returns boolean
                 */
                static bufferHasIdentifier(bb) {
                    return bb.__has_identifier('ORTM');
                }
                ortVersion(optionalEncoding) {
                    let offset = this.bb.__offset(this.bb_pos, 4);
                    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.Model= obj
                 * @returns onnxruntime.experimental.fbs.Model|null
                 */
                model(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 6);
                    return offset ? (obj || new onnxruntime.experimental.fbs.Model())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param onnxruntime.experimental.fbs.SessionState= obj
                 * @returns onnxruntime.experimental.fbs.SessionState|null
                 */
                sessionState(obj) {
                    let offset = this.bb.__offset(this.bb_pos, 8);
                    return offset ? (obj || new onnxruntime.experimental.fbs.SessionState())
                        .__init(this.bb.__indirect(this.bb_pos + offset), this.bb) :
                        null;
                }
                /**
                 * @param flatbuffers.Builder builder
                 */
                static startInferenceSession(builder) {
                    builder.startObject(3);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset ortVersionOffset
                 */
                static addOrtVersion(builder, ortVersionOffset) {
                    builder.addFieldOffset(0, ortVersionOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset modelOffset
                 */
                static addModel(builder, modelOffset) {
                    builder.addFieldOffset(1, modelOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset sessionStateOffset
                 */
                static addSessionState(builder, sessionStateOffset) {
                    builder.addFieldOffset(2, sessionStateOffset, 0);
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @returns flatbuffers.Offset
                 */
                static endInferenceSession(builder) {
                    let offset = builder.endObject();
                    return offset;
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset offset
                 */
                static finishInferenceSessionBuffer(builder, offset) {
                    builder.finish(offset, 'ORTM');
                }
                /**
                 * @param flatbuffers.Builder builder
                 * @param flatbuffers.Offset offset
                 */
                static finishSizePrefixedInferenceSessionBuffer(builder, offset) {
                    builder.finish(offset, 'ORTM', true);
                }
                static createInferenceSession(builder, ortVersionOffset, modelOffset, sessionStateOffset) {
                    InferenceSession.startInferenceSession(builder);
                    InferenceSession.addOrtVersion(builder, ortVersionOffset);
                    InferenceSession.addModel(builder, modelOffset);
                    InferenceSession.addSessionState(builder, sessionStateOffset);
                    return InferenceSession.endInferenceSession(builder);
                }
            }
            fbs.InferenceSession = InferenceSession;
        })(fbs = experimental.fbs || (experimental.fbs = {}));
    })(experimental = onnxruntime.experimental || (onnxruntime.experimental = {}));
})(onnxruntime = exports.onnxruntime || (exports.onnxruntime = {}));


/***/ }),

/***/ "./lib/onnxjs/session-handler.ts":
/*!***************************************!*\
  !*** ./lib/onnxjs/session-handler.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnnxjsSessionHandler = void 0;
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
class OnnxjsSessionHandler {
    constructor(session) {
        this.session = session;
        this.inputNames = this.session.inputNames;
        this.outputNames = this.session.outputNames;
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    run(feeds, _fetches, _options) {
        return __awaiter(this, void 0, void 0, function* () {
            const inputMap = new Map();
            for (const name in feeds) {
                if (Object.hasOwnProperty.call(feeds, name)) {
                    const feed = feeds[name];
                    inputMap.set(name, new tensor_1.Tensor(feed.dims, feed.type, undefined, undefined, feed.data));
                }
            }
            const outputMap = yield this.session.run(inputMap);
            const output = {};
            outputMap.forEach((tensor, name) => {
                output[name] = new onnxruntime_common_1.Tensor(tensor.type, tensor.data, tensor.dims);
            });
            return output;
        });
    }
    startProfiling() {
        this.session.startProfiling();
    }
    endProfiling() {
        this.session.endProfiling();
    }
}
exports.OnnxjsSessionHandler = OnnxjsSessionHandler;


/***/ }),

/***/ "./lib/onnxjs/session.ts":
/*!*******************************!*\
  !*** ./lib/onnxjs/session.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Session = void 0;
const fs_1 = __webpack_require__(/*! fs */ "?6c45");
const util_1 = __webpack_require__(/*! util */ "?b3a2");
const backend_1 = __webpack_require__(/*! ./backend */ "./lib/onnxjs/backend.ts");
const execution_plan_1 = __webpack_require__(/*! ./execution-plan */ "./lib/onnxjs/execution-plan.ts");
const instrument_1 = __webpack_require__(/*! ./instrument */ "./lib/onnxjs/instrument.ts");
const model_1 = __webpack_require__(/*! ./model */ "./lib/onnxjs/model.ts");
class Session {
    constructor(config = {}) {
        this._initialized = false;
        this.backendHint = config.backendHint;
        this.profiler = instrument_1.Profiler.create(config.profiler);
        this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
    }
    get inputNames() {
        return this._model.graph.getInputNames();
    }
    get outputNames() {
        return this._model.graph.getOutputNames();
    }
    startProfiling() {
        this.profiler.start();
    }
    endProfiling() {
        this.profiler.stop();
    }
    loadModel(arg, byteOffset, length) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.profiler.event('session', 'Session.loadModel', () => __awaiter(this, void 0, void 0, function* () {
                // resolve backend and session handler
                const backend = yield backend_1.resolveBackend(this.backendHint);
                this.sessionHandler = backend.createSessionHandler(this.context);
                this._model = new model_1.Model();
                if (typeof arg === 'string') {
                    const isOrtFormat = arg.endsWith('.ort');
                    if (typeof fetch === 'undefined') {
                        // node
                        const buf = yield util_1.promisify(fs_1.readFile)(arg);
                        this.initialize(Buffer.from(buf), isOrtFormat);
                    }
                    else {
                        // browser
                        const response = yield fetch(arg);
                        const buf = yield response.arrayBuffer();
                        this.initialize(new Uint8Array(buf), isOrtFormat);
                    }
                }
                else if (!ArrayBuffer.isView(arg)) {
                    // load model from ArrayBuffer
                    const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
                    this.initialize(arr);
                }
                else {
                    // load model from Uint8array
                    this.initialize(arg);
                }
            }));
        });
    }
    initialize(modelProtoBlob, isOrtFormat) {
        if (this._initialized) {
            throw new Error('already initialized');
        }
        this.profiler.event('session', 'Session.initialize', () => {
            // load graph
            const graphInitializer = this.sessionHandler.transformGraph ? this.sessionHandler : undefined;
            this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);
            // graph is completely initialzied at this stage , let the interested handlers know
            if (this.sessionHandler.onGraphInitialized) {
                this.sessionHandler.onGraphInitialized(this._model.graph);
            }
            // initialize each operator in the graph
            this.initializeOps(this._model.graph);
            // instantiate an ExecutionPlan object to be used by the Session object
            this._executionPlan = new execution_plan_1.ExecutionPlan(this._model.graph, this._ops, this.profiler);
        });
        this._initialized = true;
    }
    run(inputs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._initialized) {
                throw new Error('session not initialized yet');
            }
            return this.profiler.event('session', 'Session.run', () => __awaiter(this, void 0, void 0, function* () {
                const inputTensors = this.normalizeAndValidateInputs(inputs);
                const outputTensors = yield this._executionPlan.execute(this.sessionHandler, inputTensors);
                return this.createOutput(outputTensors);
            }));
        });
    }
    normalizeAndValidateInputs(inputs) {
        const modelInputNames = this._model.graph.getInputNames();
        // normalize inputs
        // inputs: Tensor[]
        if (Array.isArray(inputs)) {
            if (inputs.length !== modelInputNames.length) {
                throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);
            }
        }
        // convert map to array
        // inputs: Map<string, Tensor>
        else {
            if (inputs.size !== modelInputNames.length) {
                throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);
            }
            const sortedInputs = new Array(inputs.size);
            let sortedInputsIndex = 0;
            for (let i = 0; i < modelInputNames.length; ++i) {
                const tensor = inputs.get(modelInputNames[i]);
                if (!tensor) {
                    throw new Error(`missing input tensor for: '${name}'`);
                }
                sortedInputs[sortedInputsIndex++] = tensor;
            }
            inputs = sortedInputs;
        }
        // validate dims requirements
        // First session run - graph input data is not cached for the session
        if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims ||
            this.context.graphInputDims.length === 0) {
            const modelInputIndices = this._model.graph.getInputIndices();
            const modelValues = this._model.graph.getValues();
            const graphInputDims = new Array(modelInputIndices.length);
            for (let i = 0; i < modelInputIndices.length; ++i) {
                const graphInput = modelValues[modelInputIndices[i]];
                graphInputDims[i] = graphInput.type.shape.dims;
                // cached for second and subsequent runs.
                // Some parts of the framework works on the assumption that the graph and types and shapes are static
                this.context.graphInputTypes.push(graphInput.type.tensorType);
                this.context.graphInputDims.push(inputs[i].dims);
            }
            this.validateInputTensorDims(graphInputDims, inputs, true);
        }
        // Second and subsequent session runs - graph input data is cached for the session
        else {
            this.validateInputTensorDims(this.context.graphInputDims, inputs, false);
        }
        // validate types requirement
        this.validateInputTensorTypes(this.context.graphInputTypes, inputs);
        return inputs;
    }
    validateInputTensorTypes(graphInputTypes, givenInputs) {
        for (let i = 0; i < givenInputs.length; i++) {
            const expectedType = graphInputTypes[i];
            const actualType = givenInputs[i].type;
            if (expectedType !== actualType) {
                throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);
            }
        }
    }
    validateInputTensorDims(graphInputDims, givenInputs, noneDimSupported) {
        for (let i = 0; i < givenInputs.length; i++) {
            const expectedDims = graphInputDims[i];
            const actualDims = givenInputs[i].dims;
            if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {
                throw new Error(`input tensor[${i}] check failed: expected shape '[${expectedDims.join(',')}]' but got [${actualDims.join(',')}]`);
            }
        }
    }
    compareTensorDims(expectedDims, actualDims, noneDimSupported) {
        if (expectedDims.length !== actualDims.length) {
            return false;
        }
        for (let i = 0; i < expectedDims.length; ++i) {
            if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {
                // data shape mis-match AND not a 'None' dimension.
                return false;
            }
        }
        return true;
    }
    createOutput(outputTensors) {
        const modelOutputNames = this._model.graph.getOutputNames();
        if (outputTensors.length !== modelOutputNames.length) {
            throw new Error('expected number of outputs do not match number of generated outputs');
        }
        const output = new Map();
        for (let i = 0; i < modelOutputNames.length; ++i) {
            output.set(modelOutputNames[i], outputTensors[i]);
        }
        return output;
    }
    initializeOps(graph) {
        const nodes = graph.getNodes();
        this._ops = new Array(nodes.length);
        for (let i = 0; i < nodes.length; i++) {
            this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);
        }
    }
}
exports.Session = Session;


/***/ }),

/***/ "./lib/onnxjs/tensor.ts":
/*!******************************!*\
  !*** ./lib/onnxjs/tensor.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tensor = void 0;
const guid_typescript_1 = __webpack_require__(/*! guid-typescript */ "./node_modules/guid-typescript/dist/guid.js");
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
const ort_generated_1 = __webpack_require__(/*! ./ort-schema/ort-generated */ "./lib/onnxjs/ort-schema/ort-generated.ts");
var ortFbs = ort_generated_1.onnxruntime.experimental.fbs;
const util_1 = __webpack_require__(/*! ./util */ "./lib/onnxjs/util.ts");
class Tensor {
    constructor(
    /**
     * get the dimensions of the tensor
     */
    dims, 
    /**
     * get the type of the tensor
     */
    type, dataProvider, asyncDataProvider, cache, 
    /**
     * get the data ID that used to map to a tensor data
     */
    dataId = guid_typescript_1.Guid.create()) {
        this.dims = dims;
        this.type = type;
        this.dataProvider = dataProvider;
        this.asyncDataProvider = asyncDataProvider;
        this.cache = cache;
        this.dataId = dataId;
        this.size = util_1.ShapeUtil.validateDimsAndCalcSize(dims);
        const size = this.size;
        const empty = (dataProvider === undefined && asyncDataProvider === undefined && cache === undefined);
        if (cache !== undefined) {
            if (cache.length !== size) {
                throw new RangeError('Input dims doesn\'t match data length.');
            }
        }
        if (type === 'string') {
            if (cache !== undefined && (!Array.isArray(cache) || !cache.every(i => typeof i === 'string'))) {
                throw new TypeError('cache should be a string array');
            }
            if (empty) {
                this.cache = new Array(size);
            }
        }
        else {
            if (cache !== undefined) {
                const constructor = dataviewConstructor(type);
                if (!(cache instanceof constructor)) {
                    throw new TypeError(`cache should be type ${constructor.name}`);
                }
            }
            if (empty) {
                const buf = new ArrayBuffer(size * sizeof(type));
                this.cache = createView(buf, type);
            }
        }
    }
    /**
     * get the underlying tensor data
     */
    get data() {
        if (this.cache === undefined) {
            const data = this.dataProvider(this.dataId);
            if (data.length !== this.size) {
                throw new Error('Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.');
            }
            this.cache = data;
        }
        return this.cache;
    }
    /**
     * get the underlying string tensor data. Should only use when type is STRING
     */
    get stringData() {
        if (this.type !== 'string') {
            throw new TypeError('data type is not string');
        }
        return this.data;
    }
    /**
     * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
     * INT16, INT32, UINT32, BOOL)
     */
    get integerData() {
        switch (this.type) {
            case 'uint8':
            case 'int8':
            case 'uint16':
            case 'int16':
            case 'int32':
            case 'uint32':
            case 'bool':
                return this.data;
            default:
                throw new TypeError('data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)');
        }
    }
    /**
     * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)
     */
    get floatData() {
        switch (this.type) {
            case 'float32':
            case 'float64':
                return this.data;
            default:
                throw new TypeError('data type is not float (float32, float64)');
        }
    }
    /**
     * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
     * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)
     */
    get numberData() {
        if (this.type !== 'string') {
            return this.data;
        }
        throw new TypeError('type cannot be non-number (string)');
    }
    /**
     * get value of an element at the given indices
     */
    get(indices) {
        return this.data[util_1.ShapeUtil.indicesToOffset(indices, this.strides)];
    }
    /**
     * set value of an element at the given indices
     */
    set(indices, value) {
        this.data[util_1.ShapeUtil.indicesToOffset(indices, this.strides)] = value;
    }
    /**
     * get the underlying tensor data asynchronously
     */
    getData() {
        return __awaiter(this, void 0, void 0, function* () {
            // TBD: This function is designed for usage when any backend data provider offers a way to retrieve data in an
            //      asynchronous way. should implement this function when enabling webgl async read data.
            if (this.cache === undefined) {
                this.cache = yield this.asyncDataProvider(this.dataId);
            }
            return this.cache;
        });
    }
    /**
     * get the strides for each dimension
     */
    get strides() {
        if (!this._strides) {
            this._strides = util_1.ShapeUtil.computeStrides(this.dims);
        }
        return this._strides;
    }
    /**
     * Construct new Tensor from a ONNX Tensor object
     * @param tensorProto the ONNX Tensor
     */
    static fromProto(tensorProto) {
        if (!tensorProto) {
            throw new Error('cannot construct Value from an empty tensor');
        }
        const type = util_1.ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType);
        const dims = util_1.ProtoUtil.tensorDimsFromProto(tensorProto.dims);
        const value = new Tensor(dims, type);
        if (type === 'string') {
            // When it's STRING type, the value should always be stored in field
            // 'stringData'
            tensorProto.stringData.forEach((str, i) => {
                const buf = Buffer.from(str.buffer, str.byteOffset, str.byteLength);
                value.data[i] = buf.toString();
            });
        }
        else if (tensorProto.rawData && typeof tensorProto.rawData.byteLength === 'number' &&
            tensorProto.rawData.byteLength > 0) {
            // NOT considering segment for now (IMPORTANT)
            // populate value from rawData
            const dataDest = value.data;
            const dataSource = new DataView(tensorProto.rawData.buffer, tensorProto.rawData.byteOffset, tensorProto.rawData.byteLength);
            const elementSize = sizeofProto(tensorProto.dataType);
            const length = tensorProto.rawData.byteLength / elementSize;
            if (tensorProto.rawData.byteLength % elementSize !== 0) {
                throw new Error('invalid buffer length');
            }
            if (dataDest.length !== length) {
                throw new Error('buffer length mismatch');
            }
            for (let i = 0; i < length; i++) {
                const n = readProto(dataSource, tensorProto.dataType, i * elementSize);
                dataDest[i] = n;
            }
        }
        else {
            // populate value from array
            let array;
            switch (tensorProto.dataType) {
                case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
                    array = tensorProto.floatData;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.INT32:
                case onnx_proto_1.onnx.TensorProto.DataType.INT16:
                case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
                case onnx_proto_1.onnx.TensorProto.DataType.INT8:
                case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
                case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
                    array = tensorProto.int32Data;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.INT64:
                    array = tensorProto.int64Data;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
                    array = tensorProto.doubleData;
                    break;
                case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
                case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
                    array = tensorProto.uint64Data;
                    break;
                default:
                    // should never run here
                    throw new Error('unspecific error');
            }
            if (array === null || array === undefined) {
                throw new Error('failed to populate data from a tensorproto value');
            }
            const data = value.data;
            if (data.length !== array.length) {
                throw new Error('array length mismatch');
            }
            for (let i = 0; i < array.length; i++) {
                const element = array[i];
                if (long_1.default.isLong(element)) {
                    data[i] = longToNumber(element, tensorProto.dataType);
                }
                else {
                    data[i] = element;
                }
            }
        }
        return value;
    }
    /**
     * Construct new Tensor from raw data
     * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array
     * for other types of tensor.
     * @param dims the dimensions of the tensor
     * @param type the type of the tensor
     */
    static fromData(data, dims, type) {
        return new Tensor(dims, type, undefined, undefined, data);
    }
    static fromOrtTensor(ortTensor) {
        if (!ortTensor) {
            throw new Error('cannot construct Value from an empty tensor');
        }
        const dims = util_1.ProtoUtil.tensorDimsFromORTFormat(ortTensor);
        const type = util_1.ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());
        const value = new Tensor(dims, type);
        if (type === 'string') {
            // When it's STRING type, the value should always be stored in field
            // 'stringData'
            for (let i = 0; i < ortTensor.stringDataLength(); i++) {
                value.data[i] = ortTensor.stringData(i);
            }
        }
        else if (ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === 'number' && ortTensor.rawDataLength() > 0) {
            // NOT considering segment for now (IMPORTANT)
            // populate value from rawData
            const dataDest = value.data;
            const dataSource = new DataView(ortTensor.rawDataArray().buffer, ortTensor.rawDataArray().byteOffset, ortTensor.rawDataLength());
            const elementSize = sizeofProto(ortTensor.dataType());
            const length = ortTensor.rawDataLength() / elementSize;
            if (ortTensor.rawDataLength() % elementSize !== 0) {
                throw new Error('invalid buffer length');
            }
            if (dataDest.length !== length) {
                throw new Error('buffer length mismatch');
            }
            for (let i = 0; i < length; i++) {
                const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);
                dataDest[i] = n;
            }
        }
        return value;
    }
}
exports.Tensor = Tensor;
function sizeof(type) {
    switch (type) {
        case 'bool':
        case 'int8':
        case 'uint8':
            return 1;
        case 'int16':
        case 'uint16':
            return 2;
        case 'int32':
        case 'uint32':
        case 'float32':
            return 4;
        case 'float64':
            return 8;
        default:
            throw new Error(`cannot calculate sizeof() on type ${type}`);
    }
}
function sizeofProto(type) {
    switch (type) {
        case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
        case onnx_proto_1.onnx.TensorProto.DataType.INT8:
        case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
            return 1;
        case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
        case onnx_proto_1.onnx.TensorProto.DataType.INT16:
            return 2;
        case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
        case onnx_proto_1.onnx.TensorProto.DataType.INT32:
        case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
            return 4;
        case onnx_proto_1.onnx.TensorProto.DataType.INT64:
        case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
        case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
            return 8;
        default:
            throw new Error(`cannot calculate sizeof() on type ${onnx_proto_1.onnx.TensorProto.DataType[type]}`);
    }
}
function createView(dataBuffer, type) {
    return new (dataviewConstructor(type))(dataBuffer);
}
function dataviewConstructor(type) {
    switch (type) {
        case 'bool':
        case 'uint8':
            return Uint8Array;
        case 'int8':
            return Int8Array;
        case 'int16':
            return Int16Array;
        case 'uint16':
            return Uint16Array;
        case 'int32':
            return Int32Array;
        case 'uint32':
            return Uint32Array;
        case 'float32':
            return Float32Array;
        case 'float64':
            return Float64Array;
        default:
            // should never run to here
            throw new Error('unspecified error');
    }
}
// convert a long number to a 32-bit integer (cast-down)
function longToNumber(i, type) {
    // INT64, UINT32, UINT64
    if (type === onnx_proto_1.onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {
        if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {
            throw new TypeError('int64 is not supported');
        }
    }
    else if (type === onnx_proto_1.onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 ||
        type === onnx_proto_1.onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {
        if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {
            throw new TypeError('uint64 is not supported');
        }
    }
    else {
        throw new TypeError(`not a LONG type: ${onnx_proto_1.onnx.TensorProto.DataType[type]}`);
    }
    return i.toNumber();
}
// read one value from TensorProto
function readProto(view, type, byteOffset) {
    switch (type) {
        case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
        case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
            return view.getUint8(byteOffset);
        case onnx_proto_1.onnx.TensorProto.DataType.INT8:
            return view.getInt8(byteOffset);
        case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
            return view.getUint16(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.INT16:
            return view.getInt16(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
            return view.getFloat32(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.INT32:
            return view.getInt32(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
            return view.getUint32(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.INT64:
            return longToNumber(long_1.default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false), type);
        case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
            return view.getFloat64(byteOffset, true);
        case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
            return longToNumber(long_1.default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true), type);
        default:
            throw new Error(`cannot read from DataView for type ${onnx_proto_1.onnx.TensorProto.DataType[type]}`);
    }
}


/***/ }),

/***/ "./lib/onnxjs/util.ts":
/*!****************************!*\
  !*** ./lib/onnxjs/util.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoolConvUtil = exports.ReduceUtil = exports.SplitUtil = exports.MathUtil = exports.ShapeUtil = exports.LongUtil = exports.ProtoUtil = exports.GemmUtil = exports.arrayCopyHelper = exports.BroadcastUtil = exports.MatMulUtil = exports.ArrayUtil = exports.assert = exports.checkInputsShape = void 0;
const flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/js/flatbuffers.mjs");
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
const tensor_1 = __webpack_require__(/*! ./tensor */ "./lib/onnxjs/tensor.ts");
// check the inputs shape before running an OP.
// return true when the inputs pass the check
// return false when the inputs do not fit the requirement
// throw exception when fatal error or not implemented
function checkInputsShape(inputs, ...expectedDimensions) {
    if (!inputs || inputs.length !== expectedDimensions.length) {
        return false;
    }
    for (let i = 0; i < inputs.length; i++) {
        if (!inputs[i].dims || inputs[i].dims.length !== expectedDimensions[i]) {
            return false;
        }
    }
    return true;
}
exports.checkInputsShape = checkInputsShape;
// Evaluates the given expression and asserts error message if condition is unmet.
function assert(expr, msg) {
    if (!expr) {
        throw new Error(typeof msg === 'string' ? msg : msg());
    }
}
exports.assert = assert;
class ArrayUtil {
    /**
     * Verifies if 2 input arrays contain the same elements.
     * @param n1 Array 1
     * @param n2 Array 2
     * @returns Whether these 2 are equal
     */
    static arraysEqual(n1, n2) {
        if (n1.length !== n2.length) {
            return false;
        }
        for (let i = 0; i < n1.length; i++) {
            if (n1[i] !== n2[i]) {
                return false;
            }
        }
        return true;
    }
}
exports.ArrayUtil = ArrayUtil;
class MatMulUtil {
    /**
     * Fix the input shapes for MatMul operation if they need fixing
     * @param dimsA The shape of tensor A. Should be an array of positive integers
     * @param dimsB The shape of tensor B. Should be an array of positive integers
     * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications
     */
    static preprocessInputShapes(dimsA, dimsB) {
        // If the first argument is 1-D, it is promoted to a matrix by prepending
        // a 1 to its dimensions. After matrix multiplication the prepended 1 is
        // removed.
        const a = (dimsA.length === 1) ? [1, dimsA[0]] : dimsA;
        // If the second argument is 1-D, it is promoted to a matrix by appending
        // a 1 to its dimensions. After matrix multiplication the appended 1 is
        // removed.
        const b = (dimsB.length === 1) ? [dimsB[0], 1] : dimsB;
        return [a, b];
    }
    /**
     * Fix the output shape computed for MatMul operation if it needs fixing
     * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.
     * This will be mutated.
     * @param aRank The rank of tensor A.
     * @param bRank The rank of tensor B.
     */
    static postprocessOutputShape(outputShape, aRank, bRank) {
        // Remove prepended dimension if first input is 1d
        if (aRank === 1) {
            // outputShape = outputShape.slice(0, outputShape.length - 2).concat(outputShape.slice(outputShape.length - 1));
            outputShape.splice(outputShape.length - 2, 1);
        }
        // Remove appended dimension if second input is 1d
        if (bRank === 1) {
            outputShape.pop();
        }
    }
    /**
     * Calculate the expected shape when matrix multiplication
     * @param a The shape of tensor A. Should be a tuple of 2 positive integers
     * @param b The shape of tensor B. Should be a tuple of 2 positive integers
     * @returns The expected shape of the result, or undefined if N/A
     */
    static calcMatMulShape(a, b) {
        return (a[1] !== b[0]) ? undefined : [a[0], b[1]];
    }
}
exports.MatMulUtil = MatMulUtil;
class BroadcastUtil {
    /**
     * Calculate the expected shape when broadcasting 2 tensors
     * @param a The shape of tensor A. Should be an array of positive integers
     * @param b The shape of tensor B. Should be an array of positive integers
     * @param isMatMul Whether the operation is MatMul
     * @returns The expected shape of the result, or undefined if N/A
     */
    static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
            return bdims;
        }
        if (brank === 0) {
            return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        // calculate the last 2 dimension if it is MatMul
        if (isMatMul) {
            if (arank < 2 || brank < 2) {
                return undefined;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);
            if (cShapeMatMul === undefined) {
                return undefined;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
                return undefined;
            }
            cdims[crank - i] = Math.max(aLen, bLen);
        }
        return cdims;
    }
    /**
     * Given the indices of a broadcasted tensor, calculate the original indices
     * @param broadcastedIndices The given indices of the broadcasted tensor.
     * @param originalShape The original shape of the tensor before broadcas
     * @returns The calculated indices that maps to the original tensor.
     */
    static index(broadcastedIndices, originalShape) {
        // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same
        // length as the broadcasted shape, and for each dimension the index should
        // not be out of range.
        const originalIndices = new Array(originalShape.length);
        BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);
        return originalIndices;
    }
    /**
     * Given the indices of a broadcasted tensor, calculate the original indices
     * @param broadcastedIndices The given indices of the broadcasted tensor.
     * @param originalShape The original shape of the tensor before broadcast
     * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be
     *     mutated).
     */
    static fillIndex(broadcastedIndices, originalShape, originalIndices) {
        // NOTE 1: we assume the parameter broadcastedIndices is valid. ie. it should have the same length as the
        // broadcasted shape, and for each dimension the index should not be out of range.
        // NOTE 2: we assume the parameter originalIndices has the same length as the originalShape
        const dimOffset = broadcastedIndices.length - originalShape.length;
        for (let i = 0; i < originalShape.length; i++) {
            originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];
        }
    }
    /**
     * Perform the broadcasting operation on the specific operator
     * @param a The input tensor A
     * @param b The input tensor B
     * @param op The operator lambda function
     * @param inplace Whether to write the result back to A.
     * @returns The result tensor, or undefined if input not broadcastable.
     */
    static calc(a, b, op, inplace, resultType) {
        const outputShape = BroadcastUtil.calcShape(a.dims, b.dims);
        if (outputShape) {
            if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {
                // B is not broadcastable to A, failed to calculate inplace.
                return undefined;
            }
            const size = ShapeUtil.size(outputShape);
            const c = inplace ? a : new tensor_1.Tensor(outputShape, resultType || a.type);
            // both inputs are scalars
            if (outputShape.length === 0) {
                c.set([], op(a.get([]), b.get([])));
            }
            // atleast one input is a non-scalar
            else {
                const outputIndices = new Array(outputShape.length);
                const originalIndicesA = new Array(a.dims.length);
                const originalIndicesB = new Array(b.dims.length);
                let valA = 0;
                let valB = 0;
                let isAScalar = false;
                let isBScalar = false;
                if (a.dims.length === 0) {
                    valA = a.get([]);
                    isAScalar = true;
                }
                if (b.dims.length === 0) {
                    valB = b.get([]);
                    isBScalar = true;
                }
                let rest;
                for (let i = 0; i < size; i++) {
                    // traversal indices
                    rest = i;
                    for (let j = outputShape.length - 1; j >= 0; j--) {
                        outputIndices[j] = rest % outputShape[j];
                        rest = Math.floor(rest / outputShape[j]);
                    }
                    if (!isAScalar) {
                        // map outputIndices (which is actually broadcasted) to the originalIndices
                        BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);
                        valA = a.get(originalIndicesA);
                    }
                    if (!isBScalar) {
                        BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);
                        valB = b.get(originalIndicesB);
                    }
                    c.set(outputIndices, op(valA, valB));
                }
            }
            return c;
        }
        return undefined;
    }
    /**
     * Determine if a shape is unidirectional broadcastable to another shape
     * @param shape The input shape
     * @param finalShape The desired shape after broadcasting
     */
    static isValidBroadcast(shape, finalShape) {
        // align shape to the right
        const inputRank = shape.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
            return false;
        }
        for (let i = 1; i <= inputRank; i++) {
            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Determine the broadcasted dims in input shape based on the given output shape.
     * Note that this function only returns the broadcasted dims.
     * @param inputShape The input shape
     * @param outputShape The output shape
     * @returns The broadcasted dims in input shape.
     */
    static getBroadcastDims(inputShape, outputShape) {
        const inRank = inputShape.length;
        const dims = [];
        for (let i = 0; i < inRank; i++) {
            const dim = inRank - 1 - i;
            const a = inputShape[dim] || 1;
            const b = outputShape[outputShape.length - 1 - i] || 1;
            if (b > 1 && a === 1) {
                dims.unshift(dim);
            }
        }
        return dims;
    }
}
exports.BroadcastUtil = BroadcastUtil;
// copy array helper
// mimics memcpy as much as possible
function arrayCopyHelper(target, source, targetIndex, sourceIndex, blockSize) {
    if (sourceIndex < 0 || sourceIndex >= source.length) {
        throw new Error('sourceIndex out of bounds');
    }
    if (targetIndex < 0 || targetIndex >= target.length) {
        throw new Error('targetIndex out of bounds');
    }
    if (sourceIndex + blockSize > source.length) {
        throw new Error('source indices to be copied are outside bounds');
    }
    if (targetIndex + blockSize > target.length) {
        throw new Error('target array is too small to hold result');
    }
    for (let offset = 0; offset < blockSize; offset++) {
        target[targetIndex + offset] = source[sourceIndex + offset];
    }
}
exports.arrayCopyHelper = arrayCopyHelper;
class GemmUtil {
    // will make sure input shapes are compatible for this op
    // and return back the shape of the output in the form of a tuple
    // will throw exception if the input shapes are not compatible
    static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error('shape need to be of size 2');
        }
        let M;
        let K;
        let N;
        if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
        }
        else {
            M = leftShape[0];
            K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
            N = rightShape[0];
            kDim = 1;
        }
        else {
            N = rightShape[1];
            kDim = 0;
        }
        if (rightShape[kDim] !== K) {
            throw new Error('dimension mismatch');
        }
        if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error('invalid shape specified');
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error('gemm: invalid bias shape for broadcast');
        }
        return [M, N, K];
    }
}
exports.GemmUtil = GemmUtil;
class ProtoUtil {
    static tensorDataTypeFromProto(typeProto) {
        switch (typeProto) {
            case onnx_proto_1.onnx.TensorProto.DataType.INT8:
                return 'int8';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
                return 'uint8';
            case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
                return 'bool';
            case onnx_proto_1.onnx.TensorProto.DataType.INT16:
                return 'int16';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
                return 'uint16';
            case onnx_proto_1.onnx.TensorProto.DataType.INT32:
                return 'int32';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
                return 'uint32';
            case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
                return 'float32';
            case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
                return 'float64';
            case onnx_proto_1.onnx.TensorProto.DataType.STRING:
                return 'string';
            // For INT64/UINT64, reduce their value to 32-bits.
            // Should throw exception when overflow
            case onnx_proto_1.onnx.TensorProto.DataType.INT64:
                return 'int32';
            case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
                return 'uint32';
            default:
                throw new Error(`unsupported data type: ${onnx_proto_1.onnx.TensorProto.DataType[typeProto]}`);
        }
    }
    static tensorDataTypeStringToEnum(type) {
        switch (type) {
            case 'int8':
                return onnx_proto_1.onnx.TensorProto.DataType.INT8;
            case 'uint8':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT8;
            case 'bool':
                return onnx_proto_1.onnx.TensorProto.DataType.BOOL;
            case 'int16':
                return onnx_proto_1.onnx.TensorProto.DataType.INT16;
            case 'uint16':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT16;
            case 'int32':
                return onnx_proto_1.onnx.TensorProto.DataType.INT32;
            case 'uint32':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT32;
            case 'float32':
                return onnx_proto_1.onnx.TensorProto.DataType.FLOAT;
            case 'float64':
                return onnx_proto_1.onnx.TensorProto.DataType.DOUBLE;
            case 'string':
                return onnx_proto_1.onnx.TensorProto.DataType.STRING;
            case 'int64':
                return onnx_proto_1.onnx.TensorProto.DataType.INT64;
            case 'uint64':
                return onnx_proto_1.onnx.TensorProto.DataType.UINT64;
            default:
                throw new Error(`unsupported data type: ${type}`);
        }
    }
    static tensorDimsFromProto(dims) {
        // get rid of Long type for dims
        return dims.map(d => long_1.default.isLong(d) ? d.toNumber() : d);
    }
    static tensorValueTypeFromProto(valueType) {
        return {
            tensorType: ProtoUtil.tensorDataTypeFromProto(valueType.elemType),
            shape: { dims: ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map(d => d.dimValue)) }
        };
    }
    static tensorDimsFromORTFormat(tensor) {
        const dims = [];
        for (let i = 0; i < tensor.dimsLength(); i++) {
            dims.push(LongUtil.longToNumber(tensor.dims(i)));
        }
        return dims;
    }
    static tensorAttributesFromORTFormat(node) {
        const attributes = [];
        for (let i = 0; i < node.attributesLength(); i++) {
            attributes.push(node.attributes(i));
        }
        return attributes;
    }
}
exports.ProtoUtil = ProtoUtil;
class LongUtil {
    static longToNumber(n) {
        if (long_1.default.isLong(n)) {
            return n.toNumber();
        }
        else if (n instanceof flatbuffers_1.flatbuffers.Long) {
            return long_1.default.fromValue({ low: n.low, high: n.high, unsigned: true }).toNumber();
        }
        return n;
    }
    static isLong(n) {
        return long_1.default.isLong(n) || n instanceof flatbuffers_1.flatbuffers.Long;
    }
}
exports.LongUtil = LongUtil;
class ShapeUtil {
    static size(dims) {
        return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
    }
    // `axis` inclusive
    static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
    }
    // `axis` exclusive
    static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
    }
    static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
            // safety check as this method is called by multiple other methods requiring size.
            // size cannot be 0 or negative.
            if (dims[i] <= 0) {
                throw new Error(
                // eslint-disable-next-line max-len
                'cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.');
            }
            size *= dims[i];
        }
        return size;
    }
    static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
            return [];
        }
        else if (rank === 1) {
            return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
    }
    static transpose(dims) {
        const copy = dims.slice();
        return copy.reverse();
    }
    static indicesToOffset(indices, strides, axis) {
        if (axis === undefined) {
            axis = indices.length;
        }
        let offset = 0;
        for (let i = 0; i < axis; ++i) {
            offset += strides[i] * indices[i];
        }
        return offset;
    }
    static offsetToIndices(offset, strides) {
        const rank = strides.length;
        if (rank === 0) {
            return [];
        }
        else if (rank === 1) {
            return [offset * strides[0]];
        }
        const indices = new Array(strides.length);
        for (let i = 0; i < indices.length - 1; ++i) {
            indices[i] = Math.floor(offset / strides[i]);
            offset -= indices[i] * strides[i];
        }
        indices[indices.length - 1] = offset;
        return indices;
    }
    /**
     * normailze axis of range [-r, r) into [0, r).
     */
    static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error('unsupported axis for this operation.');
        }
        return axis < 0 ? axis + tensorRank : axis;
    }
    static normalizeAxes(axes, tensorRank) {
        return axes.map(x => this.normalizeAxis(x, tensorRank));
    }
    // Increment an index into a tensor (in lexicographic
    // ordering), wrapping around the specified upper_bound.
    /**
     * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.
     * @param index Given index to increment (Will be mutated)
     * @param dims The dimensions of the tensor for which the given index corresponds to
     * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank
     */
    static incrementIndex(index, dims, axisToIncrementOn) {
        if (dims.length === 0 || index.length === 0) {
            throw new Error('Index incrementing unsupported for scalar Tensor');
        }
        if (axisToIncrementOn === undefined) {
            axisToIncrementOn = dims.length;
        }
        else {
            if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {
                throw new Error('Incorrect axis to increment on');
            }
        }
        for (let k = axisToIncrementOn - 1; k >= 0; --k) {
            index[k]++;
            if (index[k] < dims[k]) {
                break;
            }
            index[k] = 0;
        }
    }
    /**
     * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array
     * Used in Reshape
     * @param originalDims Original Shape array
     * @param shapeHints array containing values to compute the new dimensions
     * For example:
     * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]
     * originalDims = [2,2] and shapeHints = [4] will return [4]
     * originalDims = [2,2] and shapeHints = [5] will throw an exception
     * https://github.com/onnx/onnx/blob/master/docs/Operators.md#Reshape
     */
    static calculateReshapedDims(originalDims, shapeHints) {
        // reshape to a Scalar Tensor
        if (shapeHints.length === 0) {
            if (originalDims.length === 0 || ShapeUtil.size(originalDims) === 1) {
                return [];
            }
            else {
                throw new Error('cannot reshape to a scalar Tensor');
            }
        }
        const nDims = shapeHints.length;
        const reshapedDims = new Array(nDims);
        let unknownDimension = -1;
        let newTensorSize = 1;
        for (let i = 0; i < nDims; i++) {
            if (shapeHints[i] < -1) {
                throw new Error('a dimension in shape hints cannot be less than -1');
            }
            if (shapeHints[i] === -1) {
                if (unknownDimension !== -1) {
                    throw new Error('at most one dimension in shape hints can be -1');
                }
                unknownDimension = i;
            }
            else {
                if (shapeHints[i] === 0) {
                    if (i >= originalDims.length) {
                        throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');
                    }
                    reshapedDims[i] = originalDims[i];
                }
                else {
                    reshapedDims[i] = shapeHints[i];
                }
                newTensorSize *= reshapedDims[i];
            }
        }
        const oldTensorSize = ShapeUtil.size(originalDims);
        if (unknownDimension !== -1) {
            if (oldTensorSize % newTensorSize !== 0) {
                throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${originalDims}] Output shape: [${shapeHints}]`);
            }
            reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;
        }
        // validate sizes from originalDims and reshapedDims match
        else {
            if (newTensorSize !== oldTensorSize) {
                throw new Error('reshapedDims and originalDims don\'t have matching sizes');
            }
        }
        return reshapedDims;
    }
    /**
     * Sorts a given array based on the indices in the Perm array
     * Used in Transpose
     * @param a Array to be sorted such as dims or strides
     * @param perm Perm given; if null a will be reversed
     */
    static sortBasedOnPerm(a, perm) {
        if (perm) {
            return perm.map((v) => a[v]);
        }
        else {
            return a.slice().reverse();
        }
    }
    /**
     * Pads a given shape according to the padding values
     * @param dims shape of the Tensor to be padded
     * @param pad pad values
     */
    static padShape(dims, pad) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad[i] + pad[i + rank]);
    }
    /**
     * Determines if the two shapes are identical
     * @param shape1
     * @param shape2
     */
    static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
            return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
    }
    /**
     * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size
     * @param dims - input `dims` that needs to be checked
     */
    static validateDimsAndCalcSize(dims) {
        if (dims.length > 6) {
            throw new TypeError('Only rank 0 to 6 is supported for tensor shape.');
        }
        let size = 1;
        for (const n of dims) {
            if (!Number.isInteger(n)) {
                throw new TypeError(`Invalid shape: ${n} is not an integer`);
            }
            if (n < 0 || n > 2147483647) {
                throw new TypeError(`Invalid shape: length ${n} is not allowed`);
            }
            size *= n;
        }
        return size;
    }
    /**
     * Determines the shape of output tensor y = flatten(x, axis)
     * @param dims - shape of input tensor
     * @param axis - flatten axis, in the range [-r, r]
     */
    static flattenShape(dims, axis) {
        if (axis < 0) {
            axis += dims.length;
        }
        const total = dims.reduce((x, y) => x * y, 1);
        const right = dims.slice(axis).reduce((x, y) => x * y, 1);
        const outputDims = [total / right, right];
        return outputDims;
    }
    /**
     * Determines the shape of output tensor y = squeeze(x, axes)
     * @param dims - shape of input tensor
     * @param axes - squeeze axes
     */
    static squeezeShape(dims, axes) {
        const outputDims = new Array();
        // sanity check
        axes = ShapeUtil.normalizeAxes(axes, dims.length);
        for (let i = 0; i < dims.length; i++) {
            const inSqueezeList = axes.indexOf(i) >= 0;
            if (inSqueezeList && dims[i] !== 1) {
                throw new Error('squeeze an axis of size different than 1');
            }
            if ((axes.length === 0 && dims[i] > 1) || (axes.length > 0 && !inSqueezeList)) {
                outputDims.push(dims[i]);
            }
        }
        return outputDims;
    }
    /**
     * Determines the shape of output tensor y = unsqueeze(x, axes)
     * @param dims - shape of input tensor
     * @param axes - unsqueeze axes
     */
    static unsqueezeShape(dims, axes) {
        const outputDims = new Array(dims.length + axes.length);
        // initialize the array elements to 0
        outputDims.fill(0);
        // set all axes indices to 1 in outputDims and check for duplicates
        for (let i = 0; i < axes.length; i++) {
            const axis = ShapeUtil.normalizeAxis(axes[i], dims.length);
            if (axis >= outputDims.length) {
                throw new Error('\'axes\' has an out of range axis');
            }
            if (outputDims[axis] !== 0) {
                throw new Error('\'axes\' has a duplicate axis');
            }
            outputDims[axis] = 1;
        }
        // fill in the zero entries of outputDims with the input tensor's shape
        let inputDimsIterator = 0;
        for (let i = 0; i < outputDims.length; i++) {
            if (outputDims[i] === 0) {
                outputDims[i] = dims[inputDimsIterator++];
            }
        }
        // sanity check assertion. 'inputDimsIterator'
        // should be equal to the length of 'dims'
        if (inputDimsIterator !== dims.length) {
            throw new Error('the unsqueezed dimension could not be established');
        }
        return outputDims;
    }
}
exports.ShapeUtil = ShapeUtil;
// bunch of helper methods that do a variety of math operations
class MathUtil {
    // y = (x*x) + y
    static sqr(target, source, targetIndex, sourceIndex, blockSize) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (let offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] += Math.pow(source[sourceIndex + offset], 2);
        }
    }
    // y = ax + y
    static axpy(target, source, targetIndex, sourceIndex, blockSize, alpha) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (let offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] += (alpha * source[sourceIndex + offset]);
        }
    }
    // y = pow(x, b)
    static powx(target, source, targetIndex, sourceIndex, blockSize, b) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (let offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] = Math.pow(source[sourceIndex + offset], b);
        }
    }
    // y = x * y
    static mul(target, source, targetIndex, sourceIndex, blockSize) {
        if (sourceIndex < 0 || sourceIndex >= source.length) {
            throw new Error('sourceIndex out of bounds');
        }
        if (targetIndex < 0 || targetIndex >= target.length) {
            throw new Error('targetIndex out of bounds');
        }
        if (sourceIndex + blockSize > source.length) {
            throw new Error('source indices to be copied are outside bounds');
        }
        if (targetIndex + blockSize > target.length) {
            throw new Error('target array is too small to hold result');
        }
        for (let offset = 0; offset < blockSize; offset++) {
            target[targetIndex + offset] = (source[sourceIndex + offset] * target[targetIndex + offset]);
        }
    }
}
exports.MathUtil = MathUtil;
class SplitUtil {
    /**
     * Calculates new Shapes from existing one and the splits given along the axis provides
     * @param dims Shape of the Tensor to be splitted into two or more Shapes
     * @param axis The dimension along which the Tensor will be split
     * @param splits Offsets for the start of each split
     */
    static splitShape(dims, axis, split, numOutputs) {
        if (split.length === 0) {
            if (!numOutputs) {
                throw new Error('need to know number of outputs when the \'split\' attribute is not specified');
            }
            SplitUtil.determineSplit(dims[axis], numOutputs, split);
        }
        const shapes = [];
        const offsets = [0];
        for (let i = 0; i < split.length; ++i) {
            if (i !== 0) {
                offsets.push(offsets[i - 1] + split[i - 1]);
            }
            const shape = dims.slice();
            shape[axis] = split[i];
            shapes.push(shape);
        }
        return [shapes, offsets];
    }
    static determineSplit(numElementsAlongAxis, numOutputs, split) {
        // If 'split' is not specified by the user, we need to partition the number of elements equally among the outputs
        if (numElementsAlongAxis % numOutputs !== 0) {
            throw new Error('cannot split tensor to equal sized parts');
        }
        for (let i = 0; i < numOutputs; ++i) {
            split.push(numElementsAlongAxis / numOutputs);
        }
    }
}
exports.SplitUtil = SplitUtil;
class ReduceUtil {
    /**
     * Perform reduce operations on the specific operator
     * @param a Input tensor data
     * @param axes The dimensions along which the Tensor will be reduced
     * @param keepdims If set to true, the axes which are reduced are left in the
     *    result as dimensions with size one.
     * @param op1 The operation to be performed on each element in the tensor
     * @param op2 The operation to be performed between elements in the tensor
     */
    static calcReduce(a, axes, keepdims, op1, op2) {
        const dims = a.dims.slice(0);
        // if axes is not set, perform reduce on all axes
        if (axes.length === 0) {
            dims.forEach((d, ind) => axes.push(ind));
        }
        // get a temporary broadcastable output shape
        const outputDims = ReduceUtil.calcReduceShape(dims, axes, true);
        // loop through the output and calculate result one by one
        const size = ShapeUtil.size(outputDims);
        const y = new tensor_1.Tensor(outputDims, a.type);
        const strides = ShapeUtil.computeStrides(outputDims);
        const inputStrides = ShapeUtil.computeStrides(dims);
        const indicesY = new Array(dims.length);
        for (let i = 0; i < size; i++) {
            const indices = ShapeUtil.offsetToIndices(i, strides);
            // map index
            BroadcastUtil.fillIndex(indices, dims, indicesY);
            y.set(indices, ReduceUtil.calcReduceByAxis(a.numberData, axes, dims, 0, ShapeUtil.indicesToOffset(indicesY, inputStrides), op1, op2));
        }
        if (keepdims) {
            return y;
        }
        else {
            // keepdims == 0, calculate the expected shape
            return new tensor_1.Tensor(ReduceUtil.calcReduceShape(dims, axes, keepdims), y.type, undefined, undefined, y.data, y.dataId);
        }
    }
    /**
     * Perform reduce operations on the specific operator on specific axes
     * @param a Input tensor data
     * @param axes The dimensions along which the Tensor will be reduced
     * @param dims The input dimension.
     * @param curAxisInd Index in axes specifying the current dimension along
     *      which the tensor will be reduced
     * @param pos The current index of element to perform operation
     * @param op1 The operation to be performed on each element in the tensor
     * @param op2 The operation to be performed between elements in the tensor
     */
    static calcReduceByAxis(input, axes, dims, curAxisInd, pos, op1, op2) {
        let res = 0;
        if (curAxisInd >= axes.length) {
            return op1(input[pos]);
        }
        const axis = axes[curAxisInd];
        const step = axis >= dims.length ? 1 : ShapeUtil.size(dims.slice(axis + 1));
        for (let i = 0; i < dims[axis]; i++) {
            res = i === 0 ? ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2) :
                op2(res, ReduceUtil.calcReduceByAxis(input, axes, dims, curAxisInd + 1, pos, op1, op2));
            pos += step;
        }
        return res;
    }
    /**
     * Calculate the expected shape of a reduce operation
     * @param dims The input tensor dimension
     * @param axes The dimensions along which the Tensor will be reduced
     * @param keepdims If set to true, the axes which are reduced are left in the
     *    result as dimensions with size one.
     */
    static calcReduceShape(dims, axes, keepDims) {
        const outputDims = dims.slice();
        for (let i = 0; i < axes.length; i++) {
            if (keepDims) {
                outputDims[axes[i]] = 1;
            }
            else {
                outputDims[axes[i]] = 0;
            }
        }
        return outputDims.filter(dim => dim !== 0);
    }
}
exports.ReduceUtil = ReduceUtil;
class PoolConvUtil {
    /**
     * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
     * @param isGlobalOperator If true, perform global pooling.
     * @param inputDims The input tensor dimension.
     * @param kernelShape The size of the kernel along each axis.
     * @param strides Stride along each axis.
     * @param pads Padding for the beginning and ending along each axis.
     */
    static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error('length of specified kernel shapes should be 2 less than length of input dimensions');
        }
        if (isGlobalOperator) {
            // adjust kernel shape to cover the input dims
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
                if (dim >= kernelShape.length) {
                    kernelShape.push(inputDims[dim + 2]);
                }
                else {
                    kernelShape[dim] = inputDims[dim + 2];
                }
            }
        }
        // adjust strides length to match kernel shape length
        for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
                if (strides[dim] < 0) {
                    throw new Error('strides should be greater than or equal to 1');
                }
            }
            else {
                strides.push(1);
            }
        }
        // adjust pads length to match 2 * kernel shape length
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
                if (pads[dim] < 0) {
                    throw new Error('pad should be greater than or equal to 1');
                }
            }
            else {
                pads.push(0);
            }
        }
        // sanity checks for values in kernel shapes and pads
        for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
                throw new Error('kernel shapes need to be greater than 0');
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
                throw new Error('pads should be smaller than kernel');
            }
        }
    }
    // adjust pad values based on 'autoPad' attribute
    static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (!autoPad) {
            return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error('length of pads should be twice the length of data dimensions');
        }
        if (strides.length !== (inputDims.length - 2)) {
            throw new Error('length of strides should be the length of data dimensions');
        }
        if (kernelShape.length !== (inputDims.length - 2)) {
            throw new Error('length of kernel shapes should be the length of data dimensions');
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
            PoolConvUtil.adjustPadAndReturnShape(inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2, autoPad);
        }
    }
    /**
     * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
     * @param isGlobalOperator If true, perform global pooling.
     * @param inputDims The input tensor dimension. (inputs[0].dims)
     * @param strides Stride along each axis.
     * @param kernelShape The size of the kernel along each axis.
     * @param pads Padding for the beginning and ending along each axis.
     * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
     *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
     */
    static computePoolOutputShape(isGlobalOperator, inputDims, strides, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
            throw new Error('input shape must be of size greater than 0');
        }
        // Add batch size and number of channels of output
        const outputDims = [inputDims[0], inputDims[1]];
        // TODO: support dilations for pool operators
        const dilations = new Array(kernelShape.length).fill(1);
        PoolConvUtil.computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
    }
    /**
     * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
     * @param inputDims The input tensor dimension. (inputs[0].dims)
     * @param filterDims The filter tensor dimension. (inputs[1].dims)
     * @param strides Stride along each axis.
     * @param kernelShape The size of the kernel along each axis.
     * @param pads Padding for the beginning and ending along each axis.
     * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
     *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
     */
    static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error('invalid input tensor dims or invalid filter tensor dims');
        }
        // Add batch size and number of channels of output
        const outputDims = [inputDims[0], filterDims[0]];
        PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
    }
    // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
    // called by computePoolOutputShape() and computeConvOutputShape()
    // adjust pads based on 'autoPad' attribute prior to shape computation
    static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
                outputDims.push(1);
            }
        }
        else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
                outputDims.push(PoolConvUtil.adjustPadAndReturnShape(inputDims[dim + 2], strides[dim], dilations[dim], kernelShape[dim], pads, dim, dim + inputDims.length - 2, autoPad));
            }
        }
    }
    // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
    // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
    static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== 'NOTSET') {
            switch (autoPad) {
                case 'VALID':
                    pads[padHeadIndex] = 0;
                    pads[padTailIndex] = 0;
                    return Math.floor(((inSize - dkernel) / stride) + 1);
                case 'SAME_LOWER':
                case 'SAME_UPPER':
                    if (dilation !== 1) {
                        throw new Error('Dilation not supported for SAME_UPPER or SAME_LOWER');
                    }
                    else {
                        const legacyTargetSize = (inSize + stride - 1) / stride;
                        const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                        pads[padHeadIndex] =
                            (autoPad === 'SAME_LOWER') ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                        pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                        return Math.floor(((inSize + padNeeded - kernel) / stride) + 1);
                    }
                default:
                    throw new Error('Unsupported AutoPad type');
            }
        }
        else {
            return Math.floor(((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride) + 1);
        }
    }
}
exports.PoolConvUtil = PoolConvUtil;


/***/ }),

/***/ "./lib/wasm/options-utils.ts":
/*!***********************************!*\
  !*** ./lib/wasm/options-utils.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.iterateExtraOptions = void 0;
const iterateExtraOptions = (options, prefix, seen, handler) => {
    if (typeof options == 'object' && options !== null) {
        if (seen.has(options)) {
            throw new Error('Circular reference in options');
        }
        else {
            seen.add(options);
        }
    }
    Object.entries(options).forEach(([key, value]) => {
        const name = (prefix) ? prefix + key : key;
        if (typeof value === 'object') {
            exports.iterateExtraOptions(value, name + '.', seen, handler);
        }
        else if (typeof value === 'string' || typeof value === 'number') {
            handler(name, value.toString());
        }
        else if (typeof value === 'boolean') {
            handler(name, (value) ? '1' : '0');
        }
        else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
        }
    });
};
exports.iterateExtraOptions = iterateExtraOptions;


/***/ }),

/***/ "./lib/wasm/run-options.ts":
/*!*********************************!*\
  !*** ./lib/wasm/run-options.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setRunOptions = void 0;
const options_utils_1 = __webpack_require__(/*! ./options-utils */ "./lib/wasm/options-utils.ts");
const string_utils_1 = __webpack_require__(/*! ./string-utils */ "./lib/wasm/string-utils.ts");
const wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
const setRunOptions = (options) => {
    const wasm = wasm_factory_1.getInstance();
    let runOptionsHandle = 0;
    const allocs = [];
    const runOptions = options || {};
    try {
        if ((options === null || options === void 0 ? void 0 : options.logSeverityLevel) === undefined) {
            runOptions.logSeverityLevel = 2; // Default to warning
        }
        else if (typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||
            options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
        }
        if ((options === null || options === void 0 ? void 0 : options.logVerbosityLevel) === undefined) {
            runOptions.logVerbosityLevel = 0; // Default to 0
        }
        else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        if ((options === null || options === void 0 ? void 0 : options.terminate) === undefined) {
            runOptions.terminate = false;
        }
        let tagDataOffset = 0;
        if ((options === null || options === void 0 ? void 0 : options.tag) !== undefined) {
            tagDataOffset = string_utils_1.allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm._OrtCreateRunOptions(runOptions.logSeverityLevel, runOptions.logVerbosityLevel, !!runOptions.terminate, tagDataOffset);
        if (runOptionsHandle === 0) {
            throw new Error('Can\'t create run options');
        }
        if ((options === null || options === void 0 ? void 0 : options.extra) !== undefined) {
            options_utils_1.iterateExtraOptions(options.extra, '', new WeakSet(), (key, value) => {
                const keyDataOffset = string_utils_1.allocWasmString(key, allocs);
                const valueDataOffset = string_utils_1.allocWasmString(value, allocs);
                if (wasm._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    throw new Error(`Can't set a run config entry: ${key} - ${value}`);
                }
            });
        }
        return [runOptionsHandle, allocs];
    }
    catch (e) {
        if (runOptionsHandle !== 0) {
            wasm._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach(wasm._free);
        throw e;
    }
};
exports.setRunOptions = setRunOptions;


/***/ }),

/***/ "./lib/wasm/session-handler.ts":
/*!*************************************!*\
  !*** ./lib/wasm/session-handler.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnnxruntimeWebAssemblySessionHandler = void 0;
const onnx_proto_1 = __webpack_require__(/*! onnx-proto */ "./node_modules/onnx-proto/dist/onnx.js");
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const run_options_1 = __webpack_require__(/*! ./run-options */ "./lib/wasm/run-options.ts");
const session_options_1 = __webpack_require__(/*! ./session-options */ "./lib/wasm/session-options.ts");
const string_utils_1 = __webpack_require__(/*! ./string-utils */ "./lib/wasm/string-utils.ts");
const wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
let ortInit;
const tensorDataTypeStringToEnum = (type) => {
    switch (type) {
        case 'int8':
            return onnx_proto_1.onnx.TensorProto.DataType.INT8;
        case 'uint8':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT8;
        case 'bool':
            return onnx_proto_1.onnx.TensorProto.DataType.BOOL;
        case 'int16':
            return onnx_proto_1.onnx.TensorProto.DataType.INT16;
        case 'uint16':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT16;
        case 'int32':
            return onnx_proto_1.onnx.TensorProto.DataType.INT32;
        case 'uint32':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT32;
        case 'float32':
            return onnx_proto_1.onnx.TensorProto.DataType.FLOAT;
        case 'float64':
            return onnx_proto_1.onnx.TensorProto.DataType.DOUBLE;
        case 'string':
            return onnx_proto_1.onnx.TensorProto.DataType.STRING;
        case 'int64':
            return onnx_proto_1.onnx.TensorProto.DataType.INT64;
        case 'uint64':
            return onnx_proto_1.onnx.TensorProto.DataType.UINT64;
        default:
            throw new Error(`unsupported data type: ${type}`);
    }
};
const tensorDataTypeEnumToString = (typeProto) => {
    switch (typeProto) {
        case onnx_proto_1.onnx.TensorProto.DataType.INT8:
            return 'int8';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT8:
            return 'uint8';
        case onnx_proto_1.onnx.TensorProto.DataType.BOOL:
            return 'bool';
        case onnx_proto_1.onnx.TensorProto.DataType.INT16:
            return 'int16';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT16:
            return 'uint16';
        case onnx_proto_1.onnx.TensorProto.DataType.INT32:
            return 'int32';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT32:
            return 'uint32';
        case onnx_proto_1.onnx.TensorProto.DataType.FLOAT:
            return 'float32';
        case onnx_proto_1.onnx.TensorProto.DataType.DOUBLE:
            return 'float64';
        case onnx_proto_1.onnx.TensorProto.DataType.STRING:
            return 'string';
        case onnx_proto_1.onnx.TensorProto.DataType.INT64:
            return 'int32';
        case onnx_proto_1.onnx.TensorProto.DataType.UINT64:
            return 'uint32';
        default:
            throw new Error(`unsupported data type: ${onnx_proto_1.onnx.TensorProto.DataType[typeProto]}`);
    }
};
const numericTensorTypeToTypedArray = (type) => {
    switch (type) {
        case 'float32':
            return Float32Array;
        case 'uint8':
            return Uint8Array;
        case 'int8':
            return Int8Array;
        case 'uint16':
            return Uint16Array;
        case 'int16':
            return Int16Array;
        case 'int32':
            return Int32Array;
        case 'bool':
            return Uint8Array;
        case 'float64':
            return Float64Array;
        case 'uint32':
            return Uint32Array;
        case 'int64':
            return BigInt64Array;
        case 'uint64':
            return BigUint64Array;
        default:
            throw new Error(`unsupported type: ${type}`);
    }
};
const getLogLevel = (logLevel) => {
    switch (logLevel) {
        case 'verbose':
            return 0;
        case 'info':
            return 1;
        case 'warning':
            return 2;
        case 'error':
            return 3;
        case 'fatal':
            return 4;
        default:
            throw new Error(`unsupported logging level: ${logLevel}`);
    }
};
class OnnxruntimeWebAssemblySessionHandler {
    loadModel(model, options) {
        const wasm = wasm_factory_1.getInstance();
        if (!ortInit) {
            const errorCode = wasm._OrtInit(onnxruntime_common_1.env.wasm.numThreads, getLogLevel(onnxruntime_common_1.env.logLevel));
            if (errorCode !== 0) {
                throw new Error(`Can't initialize onnxruntime. error code = ${errorCode}`);
            }
            ortInit = true;
        }
        const modelDataOffset = wasm._malloc(model.byteLength);
        let sessionOptionsHandle = 0;
        let allocs = [];
        try {
            [sessionOptionsHandle, allocs] = session_options_1.setSessionOptions(options);
            wasm.HEAPU8.set(model, modelDataOffset);
            this.sessionHandle = wasm._OrtCreateSession(modelDataOffset, model.byteLength, sessionOptionsHandle);
            if (this.sessionHandle === 0) {
                throw new Error('Can\'t create a session');
            }
        }
        finally {
            wasm._free(modelDataOffset);
            wasm._OrtReleaseSessionOptions(sessionOptionsHandle);
            allocs.forEach(wasm._free);
        }
        const inputCount = wasm._OrtGetInputCount(this.sessionHandle);
        const outputCount = wasm._OrtGetOutputCount(this.sessionHandle);
        this.inputNames = [];
        this.inputNamesUTF8Encoded = [];
        this.outputNames = [];
        this.outputNamesUTF8Encoded = [];
        for (let i = 0; i < inputCount; i++) {
            const name = wasm._OrtGetInputName(this.sessionHandle, i);
            if (name === 0) {
                throw new Error('Can\'t get an input name');
            }
            this.inputNamesUTF8Encoded.push(name);
            this.inputNames.push(wasm.UTF8ToString(name));
        }
        for (let i = 0; i < outputCount; i++) {
            const name = wasm._OrtGetOutputName(this.sessionHandle, i);
            if (name === 0) {
                throw new Error('Can\'t get an output name');
            }
            this.outputNamesUTF8Encoded.push(name);
            this.outputNames.push(wasm.UTF8ToString(name));
        }
    }
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            const wasm = wasm_factory_1.getInstance();
            if (this.inputNamesUTF8Encoded) {
                this.inputNamesUTF8Encoded.forEach(wasm._OrtFree);
                this.inputNamesUTF8Encoded = [];
            }
            if (this.outputNamesUTF8Encoded) {
                this.outputNamesUTF8Encoded.forEach(wasm._OrtFree);
                this.outputNamesUTF8Encoded = [];
            }
            if (this.sessionHandle) {
                wasm._OrtReleaseSession(this.sessionHandle);
                this.sessionHandle = 0;
            }
        });
    }
    run(feeds, fetches, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const wasm = wasm_factory_1.getInstance();
            const inputArray = [];
            const inputIndices = [];
            Object.entries(feeds).forEach(kvp => {
                const name = kvp[0];
                const tensor = kvp[1];
                const index = this.inputNames.indexOf(name);
                if (index === -1) {
                    throw new Error(`invalid input '${name}'`);
                }
                inputArray.push(tensor);
                inputIndices.push(index);
            });
            const outputIndices = [];
            Object.entries(fetches).forEach(kvp => {
                const name = kvp[0];
                // TODO: support pre-allocated output
                const index = this.outputNames.indexOf(name);
                if (index === -1) {
                    throw new Error(`invalid output '${name}'`);
                }
                outputIndices.push(index);
            });
            const inputCount = inputIndices.length;
            const outputCount = outputIndices.length;
            let runOptionsHandle = 0;
            let runOptionsAllocs = [];
            const inputValues = [];
            const inputAllocs = [];
            try {
                [runOptionsHandle, runOptionsAllocs] = run_options_1.setRunOptions(options);
                // create input tensors
                for (let i = 0; i < inputCount; i++) {
                    const data = inputArray[i].data;
                    let dataOffset;
                    let dataByteLength;
                    if (Array.isArray(data)) {
                        // string tensor
                        dataByteLength = 4 * data.length;
                        dataOffset = wasm._malloc(dataByteLength);
                        inputAllocs.push(dataOffset);
                        let dataIndex = dataOffset / 4;
                        for (let i = 0; i < data.length; i++) {
                            if (typeof data[i] !== 'string') {
                                throw new TypeError(`tensor data at index ${i} is not a string`);
                            }
                            wasm.HEAPU32[dataIndex++] = string_utils_1.allocWasmString(data[i], inputAllocs);
                        }
                    }
                    else {
                        dataByteLength = data.byteLength;
                        dataOffset = wasm._malloc(dataByteLength);
                        inputAllocs.push(dataOffset);
                        wasm.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), dataOffset);
                    }
                    const dims = inputArray[i].dims;
                    const stack = wasm.stackSave();
                    const dimsOffset = wasm.stackAlloc(4 * dims.length);
                    try {
                        let dimIndex = dimsOffset / 4;
                        dims.forEach(d => wasm.HEAP32[dimIndex++] = d);
                        const tensor = wasm._OrtCreateTensor(tensorDataTypeStringToEnum(inputArray[i].type), dataOffset, dataByteLength, dimsOffset, dims.length);
                        if (tensor === 0) {
                            throw new Error('Can\'t create a tensor');
                        }
                        inputValues.push(tensor);
                    }
                    finally {
                        wasm.stackRestore(stack);
                    }
                }
                const beforeRunStack = wasm.stackSave();
                const inputValuesOffset = wasm.stackAlloc(inputCount * 4);
                const inputNamesOffset = wasm.stackAlloc(inputCount * 4);
                const outputValuesOffset = wasm.stackAlloc(outputCount * 4);
                const outputNamesOffset = wasm.stackAlloc(outputCount * 4);
                try {
                    let inputValuesIndex = inputValuesOffset / 4;
                    let inputNamesIndex = inputNamesOffset / 4;
                    let outputValuesIndex = outputValuesOffset / 4;
                    let outputNamesIndex = outputNamesOffset / 4;
                    for (let i = 0; i < inputCount; i++) {
                        wasm.HEAPU32[inputValuesIndex++] = inputValues[i];
                        wasm.HEAPU32[inputNamesIndex++] = this.inputNamesUTF8Encoded[inputIndices[i]];
                    }
                    for (let i = 0; i < outputCount; i++) {
                        wasm.HEAPU32[outputValuesIndex++] = 0;
                        wasm.HEAPU32[outputNamesIndex++] = this.outputNamesUTF8Encoded[outputIndices[i]];
                    }
                    // support RunOptions
                    let errorCode = wasm._OrtRun(this.sessionHandle, inputNamesOffset, inputValuesOffset, inputCount, outputNamesOffset, outputCount, outputValuesOffset, runOptionsHandle);
                    const output = {};
                    if (errorCode === 0) {
                        for (let i = 0; i < outputCount; i++) {
                            const tensor = wasm.HEAPU32[outputValuesOffset / 4 + i];
                            const beforeGetTensorDataStack = wasm.stackSave();
                            // stack allocate 4 pointer value
                            const tensorDataOffset = wasm.stackAlloc(4 * 4);
                            let type, dataOffset = 0;
                            try {
                                errorCode = wasm._OrtGetTensorData(tensor, tensorDataOffset, tensorDataOffset + 4, tensorDataOffset + 8, tensorDataOffset + 12);
                                if (errorCode !== 0) {
                                    throw new Error(`Can't get a tensor data. error code = ${errorCode}`);
                                }
                                let tensorDataIndex = tensorDataOffset / 4;
                                const dataType = wasm.HEAPU32[tensorDataIndex++];
                                dataOffset = wasm.HEAPU32[tensorDataIndex++];
                                const dimsOffset = wasm.HEAPU32[tensorDataIndex++];
                                const dimsLength = wasm.HEAPU32[tensorDataIndex++];
                                const dims = [];
                                for (let i = 0; i < dimsLength; i++) {
                                    dims.push(wasm.HEAPU32[dimsOffset / 4 + i]);
                                }
                                wasm._OrtFree(dimsOffset);
                                const size = dims.length === 0 ? 1 : dims.reduce((a, b) => a * b);
                                type = tensorDataTypeEnumToString(dataType);
                                if (type === 'string') {
                                    const stringData = [];
                                    let dataIndex = dataOffset / 4;
                                    for (let i = 0; i < size; i++) {
                                        const offset = wasm.HEAPU32[dataIndex++];
                                        const maxBytesToRead = i === size - 1 ? undefined : wasm.HEAPU32[dataIndex] - offset;
                                        stringData.push(wasm.UTF8ToString(offset, maxBytesToRead));
                                    }
                                    output[this.outputNames[outputIndices[i]]] = new onnxruntime_common_1.Tensor('string', stringData, dims);
                                }
                                else {
                                    const typedArray = numericTensorTypeToTypedArray(type);
                                    const t = new onnxruntime_common_1.Tensor(type, new typedArray(size), dims);
                                    new Uint8Array(t.data.buffer, t.data.byteOffset, t.data.byteLength)
                                        .set(wasm.HEAPU8.subarray(dataOffset, dataOffset + t.data.byteLength));
                                    output[this.outputNames[outputIndices[i]]] = t;
                                }
                            }
                            finally {
                                wasm.stackRestore(beforeGetTensorDataStack);
                                if (type === 'string' && dataOffset) {
                                    wasm._free(dataOffset);
                                }
                                wasm._OrtReleaseTensor(tensor);
                            }
                        }
                    }
                    if (errorCode === 0) {
                        return output;
                    }
                    else {
                        throw new Error(`failed to call OrtRun(). error code = ${errorCode}.`);
                    }
                }
                finally {
                    wasm.stackRestore(beforeRunStack);
                }
            }
            finally {
                inputValues.forEach(wasm._OrtReleaseTensor);
                inputAllocs.forEach(wasm._free);
                wasm._OrtReleaseRunOptions(runOptionsHandle);
                runOptionsAllocs.forEach(wasm._free);
            }
        });
    }
    startProfiling() {
        // TODO: implement profiling
    }
    endProfiling() {
        // TODO: implement profiling
    }
}
exports.OnnxruntimeWebAssemblySessionHandler = OnnxruntimeWebAssemblySessionHandler;


/***/ }),

/***/ "./lib/wasm/session-options.ts":
/*!*************************************!*\
  !*** ./lib/wasm/session-options.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSessionOptions = void 0;
const options_utils_1 = __webpack_require__(/*! ./options-utils */ "./lib/wasm/options-utils.ts");
const string_utils_1 = __webpack_require__(/*! ./string-utils */ "./lib/wasm/string-utils.ts");
const wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
const getGraphOptimzationLevel = (graphOptimizationLevel) => {
    switch (graphOptimizationLevel) {
        case 'disabled':
            return 0;
        case 'basic':
            return 1;
        case 'extended':
            return 2;
        case 'all':
            return 99;
        default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
    }
};
const getExecutionMode = (executionMode) => {
    switch (executionMode) {
        case 'sequential':
            return 0;
        case 'parallel':
            return 1;
        default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
    }
};
const setSessionOptions = (options) => {
    const wasm = wasm_factory_1.getInstance();
    let sessionOptionsHandle = 0;
    const allocs = [];
    const sessionOptions = options || {};
    try {
        if ((options === null || options === void 0 ? void 0 : options.graphOptimizationLevel) === undefined) {
            sessionOptions.graphOptimizationLevel = 'all';
        }
        const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel);
        if ((options === null || options === void 0 ? void 0 : options.enableCpuMemArena) === undefined) {
            sessionOptions.enableCpuMemArena = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.enableMemPattern) === undefined) {
            sessionOptions.enableMemPattern = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.executionMode) === undefined) {
            sessionOptions.executionMode = 'sequential';
        }
        const executionMode = getExecutionMode(sessionOptions.executionMode);
        let logIdDataOffset = 0;
        if ((options === null || options === void 0 ? void 0 : options.logId) !== undefined) {
            logIdDataOffset = string_utils_1.allocWasmString(options.logId, allocs);
        }
        if ((options === null || options === void 0 ? void 0 : options.logSeverityLevel) === undefined) {
            sessionOptions.logSeverityLevel = 2; // Default to warning
        }
        else if (typeof options.logSeverityLevel !== 'number' || !Number.isInteger(options.logSeverityLevel) ||
            options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
        }
        if ((options === null || options === void 0 ? void 0 : options.logVerbosityLevel) === undefined) {
            sessionOptions.logVerbosityLevel = 0; // Default to 0
        }
        else if (typeof options.logVerbosityLevel !== 'number' || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        // TODO: Support profiling
        sessionOptions.enableProfiling = false;
        sessionOptionsHandle = wasm._OrtCreateSessionOptions(graphOptimizationLevel, !!sessionOptions.enableCpuMemArena, !!sessionOptions.enableMemPattern, executionMode, sessionOptions.enableProfiling, 0, logIdDataOffset, sessionOptions.logSeverityLevel, sessionOptions.logVerbosityLevel);
        if (sessionOptionsHandle === 0) {
            throw new Error('Can\'t create session options');
        }
        if ((options === null || options === void 0 ? void 0 : options.extra) !== undefined) {
            options_utils_1.iterateExtraOptions(options.extra, '', new WeakSet(), (key, value) => {
                const keyDataOffset = string_utils_1.allocWasmString(key, allocs);
                const valueDataOffset = string_utils_1.allocWasmString(value, allocs);
                if (wasm._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    throw new Error(`Can't set a session config entry: ${key} - ${value}`);
                }
            });
        }
        if (options === null || options === void 0 ? void 0 : options.executionProviders) {
            const eps = options.executionProviders;
            const epsNames = eps.map(i => typeof i === 'string' ? i : i.name);
            if (epsNames.indexOf('webnn') !== -1) {
                if (wasm._OrtSessionOptionsAppendExecutionProviderWebNN(sessionOptionsHandle, 0) !== 0) {
                    throw new Error(`Can't append WebNN execution provider`);
                }
            }
        }
        return [sessionOptionsHandle, allocs];
    }
    catch (e) {
        if (sessionOptionsHandle !== 0) {
            wasm._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach(wasm._free);
        throw e;
    }
};
exports.setSessionOptions = setSessionOptions;


/***/ }),

/***/ "./lib/wasm/string-utils.ts":
/*!**********************************!*\
  !*** ./lib/wasm/string-utils.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.allocWasmString = void 0;
const wasm_factory_1 = __webpack_require__(/*! ./wasm-factory */ "./lib/wasm/wasm-factory.ts");
const allocWasmString = (data, allocs) => {
    const wasm = wasm_factory_1.getInstance();
    const dataLength = wasm.lengthBytesUTF8(data) + 1;
    const dataOffset = wasm._malloc(dataLength);
    wasm.stringToUTF8(data, dataOffset, dataLength);
    allocs.push(dataOffset);
    return dataOffset;
};
exports.allocWasmString = allocWasmString;


/***/ }),

/***/ "./lib/wasm/wasm-factory.ts":
/*!**********************************!*\
  !*** ./lib/wasm/wasm-factory.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var __dirname = "/";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dispose = exports.getInstance = exports.initializeWebAssembly = void 0;
const onnxruntime_common_1 = __webpack_require__(/*! onnxruntime-common */ "onnxruntime-common");
const path = __importStar(__webpack_require__(/*! path */ "?7aa5"));
const ort_wasm_threaded_js_1 = __importDefault(__webpack_require__(/*! ./binding/ort-wasm-threaded.js */ "./lib/wasm/binding/ort-wasm-threaded.js"));
const ort_wasm_js_1 = __importDefault(__webpack_require__(/*! ./binding/ort-wasm.js */ "./lib/wasm/binding/ort-wasm.js"));
let wasm;
let initialized = false;
let initializing = false;
let aborted = false;
const isMultiThreadSupported = () => {
    try {
        if ((typeof process !== 'undefined') &&
            (typeof process.versions !== 'undefined') &&
            (typeof process.versions.node !== 'undefined')) {
            throw Error('Threads is not supported in Node.js');
        }
        // Test for transferability of SABs (for browsers. needed for Firefox)
        // https://groups.google.com/forum/#!msg/mozilla.dev.platform/IHkBZlHETpA/dwsMNchWEQAJ
        if (typeof MessageChannel !== 'undefined') {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        // Test for WebAssembly threads capability (for both browsers and Node.js)
        // This typed array is a WebAssembly program containing threaded instructions.
        return WebAssembly.validate(new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5,
            4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11
        ]));
    }
    catch (e) {
        return false;
    }
};
const isSimdSupported = () => {
    try {
        // Test for WebAssembly SIMD capability (for both browsers and Node.js)
        // This typed array is a WebAssembly program containing SIMD instructions.
        return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]));
    }
    catch (e) {
        return false;
    }
};
const initializeWebAssembly = () => __awaiter(void 0, void 0, void 0, function* () {
    if (initialized) {
        return Promise.resolve();
    }
    if (initializing) {
        throw new Error('multiple calls to \'initializeWebAssembly()\' detected.');
    }
    if (aborted) {
        throw new Error('previous call to \'initializeWebAssembly()\' failed.');
    }
    initializing = true;
    // wasm flags are already initialized
    const timeout = onnxruntime_common_1.env.wasm.initTimeout;
    const numThreads = onnxruntime_common_1.env.wasm.numThreads;
    const simd = onnxruntime_common_1.env.wasm.simd;
    const useThreads = numThreads > 1 && isMultiThreadSupported();
    const useSimd = simd && isSimdSupported();
    let isTimeout = false;
    const tasks = [];
    // promise for timeout
    if (timeout > 0) {
        tasks.push(new Promise((resolve) => {
            setTimeout(() => {
                isTimeout = true;
                resolve();
            }, timeout);
        }));
    }
    // promise for module initialization
    tasks.push(new Promise((resolve, reject) => {
        const factory = useThreads ? ort_wasm_threaded_js_1.default : ort_wasm_js_1.default;
        const config = {};
        if (!useThreads) {
            config.locateFile = (fileName, scriptDirectory) => {
                if (useSimd && fileName === 'ort-wasm.wasm') {
                    return scriptDirectory + 'ort-wasm-simd.wasm';
                }
                return scriptDirectory + fileName;
            };
        }
        else {
            if (typeof Blob === 'undefined') {
                config.mainScriptUrlOrBlob = path.join(__dirname, 'ort-wasm-threaded.js');
            }
            else {
                const scriptSourceCode = `var ortWasmThreaded=(function(){var _scriptDir;return ${ort_wasm_threaded_js_1.default.toString()}})();`;
                config.mainScriptUrlOrBlob = new Blob([scriptSourceCode], { type: 'text/javascript' });
                config.locateFile = (fileName, scriptDirectory) => {
                    if (fileName.endsWith('.worker.js')) {
                        return URL.createObjectURL(new Blob([
                            // This require() function is handled by webpack to load file content of the corresponding .worker.js
                            // eslint-disable-next-line @typescript-eslint/no-require-imports
                            __webpack_require__(/*! ./binding/ort-wasm-threaded.worker.js */ "./lib/wasm/binding/ort-wasm-threaded.worker.js")
                        ], { type: 'text/javascript' }));
                    }
                    if (useSimd && fileName === 'ort-wasm-threaded.wasm') {
                        return scriptDirectory + 'ort-wasm-simd-threaded.wasm';
                    }
                    return scriptDirectory + fileName;
                };
            }
        }
        factory(config).then(
        // wasm module initialized successfully
        module => {
            initializing = false;
            initialized = true;
            wasm = module;
            resolve();
        }, 
        // wasm module failed to initialize
        (what) => {
            initializing = false;
            aborted = true;
            reject(what);
        });
    }));
    yield Promise.race(tasks);
    if (isTimeout) {
        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
    }
});
exports.initializeWebAssembly = initializeWebAssembly;
const getInstance = () => {
    if (initialized) {
        return wasm;
    }
    throw new Error('WebAssembly is not initialized yet.');
};
exports.getInstance = getInstance;
const dispose = () => {
    var _a;
    if (initialized && !initializing && !aborted) {
        initializing = true;
        (_a = wasm.PThread) === null || _a === void 0 ? void 0 : _a.terminateAllThreads();
        initializing = false;
        initialized = false;
        aborted = true;
    }
};
exports.dispose = dispose;


/***/ }),

/***/ "onnxruntime-common":
/*!************************************************************************************************!*\
  !*** external {"commonjs":"onnxruntime-common","commonjs2":"onnxruntime-common","root":"ort"} ***!
  \************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_onnxruntime_common__;

/***/ }),

/***/ "?6c45":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b3a2":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?63c8":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?aedb":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?75c6":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?674f":
/*!****************************!*\
  !*** perf_hooks (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c6f7":
/*!********************************!*\
  !*** worker_threads (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7aa5":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d87b":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0757":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?334c":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi93YXNtL2JpbmRpbmcvb3J0LXdhc20tdGhyZWFkZWQuanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL3dhc20vYmluZGluZy9vcnQtd2FzbS5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL2pzL2ZsYXRidWZmZXJzLm1qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvZ3VpZC10eXBlc2NyaXB0L2Rpc3QvZ3VpZC5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvb25ueC1wcm90by9kaXN0L29ubnguanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL2JhY2tlbmQtb25ueGpzLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9iYWNrZW5kLXdhc20udHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL2luZGV4LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYXR0cmlidXRlLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL2JhY2tlbmQtd2ViZ2wudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWNvb3JkaW5hdGUtbGliLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1kZWZpbml0aW9ucy50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtZW5jb2RpbmctbGliLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1mcmFnY29sb3ItbGliLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1mdW5jdGlvbi1pbmxpbmVyLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1wcmVwcm9jZXNzb3IudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXJlZ2lzdGVyZWQtbGlicy50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtc2hhcGUtdXRpbHMtbGliLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1zb3VyY2UudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXZlYy1saWIudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9pbmZlcmVuY2UtaGFuZGxlci50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wLXJlc29sdmUtcnVsZXMudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvYmF0Y2gtbm9ybWFsaXphdGlvbi50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9iaW5hcnktb3AudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY2xpcC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb25jYXQtcGFja2VkLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbmNhdC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb252LXBhY2sudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9kZXB0aC10by1zcGFjZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9kcm9wb3V0LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2VsdS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9mbGF0dGVuLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2Z1c2UtdXRpbHMudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZ2F0aGVyLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2dlbW0udHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW0yY29sLXBhY2sudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW1hZ2Utc2NhbGVyLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24udHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvbGVha3ktcmVsdS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9tYXRtdWwtcGFjay50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9tYXRtdWwudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcGFjay50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wYWNraW5nLXV0aWxzLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhZC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wb29sLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3JlZHVjZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLXBhY2tlZC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Jlc2l6ZS1wYWNrZWQudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2hhcGUudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2xpY2UudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc29mdG1heC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcGxpdC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcXVlZXplLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3N1bS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy90aWxlLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3RyYW5zcG9zZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91aW50OC1lbmNvZGUudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdW5hcnktb3AudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdW5wYWNrLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vuc3F1ZWV6ZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91cHNhbXBsZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Byb2dyYW0tbWFuYWdlci50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Nlc3Npb24taGFuZGxlci50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3RleHR1cmUtZGF0YS1lbmNvZGVyLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3kudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLW1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC91dGlscy50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQtZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9leGVjdXRpb24tcGxhbi50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL2dyYXBoLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvaW5zdHJ1bWVudC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL21vZGVsLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BlcmF0b3JzLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24udHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvYmluYXJ5LW9wLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL2NsaXAudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvY29uY2F0LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL2NvbnYudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvZGVwdGgtdG8tc3BhY2UudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvZHJvcG91dC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9lbHUudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvZmxhdHRlbi50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9nYXRoZXIudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvZ2VtbS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9pbWFnZS1zY2FsZXIudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvaW5zdGFuY2Utbm9ybWFsaXphdGlvbi50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9sZWFreS1yZWx1LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL21hdG11bC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9wYWQudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvcG9vbC50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9yZWR1Y2Utb3AudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvcmVzaGFwZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9zaGFwZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9zbGljZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy9zb2Z0bWF4LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL3NwbGl0LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL3NxdWVlemUudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvc3VtLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL3RpbGUudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL29ubnhqcy9vcHMvdHJhbnNwb3NlLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL3VuYXJ5LW9wLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3BzL3Vuc3F1ZWV6ZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wcy91cHNhbXBsZS50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL29wc2V0LnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvb3J0LXNjaGVtYS9vcnQtZ2VuZXJhdGVkLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvc2Vzc2lvbi1oYW5kbGVyLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi9vbm54anMvc2Vzc2lvbi50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL3RlbnNvci50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvb25ueGpzL3V0aWwudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL3dhc20vb3B0aW9ucy11dGlscy50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViLy4vbGliL3dhc20vc2Vzc2lvbi1vcHRpb25zLnRzIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi8uL2xpYi93YXNtL3N0cmluZy11dGlscy50cyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL2V4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJvbm54cnVudGltZS1jb21tb25cIixcImNvbW1vbmpzMlwiOlwib25ueHJ1bnRpbWUtY29tbW9uXCIsXCJyb290XCI6XCJvcnRcIn0iLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYi9vbm54anN8ZnMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYi9vbm54anN8dXRpbCIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL3dhc20vYmluZGluZ3xmcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL3dhc20vYmluZGluZ3xvcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGliL3dhc20vYmluZGluZ3xwYXRoIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi9pZ25vcmVkfC9ob21lL25odS9jb2RlL29ubnhydW50aW1lL2pzL3dlYi9saWIvd2FzbS9iaW5kaW5nfHBlcmZfaG9va3MiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYi93YXNtL2JpbmRpbmd8d29ya2VyX3RocmVhZHMiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYi93YXNtfHBhdGgiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL2lnbm9yZWR8L2hvbWUvbmh1L2NvZGUvb25ueHJ1bnRpbWUvanMvd2ViL2xpYnxmcyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvaWdub3JlZHwvaG9tZS9uaHUvY29kZS9vbm54cnVudGltZS9qcy93ZWIvbGlifG9zIiwid2VicGFjazovL29ubnhydW50aW1lLXdlYi9pZ25vcmVkfC9ob21lL25odS9jb2RlL29ubnhydW50aW1lL2pzL3dlYi9saWJ8dXRpbCIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vb25ueHJ1bnRpbWUtd2ViL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9vbm54cnVudGltZS13ZWIvd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQSxNQUFNLElBQWlDLDZCQUE2QixVQUFVO0FBQzlFO0FBQ0E7QUFDQTs7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Ozs7QUMzRWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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SUFBSSxDQUFDLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLEdBQVc7UUFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUNELFFBQVEsQ0FBQyxHQUFXLEVBQUUsWUFBNkM7UUFDakUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQUVELE1BQU0sQ0FBQyxHQUFXLEVBQUUsWUFBMkM7UUFDN0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELFNBQVMsQ0FBQyxHQUFXLEVBQUUsWUFBOEM7UUFDbkUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELFNBQVMsQ0FBQyxHQUFXLEVBQUUsWUFBOEM7UUFDbkUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELFNBQVMsQ0FBQyxHQUFXLEVBQUUsWUFBOEM7UUFDbkUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVELE9BQU8sQ0FBQyxHQUFXLEVBQUUsWUFBNEM7UUFDL0QsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELFVBQVUsQ0FBQyxHQUFXLEVBQUUsWUFBK0M7UUFDckUsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELFVBQVUsQ0FBQyxHQUFXLEVBQUUsWUFBK0M7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QUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBYyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLEVBQUU7WUFDaEgsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7YUFBTSxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLEVBQUU7WUFDaEgsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDakQ7YUFBTSxJQUNILFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLGNBQWM7WUFDbEYsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLGNBQWMsRUFBRTtZQUNqQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0Q7YUFBTSxJQUNILFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjO1lBQ3RELFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLGNBQWMsRUFB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QyxFQUFHLENBQUMsRUFBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsRUFBRSxFQUFFLENBQUMsRUFBSSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUcsQ0FBQyxFQUFFLENBQUM7WUFDcEUsQ0FBQyxFQUFFLENBQUMsRUFBRyxDQUFDLEVBQUksQ0FBQyxFQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUcsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFO1NBQ25FLENBQUMsQ0FBQyxDQUFDO0tBQ0w7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDLENBQUM7QUFFRixNQUFNLGVBQWUsR0FBRyxHQUFZLEVBQUU7SUFDcEMsSUFBSTtRQUNGLHVFQUF1RTtRQUN2RSwwRUFBMEU7UUFDMUUsT0FBTyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksVUFBVSxDQUN0QyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDNUc7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDLENBQUM7QUFFSyxNQUFNLHFC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TUFBQyxJQUE4QixDQUFDLE9BQU8sMENBQUUsbUJBQW1CLEVBQUUsQ0FBQztRQUUvRCxZQUFZLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDcEIsT0FBTyxHQUFHLElBQUksQ0FBQztLQUNoQjtBQUNILENBQUMsQ0FBQztBQVZXLGVBQU8sV0FVbEI7Ozs7Ozs7Ozs7OztBQ3BLRixnRTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7OztBQ0FBLGU7Ozs7Ozs7Ozs7QUNBQSxlOzs7Ozs7VUNBQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHdDQUF3Qyx5Q0FBeUM7V0FDakY7V0FDQTtXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBLENBQUMsSTs7Ozs7V0NQRCx3Rjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7Ozs7VUNOQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJvcnQtd2ViLmVzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIm9ubnhydW50aW1lLWNvbW1vblwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwib25ueHJ1bnRpbWUtY29tbW9uXCIpKSA6IGZhY3Rvcnkocm9vdFtcIm9ydFwiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX29ubnhydW50aW1lX2NvbW1vbl9fKSB7XG5yZXR1cm4gIiwiXG52YXIgb3J0V2FzbVRocmVhZGVkID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBpZiAodHlwZW9mIF9fZmlsZW5hbWUgIT09ICd1bmRlZmluZWQnKSBfc2NyaXB0RGlyID0gX3NjcmlwdERpciB8fCBfX2ZpbGVuYW1lO1xuICByZXR1cm4gKFxuZnVuY3Rpb24ob3J0V2FzbVRocmVhZGVkKSB7XG4gIG9ydFdhc21UaHJlYWRlZCA9IG9ydFdhc21UaHJlYWRlZCB8fCB7fTtcblxuZnVuY3Rpb24gR1JPV0FCTEVfSEVBUF9JOCgpe2lmKHdhc21NZW1vcnkuYnVmZmVyIT1idWZmZXIpe3VwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKX1yZXR1cm4gSEVBUDh9ZnVuY3Rpb24gR1JPV0FCTEVfSEVBUF9VOCgpe2lmKHdhc21NZW1vcnkuYnVmZmVyIT1idWZmZXIpe3VwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKX1yZXR1cm4gSEVBUFU4fWZ1bmN0aW9uIEdST1dBQkxFX0hFQVBfSTMyKCl7aWYod2FzbU1lbW9yeS5idWZmZXIhPWJ1ZmZlcil7dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpfXJldHVybiBIRUFQMzJ9ZnVuY3Rpb24gR1JPV0FCTEVfSEVBUF9VMzIoKXtpZih3YXNtTWVtb3J5LmJ1ZmZlciE9YnVmZmVyKXt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcil9cmV0dXJuIEhFQVBVMzJ9ZnVuY3Rpb24gR1JPV0FCTEVfSEVBUF9GMzIoKXtpZih3YXNtTWVtb3J5LmJ1ZmZlciE9YnVmZmVyKXt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcil9cmV0dXJuIEhFQVBGMzJ9ZnVuY3Rpb24gR1JPV0FCTEVfSEVBUF9GNjQoKXtpZih3YXNtTWVtb3J5LmJ1ZmZlciE9YnVmZmVyKXt1cGRhdGVHbG9iYWxCdWZmZXJBbmRWaWV3cyh3YXNtTWVtb3J5LmJ1ZmZlcil9cmV0dXJuIEhFQVBGNjR9dmFyIE1vZHVsZT10eXBlb2Ygb3J0V2FzbVRocmVhZGVkIT09XCJ1bmRlZmluZWRcIj9vcnRXYXNtVGhyZWFkZWQ6e307dmFyIHJlYWR5UHJvbWlzZVJlc29sdmUscmVhZHlQcm9taXNlUmVqZWN0O01vZHVsZVtcInJlYWR5XCJdPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdH0pO3ZhciBtb2R1bGVPdmVycmlkZXM9e307dmFyIGtleTtmb3Ioa2V5IGluIE1vZHVsZSl7aWYoTW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpe21vZHVsZU92ZXJyaWRlc1trZXldPU1vZHVsZVtrZXldfX12YXIgYXJndW1lbnRzXz1bXTt2YXIgdGhpc1Byb2dyYW09XCIuL3RoaXMucHJvZ3JhbVwiO3ZhciBxdWl0Xz1mdW5jdGlvbihzdGF0dXMsdG9UaHJvdyl7dGhyb3cgdG9UaHJvd307dmFyIEVOVklST05NRU5UX0lTX1dFQj1mYWxzZTt2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19OT0RFPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19TSEVMTD1mYWxzZTtFTlZJUk9OTUVOVF9JU19XRUI9dHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCI7RU5WSVJPTk1FTlRfSVNfV09SS0VSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT09XCJmdW5jdGlvblwiO0VOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PT1cInN0cmluZ1wiO0VOVklST05NRU5UX0lTX1NIRUxMPSFFTlZJUk9OTUVOVF9JU19XRUImJiFFTlZJUk9OTUVOVF9JU19OT0RFJiYhRU5WSVJPTk1FTlRfSVNfV09SS0VSO3ZhciBFTlZJUk9OTUVOVF9JU19QVEhSRUFEPU1vZHVsZVtcIkVOVklST05NRU5UX0lTX1BUSFJFQURcIl18fGZhbHNlO3ZhciBzY3JpcHREaXJlY3Rvcnk9XCJcIjtmdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpe2lmKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pe3JldHVybiBNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKHBhdGgsc2NyaXB0RGlyZWN0b3J5KX1yZXR1cm4gc2NyaXB0RGlyZWN0b3J5K3BhdGh9dmFyIHJlYWRfLHJlYWRBc3luYyxyZWFkQmluYXJ5LHNldFdpbmRvd1RpdGxlO3ZhciBub2RlRlM7dmFyIG5vZGVQYXRoO2lmKEVOVklST05NRU5UX0lTX05PREUpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXJlcXVpcmUoXCJwYXRoXCIpLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KStcIi9cIn1lbHNle3NjcmlwdERpcmVjdG9yeT1fX2Rpcm5hbWUrXCIvXCJ9cmVhZF89ZnVuY3Rpb24gc2hlbGxfcmVhZChmaWxlbmFtZSxiaW5hcnkpe2lmKCFub2RlRlMpbm9kZUZTPXJlcXVpcmUoXCJmc1wiKTtpZighbm9kZVBhdGgpbm9kZVBhdGg9cmVxdWlyZShcInBhdGhcIik7ZmlsZW5hbWU9bm9kZVBhdGhbXCJub3JtYWxpemVcIl0oZmlsZW5hbWUpO3JldHVybiBub2RlRlNbXCJyZWFkRmlsZVN5bmNcIl0oZmlsZW5hbWUsYmluYXJ5P251bGw6XCJ1dGY4XCIpfTtyZWFkQmluYXJ5PWZ1bmN0aW9uIHJlYWRCaW5hcnkoZmlsZW5hbWUpe3ZhciByZXQ9cmVhZF8oZmlsZW5hbWUsdHJ1ZSk7aWYoIXJldC5idWZmZXIpe3JldD1uZXcgVWludDhBcnJheShyZXQpfWFzc2VydChyZXQuYnVmZmVyKTtyZXR1cm4gcmV0fTtpZihwcm9jZXNzW1wiYXJndlwiXS5sZW5ndGg+MSl7dGhpc1Byb2dyYW09cHJvY2Vzc1tcImFyZ3ZcIl1bMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKX1hcmd1bWVudHNfPXByb2Nlc3NbXCJhcmd2XCJdLnNsaWNlKDIpO3Byb2Nlc3NbXCJvblwiXShcInVuY2F1Z2h0RXhjZXB0aW9uXCIsZnVuY3Rpb24oZXgpe2lmKCEoZXggaW5zdGFuY2VvZiBFeGl0U3RhdHVzKSl7dGhyb3cgZXh9fSk7cHJvY2Vzc1tcIm9uXCJdKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsYWJvcnQpO3F1aXRfPWZ1bmN0aW9uKHN0YXR1cyl7cHJvY2Vzc1tcImV4aXRcIl0oc3RhdHVzKX07TW9kdWxlW1wiaW5zcGVjdFwiXT1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn07dmFyIG5vZGVXb3JrZXJUaHJlYWRzO3RyeXtub2RlV29ya2VyVGhyZWFkcz1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIil9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcignVGhlIFwid29ya2VyX3RocmVhZHNcIiBtb2R1bGUgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIG5vZGUuanMgYnVpbGQgLSBwZXJoYXBzIGEgbmV3ZXIgdmVyc2lvbiBpcyBuZWVkZWQ/Jyk7dGhyb3cgZX1nbG9iYWwuV29ya2VyPW5vZGVXb3JrZXJUaHJlYWRzLldvcmtlcn1lbHNlIGlmKEVOVklST05NRU5UX0lTX1NIRUxMKXtpZih0eXBlb2YgcmVhZCE9XCJ1bmRlZmluZWRcIil7cmVhZF89ZnVuY3Rpb24gc2hlbGxfcmVhZChmKXtyZXR1cm4gcmVhZChmKX19cmVhZEJpbmFyeT1mdW5jdGlvbiByZWFkQmluYXJ5KGYpe3ZhciBkYXRhO2lmKHR5cGVvZiByZWFkYnVmZmVyPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVhZGJ1ZmZlcihmKSl9ZGF0YT1yZWFkKGYsXCJiaW5hcnlcIik7YXNzZXJ0KHR5cGVvZiBkYXRhPT09XCJvYmplY3RcIik7cmV0dXJuIGRhdGF9O2lmKHR5cGVvZiBzY3JpcHRBcmdzIT1cInVuZGVmaW5lZFwiKXthcmd1bWVudHNfPXNjcmlwdEFyZ3N9ZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzIT1cInVuZGVmaW5lZFwiKXthcmd1bWVudHNfPWFyZ3VtZW50c31pZih0eXBlb2YgcXVpdD09PVwiZnVuY3Rpb25cIil7cXVpdF89ZnVuY3Rpb24oc3RhdHVzKXtxdWl0KHN0YXR1cyl9fWlmKHR5cGVvZiBwcmludCE9PVwidW5kZWZpbmVkXCIpe2lmKHR5cGVvZiBjb25zb2xlPT09XCJ1bmRlZmluZWRcIiljb25zb2xlPXt9O2NvbnNvbGUubG9nPXByaW50O2NvbnNvbGUud2Fybj1jb25zb2xlLmVycm9yPXR5cGVvZiBwcmludEVyciE9PVwidW5kZWZpbmVkXCI/cHJpbnRFcnI6cHJpbnR9fWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZn1lbHNlIGlmKHR5cGVvZiBkb2N1bWVudCE9PVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3NjcmlwdERpcmVjdG9yeT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31pZihfc2NyaXB0RGlyKXtzY3JpcHREaXJlY3Rvcnk9X3NjcmlwdERpcn1pZihzY3JpcHREaXJlY3RvcnkuaW5kZXhPZihcImJsb2I6XCIpIT09MCl7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkubGFzdEluZGV4T2YoXCIvXCIpKzEpfWVsc2V7c2NyaXB0RGlyZWN0b3J5PVwiXCJ9aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7cmVhZF89ZnVuY3Rpb24gc2hlbGxfcmVhZChmaWxlbmFtZSxiaW5hcnkpe2lmKCFub2RlRlMpbm9kZUZTPXJlcXVpcmUoXCJmc1wiKTtpZighbm9kZVBhdGgpbm9kZVBhdGg9cmVxdWlyZShcInBhdGhcIik7ZmlsZW5hbWU9bm9kZVBhdGhbXCJub3JtYWxpemVcIl0oZmlsZW5hbWUpO3JldHVybiBub2RlRlNbXCJyZWFkRmlsZVN5bmNcIl0oZmlsZW5hbWUsYmluYXJ5P251bGw6XCJ1dGY4XCIpfTtyZWFkQmluYXJ5PWZ1bmN0aW9uIHJlYWRCaW5hcnkoZmlsZW5hbWUpe3ZhciByZXQ9cmVhZF8oZmlsZW5hbWUsdHJ1ZSk7aWYoIXJldC5idWZmZXIpe3JldD1uZXcgVWludDhBcnJheShyZXQpfWFzc2VydChyZXQuYnVmZmVyKTtyZXR1cm4gcmV0fX1lbHNle3JlYWRfPWZ1bmN0aW9uKHVybCl7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5zZW5kKG51bGwpO3JldHVybiB4aHIucmVzcG9uc2VUZXh0fTtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3JlYWRCaW5hcnk9ZnVuY3Rpb24odXJsKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLnNlbmQobnVsbCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSl9fXJlYWRBc3luYz1mdW5jdGlvbih1cmwsb25sb2FkLG9uZXJyb3Ipe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLHRydWUpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5vbmxvYWQ9ZnVuY3Rpb24oKXtpZih4aHIuc3RhdHVzPT0yMDB8fHhoci5zdGF0dXM9PTAmJnhoci5yZXNwb25zZSl7b25sb2FkKHhoci5yZXNwb25zZSk7cmV0dXJufW9uZXJyb3IoKX07eGhyLm9uZXJyb3I9b25lcnJvcjt4aHIuc2VuZChudWxsKX19c2V0V2luZG93VGl0bGU9ZnVuY3Rpb24odGl0bGUpe2RvY3VtZW50LnRpdGxlPXRpdGxlfX1lbHNle31pZihFTlZJUk9OTUVOVF9JU19OT0RFKXtpZih0eXBlb2YgcGVyZm9ybWFuY2U9PT1cInVuZGVmaW5lZFwiKXtnbG9iYWwucGVyZm9ybWFuY2U9cmVxdWlyZShcInBlcmZfaG9va3NcIikucGVyZm9ybWFuY2V9fXZhciBvdXQ9TW9kdWxlW1wicHJpbnRcIl18fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7dmFyIGVycj1Nb2R1bGVbXCJwcmludEVyclwiXXx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKGtleSBpbiBtb2R1bGVPdmVycmlkZXMpe2lmKG1vZHVsZU92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtNb2R1bGVba2V5XT1tb2R1bGVPdmVycmlkZXNba2V5XX19bW9kdWxlT3ZlcnJpZGVzPW51bGw7aWYoTW9kdWxlW1wiYXJndW1lbnRzXCJdKWFyZ3VtZW50c189TW9kdWxlW1wiYXJndW1lbnRzXCJdO2lmKE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdKXRoaXNQcm9ncmFtPU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdO2lmKE1vZHVsZVtcInF1aXRcIl0pcXVpdF89TW9kdWxlW1wicXVpdFwiXTtmdW5jdGlvbiB3YXJuT25jZSh0ZXh0KXtpZighd2Fybk9uY2Uuc2hvd24pd2Fybk9uY2Uuc2hvd249e307aWYoIXdhcm5PbmNlLnNob3duW3RleHRdKXt3YXJuT25jZS5zaG93blt0ZXh0XT0xO2Vycih0ZXh0KX19dmFyIEF0b21pY3NfbG9hZD1BdG9taWNzLmxvYWQ7dmFyIEF0b21pY3Nfc3RvcmU9QXRvbWljcy5zdG9yZTt2YXIgQXRvbWljc19jb21wYXJlRXhjaGFuZ2U9QXRvbWljcy5jb21wYXJlRXhjaGFuZ2U7dmFyIHdhc21CaW5hcnk7aWYoTW9kdWxlW1wid2FzbUJpbmFyeVwiXSl3YXNtQmluYXJ5PU1vZHVsZVtcIndhc21CaW5hcnlcIl07dmFyIG5vRXhpdFJ1bnRpbWU9TW9kdWxlW1wibm9FeGl0UnVudGltZVwiXXx8ZmFsc2U7aWYodHlwZW9mIFdlYkFzc2VtYmx5IT09XCJvYmplY3RcIil7YWJvcnQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpfXZhciB3YXNtTWVtb3J5O3ZhciB3YXNtTW9kdWxlO3ZhciBBQk9SVD1mYWxzZTt2YXIgRVhJVFNUQVRVUztmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLHRleHQpe2lmKCFjb25kaXRpb24pe2Fib3J0KFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIrdGV4dCl9fWZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXAsaWR4LG1heEJ5dGVzVG9SZWFkKXt2YXIgZW5kSWR4PWlkeCttYXhCeXRlc1RvUmVhZDt2YXIgc3RyPVwiXCI7d2hpbGUoIShpZHg+PWVuZElkeCkpe3ZhciB1MD1oZWFwW2lkeCsrXTtpZighdTApcmV0dXJuIHN0cjtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX12YXIgdTI9aGVhcFtpZHgrK10mNjM7aWYoKHUwJjI0MCk9PTIyNCl7dTA9KHUwJjE1KTw8MTJ8dTE8PDZ8dTJ9ZWxzZXt1MD0odTAmNyk8PDE4fHUxPDwxMnx1Mjw8NnxoZWFwW2lkeCsrXSY2M31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKX1lbHNle3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfX1yZXR1cm4gc3RyfWZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsbWF4Qnl0ZXNUb1JlYWQpe3JldHVybiBwdHI/VVRGOEFycmF5VG9TdHJpbmcoR1JPV0FCTEVfSEVBUF9VOCgpLHB0cixtYXhCeXRlc1RvUmVhZCk6XCJcIn1mdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsaGVhcCxvdXRJZHgsbWF4Qnl0ZXNUb1dyaXRlKXtpZighKG1heEJ5dGVzVG9Xcml0ZT4wKSlyZXR1cm4gMDt2YXIgc3RhcnRJZHg9b3V0SWR4O3ZhciBlbmRJZHg9b3V0SWR4K21heEJ5dGVzVG9Xcml0ZS0xO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl7dmFyIHUxPXN0ci5jaGFyQ29kZUF0KCsraSk7dT02NTUzNisoKHUmMTAyMyk8PDEwKXx1MSYxMDIzfWlmKHU8PTEyNyl7aWYob3V0SWR4Pj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109dX1lbHNlIGlmKHU8PTIwNDcpe2lmKG91dElkeCsxPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MTkyfHU+PjY7aGVhcFtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZSBpZih1PD02NTUzNSl7aWYob3V0SWR4KzI+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yMjR8dT4+MTI7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjN9ZWxzZXtpZihvdXRJZHgrMz49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTI0MHx1Pj4xODtoZWFwW291dElkeCsrXT0xMjh8dT4+MTImNjM7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjN9fWhlYXBbb3V0SWR4XT0wO3JldHVybiBvdXRJZHgtc3RhcnRJZHh9ZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKXtyZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLEdST1dBQkxFX0hFQVBfVTgoKSxvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKX1mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKXt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXU9NjU1MzYrKCh1JjEwMjMpPDwxMCl8c3RyLmNoYXJDb2RlQXQoKytpKSYxMDIzO2lmKHU8PTEyNykrK2xlbjtlbHNlIGlmKHU8PTIwNDcpbGVuKz0yO2Vsc2UgaWYodTw9NjU1MzUpbGVuKz0zO2Vsc2UgbGVuKz00fXJldHVybiBsZW59ZnVuY3Rpb24gYWxsb2NhdGVVVEY4KHN0cil7dmFyIHNpemU9bGVuZ3RoQnl0ZXNVVEY4KHN0cikrMTt2YXIgcmV0PV9tYWxsb2Moc2l6ZSk7aWYocmV0KXN0cmluZ1RvVVRGOEFycmF5KHN0cixHUk9XQUJMRV9IRUFQX0k4KCkscmV0LHNpemUpO3JldHVybiByZXR9ZnVuY3Rpb24gd3JpdGVBcnJheVRvTWVtb3J5KGFycmF5LGJ1ZmZlcil7R1JPV0FCTEVfSEVBUF9JOCgpLnNldChhcnJheSxidWZmZXIpfWZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsYnVmZmVyLGRvbnRBZGROdWxsKXtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXtHUk9XQUJMRV9IRUFQX0k4KClbYnVmZmVyKys+PjBdPXN0ci5jaGFyQ29kZUF0KGkpfWlmKCFkb250QWRkTnVsbClHUk9XQUJMRV9IRUFQX0k4KClbYnVmZmVyPj4wXT0wfWZ1bmN0aW9uIGFsaWduVXAoeCxtdWx0aXBsZSl7aWYoeCVtdWx0aXBsZT4wKXt4Kz1tdWx0aXBsZS14JW11bHRpcGxlfXJldHVybiB4fXZhciBidWZmZXIsSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXtidWZmZXI9TW9kdWxlW1wiYnVmZmVyXCJdfWZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKGJ1Zil7YnVmZmVyPWJ1ZjtNb2R1bGVbXCJIRUFQOFwiXT1IRUFQOD1uZXcgSW50OEFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUDE2XCJdPUhFQVAxNj1uZXcgSW50MTZBcnJheShidWYpO01vZHVsZVtcIkhFQVAzMlwiXT1IRUFQMzI9bmV3IEludDMyQXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQVThcIl09SEVBUFU4PW5ldyBVaW50OEFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUFUxNlwiXT1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShidWYpO01vZHVsZVtcIkhFQVBVMzJcIl09SEVBUFUzMj1uZXcgVWludDMyQXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQRjMyXCJdPUhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShidWYpO01vZHVsZVtcIkhFQVBGNjRcIl09SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGJ1Zil9dmFyIElOSVRJQUxfTUVNT1JZPU1vZHVsZVtcIklOSVRJQUxfTUVNT1JZXCJdfHwxNjc3NzIxNjtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXt3YXNtTWVtb3J5PU1vZHVsZVtcIndhc21NZW1vcnlcIl07YnVmZmVyPU1vZHVsZVtcImJ1ZmZlclwiXX1lbHNle2lmKE1vZHVsZVtcIndhc21NZW1vcnlcIl0pe3dhc21NZW1vcnk9TW9kdWxlW1wid2FzbU1lbW9yeVwiXX1lbHNle3dhc21NZW1vcnk9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XCJpbml0aWFsXCI6SU5JVElBTF9NRU1PUlkvNjU1MzYsXCJtYXhpbXVtXCI6MjE0NzQ4MzY0OC82NTUzNixcInNoYXJlZFwiOnRydWV9KTtpZighKHdhc21NZW1vcnkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXtlcnIoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIik7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7Y29uc29sZS5sb2coXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZCBhbHNvIHVzZSBhIHJlY2VudCB2ZXJzaW9uKVwiKX10aHJvdyBFcnJvcihcImJhZCBtZW1vcnlcIil9fX1pZih3YXNtTWVtb3J5KXtidWZmZXI9d2FzbU1lbW9yeS5idWZmZXJ9SU5JVElBTF9NRU1PUlk9YnVmZmVyLmJ5dGVMZW5ndGg7dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmZmVyKTt2YXIgd2FzbVRhYmxlO3ZhciBfX0FUUFJFUlVOX189W107dmFyIF9fQVRJTklUX189W107dmFyIF9fQVRFWElUX189W107dmFyIF9fQVRQT1NUUlVOX189W107dmFyIHJ1bnRpbWVJbml0aWFsaXplZD1mYWxzZTt2YXIgcnVudGltZUV4aXRlZD1mYWxzZTtmdW5jdGlvbiBwcmVSdW4oKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybjtpZihNb2R1bGVbXCJwcmVSdW5cIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwcmVSdW5cIl09W01vZHVsZVtcInByZVJ1blwiXV07d2hpbGUoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCl7YWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpfX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pfWZ1bmN0aW9uIGluaXRSdW50aW1lKCl7cnVudGltZUluaXRpYWxpemVkPXRydWU7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm47Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyl9ZnVuY3Rpb24gZXhpdFJ1bnRpbWUoKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybjtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FURVhJVF9fKTtmbHVzaF9OT19GSUxFU1lTVEVNKCk7UFRocmVhZC5ydW5FeGl0SGFuZGxlcnMoKTtydW50aW1lRXhpdGVkPXRydWV9ZnVuY3Rpb24gcG9zdFJ1bigpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuO2lmKE1vZHVsZVtcInBvc3RSdW5cIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwb3N0UnVuXCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicG9zdFJ1blwiXT1bTW9kdWxlW1wicG9zdFJ1blwiXV07d2hpbGUoTW9kdWxlW1wicG9zdFJ1blwiXS5sZW5ndGgpe2FkZE9uUG9zdFJ1bihNb2R1bGVbXCJwb3N0UnVuXCJdLnNoaWZ0KCkpfX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKX1mdW5jdGlvbiBhZGRPblByZVJ1bihjYil7X19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uSW5pdChjYil7X19BVElOSVRfXy51bnNoaWZ0KGNiKX1mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2Ipe19fQVRQT1NUUlVOX18udW5zaGlmdChjYil9dmFyIHJ1bkRlcGVuZGVuY2llcz0wO3ZhciBydW5EZXBlbmRlbmN5V2F0Y2hlcj1udWxsO3ZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKXthc3NlcnQoIUVOVklST05NRU5UX0lTX1BUSFJFQUQsXCJhZGRSdW5EZXBlbmRlbmN5IGNhbm5vdCBiZSB1c2VkIGluIGEgcHRocmVhZCB3b3JrZXJcIik7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihydW5EZXBlbmRlbmN5V2F0Y2hlciE9PW51bGwpe2NsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO3J1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGx9aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCl9fX1Nb2R1bGVbXCJwcmVsb2FkZWRJbWFnZXNcIl09e307TW9kdWxlW1wicHJlbG9hZGVkQXVkaW9zXCJdPXt9O2Z1bmN0aW9uIGFib3J0KHdoYXQpe2lmKE1vZHVsZVtcIm9uQWJvcnRcIl0pe01vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCl9aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCljb25zb2xlLmVycm9yKFwiUHRocmVhZCBhYm9ydGluZyBhdCBcIisobmV3IEVycm9yKS5zdGFjayk7d2hhdCs9XCJcIjtlcnIod2hhdCk7QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPTE7d2hhdD1cImFib3J0KFwiK3doYXQrXCIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLlwiO3ZhciBlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKXtyZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KX1mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKX12YXIgd2FzbUJpbmFyeUZpbGU9XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI7aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPWxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpfWZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKXt0cnl7aWYoZmlsZT09d2FzbUJpbmFyeUZpbGUmJndhc21CaW5hcnkpe3JldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KX1pZihyZWFkQmluYXJ5KXtyZXR1cm4gcmVhZEJpbmFyeShmaWxlKX1lbHNle3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifX1jYXRjaChlcnIpe2Fib3J0KGVycil9fWZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoKXtpZighd2FzbUJpbmFyeSYmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKSl7aWYodHlwZW9mIGZldGNoPT09XCJmdW5jdGlvblwiJiYhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSl7cmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtpZighcmVzcG9uc2VbXCJva1wiXSl7dGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK3dhc21CaW5hcnlGaWxlK1wiJ1wifXJldHVybiByZXNwb25zZVtcImFycmF5QnVmZmVyXCJdKCl9KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpfSl9ZWxzZXtpZihyZWFkQXN5bmMpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7cmVhZEFzeW5jKHdhc21CaW5hcnlGaWxlLGZ1bmN0aW9uKHJlc3BvbnNlKXtyZXNvbHZlKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSl9LHJlamVjdCl9KX19fXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGdldEJpbmFyeSh3YXNtQmluYXJ5RmlsZSl9KX1mdW5jdGlvbiBjcmVhdGVXYXNtKCl7dmFyIGluZm89e1wiYVwiOmFzbUxpYnJhcnlBcmd9O2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSxtb2R1bGUpe3ZhciBleHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7TW9kdWxlW1wiYXNtXCJdPWV4cG9ydHM7d2FzbVRhYmxlPU1vZHVsZVtcImFzbVwiXVtcImViXCJdO2FkZE9uSW5pdChNb2R1bGVbXCJhc21cIl1bXCJNYVwiXSk7UFRocmVhZC50bHNJbml0RnVuY3Rpb25zLnB1c2goTW9kdWxlW1wiYXNtXCJdW1wiamJcIl0pO3dhc21Nb2R1bGU9bW9kdWxlO2lmKCFFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXtyZW1vdmVSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKX19aWYoIUVOVklST05NRU5UX0lTX1BUSFJFQUQpe2FkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpfWZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCl7cmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdLHJlc3VsdFtcIm1vZHVsZVwiXSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlcil7cmV0dXJuIGdldEJpbmFyeVByb21pc2UoKS50aGVuKGZ1bmN0aW9uKGJpbmFyeSl7dmFyIHJlc3VsdD1XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksaW5mbyk7cmV0dXJuIHJlc3VsdH0pLnRoZW4ocmVjZWl2ZXIsZnVuY3Rpb24ocmVhc29uKXtlcnIoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIityZWFzb24pO2Fib3J0KHJlYXNvbil9KX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKCl7aWYoIXdhc21CaW5hcnkmJnR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZz09PVwiZnVuY3Rpb25cIiYmIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkmJiFpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpJiZ0eXBlb2YgZmV0Y2g9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7dmFyIHJlc3VsdD1XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSxpbmZvKTtyZXR1cm4gcmVzdWx0LnRoZW4ocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQsZnVuY3Rpb24ocmVhc29uKXtlcnIoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrcmVhc29uKTtlcnIoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCl9KX0pfWVsc2V7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpfX1pZihNb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0pe3RyeXt2YXIgZXhwb3J0cz1Nb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0oaW5mbyxyZWNlaXZlSW5zdGFuY2UpO3JldHVybiBleHBvcnRzfWNhdGNoKGUpe2VycihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2UpO3JldHVybiBmYWxzZX19aW5zdGFudGlhdGVBc3luYygpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7cmV0dXJue319dmFyIEFTTV9DT05TVFM9ezY1Mzk4ODpmdW5jdGlvbigpe3Rocm93XCJDYW5jZWxlZCFcIn0sNjU0MDA2OmZ1bmN0aW9uKCQwLCQxKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7X19lbXNjcmlwdGVuX2RvX2Rpc3BhdGNoX3RvX3RocmVhZCgkMCwkMSl9LDApfX07ZnVuY3Rpb24gaW5pdFB0aHJlYWRzSlMoKXtQVGhyZWFkLmluaXRSdW50aW1lKCl9ZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKXt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe3ZhciBjYWxsYmFjaz1jYWxsYmFja3Muc2hpZnQoKTtpZih0eXBlb2YgY2FsbGJhY2s9PVwiZnVuY3Rpb25cIil7Y2FsbGJhY2soTW9kdWxlKTtjb250aW51ZX12YXIgZnVuYz1jYWxsYmFjay5mdW5jO2lmKHR5cGVvZiBmdW5jPT09XCJudW1iZXJcIil7aWYoY2FsbGJhY2suYXJnPT09dW5kZWZpbmVkKXt3YXNtVGFibGUuZ2V0KGZ1bmMpKCl9ZWxzZXt3YXNtVGFibGUuZ2V0KGZ1bmMpKGNhbGxiYWNrLmFyZyl9fWVsc2V7ZnVuYyhjYWxsYmFjay5hcmc9PT11bmRlZmluZWQ/bnVsbDpjYWxsYmFjay5hcmcpfX19dmFyIEVSUk5PX0NPREVTPXtFUEVSTTo2MyxFTk9FTlQ6NDQsRVNSQ0g6NzEsRUlOVFI6MjcsRUlPOjI5LEVOWElPOjYwLEUyQklHOjEsRU5PRVhFQzo0NSxFQkFERjo4LEVDSElMRDoxMixFQUdBSU46NixFV09VTERCTE9DSzo2LEVOT01FTTo0OCxFQUNDRVM6MixFRkFVTFQ6MjEsRU5PVEJMSzoxMDUsRUJVU1k6MTAsRUVYSVNUOjIwLEVYREVWOjc1LEVOT0RFVjo0MyxFTk9URElSOjU0LEVJU0RJUjozMSxFSU5WQUw6MjgsRU5GSUxFOjQxLEVNRklMRTozMyxFTk9UVFk6NTksRVRYVEJTWTo3NCxFRkJJRzoyMixFTk9TUEM6NTEsRVNQSVBFOjcwLEVST0ZTOjY5LEVNTElOSzozNCxFUElQRTo2NCxFRE9NOjE4LEVSQU5HRTo2OCxFTk9NU0c6NDksRUlEUk06MjQsRUNIUk5HOjEwNixFTDJOU1lOQzoxNTYsRUwzSExUOjEwNyxFTDNSU1Q6MTA4LEVMTlJORzoxMDksRVVOQVRDSDoxMTAsRU5PQ1NJOjExMSxFTDJITFQ6MTEyLEVERUFETEs6MTYsRU5PTENLOjQ2LEVCQURFOjExMyxFQkFEUjoxMTQsRVhGVUxMOjExNSxFTk9BTk86MTA0LEVCQURSUUM6MTAzLEVCQURTTFQ6MTAyLEVERUFETE9DSzoxNixFQkZPTlQ6MTAxLEVOT1NUUjoxMDAsRU5PREFUQToxMTYsRVRJTUU6MTE3LEVOT1NSOjExOCxFTk9ORVQ6MTE5LEVOT1BLRzoxMjAsRVJFTU9URToxMjEsRU5PTElOSzo0NyxFQURWOjEyMixFU1JNTlQ6MTIzLEVDT01NOjEyNCxFUFJPVE86NjUsRU1VTFRJSE9QOjM2LEVET1RET1Q6MTI1LEVCQURNU0c6OSxFTk9UVU5JUToxMjYsRUJBREZEOjEyNyxFUkVNQ0hHOjEyOCxFTElCQUNDOjEyOSxFTElCQkFEOjEzMCxFTElCU0NOOjEzMSxFTElCTUFYOjEzMixFTElCRVhFQzoxMzMsRU5PU1lTOjUyLEVOT1RFTVBUWTo1NSxFTkFNRVRPT0xPTkc6MzcsRUxPT1A6MzIsRU9QTk9UU1VQUDoxMzgsRVBGTk9TVVBQT1JUOjEzOSxFQ09OTlJFU0VUOjE1LEVOT0JVRlM6NDIsRUFGTk9TVVBQT1JUOjUsRVBST1RPVFlQRTo2NyxFTk9UU09DSzo1NyxFTk9QUk9UT09QVDo1MCxFU0hVVERPV046MTQwLEVDT05OUkVGVVNFRDoxNCxFQUREUklOVVNFOjMsRUNPTk5BQk9SVEVEOjEzLEVORVRVTlJFQUNIOjQwLEVORVRET1dOOjM4LEVUSU1FRE9VVDo3MyxFSE9TVERPV046MTQyLEVIT1NUVU5SRUFDSDoyMyxFSU5QUk9HUkVTUzoyNixFQUxSRUFEWTo3LEVERVNUQUREUlJFUToxNyxFTVNHU0laRTozNSxFUFJPVE9OT1NVUFBPUlQ6NjYsRVNPQ0tUTk9TVVBQT1JUOjEzNyxFQUREUk5PVEFWQUlMOjQsRU5FVFJFU0VUOjM5LEVJU0NPTk46MzAsRU5PVENPTk46NTMsRVRPT01BTllSRUZTOjE0MSxFVVNFUlM6MTM2LEVEUVVPVDoxOSxFU1RBTEU6NzIsRU5PVFNVUDoxMzgsRU5PTUVESVVNOjE0OCxFSUxTRVE6MjUsRU9WRVJGTE9XOjYxLEVDQU5DRUxFRDoxMSxFTk9UUkVDT1ZFUkFCTEU6NTYsRU9XTkVSREVBRDo2MixFU1RSUElQRToxMzV9O2Z1bmN0aW9uIF9lbXNjcmlwdGVuX2Z1dGV4X3dha2UoYWRkcixjb3VudCl7aWYoYWRkcjw9MHx8YWRkcj5HUk9XQUJMRV9IRUFQX0k4KCkubGVuZ3RofHxhZGRyJjMhPTB8fGNvdW50PDApcmV0dXJuLTI4O2lmKGNvdW50PT0wKXJldHVybiAwO2lmKGNvdW50Pj0yMTQ3NDgzNjQ3KWNvdW50PUluZmluaXR5O3ZhciBtYWluVGhyZWFkV2FpdEFkZHJlc3M9QXRvbWljcy5sb2FkKEdST1dBQkxFX0hFQVBfSTMyKCksX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4Pj4yKTt2YXIgbWFpblRocmVhZFdva2VuPTA7aWYobWFpblRocmVhZFdhaXRBZGRyZXNzPT1hZGRyKXt2YXIgbG9hZGVkQWRkcj1BdG9taWNzLmNvbXBhcmVFeGNoYW5nZShHUk9XQUJMRV9IRUFQX0kzMigpLF9fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9mdXRleD4+MixtYWluVGhyZWFkV2FpdEFkZHJlc3MsMCk7aWYobG9hZGVkQWRkcj09bWFpblRocmVhZFdhaXRBZGRyZXNzKXstLWNvdW50O21haW5UaHJlYWRXb2tlbj0xO2lmKGNvdW50PD0wKXJldHVybiAxfX12YXIgcmV0PUF0b21pY3Mubm90aWZ5KEdST1dBQkxFX0hFQVBfSTMyKCksYWRkcj4+Mixjb3VudCk7aWYocmV0Pj0wKXJldHVybiByZXQrbWFpblRocmVhZFdva2VuO3Rocm93XCJBdG9taWNzLm5vdGlmeSByZXR1cm5lZCBhbiB1bmV4cGVjdGVkIHZhbHVlIFwiK3JldH1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9mdXRleF93YWtlXCJdPV9lbXNjcmlwdGVuX2Z1dGV4X3dha2U7ZnVuY3Rpb24ga2lsbFRocmVhZChwdGhyZWFkX3B0cil7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl0aHJvd1wiSW50ZXJuYWwgRXJyb3IhIGtpbGxUaHJlYWQoKSBjYW4gb25seSBldmVyIGJlIGNhbGxlZCBmcm9tIG1haW4gYXBwbGljYXRpb24gdGhyZWFkIVwiO2lmKCFwdGhyZWFkX3B0cil0aHJvd1wiSW50ZXJuYWwgRXJyb3IhIE51bGwgcHRocmVhZF9wdHIgaW4ga2lsbFRocmVhZCFcIjtHUk9XQUJMRV9IRUFQX0kzMigpW3B0aHJlYWRfcHRyKzEyPj4yXT0wO3ZhciBwdGhyZWFkPVBUaHJlYWQucHRocmVhZHNbcHRocmVhZF9wdHJdO3B0aHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1BUaHJlYWQuZnJlZVRocmVhZERhdGEocHRocmVhZCk7UFRocmVhZC5ydW5uaW5nV29ya2Vycy5zcGxpY2UoUFRocmVhZC5ydW5uaW5nV29ya2Vycy5pbmRleE9mKHB0aHJlYWQud29ya2VyKSwxKTtwdGhyZWFkLndvcmtlci5wdGhyZWFkPXVuZGVmaW5lZH1mdW5jdGlvbiBjYW5jZWxUaHJlYWQocHRocmVhZF9wdHIpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpdGhyb3dcIkludGVybmFsIEVycm9yISBjYW5jZWxUaHJlYWQoKSBjYW4gb25seSBldmVyIGJlIGNhbGxlZCBmcm9tIG1haW4gYXBwbGljYXRpb24gdGhyZWFkIVwiO2lmKCFwdGhyZWFkX3B0cil0aHJvd1wiSW50ZXJuYWwgRXJyb3IhIE51bGwgcHRocmVhZF9wdHIgaW4gY2FuY2VsVGhyZWFkIVwiO3ZhciBwdGhyZWFkPVBUaHJlYWQucHRocmVhZHNbcHRocmVhZF9wdHJdO3B0aHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcImNtZFwiOlwiY2FuY2VsXCJ9KX1mdW5jdGlvbiBjbGVhbnVwVGhyZWFkKHB0aHJlYWRfcHRyKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXRocm93XCJJbnRlcm5hbCBFcnJvciEgY2xlYW51cFRocmVhZCgpIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIGZyb20gbWFpbiBhcHBsaWNhdGlvbiB0aHJlYWQhXCI7aWYoIXB0aHJlYWRfcHRyKXRocm93XCJJbnRlcm5hbCBFcnJvciEgTnVsbCBwdGhyZWFkX3B0ciBpbiBjbGVhbnVwVGhyZWFkIVwiO3ZhciBwdGhyZWFkPVBUaHJlYWQucHRocmVhZHNbcHRocmVhZF9wdHJdO2lmKHB0aHJlYWQpe0dST1dBQkxFX0hFQVBfSTMyKClbcHRocmVhZF9wdHIrMTI+PjJdPTA7dmFyIHdvcmtlcj1wdGhyZWFkLndvcmtlcjtQVGhyZWFkLnJldHVybldvcmtlclRvUG9vbCh3b3JrZXIpfX12YXIgUFRocmVhZD17dW51c2VkV29ya2VyczpbXSxydW5uaW5nV29ya2VyczpbXSx0bHNJbml0RnVuY3Rpb25zOltdLGluaXRNYWluVGhyZWFkQmxvY2s6ZnVuY3Rpb24oKXt9LGluaXRSdW50aW1lOmZ1bmN0aW9uKCl7dmFyIHRiPV9tYWxsb2MoMjI4KTtmb3IodmFyIGk9MDtpPDIyOC80OysraSlHUk9XQUJMRV9IRUFQX1UzMigpW3RiLzQraV09MDtHUk9XQUJMRV9IRUFQX0kzMigpW3RiKzEyPj4yXT10Yjt2YXIgaGVhZFB0cj10YisxNTI7R1JPV0FCTEVfSEVBUF9JMzIoKVtoZWFkUHRyPj4yXT1oZWFkUHRyO3ZhciB0bHNNZW1vcnk9X21hbGxvYyg1MTIpO2Zvcih2YXIgaT0wO2k8MTI4OysraSlHUk9XQUJMRV9IRUFQX1UzMigpW3Rsc01lbW9yeS80K2ldPTA7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzEwMD4+Mix0bHNNZW1vcnkpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0Yis0MD4+Mix0Yik7X19lbXNjcmlwdGVuX3RocmVhZF9pbml0KHRiLCFFTlZJUk9OTUVOVF9JU19XT1JLRVIsMSk7X2Vtc2NyaXB0ZW5fcmVnaXN0ZXJfbWFpbl9icm93c2VyX3RocmVhZF9pZCh0Yil9LGluaXRXb3JrZXI6ZnVuY3Rpb24oKXt9LHB0aHJlYWRzOnt9LHRocmVhZEV4aXRIYW5kbGVyczpbXSxydW5FeGl0SGFuZGxlcnM6ZnVuY3Rpb24oKXt3aGlsZShQVGhyZWFkLnRocmVhZEV4aXRIYW5kbGVycy5sZW5ndGg+MCl7UFRocmVhZC50aHJlYWRFeGl0SGFuZGxlcnMucG9wKCkoKX1pZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEJiZfcHRocmVhZF9zZWxmKCkpX19fcHRocmVhZF90c2RfcnVuX2R0b3JzKCl9LHJ1bkV4aXRIYW5kbGVyc0FuZERlaW5pdFRocmVhZDpmdW5jdGlvbih0YixleGl0Q29kZSl7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRiKzU2Pj4yLDEpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0Yis2MD4+MiwwKTtQVGhyZWFkLnJ1bkV4aXRIYW5kbGVycygpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0Yis0Pj4yLGV4aXRDb2RlKTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGIrMD4+MiwxKTtfZW1zY3JpcHRlbl9mdXRleF93YWtlKHRiKzAsMjE0NzQ4MzY0Nyk7X19lbXNjcmlwdGVuX3RocmVhZF9pbml0KDAsMCwwKX0sc2V0RXhpdFN0YXR1czpmdW5jdGlvbihzdGF0dXMpe0VYSVRTVEFUVVM9c3RhdHVzfSx0aHJlYWRFeGl0OmZ1bmN0aW9uKGV4aXRDb2RlKXt2YXIgdGI9X3B0aHJlYWRfc2VsZigpO2lmKHRiKXtQVGhyZWFkLnJ1bkV4aXRIYW5kbGVyc0FuZERlaW5pdFRocmVhZCh0YixleGl0Q29kZSk7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7cG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJleGl0XCJ9KX19fSx0aHJlYWRDYW5jZWw6ZnVuY3Rpb24oKXtQVGhyZWFkLnJ1bkV4aXRIYW5kbGVyc0FuZERlaW5pdFRocmVhZChfcHRocmVhZF9zZWxmKCksLTEpO3Bvc3RNZXNzYWdlKHtcImNtZFwiOlwiY2FuY2VsRG9uZVwifSl9LHRlcm1pbmF0ZUFsbFRocmVhZHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gUFRocmVhZC5wdGhyZWFkcyl7dmFyIHB0aHJlYWQ9UFRocmVhZC5wdGhyZWFkc1t0XTtpZihwdGhyZWFkJiZwdGhyZWFkLndvcmtlcil7UFRocmVhZC5yZXR1cm5Xb3JrZXJUb1Bvb2wocHRocmVhZC53b3JrZXIpfX1QVGhyZWFkLnB0aHJlYWRzPXt9O2Zvcih2YXIgaT0wO2k8UFRocmVhZC51bnVzZWRXb3JrZXJzLmxlbmd0aDsrK2kpe3ZhciB3b3JrZXI9UFRocmVhZC51bnVzZWRXb3JrZXJzW2ldO3dvcmtlci50ZXJtaW5hdGUoKX1QVGhyZWFkLnVudXNlZFdvcmtlcnM9W107Zm9yKHZhciBpPTA7aTxQVGhyZWFkLnJ1bm5pbmdXb3JrZXJzLmxlbmd0aDsrK2kpe3ZhciB3b3JrZXI9UFRocmVhZC5ydW5uaW5nV29ya2Vyc1tpXTt2YXIgcHRocmVhZD13b3JrZXIucHRocmVhZDtQVGhyZWFkLmZyZWVUaHJlYWREYXRhKHB0aHJlYWQpO3dvcmtlci50ZXJtaW5hdGUoKX1QVGhyZWFkLnJ1bm5pbmdXb3JrZXJzPVtdfSxmcmVlVGhyZWFkRGF0YTpmdW5jdGlvbihwdGhyZWFkKXtpZighcHRocmVhZClyZXR1cm47aWYocHRocmVhZC50aHJlYWRJbmZvU3RydWN0KXt2YXIgdGxzTWVtb3J5PUdST1dBQkxFX0hFQVBfSTMyKClbcHRocmVhZC50aHJlYWRJbmZvU3RydWN0KzEwMD4+Ml07R1JPV0FCTEVfSEVBUF9JMzIoKVtwdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3QrMTAwPj4yXT0wO19mcmVlKHRsc01lbW9yeSk7X2ZyZWUocHRocmVhZC50aHJlYWRJbmZvU3RydWN0KX1wdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3Q9MDtpZihwdGhyZWFkLmFsbG9jYXRlZE93blN0YWNrJiZwdGhyZWFkLnN0YWNrQmFzZSlfZnJlZShwdGhyZWFkLnN0YWNrQmFzZSk7cHRocmVhZC5zdGFja0Jhc2U9MDtpZihwdGhyZWFkLndvcmtlcilwdGhyZWFkLndvcmtlci5wdGhyZWFkPW51bGx9LHJldHVybldvcmtlclRvUG9vbDpmdW5jdGlvbih3b3JrZXIpe1BUaHJlYWQucnVuV2l0aG91dE1haW5UaHJlYWRRdWV1ZWRDYWxscyhmdW5jdGlvbigpe2RlbGV0ZSBQVGhyZWFkLnB0aHJlYWRzW3dvcmtlci5wdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3RdO1BUaHJlYWQudW51c2VkV29ya2Vycy5wdXNoKHdvcmtlcik7UFRocmVhZC5ydW5uaW5nV29ya2Vycy5zcGxpY2UoUFRocmVhZC5ydW5uaW5nV29ya2Vycy5pbmRleE9mKHdvcmtlciksMSk7UFRocmVhZC5mcmVlVGhyZWFkRGF0YSh3b3JrZXIucHRocmVhZCk7d29ya2VyLnB0aHJlYWQ9dW5kZWZpbmVkfSl9LHJ1bldpdGhvdXRNYWluVGhyZWFkUXVldWVkQ2FsbHM6ZnVuY3Rpb24oZnVuYyl7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2Vtc2NyaXB0ZW5fYWxsb3dfbWFpbl9ydW50aW1lX3F1ZXVlZF9jYWxscz4+Ml09MDt0cnl7ZnVuYygpfWZpbmFsbHl7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2Vtc2NyaXB0ZW5fYWxsb3dfbWFpbl9ydW50aW1lX3F1ZXVlZF9jYWxscz4+Ml09MX19LHJlY2VpdmVPYmplY3RUcmFuc2ZlcjpmdW5jdGlvbihkYXRhKXt9LHRocmVhZEluaXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGkgaW4gUFRocmVhZC50bHNJbml0RnVuY3Rpb25zKXtQVGhyZWFkLnRsc0luaXRGdW5jdGlvbnNbaV0oKX19LGxvYWRXYXNtTW9kdWxlVG9Xb3JrZXI6ZnVuY3Rpb24od29ya2VyLG9uRmluaXNoZWRMb2FkaW5nKXt3b3JrZXIub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBkPWVbXCJkYXRhXCJdO3ZhciBjbWQ9ZFtcImNtZFwiXTtpZih3b3JrZXIucHRocmVhZClQVGhyZWFkLmN1cnJlbnRQcm94aWVkT3BlcmF0aW9uQ2FsbGVyVGhyZWFkPXdvcmtlci5wdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3Q7aWYoZFtcInRhcmdldFRocmVhZFwiXSYmZFtcInRhcmdldFRocmVhZFwiXSE9X3B0aHJlYWRfc2VsZigpKXt2YXIgdGhyZWFkPVBUaHJlYWQucHRocmVhZHNbZC50YXJnZXRUaHJlYWRdO2lmKHRocmVhZCl7dGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZShlLmRhdGEsZFtcInRyYW5zZmVyTGlzdFwiXSl9ZWxzZXtjb25zb2xlLmVycm9yKCdJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJytjbWQrJ1wiIHRvIHRhcmdldCBwdGhyZWFkICcrZFtcInRhcmdldFRocmVhZFwiXStcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfVBUaHJlYWQuY3VycmVudFByb3hpZWRPcGVyYXRpb25DYWxsZXJUaHJlYWQ9dW5kZWZpbmVkO3JldHVybn1pZihjbWQ9PT1cInByb2Nlc3NRdWV1ZWRNYWluVGhyZWFkV29ya1wiKXtfZW1zY3JpcHRlbl9tYWluX3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscygpfWVsc2UgaWYoY21kPT09XCJzcGF3blRocmVhZFwiKXtzcGF3blRocmVhZChlLmRhdGEpfWVsc2UgaWYoY21kPT09XCJjbGVhbnVwVGhyZWFkXCIpe2NsZWFudXBUaHJlYWQoZFtcInRocmVhZFwiXSl9ZWxzZSBpZihjbWQ9PT1cImtpbGxUaHJlYWRcIil7a2lsbFRocmVhZChkW1widGhyZWFkXCJdKX1lbHNlIGlmKGNtZD09PVwiY2FuY2VsVGhyZWFkXCIpe2NhbmNlbFRocmVhZChkW1widGhyZWFkXCJdKX1lbHNlIGlmKGNtZD09PVwibG9hZGVkXCIpe3dvcmtlci5sb2FkZWQ9dHJ1ZTtpZihvbkZpbmlzaGVkTG9hZGluZylvbkZpbmlzaGVkTG9hZGluZyh3b3JrZXIpO2lmKHdvcmtlci5ydW5QdGhyZWFkKXt3b3JrZXIucnVuUHRocmVhZCgpO2RlbGV0ZSB3b3JrZXIucnVuUHRocmVhZH19ZWxzZSBpZihjbWQ9PT1cInByaW50XCIpe291dChcIlRocmVhZCBcIitkW1widGhyZWFkSWRcIl0rXCI6IFwiK2RbXCJ0ZXh0XCJdKX1lbHNlIGlmKGNtZD09PVwicHJpbnRFcnJcIil7ZXJyKFwiVGhyZWFkIFwiK2RbXCJ0aHJlYWRJZFwiXStcIjogXCIrZFtcInRleHRcIl0pfWVsc2UgaWYoY21kPT09XCJhbGVydFwiKXthbGVydChcIlRocmVhZCBcIitkW1widGhyZWFkSWRcIl0rXCI6IFwiK2RbXCJ0ZXh0XCJdKX1lbHNlIGlmKGNtZD09PVwiZXhpdFwiKXt2YXIgZGV0YWNoZWQ9d29ya2VyLnB0aHJlYWQmJkF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX1UzMigpLHdvcmtlci5wdGhyZWFkLnRocmVhZEluZm9TdHJ1Y3QrNjQ+PjIpO2lmKGRldGFjaGVkKXtQVGhyZWFkLnJldHVybldvcmtlclRvUG9vbCh3b3JrZXIpfX1lbHNlIGlmKGNtZD09PVwiZXhpdFByb2Nlc3NcIil7dHJ5e2V4aXQoZFtcInJldHVybkNvZGVcIl0pfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzKXJldHVybjt0aHJvdyBlfX1lbHNlIGlmKGNtZD09PVwiY2FuY2VsRG9uZVwiKXtQVGhyZWFkLnJldHVybldvcmtlclRvUG9vbCh3b3JrZXIpfWVsc2UgaWYoY21kPT09XCJvYmplY3RUcmFuc2ZlclwiKXtQVGhyZWFkLnJlY2VpdmVPYmplY3RUcmFuc2ZlcihlLmRhdGEpfWVsc2UgaWYoZS5kYXRhLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCIpe3dvcmtlci5wb3N0TWVzc2FnZShlLmRhdGEpfWVsc2V7ZXJyKFwid29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kIFwiK2NtZCl9UFRocmVhZC5jdXJyZW50UHJveGllZE9wZXJhdGlvbkNhbGxlclRocmVhZD11bmRlZmluZWR9O3dvcmtlci5vbmVycm9yPWZ1bmN0aW9uKGUpe2VycihcInB0aHJlYWQgc2VudCBhbiBlcnJvciEgXCIrZS5maWxlbmFtZStcIjpcIitlLmxpbmVubytcIjogXCIrZS5tZXNzYWdlKX07aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7d29ya2VyLm9uKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGRhdGEpe3dvcmtlci5vbm1lc3NhZ2Uoe2RhdGE6ZGF0YX0pfSk7d29ya2VyLm9uKFwiZXJyb3JcIixmdW5jdGlvbihkYXRhKXt3b3JrZXIub25lcnJvcihkYXRhKX0pO3dvcmtlci5vbihcImV4aXRcIixmdW5jdGlvbihkYXRhKXt9KX13b3JrZXIucG9zdE1lc3NhZ2Uoe1wiY21kXCI6XCJsb2FkXCIsXCJ1cmxPckJsb2JcIjpNb2R1bGVbXCJtYWluU2NyaXB0VXJsT3JCbG9iXCJdfHxfc2NyaXB0RGlyLFwid2FzbU1lbW9yeVwiOndhc21NZW1vcnksXCJ3YXNtTW9kdWxlXCI6d2FzbU1vZHVsZX0pfSxhbGxvY2F0ZVVudXNlZFdvcmtlcjpmdW5jdGlvbigpe3ZhciBwdGhyZWFkTWFpbkpzPWxvY2F0ZUZpbGUoXCJvcnQtd2FzbS10aHJlYWRlZC53b3JrZXIuanNcIik7UFRocmVhZC51bnVzZWRXb3JrZXJzLnB1c2gobmV3IFdvcmtlcihwdGhyZWFkTWFpbkpzKSl9LGdldE5ld1dvcmtlcjpmdW5jdGlvbigpe2lmKFBUaHJlYWQudW51c2VkV29ya2Vycy5sZW5ndGg9PTApe1BUaHJlYWQuYWxsb2NhdGVVbnVzZWRXb3JrZXIoKTtQVGhyZWFkLmxvYWRXYXNtTW9kdWxlVG9Xb3JrZXIoUFRocmVhZC51bnVzZWRXb3JrZXJzWzBdKX1yZXR1cm4gUFRocmVhZC51bnVzZWRXb3JrZXJzLnBvcCgpfSxidXN5U3BpbldhaXQ6ZnVuY3Rpb24obXNlY3Mpe3ZhciB0PXBlcmZvcm1hbmNlLm5vdygpK21zZWNzO3doaWxlKHBlcmZvcm1hbmNlLm5vdygpPHQpe319fTtmdW5jdGlvbiBlc3RhYmxpc2hTdGFja1NwYWNlKHN0YWNrVG9wLHN0YWNrTWF4KXtfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzKHN0YWNrVG9wLHN0YWNrTWF4KTtzdGFja1Jlc3RvcmUoc3RhY2tUb3ApfU1vZHVsZVtcImVzdGFibGlzaFN0YWNrU3BhY2VcIl09ZXN0YWJsaXNoU3RhY2tTcGFjZTtmdW5jdGlvbiBpbnZva2VFbnRyeVBvaW50KHB0cixhcmcpe3JldHVybiB3YXNtVGFibGUuZ2V0KHB0cikoYXJnKX1Nb2R1bGVbXCJpbnZva2VFbnRyeVBvaW50XCJdPWludm9rZUVudHJ5UG9pbnQ7dmFyIHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyPTA7ZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpe3JldHVybiBub0V4aXRSdW50aW1lfHxydW50aW1lS2VlcGFsaXZlQ291bnRlcj4wfU1vZHVsZVtcImtlZXBSdW50aW1lQWxpdmVcIl09a2VlcFJ1bnRpbWVBbGl2ZTtmdW5jdGlvbiBfX19hc3NlcnRfZmFpbChjb25kaXRpb24sZmlsZW5hbWUsbGluZSxmdW5jKXthYm9ydChcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK1VURjhUb1N0cmluZyhjb25kaXRpb24pK1wiLCBhdDogXCIrW2ZpbGVuYW1lP1VURjhUb1N0cmluZyhmaWxlbmFtZSk6XCJ1bmtub3duIGZpbGVuYW1lXCIsbGluZSxmdW5jP1VURjhUb1N0cmluZyhmdW5jKTpcInVua25vd24gZnVuY3Rpb25cIl0pfXZhciBfZW1zY3JpcHRlbl9nZXRfbm93O2lmKEVOVklST05NRU5UX0lTX05PREUpe19lbXNjcmlwdGVuX2dldF9ub3c9ZnVuY3Rpb24oKXt2YXIgdD1wcm9jZXNzW1wiaHJ0aW1lXCJdKCk7cmV0dXJuIHRbMF0qMWUzK3RbMV0vMWU2fX1lbHNlIGlmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpe19lbXNjcmlwdGVuX2dldF9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCktTW9kdWxlW1wiX19wZXJmb3JtYW5jZV9ub3dfY2xvY2tfZHJpZnRcIl19fWVsc2UgaWYodHlwZW9mIGRhdGVOb3chPT1cInVuZGVmaW5lZFwiKXtfZW1zY3JpcHRlbl9nZXRfbm93PWRhdGVOb3d9ZWxzZSBfZW1zY3JpcHRlbl9nZXRfbm93PWZ1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfTt2YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWM9dHJ1ZTtmdW5jdGlvbiBzZXRFcnJObyh2YWx1ZSl7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX19lcnJub19sb2NhdGlvbigpPj4yXT12YWx1ZTtyZXR1cm4gdmFsdWV9ZnVuY3Rpb24gX2Nsb2NrX2dldHRpbWUoY2xrX2lkLHRwKXt2YXIgbm93O2lmKGNsa19pZD09PTApe25vdz1EYXRlLm5vdygpfWVsc2UgaWYoKGNsa19pZD09PTF8fGNsa19pZD09PTQpJiZfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyl7bm93PV9lbXNjcmlwdGVuX2dldF9ub3coKX1lbHNle3NldEVyck5vKDI4KTtyZXR1cm4tMX1HUk9XQUJMRV9IRUFQX0kzMigpW3RwPj4yXT1ub3cvMWUzfDA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0cCs0Pj4yXT1ub3clMWUzKjFlMyoxZTN8MDtyZXR1cm4gMH1mdW5jdGlvbiBfX19jbG9ja19nZXR0aW1lKGEwLGExKXtyZXR1cm4gX2Nsb2NrX2dldHRpbWUoYTAsYTEpfXZhciBFeGNlcHRpb25JbmZvQXR0cnM9e0RFU1RSVUNUT1JfT0ZGU0VUOjAsUkVGQ09VTlRfT0ZGU0VUOjQsVFlQRV9PRkZTRVQ6OCxDQVVHSFRfT0ZGU0VUOjEyLFJFVEhST1dOX09GRlNFVDoxMyxTSVpFOjE2fTtmdW5jdGlvbiBfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uKHNpemUpe3JldHVybiBfbWFsbG9jKHNpemUrRXhjZXB0aW9uSW5mb0F0dHJzLlNJWkUpK0V4Y2VwdGlvbkluZm9BdHRycy5TSVpFfWZ1bmN0aW9uIF9hdGV4aXQoZnVuYyxhcmcpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDEsMSxmdW5jLGFyZyk7X19BVEVYSVRfXy51bnNoaWZ0KHtmdW5jOmZ1bmMsYXJnOmFyZ30pfWZ1bmN0aW9uIF9fX2N4YV9hdGV4aXQoYTAsYTEpe3JldHVybiBfYXRleGl0KGEwLGExKX1mdW5jdGlvbiBfcHRocmVhZF9jbGVhbnVwX3B1c2gocm91dGluZSxhcmcpe1BUaHJlYWQudGhyZWFkRXhpdEhhbmRsZXJzLnB1c2goZnVuY3Rpb24oKXt3YXNtVGFibGUuZ2V0KHJvdXRpbmUpKGFyZyl9KX1mdW5jdGlvbiBfX19jeGFfdGhyZWFkX2F0ZXhpdChhMCxhMSl7cmV0dXJuIF9wdGhyZWFkX2NsZWFudXBfcHVzaChhMCxhMSl9ZnVuY3Rpb24gRXhjZXB0aW9uSW5mbyhleGNQdHIpe3RoaXMuZXhjUHRyPWV4Y1B0cjt0aGlzLnB0cj1leGNQdHItRXhjZXB0aW9uSW5mb0F0dHJzLlNJWkU7dGhpcy5zZXRfdHlwZT1mdW5jdGlvbih0eXBlKXtHUk9XQUJMRV9IRUFQX0kzMigpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5UWVBFX09GRlNFVD4+Ml09dHlwZX07dGhpcy5nZXRfdHlwZT1mdW5jdGlvbigpe3JldHVybiBHUk9XQUJMRV9IRUFQX0kzMigpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5UWVBFX09GRlNFVD4+Ml19O3RoaXMuc2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oZGVzdHJ1Y3Rvcil7R1JPV0FCTEVfSEVBUF9JMzIoKVt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuREVTVFJVQ1RPUl9PRkZTRVQ+PjJdPWRlc3RydWN0b3J9O3RoaXMuZ2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gR1JPV0FCTEVfSEVBUF9JMzIoKVt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuREVTVFJVQ1RPUl9PRkZTRVQ+PjJdfTt0aGlzLnNldF9yZWZjb3VudD1mdW5jdGlvbihyZWZjb3VudCl7R1JPV0FCTEVfSEVBUF9JMzIoKVt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVGQ09VTlRfT0ZGU0VUPj4yXT1yZWZjb3VudH07dGhpcy5zZXRfY2F1Z2h0PWZ1bmN0aW9uKGNhdWdodCl7Y2F1Z2h0PWNhdWdodD8xOjA7R1JPV0FCTEVfSEVBUF9JOCgpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5DQVVHSFRfT0ZGU0VUPj4wXT1jYXVnaHR9O3RoaXMuZ2V0X2NhdWdodD1mdW5jdGlvbigpe3JldHVybiBHUk9XQUJMRV9IRUFQX0k4KClbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLkNBVUdIVF9PRkZTRVQ+PjBdIT0wfTt0aGlzLnNldF9yZXRocm93bj1mdW5jdGlvbihyZXRocm93bil7cmV0aHJvd249cmV0aHJvd24/MTowO0dST1dBQkxFX0hFQVBfSTgoKVt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuUkVUSFJPV05fT0ZGU0VUPj4wXT1yZXRocm93bn07dGhpcy5nZXRfcmV0aHJvd249ZnVuY3Rpb24oKXtyZXR1cm4gR1JPV0FCTEVfSEVBUF9JOCgpW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5SRVRIUk9XTl9PRkZTRVQ+PjBdIT0wfTt0aGlzLmluaXQ9ZnVuY3Rpb24odHlwZSxkZXN0cnVjdG9yKXt0aGlzLnNldF90eXBlKHR5cGUpO3RoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcik7dGhpcy5zZXRfcmVmY291bnQoMCk7dGhpcy5zZXRfY2F1Z2h0KGZhbHNlKTt0aGlzLnNldF9yZXRocm93bihmYWxzZSl9O3RoaXMuYWRkX3JlZj1mdW5jdGlvbigpe0F0b21pY3MuYWRkKEdST1dBQkxFX0hFQVBfSTMyKCksdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+MiwxKX07dGhpcy5yZWxlYXNlX3JlZj1mdW5jdGlvbigpe3ZhciBwcmV2PUF0b21pY3Muc3ViKEdST1dBQkxFX0hFQVBfSTMyKCksdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+MiwxKTtyZXR1cm4gcHJldj09PTF9fXZhciBleGNlcHRpb25MYXN0PTA7dmFyIHVuY2F1Z2h0RXhjZXB0aW9uQ291bnQ9MDtmdW5jdGlvbiBfX19jeGFfdGhyb3cocHRyLHR5cGUsZGVzdHJ1Y3Rvcil7dmFyIGluZm89bmV3IEV4Y2VwdGlvbkluZm8ocHRyKTtpbmZvLmluaXQodHlwZSxkZXN0cnVjdG9yKTtleGNlcHRpb25MYXN0PXB0cjt1bmNhdWdodEV4Y2VwdGlvbkNvdW50Kys7dGhyb3cgcHRyfXZhciBTWVNDQUxMUz17bWFwcGluZ3M6e30sYnVmZmVyczpbbnVsbCxbXSxbXV0scHJpbnRDaGFyOmZ1bmN0aW9uKHN0cmVhbSxjdXJyKXt2YXIgYnVmZmVyPVNZU0NBTExTLmJ1ZmZlcnNbc3RyZWFtXTtpZihjdXJyPT09MHx8Y3Vycj09PTEwKXsoc3RyZWFtPT09MT9vdXQ6ZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsMCkpO2J1ZmZlci5sZW5ndGg9MH1lbHNle2J1ZmZlci5wdXNoKGN1cnIpfX0sdmFyYXJnczp1bmRlZmluZWQsZ2V0OmZ1bmN0aW9uKCl7U1lTQ0FMTFMudmFyYXJncys9NDt2YXIgcmV0PUdST1dBQkxFX0hFQVBfSTMyKClbU1lTQ0FMTFMudmFyYXJncy00Pj4yXTtyZXR1cm4gcmV0fSxnZXRTdHI6ZnVuY3Rpb24ocHRyKXt2YXIgcmV0PVVURjhUb1N0cmluZyhwdHIpO3JldHVybiByZXR9LGdldDY0OmZ1bmN0aW9uKGxvdyxoaWdoKXtyZXR1cm4gbG93fX07ZnVuY3Rpb24gX19fc3lzX2FjY2VzcyhwYXRoLGFtb2RlKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygyLDEscGF0aCxhbW9kZSk7cGF0aD1TWVNDQUxMUy5nZXRTdHIocGF0aCk7cmV0dXJuIFNZU0NBTExTLmRvQWNjZXNzKHBhdGgsYW1vZGUpfWZ1bmN0aW9uIF9fX3N5c19mY250bDY0KGZkLGNtZCx2YXJhcmdzKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygzLDEsZmQsY21kLHZhcmFyZ3MpO1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJncztyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNfZnN0YXQ2NChmZCxidWYpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDQsMSxmZCxidWYpfWZ1bmN0aW9uIF9fX3N5c19nZXRkZW50czY0KGZkLGRpcnAsY291bnQpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDUsMSxmZCxkaXJwLGNvdW50KX1mdW5jdGlvbiBfX19zeXNfZ2V0cGlkKCl7cmV0dXJuIDQyfWZ1bmN0aW9uIF9fX3N5c19pb2N0bChmZCxvcCx2YXJhcmdzKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcyg2LDEsZmQsb3AsdmFyYXJncyk7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3JldHVybiAwfWZ1bmN0aW9uIF9fX3N5c19sc3RhdDY0KHBhdGgsYnVmKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcyg3LDEscGF0aCxidWYpfWZ1bmN0aW9uIF9fX3N5c19ta2RpcihwYXRoLG1vZGUpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDgsMSxwYXRoLG1vZGUpO3BhdGg9U1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO3JldHVybiBTWVNDQUxMUy5kb01rZGlyKHBhdGgsbW9kZSl9ZnVuY3Rpb24gc3lzY2FsbE1tYXAyKGFkZHIsbGVuLHByb3QsZmxhZ3MsZmQsb2ZmKXtvZmY8PD0xMjt2YXIgcHRyO3ZhciBhbGxvY2F0ZWQ9ZmFsc2U7aWYoKGZsYWdzJjE2KSE9PTAmJmFkZHIlNjU1MzYhPT0wKXtyZXR1cm4tMjh9aWYoKGZsYWdzJjMyKSE9PTApe3B0cj1fbWVtYWxpZ24oNjU1MzYsbGVuKTtpZighcHRyKXJldHVybi00ODtfbWVtc2V0KHB0ciwwLGxlbik7YWxsb2NhdGVkPXRydWV9ZWxzZXtyZXR1cm4tNTJ9U1lTQ0FMTFMubWFwcGluZ3NbcHRyXT17bWFsbG9jOnB0cixsZW46bGVuLGFsbG9jYXRlZDphbGxvY2F0ZWQsZmQ6ZmQscHJvdDpwcm90LGZsYWdzOmZsYWdzLG9mZnNldDpvZmZ9O3JldHVybiBwdHJ9ZnVuY3Rpb24gX19fc3lzX21tYXAyKGFkZHIsbGVuLHByb3QsZmxhZ3MsZmQsb2ZmKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcyg5LDEsYWRkcixsZW4scHJvdCxmbGFncyxmZCxvZmYpO3JldHVybiBzeXNjYWxsTW1hcDIoYWRkcixsZW4scHJvdCxmbGFncyxmZCxvZmYpfWZ1bmN0aW9uIHN5c2NhbGxNdW5tYXAoYWRkcixsZW4pe2lmKChhZGRyfDApPT09LTF8fGxlbj09PTApe3JldHVybi0yOH12YXIgaW5mbz1TWVNDQUxMUy5tYXBwaW5nc1thZGRyXTtpZighaW5mbylyZXR1cm4gMDtpZihsZW49PT1pbmZvLmxlbil7U1lTQ0FMTFMubWFwcGluZ3NbYWRkcl09bnVsbDtpZihpbmZvLmFsbG9jYXRlZCl7X2ZyZWUoaW5mby5tYWxsb2MpfX1yZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNfbXVubWFwKGFkZHIsbGVuKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxMCwxLGFkZHIsbGVuKTtyZXR1cm4gc3lzY2FsbE11bm1hcChhZGRyLGxlbil9ZnVuY3Rpb24gX19fc3lzX29wZW4ocGF0aCxmbGFncyx2YXJhcmdzKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxMSwxLHBhdGgsZmxhZ3MsdmFyYXJncyk7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzfWZ1bmN0aW9uIF9fX3N5c19yZWFkbGluayhwYXRoLGJ1ZixidWZzaXplKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxMiwxLHBhdGgsYnVmLGJ1ZnNpemUpO3BhdGg9U1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO3JldHVybiBTWVNDQUxMUy5kb1JlYWRsaW5rKHBhdGgsYnVmLGJ1ZnNpemUpfWZ1bmN0aW9uIF9fX3N5c19ybWRpcihwYXRoKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxMywxLHBhdGgpfWZ1bmN0aW9uIF9fX3N5c19zdGF0NjQocGF0aCxidWYpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpcmV0dXJuIF9lbXNjcmlwdGVuX3Byb3h5X3RvX21haW5fdGhyZWFkX2pzKDE0LDEscGF0aCxidWYpfWZ1bmN0aW9uIF9fX3N5c191bmxpbmsocGF0aCl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMTUsMSxwYXRoKX1mdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fbm90aWZ5X3RocmVhZF9xdWV1ZSh0YXJnZXRUaHJlYWRJZCxtYWluVGhyZWFkSWQpe2lmKHRhcmdldFRocmVhZElkPT1tYWluVGhyZWFkSWQpe3Bvc3RNZXNzYWdlKHtcImNtZFwiOlwicHJvY2Vzc1F1ZXVlZE1haW5UaHJlYWRXb3JrXCJ9KX1lbHNlIGlmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpe3Bvc3RNZXNzYWdlKHtcInRhcmdldFRocmVhZFwiOnRhcmdldFRocmVhZElkLFwiY21kXCI6XCJwcm9jZXNzVGhyZWFkUXVldWVcIn0pfWVsc2V7dmFyIHB0aHJlYWQ9UFRocmVhZC5wdGhyZWFkc1t0YXJnZXRUaHJlYWRJZF07dmFyIHdvcmtlcj1wdGhyZWFkJiZwdGhyZWFkLndvcmtlcjtpZighd29ya2VyKXtyZXR1cm59d29ya2VyLnBvc3RNZXNzYWdlKHtcImNtZFwiOlwicHJvY2Vzc1RocmVhZFF1ZXVlXCJ9KX1yZXR1cm4gMX1mdW5jdGlvbiBfYWJvcnQoKXthYm9ydCgpfWZ1bmN0aW9uIF9kaWZmdGltZSh0aW1lMSx0aW1lMCl7cmV0dXJuIHRpbWUxLXRpbWUwfWZ1bmN0aW9uIF9kbGNsb3NlKGhhbmRsZSl7YWJvcnQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCB0byB1c2UgRW1zY3JpcHRlbidzIGxpbmtpbmcgc3VwcG9ydCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9ZnVuY3Rpb24gX2RsZXJyb3IoKXthYm9ydChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIHRvIHVzZSBFbXNjcmlwdGVuJ3MgbGlua2luZyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX1mdW5jdGlvbiBfZGxvcGVuKGZpbGVuYW1lLGZsYWcpe2Fib3J0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgdG8gdXNlIEVtc2NyaXB0ZW4ncyBsaW5raW5nIHN1cHBvcnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfWZ1bmN0aW9uIF9kbHN5bShoYW5kbGUsc3ltYm9sKXthYm9ydChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIHRvIHVzZSBFbXNjcmlwdGVuJ3MgbGlua2luZyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX12YXIgcmVhZEFzbUNvbnN0QXJnc0FycmF5PVtdO2Z1bmN0aW9uIHJlYWRBc21Db25zdEFyZ3Moc2lnUHRyLGJ1Zil7cmVhZEFzbUNvbnN0QXJnc0FycmF5Lmxlbmd0aD0wO3ZhciBjaDtidWY+Pj0yO3doaWxlKGNoPUdST1dBQkxFX0hFQVBfVTgoKVtzaWdQdHIrK10pe3ZhciBkb3VibGU9Y2g8MTA1O2lmKGRvdWJsZSYmYnVmJjEpYnVmKys7cmVhZEFzbUNvbnN0QXJnc0FycmF5LnB1c2goZG91YmxlP0dST1dBQkxFX0hFQVBfRjY0KClbYnVmKys+PjFdOkdST1dBQkxFX0hFQVBfSTMyKClbYnVmXSk7KytidWZ9cmV0dXJuIHJlYWRBc21Db25zdEFyZ3NBcnJheX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9hc21fY29uc3RfaW50KGNvZGUsc2lnUHRyLGFyZ2J1Zil7dmFyIGFyZ3M9cmVhZEFzbUNvbnN0QXJncyhzaWdQdHIsYXJnYnVmKTtyZXR1cm4gQVNNX0NPTlNUU1tjb2RlXS5hcHBseShudWxsLGFyZ3MpfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX2NoZWNrX2Jsb2NraW5nX2FsbG93ZWQoKXtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXJldHVybjtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpcmV0dXJuO3dhcm5PbmNlKFwiQmxvY2tpbmcgb24gdGhlIG1haW4gdGhyZWFkIGlzIHZlcnkgZGFuZ2Vyb3VzLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL3BvcnRpbmcvcHRocmVhZHMuaHRtbCNibG9ja2luZy1vbi10aGUtbWFpbi1icm93c2VyLXRocmVhZFwiKX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9jb25kaXRpb25hbF9zZXRfY3VycmVudF90aHJlYWRfc3RhdHVzKGV4cGVjdGVkU3RhdHVzLG5ld1N0YXR1cyl7fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX2Z1dGV4X3dhaXQoYWRkcix2YWwsdGltZW91dCl7aWYoYWRkcjw9MHx8YWRkcj5HUk9XQUJMRV9IRUFQX0k4KCkubGVuZ3RofHxhZGRyJjMhPTApcmV0dXJuLTI4O2lmKCFFTlZJUk9OTUVOVF9JU19XRUIpe3ZhciByZXQ9QXRvbWljcy53YWl0KEdST1dBQkxFX0hFQVBfSTMyKCksYWRkcj4+Mix2YWwsdGltZW91dCk7aWYocmV0PT09XCJ0aW1lZC1vdXRcIilyZXR1cm4tNzM7aWYocmV0PT09XCJub3QtZXF1YWxcIilyZXR1cm4tNjtpZihyZXQ9PT1cIm9rXCIpcmV0dXJuIDA7dGhyb3dcIkF0b21pY3Mud2FpdCByZXR1cm5lZCBhbiB1bmV4cGVjdGVkIHZhbHVlIFwiK3JldH1lbHNle2lmKEF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX0kzMigpLGFkZHI+PjIpIT12YWwpe3JldHVybi02fXZhciB0Tm93PXBlcmZvcm1hbmNlLm5vdygpO3ZhciB0RW5kPXROb3crdGltZW91dDt2YXIgbGFzdEFkZHI9QXRvbWljcy5leGNoYW5nZShHUk9XQUJMRV9IRUFQX0kzMigpLF9fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9mdXRleD4+MixhZGRyKTt3aGlsZSgxKXt0Tm93PXBlcmZvcm1hbmNlLm5vdygpO2lmKHROb3c+dEVuZCl7bGFzdEFkZHI9QXRvbWljcy5leGNoYW5nZShHUk9XQUJMRV9IRUFQX0kzMigpLF9fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9mdXRleD4+MiwwKTtyZXR1cm4tNzN9bGFzdEFkZHI9QXRvbWljcy5leGNoYW5nZShHUk9XQUJMRV9IRUFQX0kzMigpLF9fZW1zY3JpcHRlbl9tYWluX3RocmVhZF9mdXRleD4+MiwwKTtpZihsYXN0QWRkcj09MCl7YnJlYWt9X2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHMoKTtpZihBdG9taWNzLmxvYWQoR1JPV0FCTEVfSEVBUF9JMzIoKSxhZGRyPj4yKSE9dmFsKXtyZXR1cm4tNn1sYXN0QWRkcj1BdG9taWNzLmV4Y2hhbmdlKEdST1dBQkxFX0hFQVBfSTMyKCksX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4Pj4yLGFkZHIpfXJldHVybiAwfX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgoKXtyZXR1cm4gMjE0NzQ4MzY0OH1mdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3Qsc3JjLG51bSl7R1JPV0FCTEVfSEVBUF9VOCgpLmNvcHlXaXRoaW4oZGVzdCxzcmMsc3JjK251bSl9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbnVtX2xvZ2ljYWxfY29yZXMoKXtpZihFTlZJUk9OTUVOVF9JU19OT0RFKXJldHVybiByZXF1aXJlKFwib3NcIikuY3B1cygpLmxlbmd0aDtyZXR1cm4gbmF2aWdhdG9yW1wiaGFyZHdhcmVDb25jdXJyZW5jeVwiXX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcyhpbmRleCxzeW5jKXt2YXIgbnVtQ2FsbEFyZ3M9YXJndW1lbnRzLmxlbmd0aC0yO3ZhciBzdGFjaz1zdGFja1NhdmUoKTt2YXIgc2VyaWFsaXplZE51bUNhbGxBcmdzPW51bUNhbGxBcmdzO3ZhciBhcmdzPXN0YWNrQWxsb2Moc2VyaWFsaXplZE51bUNhbGxBcmdzKjgpO3ZhciBiPWFyZ3M+PjM7Zm9yKHZhciBpPTA7aTxudW1DYWxsQXJncztpKyspe3ZhciBhcmc9YXJndW1lbnRzWzIraV07R1JPV0FCTEVfSEVBUF9GNjQoKVtiK2ldPWFyZ312YXIgcmV0PV9lbXNjcmlwdGVuX3J1bl9pbl9tYWluX3J1bnRpbWVfdGhyZWFkX2pzKGluZGV4LHNlcmlhbGl6ZWROdW1DYWxsQXJncyxhcmdzLHN5bmMpO3N0YWNrUmVzdG9yZShzdGFjayk7cmV0dXJuIHJldH12YXIgX2Vtc2NyaXB0ZW5fcmVjZWl2ZV9vbl9tYWluX3RocmVhZF9qc19jYWxsQXJncz1bXTtmdW5jdGlvbiBfZW1zY3JpcHRlbl9yZWNlaXZlX29uX21haW5fdGhyZWFkX2pzKGluZGV4LG51bUNhbGxBcmdzLGFyZ3Mpe19lbXNjcmlwdGVuX3JlY2VpdmVfb25fbWFpbl90aHJlYWRfanNfY2FsbEFyZ3MubGVuZ3RoPW51bUNhbGxBcmdzO3ZhciBiPWFyZ3M+PjM7Zm9yKHZhciBpPTA7aTxudW1DYWxsQXJncztpKyspe19lbXNjcmlwdGVuX3JlY2VpdmVfb25fbWFpbl90aHJlYWRfanNfY2FsbEFyZ3NbaV09R1JPV0FCTEVfSEVBUF9GNjQoKVtiK2ldfXZhciBpc0VtQXNtQ29uc3Q9aW5kZXg8MDt2YXIgZnVuYz0haXNFbUFzbUNvbnN0P3Byb3hpZWRGdW5jdGlvblRhYmxlW2luZGV4XTpBU01fQ09OU1RTWy1pbmRleC0xXTtyZXR1cm4gZnVuYy5hcHBseShudWxsLF9lbXNjcmlwdGVuX3JlY2VpdmVfb25fbWFpbl90aHJlYWRfanNfY2FsbEFyZ3MpfWZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSl7dHJ5e3dhc21NZW1vcnkuZ3JvdyhzaXplLWJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpO3VwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKTtyZXR1cm4gMX1jYXRjaChlKXt9fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpe3ZhciBvbGRTaXplPUdST1dBQkxFX0hFQVBfVTgoKS5sZW5ndGg7cmVxdWVzdGVkU2l6ZT1yZXF1ZXN0ZWRTaXplPj4+MDtpZihyZXF1ZXN0ZWRTaXplPD1vbGRTaXplKXtyZXR1cm4gZmFsc2V9dmFyIG1heEhlYXBTaXplPTIxNDc0ODM2NDg7aWYocmVxdWVzdGVkU2l6ZT5tYXhIZWFwU2l6ZSl7cmV0dXJuIGZhbHNlfWZvcih2YXIgY3V0RG93bj0xO2N1dERvd248PTQ7Y3V0RG93bio9Mil7dmFyIG92ZXJHcm93bkhlYXBTaXplPW9sZFNpemUqKDErLjIvY3V0RG93bik7b3Zlckdyb3duSGVhcFNpemU9TWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUscmVxdWVzdGVkU2l6ZSsxMDA2NjMyOTYpO3ZhciBuZXdTaXplPU1hdGgubWluKG1heEhlYXBTaXplLGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSxvdmVyR3Jvd25IZWFwU2l6ZSksNjU1MzYpKTt2YXIgcmVwbGFjZW1lbnQ9ZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtpZihyZXBsYWNlbWVudCl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX12YXIgSlNFdmVudHM9e2luRXZlbnRIYW5kbGVyOjAscmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM6ZnVuY3Rpb24oKXtmb3IodmFyIGk9SlNFdmVudHMuZXZlbnRIYW5kbGVycy5sZW5ndGgtMTtpPj0wOy0taSl7SlNFdmVudHMuX3JlbW92ZUhhbmRsZXIoaSl9SlNFdmVudHMuZXZlbnRIYW5kbGVycz1bXTtKU0V2ZW50cy5kZWZlcnJlZENhbGxzPVtdfSxyZWdpc3RlclJlbW92ZUV2ZW50TGlzdGVuZXJzOmZ1bmN0aW9uKCl7aWYoIUpTRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXJzUmVnaXN0ZXJlZCl7X19BVEVYSVRfXy5wdXNoKEpTRXZlbnRzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKTtKU0V2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyc1JlZ2lzdGVyZWQ9dHJ1ZX19LGRlZmVycmVkQ2FsbHM6W10sZGVmZXJDYWxsOmZ1bmN0aW9uKHRhcmdldEZ1bmN0aW9uLHByZWNlZGVuY2UsYXJnc0xpc3Qpe2Z1bmN0aW9uIGFycmF5c0hhdmVFcXVhbENvbnRlbnQoYXJyQSxhcnJCKXtpZihhcnJBLmxlbmd0aCE9YXJyQi5sZW5ndGgpcmV0dXJuIGZhbHNlO2Zvcih2YXIgaSBpbiBhcnJBKXtpZihhcnJBW2ldIT1hcnJCW2ldKXJldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1mb3IodmFyIGkgaW4gSlNFdmVudHMuZGVmZXJyZWRDYWxscyl7dmFyIGNhbGw9SlNFdmVudHMuZGVmZXJyZWRDYWxsc1tpXTtpZihjYWxsLnRhcmdldEZ1bmN0aW9uPT10YXJnZXRGdW5jdGlvbiYmYXJyYXlzSGF2ZUVxdWFsQ29udGVudChjYWxsLmFyZ3NMaXN0LGFyZ3NMaXN0KSl7cmV0dXJufX1KU0V2ZW50cy5kZWZlcnJlZENhbGxzLnB1c2goe3RhcmdldEZ1bmN0aW9uOnRhcmdldEZ1bmN0aW9uLHByZWNlZGVuY2U6cHJlY2VkZW5jZSxhcmdzTGlzdDphcmdzTGlzdH0pO0pTRXZlbnRzLmRlZmVycmVkQ2FsbHMuc29ydChmdW5jdGlvbih4LHkpe3JldHVybiB4LnByZWNlZGVuY2U8eS5wcmVjZWRlbmNlfSl9LHJlbW92ZURlZmVycmVkQ2FsbHM6ZnVuY3Rpb24odGFyZ2V0RnVuY3Rpb24pe2Zvcih2YXIgaT0wO2k8SlNFdmVudHMuZGVmZXJyZWRDYWxscy5sZW5ndGg7KytpKXtpZihKU0V2ZW50cy5kZWZlcnJlZENhbGxzW2ldLnRhcmdldEZ1bmN0aW9uPT10YXJnZXRGdW5jdGlvbil7SlNFdmVudHMuZGVmZXJyZWRDYWxscy5zcGxpY2UoaSwxKTstLWl9fX0sY2FuUGVyZm9ybUV2ZW50SGFuZGxlclJlcXVlc3RzOmZ1bmN0aW9uKCl7cmV0dXJuIEpTRXZlbnRzLmluRXZlbnRIYW5kbGVyJiZKU0V2ZW50cy5jdXJyZW50RXZlbnRIYW5kbGVyLmFsbG93c0RlZmVycmVkQ2FsbHN9LHJ1bkRlZmVycmVkQ2FsbHM6ZnVuY3Rpb24oKXtpZighSlNFdmVudHMuY2FuUGVyZm9ybUV2ZW50SGFuZGxlclJlcXVlc3RzKCkpe3JldHVybn1mb3IodmFyIGk9MDtpPEpTRXZlbnRzLmRlZmVycmVkQ2FsbHMubGVuZ3RoOysraSl7dmFyIGNhbGw9SlNFdmVudHMuZGVmZXJyZWRDYWxsc1tpXTtKU0V2ZW50cy5kZWZlcnJlZENhbGxzLnNwbGljZShpLDEpOy0taTtjYWxsLnRhcmdldEZ1bmN0aW9uLmFwcGx5KG51bGwsY2FsbC5hcmdzTGlzdCl9fSxldmVudEhhbmRsZXJzOltdLHJlbW92ZUFsbEhhbmRsZXJzT25UYXJnZXQ6ZnVuY3Rpb24odGFyZ2V0LGV2ZW50VHlwZVN0cmluZyl7Zm9yKHZhciBpPTA7aTxKU0V2ZW50cy5ldmVudEhhbmRsZXJzLmxlbmd0aDsrK2kpe2lmKEpTRXZlbnRzLmV2ZW50SGFuZGxlcnNbaV0udGFyZ2V0PT10YXJnZXQmJighZXZlbnRUeXBlU3RyaW5nfHxldmVudFR5cGVTdHJpbmc9PUpTRXZlbnRzLmV2ZW50SGFuZGxlcnNbaV0uZXZlbnRUeXBlU3RyaW5nKSl7SlNFdmVudHMuX3JlbW92ZUhhbmRsZXIoaS0tKX19fSxfcmVtb3ZlSGFuZGxlcjpmdW5jdGlvbihpKXt2YXIgaD1KU0V2ZW50cy5ldmVudEhhbmRsZXJzW2ldO2gudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaC5ldmVudFR5cGVTdHJpbmcsaC5ldmVudExpc3RlbmVyRnVuYyxoLnVzZUNhcHR1cmUpO0pTRXZlbnRzLmV2ZW50SGFuZGxlcnMuc3BsaWNlKGksMSl9LHJlZ2lzdGVyT3JSZW1vdmVIYW5kbGVyOmZ1bmN0aW9uKGV2ZW50SGFuZGxlcil7dmFyIGpzRXZlbnRIYW5kbGVyPWZ1bmN0aW9uIGpzRXZlbnRIYW5kbGVyKGV2ZW50KXsrK0pTRXZlbnRzLmluRXZlbnRIYW5kbGVyO0pTRXZlbnRzLmN1cnJlbnRFdmVudEhhbmRsZXI9ZXZlbnRIYW5kbGVyO0pTRXZlbnRzLnJ1bkRlZmVycmVkQ2FsbHMoKTtldmVudEhhbmRsZXIuaGFuZGxlckZ1bmMoZXZlbnQpO0pTRXZlbnRzLnJ1bkRlZmVycmVkQ2FsbHMoKTstLUpTRXZlbnRzLmluRXZlbnRIYW5kbGVyfTtpZihldmVudEhhbmRsZXIuY2FsbGJhY2tmdW5jKXtldmVudEhhbmRsZXIuZXZlbnRMaXN0ZW5lckZ1bmM9anNFdmVudEhhbmRsZXI7ZXZlbnRIYW5kbGVyLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50SGFuZGxlci5ldmVudFR5cGVTdHJpbmcsanNFdmVudEhhbmRsZXIsZXZlbnRIYW5kbGVyLnVzZUNhcHR1cmUpO0pTRXZlbnRzLmV2ZW50SGFuZGxlcnMucHVzaChldmVudEhhbmRsZXIpO0pTRXZlbnRzLnJlZ2lzdGVyUmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKX1lbHNle2Zvcih2YXIgaT0wO2k8SlNFdmVudHMuZXZlbnRIYW5kbGVycy5sZW5ndGg7KytpKXtpZihKU0V2ZW50cy5ldmVudEhhbmRsZXJzW2ldLnRhcmdldD09ZXZlbnRIYW5kbGVyLnRhcmdldCYmSlNFdmVudHMuZXZlbnRIYW5kbGVyc1tpXS5ldmVudFR5cGVTdHJpbmc9PWV2ZW50SGFuZGxlci5ldmVudFR5cGVTdHJpbmcpe0pTRXZlbnRzLl9yZW1vdmVIYW5kbGVyKGktLSl9fX19LHF1ZXVlRXZlbnRIYW5kbGVyT25UaHJlYWRfaWlpaTpmdW5jdGlvbih0YXJnZXRUaHJlYWQsZXZlbnRIYW5kbGVyRnVuYyxldmVudFR5cGVJZCxldmVudERhdGEsdXNlckRhdGEpe3ZhciBzdGFja1RvcD1zdGFja1NhdmUoKTt2YXIgdmFyYXJncz1zdGFja0FsbG9jKDEyKTtHUk9XQUJMRV9IRUFQX0kzMigpW3ZhcmFyZ3M+PjJdPWV2ZW50VHlwZUlkO0dST1dBQkxFX0hFQVBfSTMyKClbdmFyYXJncys0Pj4yXT1ldmVudERhdGE7R1JPV0FCTEVfSEVBUF9JMzIoKVt2YXJhcmdzKzg+PjJdPXVzZXJEYXRhO19fZW1zY3JpcHRlbl9jYWxsX29uX3RocmVhZCgwLHRhcmdldFRocmVhZCw2Mzc1MzQyMDgsZXZlbnRIYW5kbGVyRnVuYyxldmVudERhdGEsdmFyYXJncyk7c3RhY2tSZXN0b3JlKHN0YWNrVG9wKX0sZ2V0VGFyZ2V0VGhyZWFkRm9yRXZlbnRDYWxsYmFjazpmdW5jdGlvbih0YXJnZXRUaHJlYWQpe3N3aXRjaCh0YXJnZXRUaHJlYWQpe2Nhc2UgMTpyZXR1cm4gMDtjYXNlIDI6cmV0dXJuIFBUaHJlYWQuY3VycmVudFByb3hpZWRPcGVyYXRpb25DYWxsZXJUaHJlYWQ7ZGVmYXVsdDpyZXR1cm4gdGFyZ2V0VGhyZWFkfX0sZ2V0Tm9kZU5hbWVGb3JUYXJnZXQ6ZnVuY3Rpb24odGFyZ2V0KXtpZighdGFyZ2V0KXJldHVyblwiXCI7aWYodGFyZ2V0PT13aW5kb3cpcmV0dXJuXCIjd2luZG93XCI7aWYodGFyZ2V0PT1zY3JlZW4pcmV0dXJuXCIjc2NyZWVuXCI7cmV0dXJuIHRhcmdldCYmdGFyZ2V0Lm5vZGVOYW1lP3RhcmdldC5ub2RlTmFtZTpcIlwifSxmdWxsc2NyZWVuRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZHx8ZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWR9fTtmdW5jdGlvbiBzdHJpbmdUb05ld1VURjgoanNTdHJpbmcpe3ZhciBsZW5ndGg9bGVuZ3RoQnl0ZXNVVEY4KGpzU3RyaW5nKSsxO3ZhciBjU3RyaW5nPV9tYWxsb2MobGVuZ3RoKTtzdHJpbmdUb1VURjgoanNTdHJpbmcsY1N0cmluZyxsZW5ndGgpO3JldHVybiBjU3RyaW5nfWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3NldF9vZmZzY3JlZW5jYW52YXNfc2l6ZV9vbl90YXJnZXRfdGhyZWFkX2pzKHRhcmdldFRocmVhZCx0YXJnZXRDYW52YXMsd2lkdGgsaGVpZ2h0KXt2YXIgc3RhY2tUb3A9c3RhY2tTYXZlKCk7dmFyIHZhcmFyZ3M9c3RhY2tBbGxvYygxMik7dmFyIHRhcmdldENhbnZhc1B0cj0wO2lmKHRhcmdldENhbnZhcyl7dGFyZ2V0Q2FudmFzUHRyPXN0cmluZ1RvTmV3VVRGOCh0YXJnZXRDYW52YXMpfUdST1dBQkxFX0hFQVBfSTMyKClbdmFyYXJncz4+Ml09dGFyZ2V0Q2FudmFzUHRyO0dST1dBQkxFX0hFQVBfSTMyKClbdmFyYXJncys0Pj4yXT13aWR0aDtHUk9XQUJMRV9IRUFQX0kzMigpW3ZhcmFyZ3MrOD4+Ml09aGVpZ2h0O19fZW1zY3JpcHRlbl9jYWxsX29uX3RocmVhZCgwLHRhcmdldFRocmVhZCw2NTc0NTcxNTIsMCx0YXJnZXRDYW52YXNQdHIsdmFyYXJncyk7c3RhY2tSZXN0b3JlKHN0YWNrVG9wKX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfb2Zmc2NyZWVuY2FudmFzX3NpemVfb25fdGFyZ2V0X3RocmVhZCh0YXJnZXRUaHJlYWQsdGFyZ2V0Q2FudmFzLHdpZHRoLGhlaWdodCl7dGFyZ2V0Q2FudmFzPXRhcmdldENhbnZhcz9VVEY4VG9TdHJpbmcodGFyZ2V0Q2FudmFzKTpcIlwiO19lbXNjcmlwdGVuX3NldF9vZmZzY3JlZW5jYW52YXNfc2l6ZV9vbl90YXJnZXRfdGhyZWFkX2pzKHRhcmdldFRocmVhZCx0YXJnZXRDYW52YXMsd2lkdGgsaGVpZ2h0KX1mdW5jdGlvbiBtYXliZUNTdHJpbmdUb0pzU3RyaW5nKGNTdHJpbmcpe3JldHVybiBjU3RyaW5nPjI/VVRGOFRvU3RyaW5nKGNTdHJpbmcpOmNTdHJpbmd9dmFyIHNwZWNpYWxIVE1MVGFyZ2V0cz1bMCx0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiP2RvY3VtZW50OjAsdHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93OjBdO2Z1bmN0aW9uIGZpbmRFdmVudFRhcmdldCh0YXJnZXQpe3RhcmdldD1tYXliZUNTdHJpbmdUb0pzU3RyaW5nKHRhcmdldCk7dmFyIGRvbUVsZW1lbnQ9c3BlY2lhbEhUTUxUYXJnZXRzW3RhcmdldF18fCh0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiP2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTp1bmRlZmluZWQpO3JldHVybiBkb21FbGVtZW50fWZ1bmN0aW9uIGZpbmRDYW52YXNFdmVudFRhcmdldCh0YXJnZXQpe3JldHVybiBmaW5kRXZlbnRUYXJnZXQodGFyZ2V0KX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZV9jYWxsaW5nX3RocmVhZCh0YXJnZXQsd2lkdGgsaGVpZ2h0KXt2YXIgY2FudmFzPWZpbmRDYW52YXNFdmVudFRhcmdldCh0YXJnZXQpO2lmKCFjYW52YXMpcmV0dXJuLTQ7aWYoY2FudmFzLmNhbnZhc1NoYXJlZFB0cil7R1JPV0FCTEVfSEVBUF9JMzIoKVtjYW52YXMuY2FudmFzU2hhcmVkUHRyPj4yXT13aWR0aDtHUk9XQUJMRV9IRUFQX0kzMigpW2NhbnZhcy5jYW52YXNTaGFyZWRQdHIrND4+Ml09aGVpZ2h0fWlmKGNhbnZhcy5vZmZzY3JlZW5DYW52YXN8fCFjYW52YXMuY29udHJvbFRyYW5zZmVycmVkT2Zmc2NyZWVuKXtpZihjYW52YXMub2Zmc2NyZWVuQ2FudmFzKWNhbnZhcz1jYW52YXMub2Zmc2NyZWVuQ2FudmFzO3ZhciBhdXRvUmVzaXplVmlld3BvcnQ9ZmFsc2U7aWYoY2FudmFzLkdMY3R4T2JqZWN0JiZjYW52YXMuR0xjdHhPYmplY3QuR0xjdHgpe3ZhciBwcmV2Vmlld3BvcnQ9Y2FudmFzLkdMY3R4T2JqZWN0LkdMY3R4LmdldFBhcmFtZXRlcigyOTc4KTthdXRvUmVzaXplVmlld3BvcnQ9cHJldlZpZXdwb3J0WzBdPT09MCYmcHJldlZpZXdwb3J0WzFdPT09MCYmcHJldlZpZXdwb3J0WzJdPT09Y2FudmFzLndpZHRoJiZwcmV2Vmlld3BvcnRbM109PT1jYW52YXMuaGVpZ2h0fWNhbnZhcy53aWR0aD13aWR0aDtjYW52YXMuaGVpZ2h0PWhlaWdodDtpZihhdXRvUmVzaXplVmlld3BvcnQpe2NhbnZhcy5HTGN0eE9iamVjdC5HTGN0eC52aWV3cG9ydCgwLDAsd2lkdGgsaGVpZ2h0KX19ZWxzZSBpZihjYW52YXMuY2FudmFzU2hhcmVkUHRyKXt2YXIgdGFyZ2V0VGhyZWFkPUdST1dBQkxFX0hFQVBfSTMyKClbY2FudmFzLmNhbnZhc1NoYXJlZFB0cis4Pj4yXTtfZW1zY3JpcHRlbl9zZXRfb2Zmc2NyZWVuY2FudmFzX3NpemVfb25fdGFyZ2V0X3RocmVhZCh0YXJnZXRUaHJlYWQsdGFyZ2V0LHdpZHRoLGhlaWdodCk7cmV0dXJuIDF9ZWxzZXtyZXR1cm4tNH1yZXR1cm4gMH1mdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZV9tYWluX3RocmVhZCh0YXJnZXQsd2lkdGgsaGVpZ2h0KXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxNiwxLHRhcmdldCx3aWR0aCxoZWlnaHQpO3JldHVybiBfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZV9jYWxsaW5nX3RocmVhZCh0YXJnZXQsd2lkdGgsaGVpZ2h0KX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZSh0YXJnZXQsd2lkdGgsaGVpZ2h0KXt2YXIgY2FudmFzPWZpbmRDYW52YXNFdmVudFRhcmdldCh0YXJnZXQpO2lmKGNhbnZhcyl7cmV0dXJuIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplX2NhbGxpbmdfdGhyZWFkKHRhcmdldCx3aWR0aCxoZWlnaHQpfWVsc2V7cmV0dXJuIF9lbXNjcmlwdGVuX3NldF9jYW52YXNfZWxlbWVudF9zaXplX21haW5fdGhyZWFkKHRhcmdldCx3aWR0aCxoZWlnaHQpfX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9zZXRfY3VycmVudF90aHJlYWRfc3RhdHVzKG5ld1N0YXR1cyl7fWZ1bmN0aW9uIF9fd2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXMoY3R4KXt2YXIgZXh0PWN0eC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO2lmKGV4dCl7Y3R4W1widmVydGV4QXR0cmliRGl2aXNvclwiXT1mdW5jdGlvbihpbmRleCxkaXZpc29yKXtleHRbXCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEVcIl0oaW5kZXgsZGl2aXNvcil9O2N0eFtcImRyYXdBcnJheXNJbnN0YW5jZWRcIl09ZnVuY3Rpb24obW9kZSxmaXJzdCxjb3VudCxwcmltY291bnQpe2V4dFtcImRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRVwiXShtb2RlLGZpcnN0LGNvdW50LHByaW1jb3VudCl9O2N0eFtcImRyYXdFbGVtZW50c0luc3RhbmNlZFwiXT1mdW5jdGlvbihtb2RlLGNvdW50LHR5cGUsaW5kaWNlcyxwcmltY291bnQpe2V4dFtcImRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFXCJdKG1vZGUsY291bnQsdHlwZSxpbmRpY2VzLHByaW1jb3VudCl9O3JldHVybiAxfX1mdW5jdGlvbiBfX3dlYmdsX2VuYWJsZV9PRVNfdmVydGV4X2FycmF5X29iamVjdChjdHgpe3ZhciBleHQ9Y3R4LmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpO2lmKGV4dCl7Y3R4W1wiY3JlYXRlVmVydGV4QXJyYXlcIl09ZnVuY3Rpb24oKXtyZXR1cm4gZXh0W1wiY3JlYXRlVmVydGV4QXJyYXlPRVNcIl0oKX07Y3R4W1wiZGVsZXRlVmVydGV4QXJyYXlcIl09ZnVuY3Rpb24odmFvKXtleHRbXCJkZWxldGVWZXJ0ZXhBcnJheU9FU1wiXSh2YW8pfTtjdHhbXCJiaW5kVmVydGV4QXJyYXlcIl09ZnVuY3Rpb24odmFvKXtleHRbXCJiaW5kVmVydGV4QXJyYXlPRVNcIl0odmFvKX07Y3R4W1wiaXNWZXJ0ZXhBcnJheVwiXT1mdW5jdGlvbih2YW8pe3JldHVybiBleHRbXCJpc1ZlcnRleEFycmF5T0VTXCJdKHZhbyl9O3JldHVybiAxfX1mdW5jdGlvbiBfX3dlYmdsX2VuYWJsZV9XRUJHTF9kcmF3X2J1ZmZlcnMoY3R4KXt2YXIgZXh0PWN0eC5nZXRFeHRlbnNpb24oXCJXRUJHTF9kcmF3X2J1ZmZlcnNcIik7aWYoZXh0KXtjdHhbXCJkcmF3QnVmZmVyc1wiXT1mdW5jdGlvbihuLGJ1ZnMpe2V4dFtcImRyYXdCdWZmZXJzV0VCR0xcIl0obixidWZzKX07cmV0dXJuIDF9fWZ1bmN0aW9uIF9fd2ViZ2xfZW5hYmxlX1dFQkdMX211bHRpX2RyYXcoY3R4KXtyZXR1cm4hIShjdHgubXVsdGlEcmF3V2ViZ2w9Y3R4LmdldEV4dGVuc2lvbihcIldFQkdMX211bHRpX2RyYXdcIikpfXZhciBHTD17Y291bnRlcjoxLGJ1ZmZlcnM6W10scHJvZ3JhbXM6W10sZnJhbWVidWZmZXJzOltdLHJlbmRlcmJ1ZmZlcnM6W10sdGV4dHVyZXM6W10sc2hhZGVyczpbXSx2YW9zOltdLGNvbnRleHRzOnt9LG9mZnNjcmVlbkNhbnZhc2VzOnt9LHF1ZXJpZXM6W10sc3RyaW5nQ2FjaGU6e30sdW5wYWNrQWxpZ25tZW50OjQscmVjb3JkRXJyb3I6ZnVuY3Rpb24gcmVjb3JkRXJyb3IoZXJyb3JDb2RlKXtpZighR0wubGFzdEVycm9yKXtHTC5sYXN0RXJyb3I9ZXJyb3JDb2RlfX0sZ2V0TmV3SWQ6ZnVuY3Rpb24odGFibGUpe3ZhciByZXQ9R0wuY291bnRlcisrO2Zvcih2YXIgaT10YWJsZS5sZW5ndGg7aTxyZXQ7aSsrKXt0YWJsZVtpXT1udWxsfXJldHVybiByZXR9LGdldFNvdXJjZTpmdW5jdGlvbihzaGFkZXIsY291bnQsc3RyaW5nLGxlbmd0aCl7dmFyIHNvdXJjZT1cIlwiO2Zvcih2YXIgaT0wO2k8Y291bnQ7KytpKXt2YXIgbGVuPWxlbmd0aD9HUk9XQUJMRV9IRUFQX0kzMigpW2xlbmd0aCtpKjQ+PjJdOi0xO3NvdXJjZSs9VVRGOFRvU3RyaW5nKEdST1dBQkxFX0hFQVBfSTMyKClbc3RyaW5nK2kqND4+Ml0sbGVuPDA/dW5kZWZpbmVkOmxlbil9cmV0dXJuIHNvdXJjZX0sY3JlYXRlQ29udGV4dDpmdW5jdGlvbihjYW52YXMsd2ViR0xDb250ZXh0QXR0cmlidXRlcyl7aWYoIWNhbnZhcy5nZXRDb250ZXh0U2FmYXJpV2ViR0wyRml4ZWQpe2NhbnZhcy5nZXRDb250ZXh0U2FmYXJpV2ViR0wyRml4ZWQ9Y2FudmFzLmdldENvbnRleHQ7Y2FudmFzLmdldENvbnRleHQ9ZnVuY3Rpb24odmVyLGF0dHJzKXt2YXIgZ2w9Y2FudmFzLmdldENvbnRleHRTYWZhcmlXZWJHTDJGaXhlZCh2ZXIsYXR0cnMpO3JldHVybiB2ZXI9PVwid2ViZ2xcIj09Z2wgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ/Z2w6bnVsbH19dmFyIGN0eD1jYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsd2ViR0xDb250ZXh0QXR0cmlidXRlcyk7aWYoIWN0eClyZXR1cm4gMDt2YXIgaGFuZGxlPUdMLnJlZ2lzdGVyQ29udGV4dChjdHgsd2ViR0xDb250ZXh0QXR0cmlidXRlcyk7cmV0dXJuIGhhbmRsZX0scmVnaXN0ZXJDb250ZXh0OmZ1bmN0aW9uKGN0eCx3ZWJHTENvbnRleHRBdHRyaWJ1dGVzKXt2YXIgaGFuZGxlPV9tYWxsb2MoOCk7R1JPV0FCTEVfSEVBUF9JMzIoKVtoYW5kbGUrND4+Ml09X3B0aHJlYWRfc2VsZigpO3ZhciBjb250ZXh0PXtoYW5kbGU6aGFuZGxlLGF0dHJpYnV0ZXM6d2ViR0xDb250ZXh0QXR0cmlidXRlcyx2ZXJzaW9uOndlYkdMQ29udGV4dEF0dHJpYnV0ZXMubWFqb3JWZXJzaW9uLEdMY3R4OmN0eH07aWYoY3R4LmNhbnZhcyljdHguY2FudmFzLkdMY3R4T2JqZWN0PWNvbnRleHQ7R0wuY29udGV4dHNbaGFuZGxlXT1jb250ZXh0O2lmKHR5cGVvZiB3ZWJHTENvbnRleHRBdHRyaWJ1dGVzLmVuYWJsZUV4dGVuc2lvbnNCeURlZmF1bHQ9PT1cInVuZGVmaW5lZFwifHx3ZWJHTENvbnRleHRBdHRyaWJ1dGVzLmVuYWJsZUV4dGVuc2lvbnNCeURlZmF1bHQpe0dMLmluaXRFeHRlbnNpb25zKGNvbnRleHQpfXJldHVybiBoYW5kbGV9LG1ha2VDb250ZXh0Q3VycmVudDpmdW5jdGlvbihjb250ZXh0SGFuZGxlKXtHTC5jdXJyZW50Q29udGV4dD1HTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXTtNb2R1bGUuY3R4PUdMY3R4PUdMLmN1cnJlbnRDb250ZXh0JiZHTC5jdXJyZW50Q29udGV4dC5HTGN0eDtyZXR1cm4hKGNvbnRleHRIYW5kbGUmJiFHTGN0eCl9LGdldENvbnRleHQ6ZnVuY3Rpb24oY29udGV4dEhhbmRsZSl7cmV0dXJuIEdMLmNvbnRleHRzW2NvbnRleHRIYW5kbGVdfSxkZWxldGVDb250ZXh0OmZ1bmN0aW9uKGNvbnRleHRIYW5kbGUpe2lmKEdMLmN1cnJlbnRDb250ZXh0PT09R0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0pR0wuY3VycmVudENvbnRleHQ9bnVsbDtpZih0eXBlb2YgSlNFdmVudHM9PT1cIm9iamVjdFwiKUpTRXZlbnRzLnJlbW92ZUFsbEhhbmRsZXJzT25UYXJnZXQoR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0uR0xjdHguY2FudmFzKTtpZihHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXSYmR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0uR0xjdHguY2FudmFzKUdMLmNvbnRleHRzW2NvbnRleHRIYW5kbGVdLkdMY3R4LmNhbnZhcy5HTGN0eE9iamVjdD11bmRlZmluZWQ7X2ZyZWUoR0wuY29udGV4dHNbY29udGV4dEhhbmRsZV0uaGFuZGxlKTtHTC5jb250ZXh0c1tjb250ZXh0SGFuZGxlXT1udWxsfSxpbml0RXh0ZW5zaW9uczpmdW5jdGlvbihjb250ZXh0KXtpZighY29udGV4dCljb250ZXh0PUdMLmN1cnJlbnRDb250ZXh0O2lmKGNvbnRleHQuaW5pdEV4dGVuc2lvbnNEb25lKXJldHVybjtjb250ZXh0LmluaXRFeHRlbnNpb25zRG9uZT10cnVlO3ZhciBHTGN0eD1jb250ZXh0LkdMY3R4O19fd2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXMoR0xjdHgpO19fd2ViZ2xfZW5hYmxlX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0KEdMY3R4KTtfX3dlYmdsX2VuYWJsZV9XRUJHTF9kcmF3X2J1ZmZlcnMoR0xjdHgpO3tHTGN0eC5kaXNqb2ludFRpbWVyUXVlcnlFeHQ9R0xjdHguZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XCIpfV9fd2ViZ2xfZW5hYmxlX1dFQkdMX211bHRpX2RyYXcoR0xjdHgpO3ZhciBleHRzPUdMY3R4LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKXx8W107ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uKGV4dCl7aWYoIWV4dC5pbmNsdWRlcyhcImxvc2VfY29udGV4dFwiKSYmIWV4dC5pbmNsdWRlcyhcImRlYnVnXCIpKXtHTGN0eC5nZXRFeHRlbnNpb24oZXh0KX19KX19O3ZhciBfX2Vtc2NyaXB0ZW5fd2ViZ2xfcG93ZXJfcHJlZmVyZW5jZXM9W1wiZGVmYXVsdFwiLFwibG93LXBvd2VyXCIsXCJoaWdoLXBlcmZvcm1hbmNlXCJdO2Z1bmN0aW9uIF9lbXNjcmlwdGVuX3dlYmdsX2RvX2NyZWF0ZV9jb250ZXh0KHRhcmdldCxhdHRyaWJ1dGVzKXt2YXIgYT1hdHRyaWJ1dGVzPj4yO3ZhciBwb3dlclByZWZlcmVuY2U9R1JPV0FCTEVfSEVBUF9JMzIoKVthKygyND4+MildO3ZhciBjb250ZXh0QXR0cmlidXRlcz17XCJhbHBoYVwiOiEhR1JPV0FCTEVfSEVBUF9JMzIoKVthKygwPj4yKV0sXCJkZXB0aFwiOiEhR1JPV0FCTEVfSEVBUF9JMzIoKVthKyg0Pj4yKV0sXCJzdGVuY2lsXCI6ISFHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDg+PjIpXSxcImFudGlhbGlhc1wiOiEhR1JPV0FCTEVfSEVBUF9JMzIoKVthKygxMj4+MildLFwicHJlbXVsdGlwbGllZEFscGhhXCI6ISFHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDE2Pj4yKV0sXCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXJcIjohIUdST1dBQkxFX0hFQVBfSTMyKClbYSsoMjA+PjIpXSxcInBvd2VyUHJlZmVyZW5jZVwiOl9fZW1zY3JpcHRlbl93ZWJnbF9wb3dlcl9wcmVmZXJlbmNlc1twb3dlclByZWZlcmVuY2VdLFwiZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdFwiOiEhR1JPV0FCTEVfSEVBUF9JMzIoKVthKygyOD4+MildLG1ham9yVmVyc2lvbjpHUk9XQUJMRV9IRUFQX0kzMigpW2ErKDMyPj4yKV0sbWlub3JWZXJzaW9uOkdST1dBQkxFX0hFQVBfSTMyKClbYSsoMzY+PjIpXSxlbmFibGVFeHRlbnNpb25zQnlEZWZhdWx0OkdST1dBQkxFX0hFQVBfSTMyKClbYSsoNDA+PjIpXSxleHBsaWNpdFN3YXBDb250cm9sOkdST1dBQkxFX0hFQVBfSTMyKClbYSsoNDQ+PjIpXSxwcm94eUNvbnRleHRUb01haW5UaHJlYWQ6R1JPV0FCTEVfSEVBUF9JMzIoKVthKyg0OD4+MildLHJlbmRlclZpYU9mZnNjcmVlbkJhY2tCdWZmZXI6R1JPV0FCTEVfSEVBUF9JMzIoKVthKyg1Mj4+MildfTt2YXIgY2FudmFzPWZpbmRDYW52YXNFdmVudFRhcmdldCh0YXJnZXQpO2lmKCFjYW52YXMpe3JldHVybiAwfWlmKGNvbnRleHRBdHRyaWJ1dGVzLmV4cGxpY2l0U3dhcENvbnRyb2wpe3JldHVybiAwfXZhciBjb250ZXh0SGFuZGxlPUdMLmNyZWF0ZUNvbnRleHQoY2FudmFzLGNvbnRleHRBdHRyaWJ1dGVzKTtyZXR1cm4gY29udGV4dEhhbmRsZX1mdW5jdGlvbiBfZW1zY3JpcHRlbl93ZWJnbF9jcmVhdGVfY29udGV4dChhMCxhMSl7cmV0dXJuIF9lbXNjcmlwdGVuX3dlYmdsX2RvX2NyZWF0ZV9jb250ZXh0KGEwLGExKX12YXIgV2ViTk49e2luaXRNYW5hZ2VyczpmdW5jdGlvbigpe2lmKHRoaXNbXCJtZ3JDb250ZXh0XCJdKXJldHVybjtmdW5jdGlvbiBtYWtlTWFuYWdlcigpe3JldHVybntvYmplY3RzOnt9LG5leHRJZDoxLGNyZWF0ZTpmdW5jdGlvbihvYmplY3Qsd3JhcHBlcil7d3JhcHBlcj13cmFwcGVyfHx7fTt2YXIgaWQ9dGhpcy5uZXh0SWQrKzt3cmFwcGVyLnJlZmNvdW50PTE7d3JhcHBlci5vYmplY3Q9b2JqZWN0O3RoaXMub2JqZWN0c1tpZF09d3JhcHBlcjtyZXR1cm4gaWR9LGdldDpmdW5jdGlvbihpZCl7aWYoaWQ9PT0wKXJldHVybiB1bmRlZmluZWQ7dmFyIG89dGhpcy5vYmplY3RzW2lkXTtyZXR1cm4gby5vYmplY3R9LHJlZmVyZW5jZTpmdW5jdGlvbihpZCl7dmFyIG89dGhpcy5vYmplY3RzW2lkXTtvLnJlZmNvdW50Kyt9LHJlbGVhc2U6ZnVuY3Rpb24oaWQpe3ZhciBvPXRoaXMub2JqZWN0c1tpZF07by5yZWZjb3VudC0tO2lmKG8ucmVmY291bnQ8PTApe2RlbGV0ZSB0aGlzLm9iamVjdHNbaWRdfX19fXRoaXNbXCJtZ3JDb250ZXh0XCJdPXRoaXNbXCJtZ3JDb250ZXh0XCJdfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyR3JhcGg9dGhpcy5tZ3JHcmFwaHx8bWFrZU1hbmFnZXIoKTt0aGlzLm1nckdyYXBoQnVpbGRlcj10aGlzLm1nckdyYXBoQnVpbGRlcnx8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkSW5wdXRzPXRoaXMubWdyTmFtZWRJbnB1dHN8fG1ha2VNYW5hZ2VyKCk7dGhpcy5tZ3JOYW1lZE9wZXJhbmRzPXRoaXMubWdyTmFtZWRPcGVyYW5kc3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkT3V0cHV0cz10aGlzLm1nck5hbWVkT3V0cHV0c3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkUmVzdWx0cz10aGlzLm1nck5hbWVkUmVzdWx0c3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck9wZXJhbmQ9dGhpcy5tZ3JPcGVyYW5kfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyUmVzdWx0PXRoaXMubWdyUmVzdWx0fHxtYWtlTWFuYWdlcigpfSxBdXRvUGFkOltcImV4cGxpY2l0XCIsXCJzYW1lLXVwcGVyXCIsXCJzYW1lLWxvd2VyXCJdLEJ1aWxkR3JhcGhTdGF0dXM6W1wic3VjY2Vzc1wiLFwiZXJyb3JcIixcImNvbnRleHQtbG9zdFwiLFwidW5rbm93blwiXSxDb21wdXRlR3JhcGhTdGF0dXM6W1wic3VjY2Vzc1wiLFwiZXJyb3JcIixcImNvbnRleHQtbG9zdFwiLFwidW5rbm93blwiXSxFcnJvckZpbHRlcjpbXCJub25lXCIsXCJ2YWxpZGF0aW9uXCIsXCJvdXQtb2YtbWVtb3J5XCJdLEVycm9yVHlwZTpbXCJuby1lcnJvclwiLFwidmFsaWRhdGlvblwiLFwib3V0LW9mLW1lbW9yeVwiLFwidW5rbm93blwiLFwiZGV2aWNlLWxvc3RcIl0sRmlsdGVyT3BlcmFuZExheW91dDpbXCJvaWh3XCIsXCJod2lvXCIsXCJvaHdpXCIsXCJpaHdvXCJdLEZ1c2VkQWN0aXZhdGlvbjpbXCJub25lXCIsXCJyZWx1XCJdLElucHV0T3BlcmFuZExheW91dDpbXCJuY2h3XCIsXCJuaHdjXCJdLE9wZXJhbmRUeXBlOltcImZsb2F0MzJcIixcImZsb2F0MTZcIixcImludDMyXCIsXCJ1aW50MzJcIixcImludDhcIixcInVpbnQ4XCJdLFBvd2VyUHJlZmVyZW5jZTpbXCJkZWZhdWx0XCIsXCJoaWdoX3BlcmZvcm1hbmNlXCIsXCJsb3dfcG93ZXJcIl0sbWFrZUkzMkFycmF5OmZ1bmN0aW9uKGNvdW50LGFycmF5UHRyKXtpZihjb3VudD09PTB8fGFycmF5UHRyPT09MCl7cmV0dXJuIHVuZGVmaW5lZH12YXIgYXJyYXk9W107Zm9yKHZhciBpPTA7aTxjb3VudDsrK2ksYXJyYXlQdHIrPTQpe2FycmF5LnB1c2goR1JPV0FCTEVfSEVBUF9JMzIoKVthcnJheVB0cj4+Ml0pfXJldHVybiBhcnJheX0sbWFrZUFycmF5QnVmZmVyVmlldzpmdW5jdGlvbihvZmZzZXQsYnl0ZVNpemUsdHlwZT1cImZsb2F0MzJcIil7YXNzZXJ0KHR5cGU9PT1cImZsb2F0MzJcIik7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VOCgpLmJ1ZmZlcixvZmZzZXQsYnl0ZVNpemUvRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKX0sbWFrZUNsYW1wT3B0aW9uczpmdW5jdGlvbihwdHIpe3JldHVybntcIm1pblZhbHVlXCI6dGhpcy5tZ3JPcGVyYW5kLmdldChHUk9XQUJMRV9IRUFQX0kzMigpW3B0cj4+Ml0pLFwibWF4VmFsdWVcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzQ+PjJdKX19LG1ha2VCYXRjaE5vcm1PcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wic2NhbGVcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyPj4yXSksXCJiaWFzXCI6dGhpcy5tZ3JPcGVyYW5kLmdldChHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis0Pj4yXSksXCJheGlzXCI6R1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrOD4+Ml0sXCJlcHNpbG9uXCI6R1JPV0FCTEVfSEVBUF9GMzIoKVtwdHIrMTI+PjJdLFwiYWN0aXZhdGlvblwiOnRoaXMuRnVzZWRBY3RpdmF0aW9uW0dST1dBQkxFX0hFQVBfSTMyKClbcHRyKzE2Pj4yXV19fSxtYWtlR2VtbU9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJjXCI6dGhpcy5tZ3JPcGVyYW5kLmdldChHUk9XQUJMRV9IRUFQX0kzMigpW3B0cj4+Ml0pLFwiYWxwaGFcIjpHUk9XQUJMRV9IRUFQX0YzMigpW3B0cis0Pj4yXSxcImJldGFcIjpHUk9XQUJMRV9IRUFQX0YzMigpW3B0cis4Pj4yXSxcImFUcmFuc3Bvc2VcIjpHUk9XQUJMRV9IRUFQX0k4KClbcHRyKzEyPj4wXSE9PTAsXCJiVHJhbnNwb3NlXCI6R1JPV0FCTEVfSEVBUF9JOCgpW3B0cisxMz4+MF0hPT0wfX0sbWFrZU9wZXJhbmREZXNjcmlwdG9yOmZ1bmN0aW9uKHB0cil7cmV0dXJue1widHlwZVwiOnRoaXMuT3BlcmFuZFR5cGVbR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHI+PjJdXSxcImRpbWVuc2lvbnNcIjp0aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cis4Pj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis0Pj4yXSl9fSxtYWtlQ29udjJkT3B0aW9uczpmdW5jdGlvbihwdHIpe3JldHVybntcInBhZGRpbmdcIjp0aGlzLkF1dG9QYWRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMjQ+PjJdXT09PVwiZXhwbGljaXRcIj90aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cj4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrND4+Ml0pOnVuZGVmaW5lZCxcInN0cmlkZXNcIjp0aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cis4Pj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cisxMj4+Ml0pLFwiZGlsYXRpb25zXCI6dGhpcy5tYWtlSTMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrMTY+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzIwPj4yXSksXCJhdXRvUGFkXCI6dGhpcy5BdXRvUGFkW0dST1dBQkxFX0hFQVBfSTMyKClbcHRyKzI0Pj4yXV0sXCJncm91cHNcIjpHUk9XQUJMRV9IRUFQX0kzMigpW3B0cisyOD4+Ml0sXCJpbnB1dExheW91dFwiOnRoaXMuSW5wdXRPcGVyYW5kTGF5b3V0W0dST1dBQkxFX0hFQVBfSTMyKClbcHRyKzMyPj4yXV0sXCJmaWx0ZXJMYXlvdXRcIjp0aGlzLkZpbHRlck9wZXJhbmRMYXlvdXRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMzY+PjJdXSxcImJpYXNcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzQwPj4yXSksXCJhY3RpdmF0aW9uXCI6dGhpcy5GdXNlZEFjdGl2YXRpb25bR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrNDQ+PjJdXX19LG1ha2VQb29sMmRPcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wid2luZG93RGltZW5zaW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEdST1dBQkxFX0hFQVBfVTMyKClbcHRyPj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis0Pj4yXSksXCJwYWRkaW5nXCI6dGhpcy5BdXRvUGFkW0dST1dBQkxFX0hFQVBfSTMyKClbcHRyKzMyPj4yXV09PT1cImV4cGxpY2l0XCI/dGhpcy5tYWtlSTMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrOD4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMTI+PjJdKTp1bmRlZmluZWQsXCJzdHJpZGVzXCI6dGhpcy5tYWtlSTMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrMTY+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzIwPj4yXSksXCJkaWxhdGlvbnNcIjp0aGlzLm1ha2VJMzJBcnJheShHUk9XQUJMRV9IRUFQX1UzMigpW3B0cisyND4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMjg+PjJdKSxcImF1dG9QYWRcIjp0aGlzLkF1dG9QYWRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMzI+PjJdXSxcImlucHV0TGF5b3V0XCI6dGhpcy5JbnB1dE9wZXJhbmRMYXlvdXRbR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHIrMzY+PjJdXX19LG1ha2VJbnB1dDpmdW5jdGlvbihwdHIpe3JldHVybntcImRhdGFcIjp0aGlzLm1ha2VBcnJheUJ1ZmZlclZpZXcoR1JPV0FCTEVfSEVBUF9JMzIoKVtwdHI+PjJdLEdST1dBQkxFX0hFQVBfVTMyKClbcHRyKzQ+PjJdKSxcImRpbWVuc2lvbnNcIjpHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis4Pj4yXT09PTA/dW5kZWZpbmVkOnRoaXMubWFrZUkzMkFycmF5KEdST1dBQkxFX0hFQVBfVTMyKClbcHRyKzEyPj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis4Pj4yXSl9fSxtYWtlT3V0cHV0OmZ1bmN0aW9uKHB0cil7cmV0dXJue1wiZGF0YVwiOkdST1dBQkxFX0hFQVBfSTMyKClbcHRyPj4yXT09PTA/dW5kZWZpbmVkOnRoaXMubWFrZUFycmF5QnVmZmVyVmlldyhHUk9XQUJMRV9IRUFQX0kzMigpW3B0cj4+Ml0sR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrND4+Ml0pLFwiZGltZW5zaW9uc1wiOkdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzg+PjJdPT09MD91bmRlZmluZWQ6dGhpcy5tYWtlSTMyQXJyYXkoR1JPV0FCTEVfSEVBUF9VMzIoKVtwdHIrMTI+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbcHRyKzg+PjJdKX19fTtmdW5jdGlvbiBfZW1zY3JpcHRlbl93ZWJubl9jcmVhdGVfY29udGV4dCgpe3ZhciBjb250ZXh0PW5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KCk7cmV0dXJuIFdlYk5OLm1nckNvbnRleHQuY3JlYXRlKGNvbnRleHQpfXZhciBFTlY9e307ZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKXtyZXR1cm4gdGhpc1Byb2dyYW18fFwiLi90aGlzLnByb2dyYW1cIn1mdW5jdGlvbiBnZXRFbnZTdHJpbmdzKCl7aWYoIWdldEVudlN0cmluZ3Muc3RyaW5ncyl7dmFyIGxhbmc9KHR5cGVvZiBuYXZpZ2F0b3I9PT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIjt2YXIgZW52PXtcIlVTRVJcIjpcIndlYl91c2VyXCIsXCJMT0dOQU1FXCI6XCJ3ZWJfdXNlclwiLFwiUEFUSFwiOlwiL1wiLFwiUFdEXCI6XCIvXCIsXCJIT01FXCI6XCIvaG9tZS93ZWJfdXNlclwiLFwiTEFOR1wiOmxhbmcsXCJfXCI6Z2V0RXhlY3V0YWJsZU5hbWUoKX07Zm9yKHZhciB4IGluIEVOVil7ZW52W3hdPUVOVlt4XX12YXIgc3RyaW5ncz1bXTtmb3IodmFyIHggaW4gZW52KXtzdHJpbmdzLnB1c2goeCtcIj1cIitlbnZbeF0pfWdldEVudlN0cmluZ3Muc3RyaW5ncz1zdHJpbmdzfXJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3N9ZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbixlbnZpcm9uX2J1Zil7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMTcsMSxfX2Vudmlyb24sZW52aXJvbl9idWYpO3ZhciBidWZTaXplPTA7Z2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLGkpe3ZhciBwdHI9ZW52aXJvbl9idWYrYnVmU2l6ZTtHUk9XQUJMRV9IRUFQX0kzMigpW19fZW52aXJvbitpKjQ+PjJdPXB0cjt3cml0ZUFzY2lpVG9NZW1vcnkoc3RyaW5nLHB0cik7YnVmU2l6ZSs9c3RyaW5nLmxlbmd0aCsxfSk7cmV0dXJuIDB9ZnVuY3Rpb24gX2Vudmlyb25fc2l6ZXNfZ2V0KHBlbnZpcm9uX2NvdW50LHBlbnZpcm9uX2J1Zl9zaXplKXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXJldHVybiBfZW1zY3JpcHRlbl9wcm94eV90b19tYWluX3RocmVhZF9qcygxOCwxLHBlbnZpcm9uX2NvdW50LHBlbnZpcm9uX2J1Zl9zaXplKTt2YXIgc3RyaW5ncz1nZXRFbnZTdHJpbmdzKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVtwZW52aXJvbl9jb3VudD4+Ml09c3RyaW5ncy5sZW5ndGg7dmFyIGJ1ZlNpemU9MDtzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nKXtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtHUk9XQUJMRV9IRUFQX0kzMigpW3BlbnZpcm9uX2J1Zl9zaXplPj4yXT1idWZTaXplO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9jbG9zZShmZCl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMTksMSxmZCk7cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQscGJ1Zil7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMjAsMSxmZCxwYnVmKTt2YXIgdHlwZT1mZD09MXx8ZmQ9PTI/MjphYm9ydCgpO0dST1dBQkxFX0hFQVBfSTgoKVtwYnVmPj4wXT10eXBlO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9yZWFkKGZkLGlvdixpb3ZjbnQscG51bSl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMjEsMSxmZCxpb3YsaW92Y250LHBudW0pO3ZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTt2YXIgbnVtPVNZU0NBTExTLmRvUmVhZHYoc3RyZWFtLGlvdixpb3ZjbnQpO0dST1dBQkxFX0hFQVBfSTMyKClbcG51bT4+Ml09bnVtO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9zZWVrKGZkLG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gsd2hlbmNlLG5ld09mZnNldCl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMjIsMSxmZCxvZmZzZXRfbG93LG9mZnNldF9oaWdoLHdoZW5jZSxuZXdPZmZzZXQpfWZ1bmN0aW9uIGZsdXNoX05PX0ZJTEVTWVNURU0oKXtpZih0eXBlb2YgX2ZmbHVzaCE9PVwidW5kZWZpbmVkXCIpX2ZmbHVzaCgwKTt2YXIgYnVmZmVycz1TWVNDQUxMUy5idWZmZXJzO2lmKGJ1ZmZlcnNbMV0ubGVuZ3RoKVNZU0NBTExTLnByaW50Q2hhcigxLDEwKTtpZihidWZmZXJzWzJdLmxlbmd0aClTWVNDQUxMUy5wcmludENoYXIoMiwxMCl9ZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLGlvdixpb3ZjbnQscG51bSl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMjMsMSxmZCxpb3YsaW92Y250LHBudW0pO3ZhciBudW09MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9R1JPV0FCTEVfSEVBUF9JMzIoKVtpb3YraSo4Pj4yXTt2YXIgbGVuPUdST1dBQkxFX0hFQVBfSTMyKClbaW92KyhpKjgrNCk+PjJdO2Zvcih2YXIgaj0wO2o8bGVuO2orKyl7U1lTQ0FMTFMucHJpbnRDaGFyKGZkLEdST1dBQkxFX0hFQVBfVTgoKVtwdHIral0pfW51bSs9bGVufUdST1dBQkxFX0hFQVBfSTMyKClbcG51bT4+Ml09bnVtO3JldHVybiAwfWZ1bmN0aW9uIF9nZXR0aW1lb2ZkYXkocHRyKXt2YXIgbm93PURhdGUubm93KCk7R1JPV0FCTEVfSEVBUF9JMzIoKVtwdHI+PjJdPW5vdy8xZTN8MDtHUk9XQUJMRV9IRUFQX0kzMigpW3B0cis0Pj4yXT1ub3clMWUzKjFlM3wwO3JldHVybiAwfWZ1bmN0aW9uIF9nbXRpbWVfcih0aW1lLHRtUHRyKXt2YXIgZGF0ZT1uZXcgRGF0ZShHUk9XQUJMRV9IRUFQX0kzMigpW3RpbWU+PjJdKjFlMyk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cj4+Ml09ZGF0ZS5nZXRVVENTZWNvbmRzKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cis0Pj4yXT1kYXRlLmdldFVUQ01pbnV0ZXMoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzg+PjJdPWRhdGUuZ2V0VVRDSG91cnMoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzEyPj4yXT1kYXRlLmdldFVUQ0RhdGUoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzE2Pj4yXT1kYXRlLmdldFVUQ01vbnRoKCk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisyMD4+Ml09ZGF0ZS5nZXRVVENGdWxsWWVhcigpLTE5MDA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisyND4+Ml09ZGF0ZS5nZXRVVENEYXkoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzM2Pj4yXT0wO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMzI+PjJdPTA7dmFyIHN0YXJ0PURhdGUuVVRDKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCk7dmFyIHlkYXk9KGRhdGUuZ2V0VGltZSgpLXN0YXJ0KS8oMWUzKjYwKjYwKjI0KXwwO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMjg+PjJdPXlkYXk7aWYoIV9nbXRpbWVfci5HTVRTdHJpbmcpX2dtdGltZV9yLkdNVFN0cmluZz1hbGxvY2F0ZVVURjgoXCJHTVRcIik7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cis0MD4+Ml09X2dtdGltZV9yLkdNVFN0cmluZztyZXR1cm4gdG1QdHJ9ZnVuY3Rpb24gX3R6c2V0KCl7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm4gX2Vtc2NyaXB0ZW5fcHJveHlfdG9fbWFpbl90aHJlYWRfanMoMjQsMSk7aWYoX3R6c2V0LmNhbGxlZClyZXR1cm47X3R6c2V0LmNhbGxlZD10cnVlO3ZhciBjdXJyZW50WWVhcj0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCk7dmFyIHdpbnRlcj1uZXcgRGF0ZShjdXJyZW50WWVhciwwLDEpO3ZhciBzdW1tZXI9bmV3IERhdGUoY3VycmVudFllYXIsNiwxKTt2YXIgd2ludGVyT2Zmc2V0PXdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdW1tZXJPZmZzZXQ9c3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHN0ZFRpbWV6b25lT2Zmc2V0PU1hdGgubWF4KHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO0dST1dBQkxFX0hFQVBfSTMyKClbX19nZXRfdGltZXpvbmUoKT4+Ml09c3RkVGltZXpvbmVPZmZzZXQqNjA7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2dldF9kYXlsaWdodCgpPj4yXT1OdW1iZXIod2ludGVyT2Zmc2V0IT1zdW1tZXJPZmZzZXQpO2Z1bmN0aW9uIGV4dHJhY3Rab25lKGRhdGUpe3ZhciBtYXRjaD1kYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7cmV0dXJuIG1hdGNoP21hdGNoWzFdOlwiR01UXCJ9dmFyIHdpbnRlck5hbWU9ZXh0cmFjdFpvbmUod2ludGVyKTt2YXIgc3VtbWVyTmFtZT1leHRyYWN0Wm9uZShzdW1tZXIpO3ZhciB3aW50ZXJOYW1lUHRyPWFsbG9jYXRlVVRGOCh3aW50ZXJOYW1lKTt2YXIgc3VtbWVyTmFtZVB0cj1hbGxvY2F0ZVVURjgoc3VtbWVyTmFtZSk7aWYoc3VtbWVyT2Zmc2V0PHdpbnRlck9mZnNldCl7R1JPV0FCTEVfSEVBUF9JMzIoKVtfX2dldF90em5hbWUoKT4+Ml09d2ludGVyTmFtZVB0cjtHUk9XQUJMRV9IRUFQX0kzMigpW19fZ2V0X3R6bmFtZSgpKzQ+PjJdPXN1bW1lck5hbWVQdHJ9ZWxzZXtHUk9XQUJMRV9IRUFQX0kzMigpW19fZ2V0X3R6bmFtZSgpPj4yXT1zdW1tZXJOYW1lUHRyO0dST1dBQkxFX0hFQVBfSTMyKClbX19nZXRfdHpuYW1lKCkrND4+Ml09d2ludGVyTmFtZVB0cn19ZnVuY3Rpb24gX2xvY2FsdGltZV9yKHRpbWUsdG1QdHIpe190enNldCgpO3ZhciBkYXRlPW5ldyBEYXRlKEdST1dBQkxFX0hFQVBfSTMyKClbdGltZT4+Ml0qMWUzKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyPj4yXT1kYXRlLmdldFNlY29uZHMoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzQ+PjJdPWRhdGUuZ2V0TWludXRlcygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrOD4+Ml09ZGF0ZS5nZXRIb3VycygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTI+PjJdPWRhdGUuZ2V0RGF0ZSgpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTY+PjJdPWRhdGUuZ2V0TW9udGgoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzIwPj4yXT1kYXRlLmdldEZ1bGxZZWFyKCktMTkwMDtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzI0Pj4yXT1kYXRlLmdldERheSgpO3ZhciBzdGFydD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTt2YXIgeWRheT0oZGF0ZS5nZXRUaW1lKCktc3RhcnQuZ2V0VGltZSgpKS8oMWUzKjYwKjYwKjI0KXwwO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMjg+PjJdPXlkYXk7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0ciszNj4+Ml09LShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjApO3ZhciBzdW1tZXJPZmZzZXQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgd2ludGVyT2Zmc2V0PXN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGRzdD0oc3VtbWVyT2Zmc2V0IT13aW50ZXJPZmZzZXQmJmRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCkpfDA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0ciszMj4+Ml09ZHN0O3ZhciB6b25lUHRyPUdST1dBQkxFX0hFQVBfSTMyKClbX19nZXRfdHpuYW1lKCkrKGRzdD80OjApPj4yXTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzQwPj4yXT16b25lUHRyO3JldHVybiB0bVB0cn1mdW5jdGlvbiBfbWt0aW1lKHRtUHRyKXtfdHpzZXQoKTt2YXIgZGF0ZT1uZXcgRGF0ZShHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzIwPj4yXSsxOTAwLEdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTY+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTI+PjJdLEdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrOD4+Ml0sR1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cis0Pj4yXSxHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyPj4yXSwwKTt2YXIgZHN0PUdST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMzI+PjJdO3ZhciBndWVzc2VkT2Zmc2V0PWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3RhcnQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDAsMSk7dmFyIHN1bW1lck9mZnNldD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB3aW50ZXJPZmZzZXQ9c3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgZHN0T2Zmc2V0PU1hdGgubWluKHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO2lmKGRzdDwwKXtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzMyPj4yXT1OdW1iZXIoc3VtbWVyT2Zmc2V0IT13aW50ZXJPZmZzZXQmJmRzdE9mZnNldD09Z3Vlc3NlZE9mZnNldCl9ZWxzZSBpZihkc3Q+MCE9KGRzdE9mZnNldD09Z3Vlc3NlZE9mZnNldCkpe3ZhciBub25Ec3RPZmZzZXQ9TWF0aC5tYXgod2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCk7dmFyIHRydWVPZmZzZXQ9ZHN0PjA/ZHN0T2Zmc2V0Om5vbkRzdE9mZnNldDtkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkrKHRydWVPZmZzZXQtZ3Vlc3NlZE9mZnNldCkqNmU0KX1HUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzI0Pj4yXT1kYXRlLmdldERheSgpO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydC5nZXRUaW1lKCkpLygxZTMqNjAqNjAqMjQpfDA7R1JPV0FCTEVfSEVBUF9JMzIoKVt0bVB0cisyOD4+Ml09eWRheTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyPj4yXT1kYXRlLmdldFNlY29uZHMoKTtHUk9XQUJMRV9IRUFQX0kzMigpW3RtUHRyKzQ+PjJdPWRhdGUuZ2V0TWludXRlcygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrOD4+Ml09ZGF0ZS5nZXRIb3VycygpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTI+PjJdPWRhdGUuZ2V0RGF0ZSgpO0dST1dBQkxFX0hFQVBfSTMyKClbdG1QdHIrMTY+PjJdPWRhdGUuZ2V0TW9udGgoKTtyZXR1cm4gZGF0ZS5nZXRUaW1lKCkvMWUzfDB9ZnVuY3Rpb24gX21sQ29udGV4dFJlZmVyZW5jZShpZCl7V2ViTk4ubWdyQ29udGV4dC5yZWZlcmVuY2UoaWQpfWZ1bmN0aW9uIF9tbENvbnRleHRSZWxlYXNlKGlkKXtXZWJOTi5tZ3JDb250ZXh0LnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckFkZChidWlsZGVySWQsYUlkLGJJZCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBhPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGFJZCk7dmFyIGI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYklkKTt2YXIgYz1idWlsZGVyLmFkZChhLGIpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShjKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJBdmVyYWdlUG9vbDJkKGJ1aWxkZXJJZCxpbnB1dElkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZVBvb2wyZE9wdGlvbnMob3B0aW9uc1B0cik7dmFyIHBvb2wyZD1idWlsZGVyLmF2ZXJhZ2VQb29sMmQoaW5wdXQsb3B0aW9ucyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKHBvb2wyZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQmF0Y2hOb3JtKGJ1aWxkZXJJZCxpbnB1dElkLG1lYW5JZCx2YXJpYW5jZUlkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG1lYW49V2ViTk4ubWdyT3BlcmFuZC5nZXQobWVhbklkKTt2YXIgdmFyaWFuY2U9V2ViTk4ubWdyT3BlcmFuZC5nZXQodmFyaWFuY2VJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZUJhdGNoTm9ybU9wdGlvbnMob3B0aW9uc1B0cik7dmFyIG91dHB1dD1idWlsZGVyLmJhdGNoTm9ybWFsaXphdGlvbihpbnB1dCxtZWFuLHZhcmlhbmNlLG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckJ1aWxkU3luYyhidWlsZGVySWQsbmFtZWRPcGVyYW5kc0lkKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIG5hbWVkT3BlcmFuZHM9V2ViTk4ubWdyTmFtZWRPcGVyYW5kcy5nZXQobmFtZWRPcGVyYW5kc0lkKTt0cnl7dmFyIGdyYXBoPWJ1aWxkZXIuYnVpbGRTeW5jKG5hbWVkT3BlcmFuZHMpO3JldHVybiBXZWJOTi5tZ3JHcmFwaC5jcmVhdGUoZ3JhcGgpfWNhdGNoKGVycm9yKXtjb25zb2xlLmxvZyhcImJ1aWxkZXIuYnVpbGRTeW5jIGZhaWxlZDogXCIrZXJyb3IpO3JldHVybiAwfX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJDb25jYXQoYnVpbGRlcklkLGlucHV0c0NvdW50LGlucHV0c1B0cixheGlzKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0SWRzPVdlYk5OLm1ha2VJMzJBcnJheShpbnB1dHNDb3VudCxpbnB1dHNQdHIpO3ZhciBpbnB1dHM9W107Zm9yKHZhciBpPTA7aTxpbnB1dElkcy5sZW5ndGg7KytpKXtpbnB1dHMucHVzaChXZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkc1tpXSkpfXZhciBvdXRwdXQ9YnVpbGRlci5jb25jYXQoaW5wdXRzLGF4aXMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckNvbnN0YW50KGJ1aWxkZXJJZCxkZXNjUHRyLHZhbHVlUHRyLHNpemUpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgZGVzYz1XZWJOTi5tYWtlT3BlcmFuZERlc2NyaXB0b3IoZGVzY1B0cik7dmFyIGJ1ZmZlcj1XZWJOTi5tYWtlQXJyYXlCdWZmZXJWaWV3KHZhbHVlUHRyLHNpemUpO3ZhciBjb25zdGFudD1idWlsZGVyLmNvbnN0YW50KGRlc2MsYnVmZmVyKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoY29uc3RhbnQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckNvbnYyZChidWlsZGVySWQsaW5wdXRJZCxmaWx0ZXJJZCxvcHRpb25zUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBmaWx0ZXI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoZmlsdGVySWQpO3ZhciBvcHRpb25zPVdlYk5OLm1ha2VDb252MmRPcHRpb25zKG9wdGlvbnNQdHIpO3ZhciBjb252MmQ9YnVpbGRlci5jb252MmQoaW5wdXQsZmlsdGVyLG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShjb252MmQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckdlbW0oYnVpbGRlcklkLGFJZCxiSWQsb3B0aW9uc1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBhPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGFJZCk7dmFyIGI9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYklkKTt2YXIgb3B0aW9ucz1XZWJOTi5tYWtlR2VtbU9wdGlvbnMob3B0aW9uc1B0cik7dmFyIG91dHB1dD1idWlsZGVyLmdlbW0oYSxiLG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlcklucHV0KGJ1aWxkZXJJZCxuYW1lUHRyLGRlc2NQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgbmFtZT1VVEY4VG9TdHJpbmcobmFtZVB0cik7dmFyIGRlc2M9V2ViTk4ubWFrZU9wZXJhbmREZXNjcmlwdG9yKGRlc2NQdHIpO3ZhciBpbnB1dD1idWlsZGVyLmlucHV0KG5hbWUsZGVzYyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKGlucHV0KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJNYXRtdWwoYnVpbGRlcklkLGFJZCxiSWQpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgYT1XZWJOTi5tZ3JPcGVyYW5kLmdldChhSWQpO3ZhciBiPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGJJZCk7dmFyIGM9YnVpbGRlci5tYXRtdWwoYSxiKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoYyl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyTWF4UG9vbDJkKGJ1aWxkZXJJZCxpbnB1dElkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZVBvb2wyZE9wdGlvbnMob3B0aW9uc1B0cik7dmFyIHBvb2wyZD1idWlsZGVyLm1heFBvb2wyZChpbnB1dCxvcHRpb25zKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUocG9vbDJkKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJSZWxlYXNlKGlkKXtXZWJOTi5tZ3JHcmFwaEJ1aWxkZXIucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyUmVsdShidWlsZGVySWQsaW5wdXRJZCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgb3V0cHV0PWJ1aWxkZXIucmVsdShpbnB1dCk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKG91dHB1dCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyUmVzaGFwZShidWlsZGVySWQsaW5wdXRJZCxuZXdTaGFwZVB0cixuZXdTaGFwZUNvdW50KXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBuZXdTaGFwZT1XZWJOTi5tYWtlSTMyQXJyYXkobmV3U2hhcGVDb3VudCxuZXdTaGFwZVB0cik7dmFyIG91dHB1dD1idWlsZGVyLnJlc2hhcGUoaW5wdXQsbmV3U2hhcGUpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQ29tcHV0ZVN5bmMoZ3JhcGhJZCxpbnB1dHNJZCxvdXRwdXRzSWQpe3ZhciBncmFwaD1XZWJOTi5tZ3JHcmFwaC5nZXQoZ3JhcGhJZCk7dmFyIGlucHV0cz1XZWJOTi5tZ3JOYW1lZElucHV0cy5nZXQoaW5wdXRzSWQpO3ZhciBvdXRwdXRzPVdlYk5OLm1nck5hbWVkT3V0cHV0cy5nZXQob3V0cHV0c0lkKTtyZXR1cm4gZ3JhcGguY29tcHV0ZVN5bmMoaW5wdXRzLG91dHB1dHMpfWZ1bmN0aW9uIF9tbEdyYXBoUmVmZXJlbmNlKGlkKXtXZWJOTi5tZ3JHcmFwaC5yZWZlcmVuY2UoaWQpfWZ1bmN0aW9uIF9tbEdyYXBoUmVsZWFzZShpZCl7V2ViTk4ubWdyR3JhcGgucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sTmFtZWRJbnB1dHNSZWxlYXNlKGlkKXtXZWJOTi5tZ3JOYW1lZElucHV0cy5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxOYW1lZElucHV0c1NldChuYW1lZElucHV0c0lkLG5hbWVQdHIsaW5wdXRQdHIpe3ZhciBuYW1lZElucHV0cz1XZWJOTi5tZ3JOYW1lZElucHV0cy5nZXQobmFtZWRJbnB1dHNJZCk7dmFyIG5hbWU9VVRGOFRvU3RyaW5nKG5hbWVQdHIpO3ZhciBpbnB1dD1XZWJOTi5tYWtlSW5wdXQoaW5wdXRQdHIpO25hbWVkSW5wdXRzW25hbWVdPWlucHV0fWZ1bmN0aW9uIF9tbE5hbWVkT3BlcmFuZHNSZWxlYXNlKGlkKXtXZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbE5hbWVkT3BlcmFuZHNTZXQobmFtZWRPcGVyYW5kc0lkLG5hbWVQdHIsb3BlcmFuZElkKXt2YXIgbmFtZWRPcGVyYW5kcz1XZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLmdldChuYW1lZE9wZXJhbmRzSWQpO3ZhciBuYW1lPVVURjhUb1N0cmluZyhuYW1lUHRyKTt2YXIgb3BlcmFuZD1XZWJOTi5tZ3JPcGVyYW5kLmdldChvcGVyYW5kSWQpO25hbWVkT3BlcmFuZHNbbmFtZV09b3BlcmFuZH1mdW5jdGlvbiBfbWxOYW1lZE91dHB1dHNSZWxlYXNlKGlkKXtXZWJOTi5tZ3JOYW1lZE91dHB1dHMucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sTmFtZWRPdXRwdXRzU2V0KG5hbWVkT3V0cHV0c0lkLG5hbWVQdHIsb3V0cHV0UHRyKXt2YXIgbmFtZWRPdXRwdXRzPVdlYk5OLm1nck5hbWVkT3V0cHV0cy5nZXQobmFtZWRPdXRwdXRzSWQpO3ZhciBuYW1lPVVURjhUb1N0cmluZyhuYW1lUHRyKTt2YXIgb3V0cHV0PVdlYk5OLm1ha2VPdXRwdXQob3V0cHV0UHRyKTtuYW1lZE91dHB1dHNbbmFtZV09b3V0cHV0fWZ1bmN0aW9uIF9tbE9wZXJhbmRSZWZlcmVuY2UoaWQpe1dlYk5OLm1nck9wZXJhbmQucmVmZXJlbmNlKGlkKX1mdW5jdGlvbiBfbWxPcGVyYW5kUmVsZWFzZShpZCl7V2ViTk4ubWdyT3BlcmFuZC5yZWxlYXNlKGlkKX1mdW5jdGlvbiBzcGF3blRocmVhZCh0aHJlYWRQYXJhbXMpe2lmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpdGhyb3dcIkludGVybmFsIEVycm9yISBzcGF3blRocmVhZCgpIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIGZyb20gbWFpbiBhcHBsaWNhdGlvbiB0aHJlYWQhXCI7dmFyIHdvcmtlcj1QVGhyZWFkLmdldE5ld1dvcmtlcigpO2lmKCF3b3JrZXIpe3JldHVybiA2fWlmKHdvcmtlci5wdGhyZWFkIT09dW5kZWZpbmVkKXRocm93XCJJbnRlcm5hbCBlcnJvciFcIjtpZighdGhyZWFkUGFyYW1zLnB0aHJlYWRfcHRyKXRocm93XCJJbnRlcm5hbCBlcnJvciwgbm8gcHRocmVhZCBwdHIhXCI7UFRocmVhZC5ydW5uaW5nV29ya2Vycy5wdXNoKHdvcmtlcik7dmFyIHRsc01lbW9yeT1fbWFsbG9jKDEyOCo0KTtmb3IodmFyIGk9MDtpPDEyODsrK2kpe0dST1dBQkxFX0hFQVBfSTMyKClbdGxzTWVtb3J5K2kqND4+Ml09MH12YXIgc3RhY2tIaWdoPXRocmVhZFBhcmFtcy5zdGFja0Jhc2UrdGhyZWFkUGFyYW1zLnN0YWNrU2l6ZTt2YXIgcHRocmVhZD1QVGhyZWFkLnB0aHJlYWRzW3RocmVhZFBhcmFtcy5wdGhyZWFkX3B0cl09e3dvcmtlcjp3b3JrZXIsc3RhY2tCYXNlOnRocmVhZFBhcmFtcy5zdGFja0Jhc2Usc3RhY2tTaXplOnRocmVhZFBhcmFtcy5zdGFja1NpemUsYWxsb2NhdGVkT3duU3RhY2s6dGhyZWFkUGFyYW1zLmFsbG9jYXRlZE93blN0YWNrLHRocmVhZEluZm9TdHJ1Y3Q6dGhyZWFkUGFyYW1zLnB0aHJlYWRfcHRyfTt2YXIgdGlzPXB0aHJlYWQudGhyZWFkSW5mb1N0cnVjdD4+MjtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKyg2ND4+MiksdGhyZWFkUGFyYW1zLmRldGFjaGVkKTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKygxMDA+PjIpLHRsc01lbW9yeSk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRpcysoNDA+PjIpLHB0aHJlYWQudGhyZWFkSW5mb1N0cnVjdCk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRpcysoODA+PjIpLHRocmVhZFBhcmFtcy5zdGFja1NpemUpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aXMrKDc2Pj4yKSxzdGFja0hpZ2gpO0F0b21pY3Muc3RvcmUoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aXMrKDEwND4+MiksdGhyZWFkUGFyYW1zLnN0YWNrU2l6ZSk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRpcysoMTA0Kzg+PjIpLHN0YWNrSGlnaCk7QXRvbWljcy5zdG9yZShHUk9XQUJMRV9IRUFQX1UzMigpLHRpcysoMTA0KzEyPj4yKSx0aHJlYWRQYXJhbXMuZGV0YWNoZWQpO3ZhciBnbG9iYWxfbGliYz1fZW1zY3JpcHRlbl9nZXRfZ2xvYmFsX2xpYmMoKTt2YXIgZ2xvYmFsX2xvY2FsZT1nbG9iYWxfbGliYys0MDtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGlzKygxNzI+PjIpLGdsb2JhbF9sb2NhbGUpO3dvcmtlci5wdGhyZWFkPXB0aHJlYWQ7dmFyIG1zZz17XCJjbWRcIjpcInJ1blwiLFwic3RhcnRfcm91dGluZVwiOnRocmVhZFBhcmFtcy5zdGFydFJvdXRpbmUsXCJhcmdcIjp0aHJlYWRQYXJhbXMuYXJnLFwidGhyZWFkSW5mb1N0cnVjdFwiOnRocmVhZFBhcmFtcy5wdGhyZWFkX3B0cixcInN0YWNrQmFzZVwiOnRocmVhZFBhcmFtcy5zdGFja0Jhc2UsXCJzdGFja1NpemVcIjp0aHJlYWRQYXJhbXMuc3RhY2tTaXplfTt3b3JrZXIucnVuUHRocmVhZD1mdW5jdGlvbigpe21zZy50aW1lPXBlcmZvcm1hbmNlLm5vdygpO3dvcmtlci5wb3N0TWVzc2FnZShtc2csdGhyZWFkUGFyYW1zLnRyYW5zZmVyTGlzdCl9O2lmKHdvcmtlci5sb2FkZWQpe3dvcmtlci5ydW5QdGhyZWFkKCk7ZGVsZXRlIHdvcmtlci5ydW5QdGhyZWFkfXJldHVybiAwfWZ1bmN0aW9uIF9wdGhyZWFkX2NyZWF0ZShwdGhyZWFkX3B0cixhdHRyLHN0YXJ0X3JvdXRpbmUsYXJnKXtpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI9PT1cInVuZGVmaW5lZFwiKXtlcnIoXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKTtyZXR1cm4gNn1pZighcHRocmVhZF9wdHIpe2VycihcInB0aHJlYWRfY3JlYXRlIGNhbGxlZCB3aXRoIGEgbnVsbCB0aHJlYWQgcG9pbnRlciFcIik7cmV0dXJuIDI4fXZhciB0cmFuc2Zlckxpc3Q9W107dmFyIGVycm9yPTA7aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCYmKHRyYW5zZmVyTGlzdC5sZW5ndGg9PT0wfHxlcnJvcikpe3JldHVybiBfZW1zY3JpcHRlbl9zeW5jX3J1bl9pbl9tYWluX3RocmVhZF80KDY4Nzg2NTg1NixwdGhyZWFkX3B0cixhdHRyLHN0YXJ0X3JvdXRpbmUsYXJnKX1pZihlcnJvcilyZXR1cm4gZXJyb3I7dmFyIHN0YWNrU2l6ZT0wO3ZhciBzdGFja0Jhc2U9MDt2YXIgZGV0YWNoZWQ9MDtpZihhdHRyJiZhdHRyIT0tMSl7c3RhY2tTaXplPUdST1dBQkxFX0hFQVBfSTMyKClbYXR0cj4+Ml07c3RhY2tTaXplKz04MTkyMDtzdGFja0Jhc2U9R1JPV0FCTEVfSEVBUF9JMzIoKVthdHRyKzg+PjJdO2RldGFjaGVkPUdST1dBQkxFX0hFQVBfSTMyKClbYXR0cisxMj4+Ml0hPT0wfWVsc2V7c3RhY2tTaXplPTIwOTcxNTJ9dmFyIGFsbG9jYXRlZE93blN0YWNrPXN0YWNrQmFzZT09MDtpZihhbGxvY2F0ZWRPd25TdGFjayl7c3RhY2tCYXNlPV9tZW1hbGlnbigxNixzdGFja1NpemUpfWVsc2V7c3RhY2tCYXNlLT1zdGFja1NpemU7YXNzZXJ0KHN0YWNrQmFzZT4wKX12YXIgdGhyZWFkSW5mb1N0cnVjdD1fbWFsbG9jKDIyOCk7Zm9yKHZhciBpPTA7aTwyMjg+PjI7KytpKUdST1dBQkxFX0hFQVBfVTMyKClbKHRocmVhZEluZm9TdHJ1Y3Q+PjIpK2ldPTA7R1JPV0FCTEVfSEVBUF9JMzIoKVtwdGhyZWFkX3B0cj4+Ml09dGhyZWFkSW5mb1N0cnVjdDtHUk9XQUJMRV9IRUFQX0kzMigpW3RocmVhZEluZm9TdHJ1Y3QrMTI+PjJdPXRocmVhZEluZm9TdHJ1Y3Q7dmFyIGhlYWRQdHI9dGhyZWFkSW5mb1N0cnVjdCsxNTI7R1JPV0FCTEVfSEVBUF9JMzIoKVtoZWFkUHRyPj4yXT1oZWFkUHRyO3ZhciB0aHJlYWRQYXJhbXM9e3N0YWNrQmFzZTpzdGFja0Jhc2Usc3RhY2tTaXplOnN0YWNrU2l6ZSxhbGxvY2F0ZWRPd25TdGFjazphbGxvY2F0ZWRPd25TdGFjayxkZXRhY2hlZDpkZXRhY2hlZCxzdGFydFJvdXRpbmU6c3RhcnRfcm91dGluZSxwdGhyZWFkX3B0cjp0aHJlYWRJbmZvU3RydWN0LGFyZzphcmcsdHJhbnNmZXJMaXN0OnRyYW5zZmVyTGlzdH07aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7dGhyZWFkUGFyYW1zLmNtZD1cInNwYXduVGhyZWFkXCI7cG9zdE1lc3NhZ2UodGhyZWFkUGFyYW1zLHRyYW5zZmVyTGlzdCk7cmV0dXJuIDB9cmV0dXJuIHNwYXduVGhyZWFkKHRocmVhZFBhcmFtcyl9ZnVuY3Rpb24gX19wdGhyZWFkX3Rlc3RjYW5jZWxfanMoKXtpZighRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClyZXR1cm47dmFyIHRiPV9wdGhyZWFkX3NlbGYoKTtpZighdGIpcmV0dXJuO3ZhciBjYW5jZWxEaXNhYmxlZD1BdG9taWNzLmxvYWQoR1JPV0FCTEVfSEVBUF9VMzIoKSx0Yis1Nj4+Mik7aWYoY2FuY2VsRGlzYWJsZWQpcmV0dXJuO3ZhciBjYW5jZWxlZD1BdG9taWNzLmxvYWQoR1JPV0FCTEVfSEVBUF9VMzIoKSx0YiswPj4yKTtpZihjYW5jZWxlZD09Mil0aHJvd1wiQ2FuY2VsZWQhXCJ9ZnVuY3Rpb24gX19lbXNjcmlwdGVuX2RvX3B0aHJlYWRfam9pbih0aHJlYWQsc3RhdHVzLGJsb2NrKXtpZighdGhyZWFkKXtlcnIoXCJwdGhyZWFkX2pvaW4gYXR0ZW1wdGVkIG9uIGEgbnVsbCB0aHJlYWQgcG9pbnRlciFcIik7cmV0dXJuIEVSUk5PX0NPREVTLkVTUkNIfWlmKEVOVklST05NRU5UX0lTX1BUSFJFQUQmJl9wdGhyZWFkX3NlbGYoKT09dGhyZWFkKXtlcnIoXCJQVGhyZWFkIFwiK3RocmVhZCtcIiBpcyBhdHRlbXB0aW5nIHRvIGpvaW4gdG8gaXRzZWxmIVwiKTtyZXR1cm4gRVJSTk9fQ09ERVMuRURFQURMS31lbHNlIGlmKCFFTlZJUk9OTUVOVF9JU19QVEhSRUFEJiZfZW1zY3JpcHRlbl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkKCk9PXRocmVhZCl7ZXJyKFwiTWFpbiB0aHJlYWQgXCIrdGhyZWFkK1wiIGlzIGF0dGVtcHRpbmcgdG8gam9pbiB0byBpdHNlbGYhXCIpO3JldHVybiBFUlJOT19DT0RFUy5FREVBRExLfXZhciBzZWxmPUdST1dBQkxFX0hFQVBfSTMyKClbdGhyZWFkKzEyPj4yXTtpZihzZWxmIT09dGhyZWFkKXtlcnIoXCJwdGhyZWFkX2pvaW4gYXR0ZW1wdGVkIG9uIHRocmVhZCBcIit0aHJlYWQrXCIsIHdoaWNoIGRvZXMgbm90IHBvaW50IHRvIGEgdmFsaWQgdGhyZWFkLCBvciBkb2VzIG5vdCBleGlzdCBhbnltb3JlIVwiKTtyZXR1cm4gRVJSTk9fQ09ERVMuRVNSQ0h9dmFyIGRldGFjaGVkPUF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX1UzMigpLHRocmVhZCs2ND4+Mik7aWYoZGV0YWNoZWQpe2VycihcIkF0dGVtcHRlZCB0byBqb2luIHRocmVhZCBcIit0aHJlYWQrXCIsIHdoaWNoIHdhcyBhbHJlYWR5IGRldGFjaGVkIVwiKTtyZXR1cm4gRVJSTk9fQ09ERVMuRUlOVkFMfWlmKGJsb2NrKXtfZW1zY3JpcHRlbl9jaGVja19ibG9ja2luZ19hbGxvd2VkKCl9Zm9yKDs7KXt2YXIgdGhyZWFkU3RhdHVzPUF0b21pY3MubG9hZChHUk9XQUJMRV9IRUFQX1UzMigpLHRocmVhZCswPj4yKTtpZih0aHJlYWRTdGF0dXM9PTEpe3ZhciB0aHJlYWRFeGl0Q29kZT1BdG9taWNzLmxvYWQoR1JPV0FCTEVfSEVBUF9VMzIoKSx0aHJlYWQrND4+Mik7aWYoc3RhdHVzKUdST1dBQkxFX0hFQVBfSTMyKClbc3RhdHVzPj4yXT10aHJlYWRFeGl0Q29kZTtBdG9taWNzLnN0b3JlKEdST1dBQkxFX0hFQVBfVTMyKCksdGhyZWFkKzY0Pj4yLDEpO2lmKCFFTlZJUk9OTUVOVF9JU19QVEhSRUFEKWNsZWFudXBUaHJlYWQodGhyZWFkKTtlbHNlIHBvc3RNZXNzYWdlKHtcImNtZFwiOlwiY2xlYW51cFRocmVhZFwiLFwidGhyZWFkXCI6dGhyZWFkfSk7cmV0dXJuIDB9aWYoIWJsb2NrKXtyZXR1cm4gRVJSTk9fQ09ERVMuRUJVU1l9X19wdGhyZWFkX3Rlc3RjYW5jZWxfanMoKTtpZighRU5WSVJPTk1FTlRfSVNfUFRIUkVBRClfZW1zY3JpcHRlbl9tYWluX3RocmVhZF9wcm9jZXNzX3F1ZXVlZF9jYWxscygpO19lbXNjcmlwdGVuX2Z1dGV4X3dhaXQodGhyZWFkKzAsdGhyZWFkU3RhdHVzLEVOVklST05NRU5UX0lTX1BUSFJFQUQ/MTAwOjEpfX1mdW5jdGlvbiBfcHRocmVhZF9qb2luKHRocmVhZCxzdGF0dXMpe3JldHVybiBfX2Vtc2NyaXB0ZW5fZG9fcHRocmVhZF9qb2luKHRocmVhZCxzdGF0dXMsdHJ1ZSl9ZnVuY3Rpb24gX19pc0xlYXBZZWFyKHllYXIpe3JldHVybiB5ZWFyJTQ9PT0wJiYoeWVhciUxMDAhPT0wfHx5ZWFyJTQwMD09PTApfWZ1bmN0aW9uIF9fYXJyYXlTdW0oYXJyYXksaW5kZXgpe3ZhciBzdW09MDtmb3IodmFyIGk9MDtpPD1pbmRleDtzdW0rPWFycmF5W2krK10pe31yZXR1cm4gc3VtfXZhciBfX01PTlRIX0RBWVNfTEVBUD1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO3ZhciBfX01PTlRIX0RBWVNfUkVHVUxBUj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIF9fYWRkRGF5cyhkYXRlLGRheXMpe3ZhciBuZXdEYXRlPW5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTt3aGlsZShkYXlzPjApe3ZhciBsZWFwPV9faXNMZWFwWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkpO3ZhciBjdXJyZW50TW9udGg9bmV3RGF0ZS5nZXRNb250aCgpO3ZhciBkYXlzSW5DdXJyZW50TW9udGg9KGxlYXA/X19NT05USF9EQVlTX0xFQVA6X19NT05USF9EQVlTX1JFR1VMQVIpW2N1cnJlbnRNb250aF07aWYoZGF5cz5kYXlzSW5DdXJyZW50TW9udGgtbmV3RGF0ZS5nZXREYXRlKCkpe2RheXMtPWRheXNJbkN1cnJlbnRNb250aC1uZXdEYXRlLmdldERhdGUoKSsxO25ld0RhdGUuc2V0RGF0ZSgxKTtpZihjdXJyZW50TW9udGg8MTEpe25ld0RhdGUuc2V0TW9udGgoY3VycmVudE1vbnRoKzEpfWVsc2V7bmV3RGF0ZS5zZXRNb250aCgwKTtuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSsxKX19ZWxzZXtuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkrZGF5cyk7cmV0dXJuIG5ld0RhdGV9fXJldHVybiBuZXdEYXRlfWZ1bmN0aW9uIF9zdHJmdGltZShzLG1heHNpemUsZm9ybWF0LHRtKXt2YXIgdG1fem9uZT1HUk9XQUJMRV9IRUFQX0kzMigpW3RtKzQwPj4yXTt2YXIgZGF0ZT17dG1fc2VjOkdST1dBQkxFX0hFQVBfSTMyKClbdG0+PjJdLHRtX21pbjpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzQ+PjJdLHRtX2hvdXI6R1JPV0FCTEVfSEVBUF9JMzIoKVt0bSs4Pj4yXSx0bV9tZGF5OkdST1dBQkxFX0hFQVBfSTMyKClbdG0rMTI+PjJdLHRtX21vbjpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzE2Pj4yXSx0bV95ZWFyOkdST1dBQkxFX0hFQVBfSTMyKClbdG0rMjA+PjJdLHRtX3dkYXk6R1JPV0FCTEVfSEVBUF9JMzIoKVt0bSsyND4+Ml0sdG1feWRheTpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzI4Pj4yXSx0bV9pc2RzdDpHUk9XQUJMRV9IRUFQX0kzMigpW3RtKzMyPj4yXSx0bV9nbXRvZmY6R1JPV0FCTEVfSEVBUF9JMzIoKVt0bSszNj4+Ml0sdG1fem9uZTp0bV96b25lP1VURjhUb1N0cmluZyh0bV96b25lKTpcIlwifTt2YXIgcGF0dGVybj1VVEY4VG9TdHJpbmcoZm9ybWF0KTt2YXIgRVhQQU5TSU9OX1JVTEVTXzE9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzEpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzFbcnVsZV0pfXZhciBXRUVLREFZUz1bXCJTdW5kYXlcIixcIk1vbmRheVwiLFwiVHVlc2RheVwiLFwiV2VkbmVzZGF5XCIsXCJUaHVyc2RheVwiLFwiRnJpZGF5XCIsXCJTYXR1cmRheVwiXTt2YXIgTU9OVEhTPVtcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFwiSnVseVwiLFwiQXVndXN0XCIsXCJTZXB0ZW1iZXJcIixcIk9jdG9iZXJcIixcIk5vdmVtYmVyXCIsXCJEZWNlbWJlclwiXTtmdW5jdGlvbiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxjaGFyYWN0ZXIpe3ZhciBzdHI9dHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIj92YWx1ZS50b1N0cmluZygpOnZhbHVlfHxcIlwiO3doaWxlKHN0ci5sZW5ndGg8ZGlnaXRzKXtzdHI9Y2hhcmFjdGVyWzBdK3N0cn1yZXR1cm4gc3RyfWZ1bmN0aW9uIGxlYWRpbmdOdWxscyh2YWx1ZSxkaWdpdHMpe3JldHVybiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxcIjBcIil9ZnVuY3Rpb24gY29tcGFyZUJ5RGF5KGRhdGUxLGRhdGUyKXtmdW5jdGlvbiBzZ24odmFsdWUpe3JldHVybiB2YWx1ZTwwPy0xOnZhbHVlPjA/MTowfXZhciBjb21wYXJlO2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRGdWxsWWVhcigpLWRhdGUyLmdldEZ1bGxZZWFyKCkpKT09PTApe2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRNb250aCgpLWRhdGUyLmdldE1vbnRoKCkpKT09PTApe2NvbXBhcmU9c2duKGRhdGUxLmdldERhdGUoKS1kYXRlMi5nZXREYXRlKCkpfX1yZXR1cm4gY29tcGFyZX1mdW5jdGlvbiBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoKXtzd2l0Y2goamFuRm91cnRoLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gamFuRm91cnRoO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKXt2YXIgdGhpc0RhdGU9X19hZGREYXlzKG5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsMSksZGF0ZS50bV95ZGF5KTt2YXIgamFuRm91cnRoVGhpc1llYXI9bmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSwwLDQpO3ZhciBqYW5Gb3VydGhOZXh0WWVhcj1uZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpKzEsMCw0KTt2YXIgZmlyc3RXZWVrU3RhcnRUaGlzWWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoVGhpc1llYXIpO3ZhciBmaXJzdFdlZWtTdGFydE5leHRZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhOZXh0WWVhcik7aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIsdGhpc0RhdGUpPD0wKXtpZihjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnROZXh0WWVhcix0aGlzRGF0ZSk8PTApe3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpKzF9ZWxzZXtyZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKX19ZWxzZXtyZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKS0xfX12YXIgRVhQQU5TSU9OX1JVTEVTXzI9e1wiJWFcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gV0VFS0RBWVNbZGF0ZS50bV93ZGF5XS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldfSxcIiViXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIE1PTlRIU1tkYXRlLnRtX21vbl0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXX0sXCIlQ1wiOmZ1bmN0aW9uKGRhdGUpe3ZhciB5ZWFyPWRhdGUudG1feWVhcisxOTAwO3JldHVybiBsZWFkaW5nTnVsbHMoeWVhci8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5LDIpfSxcIiVlXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdTb21ldGhpbmcoZGF0ZS50bV9tZGF5LDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKX0sXCIlSFwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9ob3VyLDIpfSxcIiVJXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIHR3ZWx2ZUhvdXI9ZGF0ZS50bV9ob3VyO2lmKHR3ZWx2ZUhvdXI9PTApdHdlbHZlSG91cj0xMjtlbHNlIGlmKHR3ZWx2ZUhvdXI+MTIpdHdlbHZlSG91ci09MTI7cmV0dXJuIGxlYWRpbmdOdWxscyh0d2VsdmVIb3VyLDIpfSxcIiVqXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXkrX19hcnJheVN1bShfX2lzTGVhcFllYXIoZGF0ZS50bV95ZWFyKzE5MDApP19fTU9OVEhfREFZU19MRUFQOl9fTU9OVEhfREFZU19SRUdVTEFSLGRhdGUudG1fbW9uLTEpLDMpfSxcIiVtXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21vbisxLDIpfSxcIiVNXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21pbiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKGRhdGUpe2lmKGRhdGUudG1faG91cj49MCYmZGF0ZS50bV9ob3VyPDEyKXtyZXR1cm5cIkFNXCJ9ZWxzZXtyZXR1cm5cIlBNXCJ9fSxcIiVTXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX3NlYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3dkYXl8fDd9LFwiJVVcIjpmdW5jdGlvbihkYXRlKXt2YXIgamFuRmlyc3Q9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCwxKTt2YXIgZmlyc3RTdW5kYXk9amFuRmlyc3QuZ2V0RGF5KCk9PT0wP2phbkZpcnN0Ol9fYWRkRGF5cyhqYW5GaXJzdCw3LWphbkZpcnN0LmdldERheSgpKTt2YXIgZW5kRGF0ZT1uZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCxkYXRlLnRtX21vbixkYXRlLnRtX21kYXkpO2lmKGNvbXBhcmVCeURheShmaXJzdFN1bmRheSxlbmREYXRlKTwwKXt2YXIgZmVicnVhcnlGaXJzdFVudGlsRW5kTW9udGg9X19hcnJheVN1bShfX2lzTGVhcFllYXIoZW5kRGF0ZS5nZXRGdWxsWWVhcigpKT9fX01PTlRIX0RBWVNfTEVBUDpfX01PTlRIX0RBWVNfUkVHVUxBUixlbmREYXRlLmdldE1vbnRoKCktMSktMzE7dmFyIGZpcnN0U3VuZGF5VW50aWxFbmRKYW51YXJ5PTMxLWZpcnN0U3VuZGF5LmdldERhdGUoKTt2YXIgZGF5cz1maXJzdFN1bmRheVVudGlsRW5kSmFudWFyeStmZWJydWFyeUZpcnN0VW50aWxFbmRNb250aCtlbmREYXRlLmdldERhdGUoKTtyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguY2VpbChkYXlzLzcpLDIpfXJldHVybiBjb21wYXJlQnlEYXkoZmlyc3RTdW5kYXksamFuRmlyc3QpPT09MD9cIjAxXCI6XCIwMFwifSxcIiVWXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIGphbkZvdXJ0aFRoaXNZZWFyPW5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsNCk7dmFyIGphbkZvdXJ0aE5leHRZZWFyPW5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAxLDAsNCk7dmFyIGZpcnN0V2Vla1N0YXJ0VGhpc1llYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aFRoaXNZZWFyKTt2YXIgZmlyc3RXZWVrU3RhcnROZXh0WWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoTmV4dFllYXIpO3ZhciBlbmREYXRlPV9fYWRkRGF5cyhuZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCwwLDEpLGRhdGUudG1feWRheSk7aWYoY29tcGFyZUJ5RGF5KGVuZERhdGUsZmlyc3RXZWVrU3RhcnRUaGlzWWVhcik8MCl7cmV0dXJuXCI1M1wifWlmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydE5leHRZZWFyLGVuZERhdGUpPD0wKXtyZXR1cm5cIjAxXCJ9dmFyIGRheXNEaWZmZXJlbmNlO2lmKGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIuZ2V0RnVsbFllYXIoKTxkYXRlLnRtX3llYXIrMTkwMCl7ZGF5c0RpZmZlcmVuY2U9ZGF0ZS50bV95ZGF5KzMyLWZpcnN0V2Vla1N0YXJ0VGhpc1llYXIuZ2V0RGF0ZSgpfWVsc2V7ZGF5c0RpZmZlcmVuY2U9ZGF0ZS50bV95ZGF5KzEtZmlyc3RXZWVrU3RhcnRUaGlzWWVhci5nZXREYXRlKCl9cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmNlaWwoZGF5c0RpZmZlcmVuY2UvNyksMil9LFwiJXdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV93ZGF5fSxcIiVXXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIGphbkZpcnN0PW5ldyBEYXRlKGRhdGUudG1feWVhciwwLDEpO3ZhciBmaXJzdE1vbmRheT1qYW5GaXJzdC5nZXREYXkoKT09PTE/amFuRmlyc3Q6X19hZGREYXlzKGphbkZpcnN0LGphbkZpcnN0LmdldERheSgpPT09MD8xOjctamFuRmlyc3QuZ2V0RGF5KCkrMSk7dmFyIGVuZERhdGU9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsZGF0ZS50bV9tb24sZGF0ZS50bV9tZGF5KTtpZihjb21wYXJlQnlEYXkoZmlyc3RNb25kYXksZW5kRGF0ZSk8MCl7dmFyIGZlYnJ1YXJ5Rmlyc3RVbnRpbEVuZE1vbnRoPV9fYXJyYXlTdW0oX19pc0xlYXBZZWFyKGVuZERhdGUuZ2V0RnVsbFllYXIoKSk/X19NT05USF9EQVlTX0xFQVA6X19NT05USF9EQVlTX1JFR1VMQVIsZW5kRGF0ZS5nZXRNb250aCgpLTEpLTMxO3ZhciBmaXJzdE1vbmRheVVudGlsRW5kSmFudWFyeT0zMS1maXJzdE1vbmRheS5nZXREYXRlKCk7dmFyIGRheXM9Zmlyc3RNb25kYXlVbnRpbEVuZEphbnVhcnkrZmVicnVhcnlGaXJzdFVudGlsRW5kTW9udGgrZW5kRGF0ZS5nZXREYXRlKCk7cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmNlaWwoZGF5cy83KSwyKX1yZXR1cm4gY29tcGFyZUJ5RGF5KGZpcnN0TW9uZGF5LGphbkZpcnN0KT09PTA/XCIwMVwiOlwiMDBcIn0sXCIleVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybihkYXRlLnRtX3llYXIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV95ZWFyKzE5MDB9LFwiJXpcIjpmdW5jdGlvbihkYXRlKXt2YXIgb2ZmPWRhdGUudG1fZ210b2ZmO3ZhciBhaGVhZD1vZmY+PTA7b2ZmPU1hdGguYWJzKG9mZikvNjA7b2ZmPW9mZi82MCoxMDArb2ZmJTYwO3JldHVybihhaGVhZD9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiK29mZikuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fem9uZX0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzIpe2lmKHBhdHRlcm4uaW5jbHVkZXMocnVsZSkpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzJbcnVsZV0oZGF0ZSkpfX12YXIgYnl0ZXM9aW50QXJyYXlGcm9tU3RyaW5nKHBhdHRlcm4sZmFsc2UpO2lmKGJ5dGVzLmxlbmd0aD5tYXhzaXplKXtyZXR1cm4gMH13cml0ZUFycmF5VG9NZW1vcnkoYnl0ZXMscyk7cmV0dXJuIGJ5dGVzLmxlbmd0aC0xfWZ1bmN0aW9uIF9zdHJmdGltZV9sKHMsbWF4c2l6ZSxmb3JtYXQsdG0pe3JldHVybiBfc3RyZnRpbWUocyxtYXhzaXplLGZvcm1hdCx0bSl9ZnVuY3Rpb24gX3dlYm5uQ3JlYXRlR3JhcGhCdWlsZGVyKGNvbnRleHRJZCl7dmFyIGNvbnRleHQ9V2ViTk4ubWdyQ29udGV4dC5nZXQoY29udGV4dElkKTt2YXIgYnVpbGRlcj1uZXcgTUxHcmFwaEJ1aWxkZXIoY29udGV4dCk7cmV0dXJuIFdlYk5OLm1nckdyYXBoQnVpbGRlci5jcmVhdGUoYnVpbGRlcil9ZnVuY3Rpb24gX3dlYm5uQ3JlYXRlTmFtZWRJbnB1dHMoKXt2YXIgaW5wdXRzPXt9O3JldHVybiBXZWJOTi5tZ3JOYW1lZElucHV0cy5jcmVhdGUoaW5wdXRzKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVOYW1lZE9wZXJhbmRzKCl7dmFyIG9wZXJhbmRzPXt9O3JldHVybiBXZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLmNyZWF0ZShvcGVyYW5kcyl9ZnVuY3Rpb24gX3dlYm5uQ3JlYXRlTmFtZWRPdXRwdXRzKCl7dmFyIG91dHB1dHM9e307cmV0dXJuIFdlYk5OLm1nck5hbWVkT3V0cHV0cy5jcmVhdGUob3V0cHV0cyl9aWYoIUVOVklST05NRU5UX0lTX1BUSFJFQUQpUFRocmVhZC5pbml0TWFpblRocmVhZEJsb2NrKCk7dmFyIEdMY3R4O1dlYk5OLmluaXRNYW5hZ2VycygpO3ZhciBwcm94aWVkRnVuY3Rpb25UYWJsZT1bbnVsbCxfYXRleGl0LF9fX3N5c19hY2Nlc3MsX19fc3lzX2ZjbnRsNjQsX19fc3lzX2ZzdGF0NjQsX19fc3lzX2dldGRlbnRzNjQsX19fc3lzX2lvY3RsLF9fX3N5c19sc3RhdDY0LF9fX3N5c19ta2RpcixfX19zeXNfbW1hcDIsX19fc3lzX211bm1hcCxfX19zeXNfb3BlbixfX19zeXNfcmVhZGxpbmssX19fc3lzX3JtZGlyLF9fX3N5c19zdGF0NjQsX19fc3lzX3VubGluayxfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZV9tYWluX3RocmVhZCxfZW52aXJvbl9nZXQsX2Vudmlyb25fc2l6ZXNfZ2V0LF9mZF9jbG9zZSxfZmRfZmRzdGF0X2dldCxfZmRfcmVhZCxfZmRfc2VlayxfZmRfd3JpdGUsX3R6c2V0XTtmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSxkb250QWRkTnVsbCxsZW5ndGgpe3ZhciBsZW49bGVuZ3RoPjA/bGVuZ3RoOmxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO3ZhciB1OGFycmF5PW5ldyBBcnJheShsZW4pO3ZhciBudW1CeXRlc1dyaXR0ZW49c3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSx1OGFycmF5LDAsdThhcnJheS5sZW5ndGgpO2lmKGRvbnRBZGROdWxsKXU4YXJyYXkubGVuZ3RoPW51bUJ5dGVzV3JpdHRlbjtyZXR1cm4gdThhcnJheX12YXIgYXNtTGlicmFyeUFyZz17XCJoXCI6X19fYXNzZXJ0X2ZhaWwsXCJiYVwiOl9fX2Nsb2NrX2dldHRpbWUsXCJiXCI6X19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbixcImRcIjpfX19jeGFfYXRleGl0LFwiZVwiOl9fX2N4YV90aHJlYWRfYXRleGl0LFwiY1wiOl9fX2N4YV90aHJvdyxcIlFcIjpfX19zeXNfYWNjZXNzLFwiclwiOl9fX3N5c19mY250bDY0LFwiWFwiOl9fX3N5c19mc3RhdDY0LFwiUlwiOl9fX3N5c19nZXRkZW50czY0LFwidFwiOl9fX3N5c19nZXRwaWQsXCJJXCI6X19fc3lzX2lvY3RsLFwiU1wiOl9fX3N5c19sc3RhdDY0LFwiV1wiOl9fX3N5c19ta2RpcixcIlZcIjpfX19zeXNfbW1hcDIsXCJVXCI6X19fc3lzX211bm1hcCxcInFcIjpfX19zeXNfb3BlbixcIlBcIjpfX19zeXNfcmVhZGxpbmssXCJOXCI6X19fc3lzX3JtZGlyLFwidVwiOl9fX3N5c19zdGF0NjQsXCJPXCI6X19fc3lzX3VubGluayxcImFhXCI6X19lbXNjcmlwdGVuX25vdGlmeV90aHJlYWRfcXVldWUsXCJnXCI6X2Fib3J0LFwieVwiOl9jbG9ja19nZXR0aW1lLFwiS2FcIjpfZGlmZnRpbWUsXCJNXCI6X2RsY2xvc2UsXCJtXCI6X2RsZXJyb3IsXCJUXCI6X2Rsb3BlbixcIkRcIjpfZGxzeW0sXCJ3XCI6X2Vtc2NyaXB0ZW5fYXNtX2NvbnN0X2ludCxcIkhcIjpfZW1zY3JpcHRlbl9jaGVja19ibG9ja2luZ19hbGxvd2VkLFwiblwiOl9lbXNjcmlwdGVuX2NvbmRpdGlvbmFsX3NldF9jdXJyZW50X3RocmVhZF9zdGF0dXMsXCJqXCI6X2Vtc2NyaXB0ZW5fZnV0ZXhfd2FpdCxcImtcIjpfZW1zY3JpcHRlbl9mdXRleF93YWtlLFwiWVwiOl9lbXNjcmlwdGVuX2dldF9oZWFwX21heCxcImlcIjpfZW1zY3JpcHRlbl9nZXRfbm93LFwiRlwiOl9lbXNjcmlwdGVuX21lbWNweV9iaWcsXCJvXCI6X2Vtc2NyaXB0ZW5fbnVtX2xvZ2ljYWxfY29yZXMsXCJaXCI6X2Vtc2NyaXB0ZW5fcmVjZWl2ZV9vbl9tYWluX3RocmVhZF9qcyxcIkdcIjpfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcIl9cIjpfZW1zY3JpcHRlbl9zZXRfY2FudmFzX2VsZW1lbnRfc2l6ZSxcInZcIjpfZW1zY3JpcHRlbl9zZXRfY3VycmVudF90aHJlYWRfc3RhdHVzLFwiJFwiOl9lbXNjcmlwdGVuX3dlYmdsX2NyZWF0ZV9jb250ZXh0LFwiSWFcIjpfZW1zY3JpcHRlbl93ZWJubl9jcmVhdGVfY29udGV4dCxcIktcIjpfZW52aXJvbl9nZXQsXCJMXCI6X2Vudmlyb25fc2l6ZXNfZ2V0LFwibFwiOl9mZF9jbG9zZSxcIkpcIjpfZmRfZmRzdGF0X2dldCxcInNcIjpfZmRfcmVhZCxcIkNcIjpfZmRfc2VlayxcInBcIjpfZmRfd3JpdGUsXCJuYVwiOl9nZXR0aW1lb2ZkYXksXCJMYVwiOl9nbXRpbWVfcixcIkVcIjppbml0UHRocmVhZHNKUyxcIkFcIjpfbG9jYWx0aW1lX3IsXCJhXCI6d2FzbU1lbW9yeXx8TW9kdWxlW1wid2FzbU1lbW9yeVwiXSxcInpcIjpfbWt0aW1lLFwiSGFcIjpfbWxDb250ZXh0UmVmZXJlbmNlLFwiR2FcIjpfbWxDb250ZXh0UmVsZWFzZSxcIkNhXCI6X21sR3JhcGhCdWlsZGVyQWRkLFwiQmFcIjpfbWxHcmFwaEJ1aWxkZXJBdmVyYWdlUG9vbDJkLFwiQWFcIjpfbWxHcmFwaEJ1aWxkZXJCYXRjaE5vcm0sXCJ6YVwiOl9tbEdyYXBoQnVpbGRlckJ1aWxkU3luYyxcInlhXCI6X21sR3JhcGhCdWlsZGVyQ29uY2F0LFwieGFcIjpfbWxHcmFwaEJ1aWxkZXJDb25zdGFudCxcIndhXCI6X21sR3JhcGhCdWlsZGVyQ29udjJkLFwidmFcIjpfbWxHcmFwaEJ1aWxkZXJHZW1tLFwidWFcIjpfbWxHcmFwaEJ1aWxkZXJJbnB1dCxcInRhXCI6X21sR3JhcGhCdWlsZGVyTWF0bXVsLFwic2FcIjpfbWxHcmFwaEJ1aWxkZXJNYXhQb29sMmQsXCJwYVwiOl9tbEdyYXBoQnVpbGRlclJlbGVhc2UsXCJyYVwiOl9tbEdyYXBoQnVpbGRlclJlbHUsXCJxYVwiOl9tbEdyYXBoQnVpbGRlclJlc2hhcGUsXCJGYVwiOl9tbEdyYXBoQ29tcHV0ZVN5bmMsXCJFYVwiOl9tbEdyYXBoUmVmZXJlbmNlLFwiRGFcIjpfbWxHcmFwaFJlbGVhc2UsXCJtYVwiOl9tbE5hbWVkSW5wdXRzUmVsZWFzZSxcIm9hXCI6X21sTmFtZWRJbnB1dHNTZXQsXCJrYVwiOl9tbE5hbWVkT3BlcmFuZHNSZWxlYXNlLFwibGFcIjpfbWxOYW1lZE9wZXJhbmRzU2V0LFwiaWFcIjpfbWxOYW1lZE91dHB1dHNSZWxlYXNlLFwiamFcIjpfbWxOYW1lZE91dHB1dHNTZXQsXCJoYVwiOl9tbE9wZXJhbmRSZWZlcmVuY2UsXCJnYVwiOl9tbE9wZXJhbmRSZWxlYXNlLFwieFwiOl9wdGhyZWFkX2NyZWF0ZSxcIkJcIjpfcHRocmVhZF9qb2luLFwiSmFcIjpfc3RyZnRpbWUsXCJmXCI6X3N0cmZ0aW1lX2wsXCJmYVwiOl93ZWJubkNyZWF0ZUdyYXBoQnVpbGRlcixcImVhXCI6X3dlYm5uQ3JlYXRlTmFtZWRJbnB1dHMsXCJkYVwiOl93ZWJubkNyZWF0ZU5hbWVkT3BlcmFuZHMsXCJjYVwiOl93ZWJubkNyZWF0ZU5hbWVkT3V0cHV0c307dmFyIGFzbT1jcmVhdGVXYXNtKCk7dmFyIF9fX3dhc21fY2FsbF9jdG9ycz1Nb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19fd2FzbV9jYWxsX2N0b3JzPU1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJNYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEluaXQ9TW9kdWxlW1wiX09ydEluaXRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEluaXQ9TW9kdWxlW1wiX09ydEluaXRcIl09TW9kdWxlW1wiYXNtXCJdW1wiTmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1Nb2R1bGVbXCJfT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9uc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJPYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFNlc3Npb25PcHRpb25zQXBwZW5kRXhlY3V0aW9uUHJvdmlkZXJXZWJOTj1Nb2R1bGVbXCJfT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRTZXNzaW9uT3B0aW9uc0FwcGVuZEV4ZWN1dGlvblByb3ZpZGVyV2ViTk49TW9kdWxlW1wiX09ydFNlc3Npb25PcHRpb25zQXBwZW5kRXhlY3V0aW9uUHJvdmlkZXJXZWJOTlwiXT1Nb2R1bGVbXCJhc21cIl1bXCJQYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9TW9kdWxlW1wiX09ydEFkZFNlc3Npb25Db25maWdFbnRyeVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJRYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1Nb2R1bGVbXCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9TW9kdWxlW1wiX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9uc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJSYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydENyZWF0ZVNlc3Npb249TW9kdWxlW1wiX09ydENyZWF0ZVNlc3Npb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVNlc3Npb249TW9kdWxlW1wiX09ydENyZWF0ZVNlc3Npb25cIl09TW9kdWxlW1wiYXNtXCJdW1wiU2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRSZWxlYXNlU2Vzc2lvbj1Nb2R1bGVbXCJfT3J0UmVsZWFzZVNlc3Npb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VTZXNzaW9uPU1vZHVsZVtcIl9PcnRSZWxlYXNlU2Vzc2lvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJUYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldElucHV0Q291bnQ9TW9kdWxlW1wiX09ydEdldElucHV0Q291bnRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldElucHV0Q291bnQ9TW9kdWxlW1wiX09ydEdldElucHV0Q291bnRcIl09TW9kdWxlW1wiYXNtXCJdW1wiVWFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRHZXRPdXRwdXRDb3VudD1Nb2R1bGVbXCJfT3J0R2V0T3V0cHV0Q291bnRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldE91dHB1dENvdW50PU1vZHVsZVtcIl9PcnRHZXRPdXRwdXRDb3VudFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJWYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldElucHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0SW5wdXROYW1lXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRHZXRJbnB1dE5hbWU9TW9kdWxlW1wiX09ydEdldElucHV0TmFtZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJXYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldE91dHB1dE5hbWU9TW9kdWxlW1wiX09ydEdldE91dHB1dE5hbWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldE91dHB1dE5hbWU9TW9kdWxlW1wiX09ydEdldE91dHB1dE5hbWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiWGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRGcmVlPU1vZHVsZVtcIl9PcnRGcmVlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRGcmVlPU1vZHVsZVtcIl9PcnRGcmVlXCJdPU1vZHVsZVtcImFzbVwiXVtcIllhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0Q3JlYXRlVGVuc29yPU1vZHVsZVtcIl9PcnRDcmVhdGVUZW5zb3JcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVRlbnNvcj1Nb2R1bGVbXCJfT3J0Q3JlYXRlVGVuc29yXCJdPU1vZHVsZVtcImFzbVwiXVtcIlphXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0VGVuc29yRGF0YT1Nb2R1bGVbXCJfT3J0R2V0VGVuc29yRGF0YVwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0VGVuc29yRGF0YT1Nb2R1bGVbXCJfT3J0R2V0VGVuc29yRGF0YVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJfYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VUZW5zb3I9TW9kdWxlW1wiX09ydFJlbGVhc2VUZW5zb3JcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VUZW5zb3I9TW9kdWxlW1wiX09ydFJlbGVhc2VUZW5zb3JcIl09TW9kdWxlW1wiYXNtXCJdW1wiJGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRDcmVhdGVSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVSdW5PcHRpb25zXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRDcmVhdGVSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVSdW5PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcImFiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0QWRkUnVuQ29uZmlnRW50cnk9TW9kdWxlW1wiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRBZGRSdW5Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkUnVuQ29uZmlnRW50cnlcIl09TW9kdWxlW1wiYXNtXCJdW1wiYmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRSZWxlYXNlUnVuT3B0aW9ucz1Nb2R1bGVbXCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRSZWxlYXNlUnVuT3B0aW9uc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJjYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJ1bj1Nb2R1bGVbXCJfT3J0UnVuXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRSdW49TW9kdWxlW1wiX09ydFJ1blwiXT1Nb2R1bGVbXCJhc21cIl1bXCJkYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9tYWxsb2M9TW9kdWxlW1wiX21hbGxvY1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJmYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19fZXJybm9fbG9jYXRpb249TW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19fZXJybm9fbG9jYXRpb249TW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl09TW9kdWxlW1wiYXNtXCJdW1wiZ2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9mcmVlPU1vZHVsZVtcIl9mcmVlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9mcmVlPU1vZHVsZVtcIl9mcmVlXCJdPU1vZHVsZVtcImFzbVwiXVtcImhiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfcHRocmVhZF9zZWxmPU1vZHVsZVtcIl9wdGhyZWFkX3NlbGZcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX3B0aHJlYWRfc2VsZj1Nb2R1bGVbXCJfcHRocmVhZF9zZWxmXCJdPU1vZHVsZVtcImFzbVwiXVtcImliXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZW1zY3JpcHRlbl90bHNfaW5pdD1Nb2R1bGVbXCJfZW1zY3JpcHRlbl90bHNfaW5pdFwiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl90bHNfaW5pdD1Nb2R1bGVbXCJfZW1zY3JpcHRlbl90bHNfaW5pdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJqYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fY3VycmVudF90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fY3VycmVudF90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2Vtc2NyaXB0ZW5fY3VycmVudF90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fY3VycmVudF90aHJlYWRfcHJvY2Vzc19xdWV1ZWRfY2FsbHNcIl09TW9kdWxlW1wiYXNtXCJdW1wia2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX3JlZ2lzdGVyX21haW5fYnJvd3Nlcl90aHJlYWRfaWQ9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fcmVnaXN0ZXJfbWFpbl9icm93c2VyX3RocmVhZF9pZFwiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9yZWdpc3Rlcl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkPU1vZHVsZVtcIl9lbXNjcmlwdGVuX3JlZ2lzdGVyX21haW5fYnJvd3Nlcl90aHJlYWRfaWRcIl09TW9kdWxlW1wiYXNtXCJdW1wibGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX21haW5fYnJvd3Nlcl90aHJlYWRfaWQ9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fbWFpbl9icm93c2VyX3RocmVhZF9pZFwiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9tYWluX2Jyb3dzZXJfdGhyZWFkX2lkPU1vZHVsZVtcIl9lbXNjcmlwdGVuX21haW5fYnJvd3Nlcl90aHJlYWRfaWRcIl09TW9kdWxlW1wiYXNtXCJdW1wibWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZW1zY3JpcHRlbl9kb19kaXNwYXRjaF90b190aHJlYWQ9TW9kdWxlW1wiX19lbXNjcmlwdGVuX2RvX2Rpc3BhdGNoX3RvX3RocmVhZFwiXT1mdW5jdGlvbigpe3JldHVybihfX2Vtc2NyaXB0ZW5fZG9fZGlzcGF0Y2hfdG9fdGhyZWFkPU1vZHVsZVtcIl9fZW1zY3JpcHRlbl9kb19kaXNwYXRjaF90b190aHJlYWRcIl09TW9kdWxlW1wiYXNtXCJdW1wibmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX3N5bmNfcnVuX2luX21haW5fdGhyZWFkXzQ9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3luY19ydW5faW5fbWFpbl90aHJlYWRfNFwiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9zeW5jX3J1bl9pbl9tYWluX3RocmVhZF80PU1vZHVsZVtcIl9lbXNjcmlwdGVuX3N5bmNfcnVuX2luX21haW5fdGhyZWFkXzRcIl09TW9kdWxlW1wiYXNtXCJdW1wib2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzPU1vZHVsZVtcIl9lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzPU1vZHVsZVtcIl9lbXNjcmlwdGVuX21haW5fdGhyZWFkX3Byb2Nlc3NfcXVldWVkX2NhbGxzXCJdPU1vZHVsZVtcImFzbVwiXVtcInBiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qc1wiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qcz1Nb2R1bGVbXCJfZW1zY3JpcHRlbl9ydW5faW5fbWFpbl9ydW50aW1lX3RocmVhZF9qc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJxYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19lbXNjcmlwdGVuX2NhbGxfb25fdGhyZWFkPU1vZHVsZVtcIl9fZW1zY3JpcHRlbl9jYWxsX29uX3RocmVhZFwiXT1mdW5jdGlvbigpe3JldHVybihfX2Vtc2NyaXB0ZW5fY2FsbF9vbl90aHJlYWQ9TW9kdWxlW1wiX19lbXNjcmlwdGVuX2NhbGxfb25fdGhyZWFkXCJdPU1vZHVsZVtcImFzbVwiXVtcInJiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQ9TW9kdWxlW1wiX19lbXNjcmlwdGVuX3RocmVhZF9pbml0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1Nb2R1bGVbXCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXRcIl09TW9kdWxlW1wiYXNtXCJdW1wic2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9tZW1zZXQ9TW9kdWxlW1wiX21lbXNldFwiXT1mdW5jdGlvbigpe3JldHVybihfbWVtc2V0PU1vZHVsZVtcIl9tZW1zZXRcIl09TW9kdWxlW1wiYXNtXCJdW1widGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fX3B0aHJlYWRfdHNkX3J1bl9kdG9ycz1Nb2R1bGVbXCJfX19wdGhyZWFkX3RzZF9ydW5fZHRvcnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19fcHRocmVhZF90c2RfcnVuX2R0b3JzPU1vZHVsZVtcIl9fX3B0aHJlYWRfdHNkX3J1bl9kdG9yc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJ1YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2Vtc2NyaXB0ZW5fZ2V0X2dsb2JhbF9saWJjPU1vZHVsZVtcIl9lbXNjcmlwdGVuX2dldF9nbG9iYWxfbGliY1wiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9nZXRfZ2xvYmFsX2xpYmM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fZ2V0X2dsb2JhbF9saWJjXCJdPU1vZHVsZVtcImFzbVwiXVtcInZiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2dldF90em5hbWU9TW9kdWxlW1wiX19nZXRfdHpuYW1lXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZ2V0X3R6bmFtZT1Nb2R1bGVbXCJfX2dldF90em5hbWVcIl09TW9kdWxlW1wiYXNtXCJdW1wid2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZ2V0X2RheWxpZ2h0PU1vZHVsZVtcIl9fZ2V0X2RheWxpZ2h0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZ2V0X2RheWxpZ2h0PU1vZHVsZVtcIl9fZ2V0X2RheWxpZ2h0XCJdPU1vZHVsZVtcImFzbVwiXVtcInhiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2dldF90aW1lem9uZT1Nb2R1bGVbXCJfX2dldF90aW1lem9uZVwiXT1mdW5jdGlvbigpe3JldHVybihfX2dldF90aW1lem9uZT1Nb2R1bGVbXCJfX2dldF90aW1lem9uZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ5YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tTYXZlPU1vZHVsZVtcInN0YWNrU2F2ZVwiXT1mdW5jdGlvbigpe3JldHVybihzdGFja1NhdmU9TW9kdWxlW1wic3RhY2tTYXZlXCJdPU1vZHVsZVtcImFzbVwiXVtcInpiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja1Jlc3RvcmU9TW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrUmVzdG9yZT1Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl09TW9kdWxlW1wiYXNtXCJdW1wiQWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHN0YWNrQWxsb2M9TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1mdW5jdGlvbigpe3JldHVybihzdGFja0FsbG9jPU1vZHVsZVtcInN0YWNrQWxsb2NcIl09TW9kdWxlW1wiYXNtXCJdW1wiQmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHM9TW9kdWxlW1wiX2Vtc2NyaXB0ZW5fc3RhY2tfc2V0X2xpbWl0c1wiXT1mdW5jdGlvbigpe3JldHVybihfZW1zY3JpcHRlbl9zdGFja19zZXRfbGltaXRzPU1vZHVsZVtcIl9lbXNjcmlwdGVuX3N0YWNrX3NldF9saW1pdHNcIl09TW9kdWxlW1wiYXNtXCJdW1wiQ2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9tZW1hbGlnbj1Nb2R1bGVbXCJfbWVtYWxpZ25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21lbWFsaWduPU1vZHVsZVtcIl9tZW1hbGlnblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJEYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19lbXNjcmlwdGVuX2FsbG93X21haW5fcnVudGltZV9xdWV1ZWRfY2FsbHM9TW9kdWxlW1wiX19lbXNjcmlwdGVuX2FsbG93X21haW5fcnVudGltZV9xdWV1ZWRfY2FsbHNcIl09NjUzNTM2O3ZhciBfX2Vtc2NyaXB0ZW5fbWFpbl90aHJlYWRfZnV0ZXg9TW9kdWxlW1wiX19lbXNjcmlwdGVuX21haW5fdGhyZWFkX2Z1dGV4XCJdPTY1ODkwNDtNb2R1bGVbXCJVVEY4VG9TdHJpbmdcIl09VVRGOFRvU3RyaW5nO01vZHVsZVtcInN0cmluZ1RvVVRGOFwiXT1zdHJpbmdUb1VURjg7TW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEY4XCJdPWxlbmd0aEJ5dGVzVVRGODtNb2R1bGVbXCJQVGhyZWFkXCJdPVBUaHJlYWQ7TW9kdWxlW1wic3RhY2tTYXZlXCJdPXN0YWNrU2F2ZTtNb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl09c3RhY2tSZXN0b3JlO01vZHVsZVtcInN0YWNrQWxsb2NcIl09c3RhY2tBbGxvYztNb2R1bGVbXCJQVGhyZWFkXCJdPVBUaHJlYWQ7TW9kdWxlW1wid2FzbU1lbW9yeVwiXT13YXNtTWVtb3J5O01vZHVsZVtcIkV4aXRTdGF0dXNcIl09RXhpdFN0YXR1czt2YXIgY2FsbGVkUnVuO2Z1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCI7dGhpcy5tZXNzYWdlPVwiUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdChcIitzdGF0dXMrXCIpXCI7dGhpcy5zdGF0dXM9c3RhdHVzfWRlcGVuZGVuY2llc0Z1bGZpbGxlZD1mdW5jdGlvbiBydW5DYWxsZXIoKXtpZighY2FsbGVkUnVuKXJ1bigpO2lmKCFjYWxsZWRSdW4pZGVwZW5kZW5jaWVzRnVsZmlsbGVkPXJ1bkNhbGxlcn07ZnVuY3Rpb24gcnVuKGFyZ3Mpe2FyZ3M9YXJnc3x8YXJndW1lbnRzXztpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufWlmKEVOVklST05NRU5UX0lTX1BUSFJFQUQpe3JlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtpbml0UnVudGltZSgpO3Bvc3RNZXNzYWdlKHtcImNtZFwiOlwibG9hZGVkXCJ9KTtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1mdW5jdGlvbiBkb1J1bigpe2lmKGNhbGxlZFJ1bilyZXR1cm47Y2FsbGVkUnVuPXRydWU7TW9kdWxlW1wiY2FsbGVkUnVuXCJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2lmKE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKU1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7cG9zdFJ1bigpfWlmKE1vZHVsZVtcInNldFN0YXR1c1wiXSl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiUnVubmluZy4uLlwiKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKX0sMSk7ZG9SdW4oKX0sMSl9ZWxzZXtkb1J1bigpfX1Nb2R1bGVbXCJydW5cIl09cnVuO2Z1bmN0aW9uIGV4aXQoc3RhdHVzLGltcGxpY2l0KXtFWElUU1RBVFVTPXN0YXR1cztpZihpbXBsaWNpdCYma2VlcFJ1bnRpbWVBbGl2ZSgpJiZzdGF0dXM9PT0wKXtyZXR1cm59aWYoIWltcGxpY2l0KXtpZihFTlZJUk9OTUVOVF9JU19QVEhSRUFEKXtwb3N0TWVzc2FnZSh7XCJjbWRcIjpcImV4aXRQcm9jZXNzXCIsXCJyZXR1cm5Db2RlXCI6c3RhdHVzfSk7dGhyb3cgbmV3IEV4aXRTdGF0dXMoc3RhdHVzKX1lbHNle319aWYoa2VlcFJ1bnRpbWVBbGl2ZSgpKXt9ZWxzZXtQVGhyZWFkLnRlcm1pbmF0ZUFsbFRocmVhZHMoKTtleGl0UnVudGltZSgpO2lmKE1vZHVsZVtcIm9uRXhpdFwiXSlNb2R1bGVbXCJvbkV4aXRcIl0oc3RhdHVzKTtBQk9SVD10cnVlfXF1aXRfKHN0YXR1cyxuZXcgRXhpdFN0YXR1cyhzdGF0dXMpKX1pZihNb2R1bGVbXCJwcmVJbml0XCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicHJlSW5pdFwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInByZUluaXRcIl09W01vZHVsZVtcInByZUluaXRcIl1dO3doaWxlKE1vZHVsZVtcInByZUluaXRcIl0ubGVuZ3RoPjApe01vZHVsZVtcInByZUluaXRcIl0ucG9wKCkoKX19aWYoRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCl7bm9FeGl0UnVudGltZT1mYWxzZTtQVGhyZWFkLmluaXRXb3JrZXIoKX1ydW4oKTtcblxuXG4gIHJldHVybiBvcnRXYXNtVGhyZWFkZWQucmVhZHlcbn1cbik7XG59KSgpO1xuaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcbiAgbW9kdWxlLmV4cG9ydHMgPSBvcnRXYXNtVGhyZWFkZWQ7XG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10pXG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBvcnRXYXNtVGhyZWFkZWQ7IH0pO1xuZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICBleHBvcnRzW1wib3J0V2FzbVRocmVhZGVkXCJdID0gb3J0V2FzbVRocmVhZGVkO1xuIiwiXG52YXIgb3J0V2FzbSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIF9zY3JpcHREaXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBfX2ZpbGVuYW1lICE9PSAndW5kZWZpbmVkJykgX3NjcmlwdERpciA9IF9zY3JpcHREaXIgfHwgX19maWxlbmFtZTtcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKG9ydFdhc20pIHtcbiAgb3J0V2FzbSA9IG9ydFdhc20gfHwge307XG5cbnZhciBNb2R1bGU9dHlwZW9mIG9ydFdhc20hPT1cInVuZGVmaW5lZFwiP29ydFdhc206e307dmFyIHJlYWR5UHJvbWlzZVJlc29sdmUscmVhZHlQcm9taXNlUmVqZWN0O01vZHVsZVtcInJlYWR5XCJdPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KXtyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdH0pO3ZhciBtb2R1bGVPdmVycmlkZXM9e307dmFyIGtleTtmb3Ioa2V5IGluIE1vZHVsZSl7aWYoTW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpe21vZHVsZU92ZXJyaWRlc1trZXldPU1vZHVsZVtrZXldfX12YXIgYXJndW1lbnRzXz1bXTt2YXIgdGhpc1Byb2dyYW09XCIuL3RoaXMucHJvZ3JhbVwiO3ZhciBxdWl0Xz1mdW5jdGlvbihzdGF0dXMsdG9UaHJvdyl7dGhyb3cgdG9UaHJvd307dmFyIEVOVklST05NRU5UX0lTX1dFQj1mYWxzZTt2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19OT0RFPWZhbHNlO3ZhciBFTlZJUk9OTUVOVF9JU19TSEVMTD1mYWxzZTtFTlZJUk9OTUVOVF9JU19XRUI9dHlwZW9mIHdpbmRvdz09PVwib2JqZWN0XCI7RU5WSVJPTk1FTlRfSVNfV09SS0VSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT09XCJmdW5jdGlvblwiO0VOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucz09PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PT1cInN0cmluZ1wiO0VOVklST05NRU5UX0lTX1NIRUxMPSFFTlZJUk9OTUVOVF9JU19XRUImJiFFTlZJUk9OTUVOVF9JU19OT0RFJiYhRU5WSVJPTk1FTlRfSVNfV09SS0VSO3ZhciBzY3JpcHREaXJlY3Rvcnk9XCJcIjtmdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpe2lmKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pe3JldHVybiBNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKHBhdGgsc2NyaXB0RGlyZWN0b3J5KX1yZXR1cm4gc2NyaXB0RGlyZWN0b3J5K3BhdGh9dmFyIHJlYWRfLHJlYWRBc3luYyxyZWFkQmluYXJ5LHNldFdpbmRvd1RpdGxlO3ZhciBub2RlRlM7dmFyIG5vZGVQYXRoO2lmKEVOVklST05NRU5UX0lTX05PREUpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXJlcXVpcmUoXCJwYXRoXCIpLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KStcIi9cIn1lbHNle3NjcmlwdERpcmVjdG9yeT1fX2Rpcm5hbWUrXCIvXCJ9cmVhZF89ZnVuY3Rpb24gc2hlbGxfcmVhZChmaWxlbmFtZSxiaW5hcnkpe2lmKCFub2RlRlMpbm9kZUZTPXJlcXVpcmUoXCJmc1wiKTtpZighbm9kZVBhdGgpbm9kZVBhdGg9cmVxdWlyZShcInBhdGhcIik7ZmlsZW5hbWU9bm9kZVBhdGhbXCJub3JtYWxpemVcIl0oZmlsZW5hbWUpO3JldHVybiBub2RlRlNbXCJyZWFkRmlsZVN5bmNcIl0oZmlsZW5hbWUsYmluYXJ5P251bGw6XCJ1dGY4XCIpfTtyZWFkQmluYXJ5PWZ1bmN0aW9uIHJlYWRCaW5hcnkoZmlsZW5hbWUpe3ZhciByZXQ9cmVhZF8oZmlsZW5hbWUsdHJ1ZSk7aWYoIXJldC5idWZmZXIpe3JldD1uZXcgVWludDhBcnJheShyZXQpfWFzc2VydChyZXQuYnVmZmVyKTtyZXR1cm4gcmV0fTtpZihwcm9jZXNzW1wiYXJndlwiXS5sZW5ndGg+MSl7dGhpc1Byb2dyYW09cHJvY2Vzc1tcImFyZ3ZcIl1bMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKX1hcmd1bWVudHNfPXByb2Nlc3NbXCJhcmd2XCJdLnNsaWNlKDIpO3Byb2Nlc3NbXCJvblwiXShcInVuY2F1Z2h0RXhjZXB0aW9uXCIsZnVuY3Rpb24oZXgpe2lmKCEoZXggaW5zdGFuY2VvZiBFeGl0U3RhdHVzKSl7dGhyb3cgZXh9fSk7cHJvY2Vzc1tcIm9uXCJdKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsYWJvcnQpO3F1aXRfPWZ1bmN0aW9uKHN0YXR1cyl7cHJvY2Vzc1tcImV4aXRcIl0oc3RhdHVzKX07TW9kdWxlW1wiaW5zcGVjdFwiXT1mdW5jdGlvbigpe3JldHVyblwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIn19ZWxzZSBpZihFTlZJUk9OTUVOVF9JU19TSEVMTCl7aWYodHlwZW9mIHJlYWQhPVwidW5kZWZpbmVkXCIpe3JlYWRfPWZ1bmN0aW9uIHNoZWxsX3JlYWQoZil7cmV0dXJuIHJlYWQoZil9fXJlYWRCaW5hcnk9ZnVuY3Rpb24gcmVhZEJpbmFyeShmKXt2YXIgZGF0YTtpZih0eXBlb2YgcmVhZGJ1ZmZlcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpfWRhdGE9cmVhZChmLFwiYmluYXJ5XCIpO2Fzc2VydCh0eXBlb2YgZGF0YT09PVwib2JqZWN0XCIpO3JldHVybiBkYXRhfTtpZih0eXBlb2Ygc2NyaXB0QXJncyE9XCJ1bmRlZmluZWRcIil7YXJndW1lbnRzXz1zY3JpcHRBcmdzfWVsc2UgaWYodHlwZW9mIGFyZ3VtZW50cyE9XCJ1bmRlZmluZWRcIil7YXJndW1lbnRzXz1hcmd1bWVudHN9aWYodHlwZW9mIHF1aXQ9PT1cImZ1bmN0aW9uXCIpe3F1aXRfPWZ1bmN0aW9uKHN0YXR1cyl7cXVpdChzdGF0dXMpfX1pZih0eXBlb2YgcHJpbnQhPT1cInVuZGVmaW5lZFwiKXtpZih0eXBlb2YgY29uc29sZT09PVwidW5kZWZpbmVkXCIpY29uc29sZT17fTtjb25zb2xlLmxvZz1wcmludDtjb25zb2xlLndhcm49Y29uc29sZS5lcnJvcj10eXBlb2YgcHJpbnRFcnIhPT1cInVuZGVmaW5lZFwiP3ByaW50RXJyOnByaW50fX1lbHNlIGlmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKXtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3NjcmlwdERpcmVjdG9yeT1zZWxmLmxvY2F0aW9uLmhyZWZ9ZWxzZSBpZih0eXBlb2YgZG9jdW1lbnQhPT1cInVuZGVmaW5lZFwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0KXtzY3JpcHREaXJlY3Rvcnk9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9aWYoX3NjcmlwdERpcil7c2NyaXB0RGlyZWN0b3J5PV9zY3JpcHREaXJ9aWYoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoXCJibG9iOlwiKSE9PTApe3NjcmlwdERpcmVjdG9yeT1zY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsc2NyaXB0RGlyZWN0b3J5Lmxhc3RJbmRleE9mKFwiL1wiKSsxKX1lbHNle3NjcmlwdERpcmVjdG9yeT1cIlwifXtyZWFkXz1mdW5jdGlvbih1cmwpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLGZhbHNlKTt4aHIuc2VuZChudWxsKTtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH07aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtyZWFkQmluYXJ5PWZ1bmN0aW9uKHVybCl7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfX1yZWFkQXN5bmM9ZnVuY3Rpb24odXJsLG9ubG9hZCxvbmVycm9yKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCx0cnVlKTt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjt4aHIub25sb2FkPWZ1bmN0aW9uKCl7aWYoeGhyLnN0YXR1cz09MjAwfHx4aHIuc3RhdHVzPT0wJiZ4aHIucmVzcG9uc2Upe29ubG9hZCh4aHIucmVzcG9uc2UpO3JldHVybn1vbmVycm9yKCl9O3hoci5vbmVycm9yPW9uZXJyb3I7eGhyLnNlbmQobnVsbCl9fXNldFdpbmRvd1RpdGxlPWZ1bmN0aW9uKHRpdGxlKXtkb2N1bWVudC50aXRsZT10aXRsZX19ZWxzZXt9dmFyIG91dD1Nb2R1bGVbXCJwcmludFwiXXx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKTt2YXIgZXJyPU1vZHVsZVtcInByaW50RXJyXCJdfHxjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtmb3Ioa2V5IGluIG1vZHVsZU92ZXJyaWRlcyl7aWYobW9kdWxlT3ZlcnJpZGVzLmhhc093blByb3BlcnR5KGtleSkpe01vZHVsZVtrZXldPW1vZHVsZU92ZXJyaWRlc1trZXldfX1tb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbXCJhcmd1bWVudHNcIl0pYXJndW1lbnRzXz1Nb2R1bGVbXCJhcmd1bWVudHNcIl07aWYoTW9kdWxlW1widGhpc1Byb2dyYW1cIl0pdGhpc1Byb2dyYW09TW9kdWxlW1widGhpc1Byb2dyYW1cIl07aWYoTW9kdWxlW1wicXVpdFwiXSlxdWl0Xz1Nb2R1bGVbXCJxdWl0XCJdO3ZhciB3YXNtQmluYXJ5O2lmKE1vZHVsZVtcIndhc21CaW5hcnlcIl0pd2FzbUJpbmFyeT1Nb2R1bGVbXCJ3YXNtQmluYXJ5XCJdO3ZhciBub0V4aXRSdW50aW1lPU1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl18fGZhbHNlO2lmKHR5cGVvZiBXZWJBc3NlbWJseSE9PVwib2JqZWN0XCIpe2Fib3J0KFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKX12YXIgd2FzbU1lbW9yeTt2YXIgQUJPUlQ9ZmFsc2U7dmFyIEVYSVRTVEFUVVM7ZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbix0ZXh0KXtpZighY29uZGl0aW9uKXthYm9ydChcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK3RleHQpfX12YXIgVVRGOERlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT09XCJ1bmRlZmluZWRcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnVuZGVmaW5lZDtmdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwLGlkeCxtYXhCeXRlc1RvUmVhZCl7dmFyIGVuZElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQ7dmFyIGVuZFB0cj1pZHg7d2hpbGUoaGVhcFtlbmRQdHJdJiYhKGVuZFB0cj49ZW5kSWR4KSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZoZWFwLnN1YmFycmF5JiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwLnN1YmFycmF5KGlkeCxlbmRQdHIpKX1lbHNle3ZhciBzdHI9XCJcIjt3aGlsZShpZHg8ZW5kUHRyKXt2YXIgdTA9aGVhcFtpZHgrK107aWYoISh1MCYxMjgpKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO2NvbnRpbnVlfXZhciB1MT1oZWFwW2lkeCsrXSY2MztpZigodTAmMjI0KT09MTkyKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKHUwJjMxKTw8Nnx1MSk7Y29udGludWV9dmFyIHUyPWhlYXBbaWR4KytdJjYzO2lmKCh1MCYyNDApPT0yMjQpe3UwPSh1MCYxNSk8PDEyfHUxPDw2fHUyfWVsc2V7dTA9KHUwJjcpPDwxOHx1MTw8MTJ8dTI8PDZ8aGVhcFtpZHgrK10mNjN9aWYodTA8NjU1MzYpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCl9ZWxzZXt2YXIgY2g9dTAtNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKX19fXJldHVybiBzdHJ9ZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cixtYXhCeXRlc1RvUmVhZCl7cmV0dXJuIHB0cj9VVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgscHRyLG1heEJ5dGVzVG9SZWFkKTpcIlwifWZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpe2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXt2YXIgdTE9c3RyLmNoYXJDb2RlQXQoKytpKTt1PTY1NTM2KygodSYxMDIzKTw8MTApfHUxJjEwMjN9aWYodTw9MTI3KXtpZihvdXRJZHg+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT11fWVsc2UgaWYodTw9MjA0Nyl7aWYob3V0SWR4KzE+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0xOTJ8dT4+NjtoZWFwW291dElkeCsrXT0xMjh8dSY2M31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTIyNHx1Pj4xMjtoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2M31lbHNle2lmKG91dElkeCszPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjQwfHU+PjE4O2hlYXBbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2M319aGVhcFtvdXRJZHhdPTA7cmV0dXJuIG91dElkeC1zdGFydElkeH1mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpe3JldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUFU4LG91dFB0cixtYXhCeXRlc1RvV3JpdGUpfWZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpe3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpdT02NTUzNisoKHUmMTAyMyk8PDEwKXxzdHIuY2hhckNvZGVBdCgrK2kpJjEwMjM7aWYodTw9MTI3KSsrbGVuO2Vsc2UgaWYodTw9MjA0NylsZW4rPTI7ZWxzZSBpZih1PD02NTUzNSlsZW4rPTM7ZWxzZSBsZW4rPTR9cmV0dXJuIGxlbn1mdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKXt2YXIgc2l6ZT1sZW5ndGhCeXRlc1VURjgoc3RyKSsxO3ZhciByZXQ9X21hbGxvYyhzaXplKTtpZihyZXQpc3RyaW5nVG9VVEY4QXJyYXkoc3RyLEhFQVA4LHJldCxzaXplKTtyZXR1cm4gcmV0fWZ1bmN0aW9uIHdyaXRlQXJyYXlUb01lbW9yeShhcnJheSxidWZmZXIpe0hFQVA4LnNldChhcnJheSxidWZmZXIpfWZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsYnVmZmVyLGRvbnRBZGROdWxsKXtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXtIRUFQOFtidWZmZXIrKz4+MF09c3RyLmNoYXJDb2RlQXQoaSl9aWYoIWRvbnRBZGROdWxsKUhFQVA4W2J1ZmZlcj4+MF09MH1mdW5jdGlvbiBhbGlnblVwKHgsbXVsdGlwbGUpe2lmKHglbXVsdGlwbGU+MCl7eCs9bXVsdGlwbGUteCVtdWx0aXBsZX1yZXR1cm4geH12YXIgYnVmZmVyLEhFQVA4LEhFQVBVOCxIRUFQMTYsSEVBUFUxNixIRUFQMzIsSEVBUFUzMixIRUFQRjMyLEhFQVBGNjQ7ZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmKXtidWZmZXI9YnVmO01vZHVsZVtcIkhFQVA4XCJdPUhFQVA4PW5ldyBJbnQ4QXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQMTZcIl09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUDMyXCJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShidWYpO01vZHVsZVtcIkhFQVBVOFwiXT1IRUFQVTg9bmV3IFVpbnQ4QXJyYXkoYnVmKTtNb2R1bGVbXCJIRUFQVTE2XCJdPUhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUFUzMlwiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShidWYpO01vZHVsZVtcIkhFQVBGMzJcIl09SEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGJ1Zik7TW9kdWxlW1wiSEVBUEY2NFwiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYnVmKX12YXIgSU5JVElBTF9NRU1PUlk9TW9kdWxlW1wiSU5JVElBTF9NRU1PUllcIl18fDE2Nzc3MjE2O3ZhciB3YXNtVGFibGU7dmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVEVYSVRfXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTt2YXIgcnVudGltZUluaXRpYWxpemVkPWZhbHNlO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVtcInByZVJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInByZVJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInByZVJ1blwiXT1bTW9kdWxlW1wicHJlUnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwcmVSdW5cIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbXCJwcmVSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyl9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtydW50aW1lSW5pdGlhbGl6ZWQ9dHJ1ZTtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKX1mdW5jdGlvbiBwb3N0UnVuKCl7aWYoTW9kdWxlW1wicG9zdFJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInBvc3RSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwb3N0UnVuXCJdPVtNb2R1bGVbXCJwb3N0UnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwb3N0UnVuXCJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVtcInBvc3RSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pfWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Jbml0KGNiKXtfX0FUSU5JVF9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKX12YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGw7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcysrO2lmKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pe01vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKX19ZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzLS07aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfWlmKHJ1bkRlcGVuZGVuY2llcz09MCl7aWYocnVuRGVwZW5kZW5jeVdhdGNoZXIhPT1udWxsKXtjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtydW5EZXBlbmRlbmN5V2F0Y2hlcj1udWxsfWlmKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCl7dmFyIGNhbGxiYWNrPWRlcGVuZGVuY2llc0Z1bGZpbGxlZDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtjYWxsYmFjaygpfX19TW9kdWxlW1wicHJlbG9hZGVkSW1hZ2VzXCJdPXt9O01vZHVsZVtcInByZWxvYWRlZEF1ZGlvc1wiXT17fTtmdW5jdGlvbiBhYm9ydCh3aGF0KXtpZihNb2R1bGVbXCJvbkFib3J0XCJdKXtNb2R1bGVbXCJvbkFib3J0XCJdKHdoYXQpfXdoYXQrPVwiXCI7ZXJyKHdoYXQpO0FCT1JUPXRydWU7RVhJVFNUQVRVUz0xO3doYXQ9XCJhYm9ydChcIit3aGF0K1wiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby5cIjt2YXIgZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO3JlYWR5UHJvbWlzZVJlamVjdChlKTt0aHJvdyBlfXZhciBkYXRhVVJJUHJlZml4PVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSl7cmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCl9ZnVuY3Rpb24gaXNGaWxlVVJJKGZpbGVuYW1lKXtyZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil9dmFyIHdhc21CaW5hcnlGaWxlPVwib3J0LXdhc20ud2FzbVwiO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKX1mdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSl7dHJ5e2lmKGZpbGU9PXdhc21CaW5hcnlGaWxlJiZ3YXNtQmluYXJ5KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSl9aWYocmVhZEJpbmFyeSl7cmV0dXJuIHJlYWRCaW5hcnkoZmlsZSl9ZWxzZXt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn19Y2F0Y2goZXJyKXthYm9ydChlcnIpfX1mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCl7aWYoIXdhc21CaW5hcnkmJihFTlZJUk9OTUVOVF9JU19XRUJ8fEVOVklST05NRU5UX0lTX1dPUktFUikpe2lmKHR5cGVvZiBmZXRjaD09PVwiZnVuY3Rpb25cIiYmIWlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkpe3JldHVybiBmZXRjaCh3YXNtQmluYXJ5RmlsZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7aWYoIXJlc3BvbnNlW1wib2tcIl0pe3Rocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIit3YXNtQmluYXJ5RmlsZStcIidcIn1yZXR1cm4gcmVzcG9uc2VbXCJhcnJheUJ1ZmZlclwiXSgpfSkuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKX0pfWVsc2V7aWYocmVhZEFzeW5jKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3Qpe3JlYWRBc3luYyh3YXNtQmluYXJ5RmlsZSxmdW5jdGlvbihyZXNwb25zZSl7cmVzb2x2ZShuZXcgVWludDhBcnJheShyZXNwb25zZSkpfSxyZWplY3QpfSl9fX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBnZXRCaW5hcnkod2FzbUJpbmFyeUZpbGUpfSl9ZnVuY3Rpb24gY3JlYXRlV2FzbSgpe3ZhciBpbmZvPXtcImFcIjphc21MaWJyYXJ5QXJnfTtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsbW9kdWxlKXt2YXIgZXhwb3J0cz1pbnN0YW5jZS5leHBvcnRzO01vZHVsZVtcImFzbVwiXT1leHBvcnRzO3dhc21NZW1vcnk9TW9kdWxlW1wiYXNtXCJdW1wieGFcIl07dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpO3dhc21UYWJsZT1Nb2R1bGVbXCJhc21cIl1bXCJiYlwiXTthZGRPbkluaXQoTW9kdWxlW1wiYXNtXCJdW1wieWFcIl0pO3JlbW92ZVJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpfWFkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCl7cmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdKX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKXtyZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24oYmluYXJ5KXt2YXIgcmVzdWx0PVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbmZvKTtyZXR1cm4gcmVzdWx0fSkudGhlbihyZWNlaXZlcixmdW5jdGlvbihyZWFzb24pe2VycihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3JlYXNvbik7YWJvcnQocmVhc29uKX0pfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKXtpZighd2FzbUJpbmFyeSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT09XCJmdW5jdGlvblwiJiYhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSYmIWlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkmJnR5cGVvZiBmZXRjaD09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXt2YXIgcmVzdWx0PVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLGluZm8pO3JldHVybiByZXN1bHQudGhlbihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCxmdW5jdGlvbihyZWFzb24pe2VycihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIityZWFzb24pO2VycihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KX0pfSl9ZWxzZXtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCl9fWlmKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSl7dHJ5e3ZhciBleHBvcnRzPU1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLHJlY2VpdmVJbnN0YW5jZSk7cmV0dXJuIGV4cG9ydHN9Y2F0Y2goZSl7ZXJyKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSk7cmV0dXJuIGZhbHNlfX1pbnN0YW50aWF0ZUFzeW5jKCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm57fX1mdW5jdGlvbiBjYWxsUnVudGltZUNhbGxiYWNrcyhjYWxsYmFja3Mpe3doaWxlKGNhbGxiYWNrcy5sZW5ndGg+MCl7dmFyIGNhbGxiYWNrPWNhbGxiYWNrcy5zaGlmdCgpO2lmKHR5cGVvZiBjYWxsYmFjaz09XCJmdW5jdGlvblwiKXtjYWxsYmFjayhNb2R1bGUpO2NvbnRpbnVlfXZhciBmdW5jPWNhbGxiYWNrLmZ1bmM7aWYodHlwZW9mIGZ1bmM9PT1cIm51bWJlclwiKXtpZihjYWxsYmFjay5hcmc9PT11bmRlZmluZWQpe3dhc21UYWJsZS5nZXQoZnVuYykoKX1lbHNle3dhc21UYWJsZS5nZXQoZnVuYykoY2FsbGJhY2suYXJnKX19ZWxzZXtmdW5jKGNhbGxiYWNrLmFyZz09PXVuZGVmaW5lZD9udWxsOmNhbGxiYWNrLmFyZyl9fX12YXIgRXhjZXB0aW9uSW5mb0F0dHJzPXtERVNUUlVDVE9SX09GRlNFVDowLFJFRkNPVU5UX09GRlNFVDo0LFRZUEVfT0ZGU0VUOjgsQ0FVR0hUX09GRlNFVDoxMixSRVRIUk9XTl9PRkZTRVQ6MTMsU0laRToxNn07ZnVuY3Rpb24gX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbihzaXplKXtyZXR1cm4gX21hbGxvYyhzaXplK0V4Y2VwdGlvbkluZm9BdHRycy5TSVpFKStFeGNlcHRpb25JbmZvQXR0cnMuU0laRX1mdW5jdGlvbiBfYXRleGl0KGZ1bmMsYXJnKXtfX0FURVhJVF9fLnVuc2hpZnQoe2Z1bmM6ZnVuYyxhcmc6YXJnfSl9ZnVuY3Rpb24gX19fY3hhX2F0ZXhpdChhMCxhMSl7cmV0dXJuIF9hdGV4aXQoYTAsYTEpfWZ1bmN0aW9uIF9fX2N4YV90aHJlYWRfYXRleGl0KGEwLGExKXtyZXR1cm4gX2F0ZXhpdChhMCxhMSl9ZnVuY3Rpb24gRXhjZXB0aW9uSW5mbyhleGNQdHIpe3RoaXMuZXhjUHRyPWV4Y1B0cjt0aGlzLnB0cj1leGNQdHItRXhjZXB0aW9uSW5mb0F0dHJzLlNJWkU7dGhpcy5zZXRfdHlwZT1mdW5jdGlvbih0eXBlKXtIRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlRZUEVfT0ZGU0VUPj4yXT10eXBlfTt0aGlzLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVAzMlt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuVFlQRV9PRkZTRVQ+PjJdfTt0aGlzLnNldF9kZXN0cnVjdG9yPWZ1bmN0aW9uKGRlc3RydWN0b3Ipe0hFQVAzMlt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuREVTVFJVQ1RPUl9PRkZTRVQ+PjJdPWRlc3RydWN0b3J9O3RoaXMuZ2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUDMyW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5ERVNUUlVDVE9SX09GRlNFVD4+Ml19O3RoaXMuc2V0X3JlZmNvdW50PWZ1bmN0aW9uKHJlZmNvdW50KXtIRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+Ml09cmVmY291bnR9O3RoaXMuc2V0X2NhdWdodD1mdW5jdGlvbihjYXVnaHQpe2NhdWdodD1jYXVnaHQ/MTowO0hFQVA4W3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5DQVVHSFRfT0ZGU0VUPj4wXT1jYXVnaHR9O3RoaXMuZ2V0X2NhdWdodD1mdW5jdGlvbigpe3JldHVybiBIRUFQOFt0aGlzLnB0citFeGNlcHRpb25JbmZvQXR0cnMuQ0FVR0hUX09GRlNFVD4+MF0hPTB9O3RoaXMuc2V0X3JldGhyb3duPWZ1bmN0aW9uKHJldGhyb3duKXtyZXRocm93bj1yZXRocm93bj8xOjA7SEVBUDhbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFVEhST1dOX09GRlNFVD4+MF09cmV0aHJvd259O3RoaXMuZ2V0X3JldGhyb3duPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5SRVRIUk9XTl9PRkZTRVQ+PjBdIT0wfTt0aGlzLmluaXQ9ZnVuY3Rpb24odHlwZSxkZXN0cnVjdG9yKXt0aGlzLnNldF90eXBlKHR5cGUpO3RoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcik7dGhpcy5zZXRfcmVmY291bnQoMCk7dGhpcy5zZXRfY2F1Z2h0KGZhbHNlKTt0aGlzLnNldF9yZXRocm93bihmYWxzZSl9O3RoaXMuYWRkX3JlZj1mdW5jdGlvbigpe3ZhciB2YWx1ZT1IRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+Ml07SEVBUDMyW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5SRUZDT1VOVF9PRkZTRVQ+PjJdPXZhbHVlKzF9O3RoaXMucmVsZWFzZV9yZWY9ZnVuY3Rpb24oKXt2YXIgcHJldj1IRUFQMzJbdGhpcy5wdHIrRXhjZXB0aW9uSW5mb0F0dHJzLlJFRkNPVU5UX09GRlNFVD4+Ml07SEVBUDMyW3RoaXMucHRyK0V4Y2VwdGlvbkluZm9BdHRycy5SRUZDT1VOVF9PRkZTRVQ+PjJdPXByZXYtMTtyZXR1cm4gcHJldj09PTF9fXZhciBleGNlcHRpb25MYXN0PTA7dmFyIHVuY2F1Z2h0RXhjZXB0aW9uQ291bnQ9MDtmdW5jdGlvbiBfX19jeGFfdGhyb3cocHRyLHR5cGUsZGVzdHJ1Y3Rvcil7dmFyIGluZm89bmV3IEV4Y2VwdGlvbkluZm8ocHRyKTtpbmZvLmluaXQodHlwZSxkZXN0cnVjdG9yKTtleGNlcHRpb25MYXN0PXB0cjt1bmNhdWdodEV4Y2VwdGlvbkNvdW50Kys7dGhyb3cgcHRyfXZhciBTWVNDQUxMUz17bWFwcGluZ3M6e30sYnVmZmVyczpbbnVsbCxbXSxbXV0scHJpbnRDaGFyOmZ1bmN0aW9uKHN0cmVhbSxjdXJyKXt2YXIgYnVmZmVyPVNZU0NBTExTLmJ1ZmZlcnNbc3RyZWFtXTtpZihjdXJyPT09MHx8Y3Vycj09PTEwKXsoc3RyZWFtPT09MT9vdXQ6ZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsMCkpO2J1ZmZlci5sZW5ndGg9MH1lbHNle2J1ZmZlci5wdXNoKGN1cnIpfX0sdmFyYXJnczp1bmRlZmluZWQsZ2V0OmZ1bmN0aW9uKCl7U1lTQ0FMTFMudmFyYXJncys9NDt2YXIgcmV0PUhFQVAzMltTWVNDQUxMUy52YXJhcmdzLTQ+PjJdO3JldHVybiByZXR9LGdldFN0cjpmdW5jdGlvbihwdHIpe3ZhciByZXQ9VVRGOFRvU3RyaW5nKHB0cik7cmV0dXJuIHJldH0sZ2V0NjQ6ZnVuY3Rpb24obG93LGhpZ2gpe3JldHVybiBsb3d9fTtmdW5jdGlvbiBfX19zeXNfYWNjZXNzKHBhdGgsYW1vZGUpe3BhdGg9U1lTQ0FMTFMuZ2V0U3RyKHBhdGgpO3JldHVybiBTWVNDQUxMUy5kb0FjY2VzcyhwYXRoLGFtb2RlKX1mdW5jdGlvbiBzZXRFcnJObyh2YWx1ZSl7SEVBUDMyW19fX2Vycm5vX2xvY2F0aW9uKCk+PjJdPXZhbHVlO3JldHVybiB2YWx1ZX1mdW5jdGlvbiBfX19zeXNfZmNudGw2NChmZCxjbWQsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3JldHVybiAwfWZ1bmN0aW9uIF9fX3N5c19mc3RhdDY0KGZkLGJ1Zil7fWZ1bmN0aW9uIF9fX3N5c19nZXRkZW50czY0KGZkLGRpcnAsY291bnQpe31mdW5jdGlvbiBfX19zeXNfZ2V0cGlkKCl7cmV0dXJuIDQyfWZ1bmN0aW9uIF9fX3N5c19pb2N0bChmZCxvcCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7cmV0dXJuIDB9ZnVuY3Rpb24gX19fc3lzX2xzdGF0NjQocGF0aCxidWYpe31mdW5jdGlvbiBfX19zeXNfbWtkaXIocGF0aCxtb2RlKXtwYXRoPVNZU0NBTExTLmdldFN0cihwYXRoKTtyZXR1cm4gU1lTQ0FMTFMuZG9Na2RpcihwYXRoLG1vZGUpfWZ1bmN0aW9uIHN5c2NhbGxNbWFwMihhZGRyLGxlbixwcm90LGZsYWdzLGZkLG9mZil7b2ZmPDw9MTI7dmFyIHB0cjt2YXIgYWxsb2NhdGVkPWZhbHNlO2lmKChmbGFncyYxNikhPT0wJiZhZGRyJTY1NTM2IT09MCl7cmV0dXJuLTI4fWlmKChmbGFncyYzMikhPT0wKXtwdHI9X21lbWFsaWduKDY1NTM2LGxlbik7aWYoIXB0cilyZXR1cm4tNDg7X21lbXNldChwdHIsMCxsZW4pO2FsbG9jYXRlZD10cnVlfWVsc2V7cmV0dXJuLTUyfVNZU0NBTExTLm1hcHBpbmdzW3B0cl09e21hbGxvYzpwdHIsbGVuOmxlbixhbGxvY2F0ZWQ6YWxsb2NhdGVkLGZkOmZkLHByb3Q6cHJvdCxmbGFnczpmbGFncyxvZmZzZXQ6b2ZmfTtyZXR1cm4gcHRyfWZ1bmN0aW9uIF9fX3N5c19tbWFwMihhZGRyLGxlbixwcm90LGZsYWdzLGZkLG9mZil7cmV0dXJuIHN5c2NhbGxNbWFwMihhZGRyLGxlbixwcm90LGZsYWdzLGZkLG9mZil9ZnVuY3Rpb24gc3lzY2FsbE11bm1hcChhZGRyLGxlbil7aWYoKGFkZHJ8MCk9PT0tMXx8bGVuPT09MCl7cmV0dXJuLTI4fXZhciBpbmZvPVNZU0NBTExTLm1hcHBpbmdzW2FkZHJdO2lmKCFpbmZvKXJldHVybiAwO2lmKGxlbj09PWluZm8ubGVuKXtTWVNDQUxMUy5tYXBwaW5nc1thZGRyXT1udWxsO2lmKGluZm8uYWxsb2NhdGVkKXtfZnJlZShpbmZvLm1hbGxvYyl9fXJldHVybiAwfWZ1bmN0aW9uIF9fX3N5c19tdW5tYXAoYWRkcixsZW4pe3JldHVybiBzeXNjYWxsTXVubWFwKGFkZHIsbGVuKX1mdW5jdGlvbiBfX19zeXNfb3BlbihwYXRoLGZsYWdzLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnc31mdW5jdGlvbiBfX19zeXNfcmVhZGxpbmsocGF0aCxidWYsYnVmc2l6ZSl7cGF0aD1TWVNDQUxMUy5nZXRTdHIocGF0aCk7cmV0dXJuIFNZU0NBTExTLmRvUmVhZGxpbmsocGF0aCxidWYsYnVmc2l6ZSl9ZnVuY3Rpb24gX19fc3lzX3JtZGlyKHBhdGgpe31mdW5jdGlvbiBfX19zeXNfc3RhdDY0KHBhdGgsYnVmKXt9ZnVuY3Rpb24gX19fc3lzX3VubGluayhwYXRoKXt9ZnVuY3Rpb24gX2Fib3J0KCl7YWJvcnQoKX12YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtfZW1zY3JpcHRlbl9nZXRfbm93PWZ1bmN0aW9uKCl7dmFyIHQ9cHJvY2Vzc1tcImhydGltZVwiXSgpO3JldHVybiB0WzBdKjFlMyt0WzFdLzFlNn19ZWxzZSBpZih0eXBlb2YgZGF0ZU5vdyE9PVwidW5kZWZpbmVkXCIpe19lbXNjcmlwdGVuX2dldF9ub3c9ZGF0ZU5vd31lbHNlIF9lbXNjcmlwdGVuX2dldF9ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9O3ZhciBfZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYz10cnVlO2Z1bmN0aW9uIF9jbG9ja19nZXR0aW1lKGNsa19pZCx0cCl7dmFyIG5vdztpZihjbGtfaWQ9PT0wKXtub3c9RGF0ZS5ub3coKX1lbHNlIGlmKChjbGtfaWQ9PT0xfHxjbGtfaWQ9PT00KSYmX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMpe25vdz1fZW1zY3JpcHRlbl9nZXRfbm93KCl9ZWxzZXtzZXRFcnJObygyOCk7cmV0dXJuLTF9SEVBUDMyW3RwPj4yXT1ub3cvMWUzfDA7SEVBUDMyW3RwKzQ+PjJdPW5vdyUxZTMqMWUzKjFlM3wwO3JldHVybiAwfWZ1bmN0aW9uIF9kaWZmdGltZSh0aW1lMSx0aW1lMCl7cmV0dXJuIHRpbWUxLXRpbWUwfWZ1bmN0aW9uIF9kbGNsb3NlKGhhbmRsZSl7YWJvcnQoXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCB0byB1c2UgRW1zY3JpcHRlbidzIGxpbmtpbmcgc3VwcG9ydCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi93aWtpL0xpbmtpbmdcIil9ZnVuY3Rpb24gX2RsZXJyb3IoKXthYm9ydChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIHRvIHVzZSBFbXNjcmlwdGVuJ3MgbGlua2luZyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX1mdW5jdGlvbiBfZGxvcGVuKGZpbGVuYW1lLGZsYWcpe2Fib3J0KFwiVG8gdXNlIGRsb3BlbiwgeW91IG5lZWQgdG8gdXNlIEVtc2NyaXB0ZW4ncyBsaW5raW5nIHN1cHBvcnQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZW1zY3JpcHRlbi1jb3JlL2Vtc2NyaXB0ZW4vd2lraS9MaW5raW5nXCIpfWZ1bmN0aW9uIF9kbHN5bShoYW5kbGUsc3ltYm9sKXthYm9ydChcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIHRvIHVzZSBFbXNjcmlwdGVuJ3MgbGlua2luZyBzdXBwb3J0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL3dpa2kvTGlua2luZ1wiKX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgoKXtyZXR1cm4gMjE0NzQ4MzY0OH1mdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3Qsc3JjLG51bSl7SEVBUFU4LmNvcHlXaXRoaW4oZGVzdCxzcmMsc3JjK251bSl9ZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKXt0cnl7d2FzbU1lbW9yeS5ncm93KHNpemUtYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNik7dXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3Mod2FzbU1lbW9yeS5idWZmZXIpO3JldHVybiAxfWNhdGNoKGUpe319ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSl7dmFyIG9sZFNpemU9SEVBUFU4Lmxlbmd0aDtyZXF1ZXN0ZWRTaXplPXJlcXVlc3RlZFNpemU+Pj4wO3ZhciBtYXhIZWFwU2l6ZT0yMTQ3NDgzNjQ4O2lmKHJlcXVlc3RlZFNpemU+bWF4SGVhcFNpemUpe3JldHVybiBmYWxzZX1mb3IodmFyIGN1dERvd249MTtjdXREb3duPD00O2N1dERvd24qPTIpe3ZhciBvdmVyR3Jvd25IZWFwU2l6ZT1vbGRTaXplKigxKy4yL2N1dERvd24pO292ZXJHcm93bkhlYXBTaXplPU1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLHJlcXVlc3RlZFNpemUrMTAwNjYzMjk2KTt2YXIgbmV3U2l6ZT1NYXRoLm1pbihtYXhIZWFwU2l6ZSxhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsb3Zlckdyb3duSGVhcFNpemUpLDY1NTM2KSk7dmFyIHJlcGxhY2VtZW50PWVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIobmV3U2l6ZSk7aWYocmVwbGFjZW1lbnQpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fdGhyZWFkX3NsZWVwKG1zZWNzKXt2YXIgc3RhcnQ9X2Vtc2NyaXB0ZW5fZ2V0X25vdygpO3doaWxlKF9lbXNjcmlwdGVuX2dldF9ub3coKS1zdGFydDxtc2Vjcyl7fX12YXIgV2ViTk49e2luaXRNYW5hZ2VyczpmdW5jdGlvbigpe2lmKHRoaXNbXCJtZ3JDb250ZXh0XCJdKXJldHVybjtmdW5jdGlvbiBtYWtlTWFuYWdlcigpe3JldHVybntvYmplY3RzOnt9LG5leHRJZDoxLGNyZWF0ZTpmdW5jdGlvbihvYmplY3Qsd3JhcHBlcil7d3JhcHBlcj13cmFwcGVyfHx7fTt2YXIgaWQ9dGhpcy5uZXh0SWQrKzt3cmFwcGVyLnJlZmNvdW50PTE7d3JhcHBlci5vYmplY3Q9b2JqZWN0O3RoaXMub2JqZWN0c1tpZF09d3JhcHBlcjtyZXR1cm4gaWR9LGdldDpmdW5jdGlvbihpZCl7aWYoaWQ9PT0wKXJldHVybiB1bmRlZmluZWQ7dmFyIG89dGhpcy5vYmplY3RzW2lkXTtyZXR1cm4gby5vYmplY3R9LHJlZmVyZW5jZTpmdW5jdGlvbihpZCl7dmFyIG89dGhpcy5vYmplY3RzW2lkXTtvLnJlZmNvdW50Kyt9LHJlbGVhc2U6ZnVuY3Rpb24oaWQpe3ZhciBvPXRoaXMub2JqZWN0c1tpZF07by5yZWZjb3VudC0tO2lmKG8ucmVmY291bnQ8PTApe2RlbGV0ZSB0aGlzLm9iamVjdHNbaWRdfX19fXRoaXNbXCJtZ3JDb250ZXh0XCJdPXRoaXNbXCJtZ3JDb250ZXh0XCJdfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyR3JhcGg9dGhpcy5tZ3JHcmFwaHx8bWFrZU1hbmFnZXIoKTt0aGlzLm1nckdyYXBoQnVpbGRlcj10aGlzLm1nckdyYXBoQnVpbGRlcnx8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkSW5wdXRzPXRoaXMubWdyTmFtZWRJbnB1dHN8fG1ha2VNYW5hZ2VyKCk7dGhpcy5tZ3JOYW1lZE9wZXJhbmRzPXRoaXMubWdyTmFtZWRPcGVyYW5kc3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkT3V0cHV0cz10aGlzLm1nck5hbWVkT3V0cHV0c3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck5hbWVkUmVzdWx0cz10aGlzLm1nck5hbWVkUmVzdWx0c3x8bWFrZU1hbmFnZXIoKTt0aGlzLm1nck9wZXJhbmQ9dGhpcy5tZ3JPcGVyYW5kfHxtYWtlTWFuYWdlcigpO3RoaXMubWdyUmVzdWx0PXRoaXMubWdyUmVzdWx0fHxtYWtlTWFuYWdlcigpfSxBdXRvUGFkOltcImV4cGxpY2l0XCIsXCJzYW1lLXVwcGVyXCIsXCJzYW1lLWxvd2VyXCJdLEJ1aWxkR3JhcGhTdGF0dXM6W1wic3VjY2Vzc1wiLFwiZXJyb3JcIixcImNvbnRleHQtbG9zdFwiLFwidW5rbm93blwiXSxDb21wdXRlR3JhcGhTdGF0dXM6W1wic3VjY2Vzc1wiLFwiZXJyb3JcIixcImNvbnRleHQtbG9zdFwiLFwidW5rbm93blwiXSxFcnJvckZpbHRlcjpbXCJub25lXCIsXCJ2YWxpZGF0aW9uXCIsXCJvdXQtb2YtbWVtb3J5XCJdLEVycm9yVHlwZTpbXCJuby1lcnJvclwiLFwidmFsaWRhdGlvblwiLFwib3V0LW9mLW1lbW9yeVwiLFwidW5rbm93blwiLFwiZGV2aWNlLWxvc3RcIl0sRmlsdGVyT3BlcmFuZExheW91dDpbXCJvaWh3XCIsXCJod2lvXCIsXCJvaHdpXCIsXCJpaHdvXCJdLEZ1c2VkQWN0aXZhdGlvbjpbXCJub25lXCIsXCJyZWx1XCJdLElucHV0T3BlcmFuZExheW91dDpbXCJuY2h3XCIsXCJuaHdjXCJdLE9wZXJhbmRUeXBlOltcImZsb2F0MzJcIixcImZsb2F0MTZcIixcImludDMyXCIsXCJ1aW50MzJcIixcImludDhcIixcInVpbnQ4XCJdLFBvd2VyUHJlZmVyZW5jZTpbXCJkZWZhdWx0XCIsXCJoaWdoX3BlcmZvcm1hbmNlXCIsXCJsb3dfcG93ZXJcIl0sbWFrZUkzMkFycmF5OmZ1bmN0aW9uKGNvdW50LGFycmF5UHRyKXtpZihjb3VudD09PTB8fGFycmF5UHRyPT09MCl7cmV0dXJuIHVuZGVmaW5lZH12YXIgYXJyYXk9W107Zm9yKHZhciBpPTA7aTxjb3VudDsrK2ksYXJyYXlQdHIrPTQpe2FycmF5LnB1c2goSEVBUDMyW2FycmF5UHRyPj4yXSl9cmV0dXJuIGFycmF5fSxtYWtlQXJyYXlCdWZmZXJWaWV3OmZ1bmN0aW9uKG9mZnNldCxieXRlU2l6ZSx0eXBlPVwiZmxvYXQzMlwiKXthc3NlcnQodHlwZT09PVwiZmxvYXQzMlwiKTtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShIRUFQVTguYnVmZmVyLG9mZnNldCxieXRlU2l6ZS9GbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpfSxtYWtlQ2xhbXBPcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wibWluVmFsdWVcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEhFQVAzMltwdHI+PjJdKSxcIm1heFZhbHVlXCI6dGhpcy5tZ3JPcGVyYW5kLmdldChIRUFQMzJbcHRyKzQ+PjJdKX19LG1ha2VCYXRjaE5vcm1PcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wic2NhbGVcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEhFQVAzMltwdHI+PjJdKSxcImJpYXNcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEhFQVAzMltwdHIrND4+Ml0pLFwiYXhpc1wiOkhFQVAzMltwdHIrOD4+Ml0sXCJlcHNpbG9uXCI6SEVBUEYzMltwdHIrMTI+PjJdLFwiYWN0aXZhdGlvblwiOnRoaXMuRnVzZWRBY3RpdmF0aW9uW0hFQVAzMltwdHIrMTY+PjJdXX19LG1ha2VHZW1tT3B0aW9uczpmdW5jdGlvbihwdHIpe3JldHVybntcImNcIjp0aGlzLm1nck9wZXJhbmQuZ2V0KEhFQVAzMltwdHI+PjJdKSxcImFscGhhXCI6SEVBUEYzMltwdHIrND4+Ml0sXCJiZXRhXCI6SEVBUEYzMltwdHIrOD4+Ml0sXCJhVHJhbnNwb3NlXCI6SEVBUDhbcHRyKzEyPj4wXSE9PTAsXCJiVHJhbnNwb3NlXCI6SEVBUDhbcHRyKzEzPj4wXSE9PTB9fSxtYWtlT3BlcmFuZERlc2NyaXB0b3I6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJ0eXBlXCI6dGhpcy5PcGVyYW5kVHlwZVtIRUFQVTMyW3B0cj4+Ml1dLFwiZGltZW5zaW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzg+PjJdLEhFQVAzMltwdHIrND4+Ml0pfX0sbWFrZUNvbnYyZE9wdGlvbnM6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJwYWRkaW5nXCI6dGhpcy5BdXRvUGFkW0hFQVAzMltwdHIrMjQ+PjJdXT09PVwiZXhwbGljaXRcIj90aGlzLm1ha2VJMzJBcnJheShIRUFQVTMyW3B0cj4+Ml0sSEVBUDMyW3B0cis0Pj4yXSk6dW5kZWZpbmVkLFwic3RyaWRlc1wiOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzg+PjJdLEhFQVAzMltwdHIrMTI+PjJdKSxcImRpbGF0aW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzE2Pj4yXSxIRUFQMzJbcHRyKzIwPj4yXSksXCJhdXRvUGFkXCI6dGhpcy5BdXRvUGFkW0hFQVAzMltwdHIrMjQ+PjJdXSxcImdyb3Vwc1wiOkhFQVAzMltwdHIrMjg+PjJdLFwiaW5wdXRMYXlvdXRcIjp0aGlzLklucHV0T3BlcmFuZExheW91dFtIRUFQMzJbcHRyKzMyPj4yXV0sXCJmaWx0ZXJMYXlvdXRcIjp0aGlzLkZpbHRlck9wZXJhbmRMYXlvdXRbSEVBUDMyW3B0ciszNj4+Ml1dLFwiYmlhc1wiOnRoaXMubWdyT3BlcmFuZC5nZXQoSEVBUDMyW3B0cis0MD4+Ml0pLFwiYWN0aXZhdGlvblwiOnRoaXMuRnVzZWRBY3RpdmF0aW9uW0hFQVAzMltwdHIrNDQ+PjJdXX19LG1ha2VQb29sMmRPcHRpb25zOmZ1bmN0aW9uKHB0cil7cmV0dXJue1wid2luZG93RGltZW5zaW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyPj4yXSxIRUFQMzJbcHRyKzQ+PjJdKSxcInBhZGRpbmdcIjp0aGlzLkF1dG9QYWRbSEVBUDMyW3B0ciszMj4+Ml1dPT09XCJleHBsaWNpdFwiP3RoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzg+PjJdLEhFQVAzMltwdHIrMTI+PjJdKTp1bmRlZmluZWQsXCJzdHJpZGVzXCI6dGhpcy5tYWtlSTMyQXJyYXkoSEVBUFUzMltwdHIrMTY+PjJdLEhFQVAzMltwdHIrMjA+PjJdKSxcImRpbGF0aW9uc1wiOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzI0Pj4yXSxIRUFQMzJbcHRyKzI4Pj4yXSksXCJhdXRvUGFkXCI6dGhpcy5BdXRvUGFkW0hFQVAzMltwdHIrMzI+PjJdXSxcImlucHV0TGF5b3V0XCI6dGhpcy5JbnB1dE9wZXJhbmRMYXlvdXRbSEVBUDMyW3B0ciszNj4+Ml1dfX0sbWFrZUlucHV0OmZ1bmN0aW9uKHB0cil7cmV0dXJue1wiZGF0YVwiOnRoaXMubWFrZUFycmF5QnVmZmVyVmlldyhIRUFQMzJbcHRyPj4yXSxIRUFQVTMyW3B0cis0Pj4yXSksXCJkaW1lbnNpb25zXCI6SEVBUDMyW3B0cis4Pj4yXT09PTA/dW5kZWZpbmVkOnRoaXMubWFrZUkzMkFycmF5KEhFQVBVMzJbcHRyKzEyPj4yXSxIRUFQMzJbcHRyKzg+PjJdKX19LG1ha2VPdXRwdXQ6ZnVuY3Rpb24ocHRyKXtyZXR1cm57XCJkYXRhXCI6SEVBUDMyW3B0cj4+Ml09PT0wP3VuZGVmaW5lZDp0aGlzLm1ha2VBcnJheUJ1ZmZlclZpZXcoSEVBUDMyW3B0cj4+Ml0sSEVBUFUzMltwdHIrND4+Ml0pLFwiZGltZW5zaW9uc1wiOkhFQVAzMltwdHIrOD4+Ml09PT0wP3VuZGVmaW5lZDp0aGlzLm1ha2VJMzJBcnJheShIRUFQVTMyW3B0cisxMj4+Ml0sSEVBUDMyW3B0cis4Pj4yXSl9fX07ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fd2Vibm5fY3JlYXRlX2NvbnRleHQoKXt2YXIgY29udGV4dD1uYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCgpO3JldHVybiBXZWJOTi5tZ3JDb250ZXh0LmNyZWF0ZShjb250ZXh0KX12YXIgRU5WPXt9O2Z1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCl7cmV0dXJuIHRoaXNQcm9ncmFtfHxcIi4vdGhpcy5wcm9ncmFtXCJ9ZnVuY3Rpb24gZ2V0RW52U3RyaW5ncygpe2lmKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3Mpe3ZhciBsYW5nPSh0eXBlb2YgbmF2aWdhdG9yPT09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCI7dmFyIGVudj17XCJVU0VSXCI6XCJ3ZWJfdXNlclwiLFwiTE9HTkFNRVwiOlwid2ViX3VzZXJcIixcIlBBVEhcIjpcIi9cIixcIlBXRFwiOlwiL1wiLFwiSE9NRVwiOlwiL2hvbWUvd2ViX3VzZXJcIixcIkxBTkdcIjpsYW5nLFwiX1wiOmdldEV4ZWN1dGFibGVOYW1lKCl9O2Zvcih2YXIgeCBpbiBFTlYpe2Vudlt4XT1FTlZbeF19dmFyIHN0cmluZ3M9W107Zm9yKHZhciB4IGluIGVudil7c3RyaW5ncy5wdXNoKHgrXCI9XCIrZW52W3hdKX1nZXRFbnZTdHJpbmdzLnN0cmluZ3M9c3RyaW5nc31yZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzfWZ1bmN0aW9uIF9lbnZpcm9uX2dldChfX2Vudmlyb24sZW52aXJvbl9idWYpe3ZhciBidWZTaXplPTA7Z2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLGkpe3ZhciBwdHI9ZW52aXJvbl9idWYrYnVmU2l6ZTtIRUFQMzJbX19lbnZpcm9uK2kqND4+Ml09cHRyO3dyaXRlQXNjaWlUb01lbW9yeShzdHJpbmcscHRyKTtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtyZXR1cm4gMH1mdW5jdGlvbiBfZW52aXJvbl9zaXplc19nZXQocGVudmlyb25fY291bnQscGVudmlyb25fYnVmX3NpemUpe3ZhciBzdHJpbmdzPWdldEVudlN0cmluZ3MoKTtIRUFQMzJbcGVudmlyb25fY291bnQ+PjJdPXN0cmluZ3MubGVuZ3RoO3ZhciBidWZTaXplPTA7c3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZyl7YnVmU2l6ZSs9c3RyaW5nLmxlbmd0aCsxfSk7SEVBUDMyW3BlbnZpcm9uX2J1Zl9zaXplPj4yXT1idWZTaXplO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9jbG9zZShmZCl7cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQscGJ1Zil7dmFyIHR5cGU9ZmQ9PTF8fGZkPT0yPzI6YWJvcnQoKTtIRUFQOFtwYnVmPj4wXT10eXBlO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9yZWFkKGZkLGlvdixpb3ZjbnQscG51bSl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO3ZhciBudW09U1lTQ0FMTFMuZG9SZWFkdihzdHJlYW0saW92LGlvdmNudCk7SEVBUDMyW3BudW0+PjJdPW51bTtyZXR1cm4gMH1mdW5jdGlvbiBfZmRfc2VlayhmZCxvZmZzZXRfbG93LG9mZnNldF9oaWdoLHdoZW5jZSxuZXdPZmZzZXQpe31mdW5jdGlvbiBfZmRfd3JpdGUoZmQsaW92LGlvdmNudCxwbnVtKXt2YXIgbnVtPTA7Zm9yKHZhciBpPTA7aTxpb3ZjbnQ7aSsrKXt2YXIgcHRyPUhFQVAzMltpb3YraSo4Pj4yXTt2YXIgbGVuPUhFQVAzMltpb3YrKGkqOCs0KT4+Ml07Zm9yKHZhciBqPTA7ajxsZW47aisrKXtTWVNDQUxMUy5wcmludENoYXIoZmQsSEVBUFU4W3B0citqXSl9bnVtKz1sZW59SEVBUDMyW3BudW0+PjJdPW51bTtyZXR1cm4gMH1mdW5jdGlvbiBfZ2V0dGltZW9mZGF5KHB0cil7dmFyIG5vdz1EYXRlLm5vdygpO0hFQVAzMltwdHI+PjJdPW5vdy8xZTN8MDtIRUFQMzJbcHRyKzQ+PjJdPW5vdyUxZTMqMWUzfDA7cmV0dXJuIDB9ZnVuY3Rpb24gX2dtdGltZV9yKHRpbWUsdG1QdHIpe3ZhciBkYXRlPW5ldyBEYXRlKEhFQVAzMlt0aW1lPj4yXSoxZTMpO0hFQVAzMlt0bVB0cj4+Ml09ZGF0ZS5nZXRVVENTZWNvbmRzKCk7SEVBUDMyW3RtUHRyKzQ+PjJdPWRhdGUuZ2V0VVRDTWludXRlcygpO0hFQVAzMlt0bVB0cis4Pj4yXT1kYXRlLmdldFVUQ0hvdXJzKCk7SEVBUDMyW3RtUHRyKzEyPj4yXT1kYXRlLmdldFVUQ0RhdGUoKTtIRUFQMzJbdG1QdHIrMTY+PjJdPWRhdGUuZ2V0VVRDTW9udGgoKTtIRUFQMzJbdG1QdHIrMjA+PjJdPWRhdGUuZ2V0VVRDRnVsbFllYXIoKS0xOTAwO0hFQVAzMlt0bVB0cisyND4+Ml09ZGF0ZS5nZXRVVENEYXkoKTtIRUFQMzJbdG1QdHIrMzY+PjJdPTA7SEVBUDMyW3RtUHRyKzMyPj4yXT0wO3ZhciBzdGFydD1EYXRlLlVUQyhkYXRlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApO3ZhciB5ZGF5PShkYXRlLmdldFRpbWUoKS1zdGFydCkvKDFlMyo2MCo2MCoyNCl8MDtIRUFQMzJbdG1QdHIrMjg+PjJdPXlkYXk7aWYoIV9nbXRpbWVfci5HTVRTdHJpbmcpX2dtdGltZV9yLkdNVFN0cmluZz1hbGxvY2F0ZVVURjgoXCJHTVRcIik7SEVBUDMyW3RtUHRyKzQwPj4yXT1fZ210aW1lX3IuR01UU3RyaW5nO3JldHVybiB0bVB0cn1mdW5jdGlvbiBfdHpzZXQoKXtpZihfdHpzZXQuY2FsbGVkKXJldHVybjtfdHpzZXQuY2FsbGVkPXRydWU7dmFyIGN1cnJlbnRZZWFyPShuZXcgRGF0ZSkuZ2V0RnVsbFllYXIoKTt2YXIgd2ludGVyPW5ldyBEYXRlKGN1cnJlbnRZZWFyLDAsMSk7dmFyIHN1bW1lcj1uZXcgRGF0ZShjdXJyZW50WWVhciw2LDEpO3ZhciB3aW50ZXJPZmZzZXQ9d2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHN1bW1lck9mZnNldD1zdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3RkVGltZXpvbmVPZmZzZXQ9TWF0aC5tYXgod2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCk7SEVBUDMyW19fZ2V0X3RpbWV6b25lKCk+PjJdPXN0ZFRpbWV6b25lT2Zmc2V0KjYwO0hFQVAzMltfX2dldF9kYXlsaWdodCgpPj4yXT1OdW1iZXIod2ludGVyT2Zmc2V0IT1zdW1tZXJPZmZzZXQpO2Z1bmN0aW9uIGV4dHJhY3Rab25lKGRhdGUpe3ZhciBtYXRjaD1kYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7cmV0dXJuIG1hdGNoP21hdGNoWzFdOlwiR01UXCJ9dmFyIHdpbnRlck5hbWU9ZXh0cmFjdFpvbmUod2ludGVyKTt2YXIgc3VtbWVyTmFtZT1leHRyYWN0Wm9uZShzdW1tZXIpO3ZhciB3aW50ZXJOYW1lUHRyPWFsbG9jYXRlVVRGOCh3aW50ZXJOYW1lKTt2YXIgc3VtbWVyTmFtZVB0cj1hbGxvY2F0ZVVURjgoc3VtbWVyTmFtZSk7aWYoc3VtbWVyT2Zmc2V0PHdpbnRlck9mZnNldCl7SEVBUDMyW19fZ2V0X3R6bmFtZSgpPj4yXT13aW50ZXJOYW1lUHRyO0hFQVAzMltfX2dldF90em5hbWUoKSs0Pj4yXT1zdW1tZXJOYW1lUHRyfWVsc2V7SEVBUDMyW19fZ2V0X3R6bmFtZSgpPj4yXT1zdW1tZXJOYW1lUHRyO0hFQVAzMltfX2dldF90em5hbWUoKSs0Pj4yXT13aW50ZXJOYW1lUHRyfX1mdW5jdGlvbiBfbG9jYWx0aW1lX3IodGltZSx0bVB0cil7X3R6c2V0KCk7dmFyIGRhdGU9bmV3IERhdGUoSEVBUDMyW3RpbWU+PjJdKjFlMyk7SEVBUDMyW3RtUHRyPj4yXT1kYXRlLmdldFNlY29uZHMoKTtIRUFQMzJbdG1QdHIrND4+Ml09ZGF0ZS5nZXRNaW51dGVzKCk7SEVBUDMyW3RtUHRyKzg+PjJdPWRhdGUuZ2V0SG91cnMoKTtIRUFQMzJbdG1QdHIrMTI+PjJdPWRhdGUuZ2V0RGF0ZSgpO0hFQVAzMlt0bVB0cisxNj4+Ml09ZGF0ZS5nZXRNb250aCgpO0hFQVAzMlt0bVB0cisyMD4+Ml09ZGF0ZS5nZXRGdWxsWWVhcigpLTE5MDA7SEVBUDMyW3RtUHRyKzI0Pj4yXT1kYXRlLmdldERheSgpO3ZhciBzdGFydD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksMCwxKTt2YXIgeWRheT0oZGF0ZS5nZXRUaW1lKCktc3RhcnQuZ2V0VGltZSgpKS8oMWUzKjYwKjYwKjI0KXwwO0hFQVAzMlt0bVB0cisyOD4+Ml09eWRheTtIRUFQMzJbdG1QdHIrMzY+PjJdPS0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKjYwKTt2YXIgc3VtbWVyT2Zmc2V0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHdpbnRlck9mZnNldD1zdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBkc3Q9KHN1bW1lck9mZnNldCE9d2ludGVyT2Zmc2V0JiZkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpKXwwO0hFQVAzMlt0bVB0ciszMj4+Ml09ZHN0O3ZhciB6b25lUHRyPUhFQVAzMltfX2dldF90em5hbWUoKSsoZHN0PzQ6MCk+PjJdO0hFQVAzMlt0bVB0cis0MD4+Ml09em9uZVB0cjtyZXR1cm4gdG1QdHJ9ZnVuY3Rpb24gX21rdGltZSh0bVB0cil7X3R6c2V0KCk7dmFyIGRhdGU9bmV3IERhdGUoSEVBUDMyW3RtUHRyKzIwPj4yXSsxOTAwLEhFQVAzMlt0bVB0cisxNj4+Ml0sSEVBUDMyW3RtUHRyKzEyPj4yXSxIRUFQMzJbdG1QdHIrOD4+Ml0sSEVBUDMyW3RtUHRyKzQ+PjJdLEhFQVAzMlt0bVB0cj4+Ml0sMCk7dmFyIGRzdD1IRUFQMzJbdG1QdHIrMzI+PjJdO3ZhciBndWVzc2VkT2Zmc2V0PWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3RhcnQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDAsMSk7dmFyIHN1bW1lck9mZnNldD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB3aW50ZXJPZmZzZXQ9c3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgZHN0T2Zmc2V0PU1hdGgubWluKHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO2lmKGRzdDwwKXtIRUFQMzJbdG1QdHIrMzI+PjJdPU51bWJlcihzdW1tZXJPZmZzZXQhPXdpbnRlck9mZnNldCYmZHN0T2Zmc2V0PT1ndWVzc2VkT2Zmc2V0KX1lbHNlIGlmKGRzdD4wIT0oZHN0T2Zmc2V0PT1ndWVzc2VkT2Zmc2V0KSl7dmFyIG5vbkRzdE9mZnNldD1NYXRoLm1heCh3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KTt2YXIgdHJ1ZU9mZnNldD1kc3Q+MD9kc3RPZmZzZXQ6bm9uRHN0T2Zmc2V0O2RhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSsodHJ1ZU9mZnNldC1ndWVzc2VkT2Zmc2V0KSo2ZTQpfUhFQVAzMlt0bVB0cisyND4+Ml09ZGF0ZS5nZXREYXkoKTt2YXIgeWRheT0oZGF0ZS5nZXRUaW1lKCktc3RhcnQuZ2V0VGltZSgpKS8oMWUzKjYwKjYwKjI0KXwwO0hFQVAzMlt0bVB0cisyOD4+Ml09eWRheTtIRUFQMzJbdG1QdHI+PjJdPWRhdGUuZ2V0U2Vjb25kcygpO0hFQVAzMlt0bVB0cis0Pj4yXT1kYXRlLmdldE1pbnV0ZXMoKTtIRUFQMzJbdG1QdHIrOD4+Ml09ZGF0ZS5nZXRIb3VycygpO0hFQVAzMlt0bVB0cisxMj4+Ml09ZGF0ZS5nZXREYXRlKCk7SEVBUDMyW3RtUHRyKzE2Pj4yXT1kYXRlLmdldE1vbnRoKCk7cmV0dXJuIGRhdGUuZ2V0VGltZSgpLzFlM3wwfWZ1bmN0aW9uIF9tbENvbnRleHRSZWZlcmVuY2UoaWQpe1dlYk5OLm1nckNvbnRleHQucmVmZXJlbmNlKGlkKX1mdW5jdGlvbiBfbWxDb250ZXh0UmVsZWFzZShpZCl7V2ViTk4ubWdyQ29udGV4dC5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJBZGQoYnVpbGRlcklkLGFJZCxiSWQpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgYT1XZWJOTi5tZ3JPcGVyYW5kLmdldChhSWQpO3ZhciBiPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGJJZCk7dmFyIGM9YnVpbGRlci5hZGQoYSxiKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoYyl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQXZlcmFnZVBvb2wyZChidWlsZGVySWQsaW5wdXRJZCxvcHRpb25zUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBvcHRpb25zPVdlYk5OLm1ha2VQb29sMmRPcHRpb25zKG9wdGlvbnNQdHIpO3ZhciBwb29sMmQ9YnVpbGRlci5hdmVyYWdlUG9vbDJkKGlucHV0LG9wdGlvbnMpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShwb29sMmQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlckJhdGNoTm9ybShidWlsZGVySWQsaW5wdXRJZCxtZWFuSWQsdmFyaWFuY2VJZCxvcHRpb25zUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBtZWFuPVdlYk5OLm1nck9wZXJhbmQuZ2V0KG1lYW5JZCk7dmFyIHZhcmlhbmNlPVdlYk5OLm1nck9wZXJhbmQuZ2V0KHZhcmlhbmNlSWQpO3ZhciBvcHRpb25zPVdlYk5OLm1ha2VCYXRjaE5vcm1PcHRpb25zKG9wdGlvbnNQdHIpO3ZhciBvdXRwdXQ9YnVpbGRlci5iYXRjaE5vcm1hbGl6YXRpb24oaW5wdXQsbWVhbix2YXJpYW5jZSxvcHRpb25zKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUob3V0cHV0KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJCdWlsZFN5bmMoYnVpbGRlcklkLG5hbWVkT3BlcmFuZHNJZCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBuYW1lZE9wZXJhbmRzPVdlYk5OLm1nck5hbWVkT3BlcmFuZHMuZ2V0KG5hbWVkT3BlcmFuZHNJZCk7dHJ5e3ZhciBncmFwaD1idWlsZGVyLmJ1aWxkU3luYyhuYW1lZE9wZXJhbmRzKTtyZXR1cm4gV2ViTk4ubWdyR3JhcGguY3JlYXRlKGdyYXBoKX1jYXRjaChlcnJvcil7Y29uc29sZS5sb2coXCJidWlsZGVyLmJ1aWxkU3luYyBmYWlsZWQ6IFwiK2Vycm9yKTtyZXR1cm4gMH19ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyQ29uY2F0KGJ1aWxkZXJJZCxpbnB1dHNDb3VudCxpbnB1dHNQdHIsYXhpcyl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dElkcz1XZWJOTi5tYWtlSTMyQXJyYXkoaW5wdXRzQ291bnQsaW5wdXRzUHRyKTt2YXIgaW5wdXRzPVtdO2Zvcih2YXIgaT0wO2k8aW5wdXRJZHMubGVuZ3RoOysraSl7aW5wdXRzLnB1c2goV2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZHNbaV0pKX12YXIgb3V0cHV0PWJ1aWxkZXIuY29uY2F0KGlucHV0cyxheGlzKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUob3V0cHV0KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJDb25zdGFudChidWlsZGVySWQsZGVzY1B0cix2YWx1ZVB0cixzaXplKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGRlc2M9V2ViTk4ubWFrZU9wZXJhbmREZXNjcmlwdG9yKGRlc2NQdHIpO3ZhciBidWZmZXI9V2ViTk4ubWFrZUFycmF5QnVmZmVyVmlldyh2YWx1ZVB0cixzaXplKTt2YXIgY29uc3RhbnQ9YnVpbGRlci5jb25zdGFudChkZXNjLGJ1ZmZlcik7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKGNvbnN0YW50KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJDb252MmQoYnVpbGRlcklkLGlucHV0SWQsZmlsdGVySWQsb3B0aW9uc1B0cil7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgZmlsdGVyPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGZpbHRlcklkKTt2YXIgb3B0aW9ucz1XZWJOTi5tYWtlQ29udjJkT3B0aW9ucyhvcHRpb25zUHRyKTt2YXIgY29udjJkPWJ1aWxkZXIuY29udjJkKGlucHV0LGZpbHRlcixvcHRpb25zKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUoY29udjJkKX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJHZW1tKGJ1aWxkZXJJZCxhSWQsYklkLG9wdGlvbnNQdHIpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgYT1XZWJOTi5tZ3JPcGVyYW5kLmdldChhSWQpO3ZhciBiPVdlYk5OLm1nck9wZXJhbmQuZ2V0KGJJZCk7dmFyIG9wdGlvbnM9V2ViTk4ubWFrZUdlbW1PcHRpb25zKG9wdGlvbnNQdHIpO3ZhciBvdXRwdXQ9YnVpbGRlci5nZW1tKGEsYixvcHRpb25zKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUob3V0cHV0KX1mdW5jdGlvbiBfbWxHcmFwaEJ1aWxkZXJJbnB1dChidWlsZGVySWQsbmFtZVB0cixkZXNjUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIG5hbWU9VVRGOFRvU3RyaW5nKG5hbWVQdHIpO3ZhciBkZXNjPVdlYk5OLm1ha2VPcGVyYW5kRGVzY3JpcHRvcihkZXNjUHRyKTt2YXIgaW5wdXQ9YnVpbGRlci5pbnB1dChuYW1lLGRlc2MpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShpbnB1dCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyTWF0bXVsKGJ1aWxkZXJJZCxhSWQsYklkKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGE9V2ViTk4ubWdyT3BlcmFuZC5nZXQoYUlkKTt2YXIgYj1XZWJOTi5tZ3JPcGVyYW5kLmdldChiSWQpO3ZhciBjPWJ1aWxkZXIubWF0bXVsKGEsYik7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKGMpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlck1heFBvb2wyZChidWlsZGVySWQsaW5wdXRJZCxvcHRpb25zUHRyKXt2YXIgYnVpbGRlcj1XZWJOTi5tZ3JHcmFwaEJ1aWxkZXIuZ2V0KGJ1aWxkZXJJZCk7dmFyIGlucHV0PVdlYk5OLm1nck9wZXJhbmQuZ2V0KGlucHV0SWQpO3ZhciBvcHRpb25zPVdlYk5OLm1ha2VQb29sMmRPcHRpb25zKG9wdGlvbnNQdHIpO3ZhciBwb29sMmQ9YnVpbGRlci5tYXhQb29sMmQoaW5wdXQsb3B0aW9ucyk7cmV0dXJuIFdlYk5OLm1nck9wZXJhbmQuY3JlYXRlKHBvb2wyZCl9ZnVuY3Rpb24gX21sR3JhcGhCdWlsZGVyUmVsZWFzZShpZCl7V2ViTk4ubWdyR3JhcGhCdWlsZGVyLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlclJlbHUoYnVpbGRlcklkLGlucHV0SWQpe3ZhciBidWlsZGVyPVdlYk5OLm1nckdyYXBoQnVpbGRlci5nZXQoYnVpbGRlcklkKTt2YXIgaW5wdXQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQoaW5wdXRJZCk7dmFyIG91dHB1dD1idWlsZGVyLnJlbHUoaW5wdXQpO3JldHVybiBXZWJOTi5tZ3JPcGVyYW5kLmNyZWF0ZShvdXRwdXQpfWZ1bmN0aW9uIF9tbEdyYXBoQnVpbGRlclJlc2hhcGUoYnVpbGRlcklkLGlucHV0SWQsbmV3U2hhcGVQdHIsbmV3U2hhcGVDb3VudCl7dmFyIGJ1aWxkZXI9V2ViTk4ubWdyR3JhcGhCdWlsZGVyLmdldChidWlsZGVySWQpO3ZhciBpbnB1dD1XZWJOTi5tZ3JPcGVyYW5kLmdldChpbnB1dElkKTt2YXIgbmV3U2hhcGU9V2ViTk4ubWFrZUkzMkFycmF5KG5ld1NoYXBlQ291bnQsbmV3U2hhcGVQdHIpO3ZhciBvdXRwdXQ9YnVpbGRlci5yZXNoYXBlKGlucHV0LG5ld1NoYXBlKTtyZXR1cm4gV2ViTk4ubWdyT3BlcmFuZC5jcmVhdGUob3V0cHV0KX1mdW5jdGlvbiBfbWxHcmFwaENvbXB1dGVTeW5jKGdyYXBoSWQsaW5wdXRzSWQsb3V0cHV0c0lkKXt2YXIgZ3JhcGg9V2ViTk4ubWdyR3JhcGguZ2V0KGdyYXBoSWQpO3ZhciBpbnB1dHM9V2ViTk4ubWdyTmFtZWRJbnB1dHMuZ2V0KGlucHV0c0lkKTt2YXIgb3V0cHV0cz1XZWJOTi5tZ3JOYW1lZE91dHB1dHMuZ2V0KG91dHB1dHNJZCk7cmV0dXJuIGdyYXBoLmNvbXB1dGVTeW5jKGlucHV0cyxvdXRwdXRzKX1mdW5jdGlvbiBfbWxHcmFwaFJlZmVyZW5jZShpZCl7V2ViTk4ubWdyR3JhcGgucmVmZXJlbmNlKGlkKX1mdW5jdGlvbiBfbWxHcmFwaFJlbGVhc2UoaWQpe1dlYk5OLm1nckdyYXBoLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbE5hbWVkSW5wdXRzUmVsZWFzZShpZCl7V2ViTk4ubWdyTmFtZWRJbnB1dHMucmVsZWFzZShpZCl9ZnVuY3Rpb24gX21sTmFtZWRJbnB1dHNTZXQobmFtZWRJbnB1dHNJZCxuYW1lUHRyLGlucHV0UHRyKXt2YXIgbmFtZWRJbnB1dHM9V2ViTk4ubWdyTmFtZWRJbnB1dHMuZ2V0KG5hbWVkSW5wdXRzSWQpO3ZhciBuYW1lPVVURjhUb1N0cmluZyhuYW1lUHRyKTt2YXIgaW5wdXQ9V2ViTk4ubWFrZUlucHV0KGlucHV0UHRyKTtuYW1lZElucHV0c1tuYW1lXT1pbnB1dH1mdW5jdGlvbiBfbWxOYW1lZE9wZXJhbmRzUmVsZWFzZShpZCl7V2ViTk4ubWdyTmFtZWRPcGVyYW5kcy5yZWxlYXNlKGlkKX1mdW5jdGlvbiBfbWxOYW1lZE9wZXJhbmRzU2V0KG5hbWVkT3BlcmFuZHNJZCxuYW1lUHRyLG9wZXJhbmRJZCl7dmFyIG5hbWVkT3BlcmFuZHM9V2ViTk4ubWdyTmFtZWRPcGVyYW5kcy5nZXQobmFtZWRPcGVyYW5kc0lkKTt2YXIgbmFtZT1VVEY4VG9TdHJpbmcobmFtZVB0cik7dmFyIG9wZXJhbmQ9V2ViTk4ubWdyT3BlcmFuZC5nZXQob3BlcmFuZElkKTtuYW1lZE9wZXJhbmRzW25hbWVdPW9wZXJhbmR9ZnVuY3Rpb24gX21sTmFtZWRPdXRwdXRzUmVsZWFzZShpZCl7V2ViTk4ubWdyTmFtZWRPdXRwdXRzLnJlbGVhc2UoaWQpfWZ1bmN0aW9uIF9tbE5hbWVkT3V0cHV0c1NldChuYW1lZE91dHB1dHNJZCxuYW1lUHRyLG91dHB1dFB0cil7dmFyIG5hbWVkT3V0cHV0cz1XZWJOTi5tZ3JOYW1lZE91dHB1dHMuZ2V0KG5hbWVkT3V0cHV0c0lkKTt2YXIgbmFtZT1VVEY4VG9TdHJpbmcobmFtZVB0cik7dmFyIG91dHB1dD1XZWJOTi5tYWtlT3V0cHV0KG91dHB1dFB0cik7bmFtZWRPdXRwdXRzW25hbWVdPW91dHB1dH1mdW5jdGlvbiBfbWxPcGVyYW5kUmVmZXJlbmNlKGlkKXtXZWJOTi5tZ3JPcGVyYW5kLnJlZmVyZW5jZShpZCl9ZnVuY3Rpb24gX21sT3BlcmFuZFJlbGVhc2UoaWQpe1dlYk5OLm1nck9wZXJhbmQucmVsZWFzZShpZCl9ZnVuY3Rpb24gX3B0aHJlYWRfY3JlYXRlKCl7cmV0dXJuIDZ9ZnVuY3Rpb24gX3B0aHJlYWRfam9pbigpe3JldHVybiAyOH1mdW5jdGlvbiBfX2lzTGVhcFllYXIoeWVhcil7cmV0dXJuIHllYXIlND09PTAmJih5ZWFyJTEwMCE9PTB8fHllYXIlNDAwPT09MCl9ZnVuY3Rpb24gX19hcnJheVN1bShhcnJheSxpbmRleCl7dmFyIHN1bT0wO2Zvcih2YXIgaT0wO2k8PWluZGV4O3N1bSs9YXJyYXlbaSsrXSl7fXJldHVybiBzdW19dmFyIF9fTU9OVEhfREFZU19MRUFQPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07dmFyIF9fTU9OVEhfREFZU19SRUdVTEFSPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gX19hZGREYXlzKGRhdGUsZGF5cyl7dmFyIG5ld0RhdGU9bmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO3doaWxlKGRheXM+MCl7dmFyIGxlYXA9X19pc0xlYXBZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSk7dmFyIGN1cnJlbnRNb250aD1uZXdEYXRlLmdldE1vbnRoKCk7dmFyIGRheXNJbkN1cnJlbnRNb250aD0obGVhcD9fX01PTlRIX0RBWVNfTEVBUDpfX01PTlRIX0RBWVNfUkVHVUxBUilbY3VycmVudE1vbnRoXTtpZihkYXlzPmRheXNJbkN1cnJlbnRNb250aC1uZXdEYXRlLmdldERhdGUoKSl7ZGF5cy09ZGF5c0luQ3VycmVudE1vbnRoLW5ld0RhdGUuZ2V0RGF0ZSgpKzE7bmV3RGF0ZS5zZXREYXRlKDEpO2lmKGN1cnJlbnRNb250aDwxMSl7bmV3RGF0ZS5zZXRNb250aChjdXJyZW50TW9udGgrMSl9ZWxzZXtuZXdEYXRlLnNldE1vbnRoKDApO25ld0RhdGUuc2V0RnVsbFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKzEpfX1lbHNle25ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKStkYXlzKTtyZXR1cm4gbmV3RGF0ZX19cmV0dXJuIG5ld0RhdGV9ZnVuY3Rpb24gX3N0cmZ0aW1lKHMsbWF4c2l6ZSxmb3JtYXQsdG0pe3ZhciB0bV96b25lPUhFQVAzMlt0bSs0MD4+Ml07dmFyIGRhdGU9e3RtX3NlYzpIRUFQMzJbdG0+PjJdLHRtX21pbjpIRUFQMzJbdG0rND4+Ml0sdG1faG91cjpIRUFQMzJbdG0rOD4+Ml0sdG1fbWRheTpIRUFQMzJbdG0rMTI+PjJdLHRtX21vbjpIRUFQMzJbdG0rMTY+PjJdLHRtX3llYXI6SEVBUDMyW3RtKzIwPj4yXSx0bV93ZGF5OkhFQVAzMlt0bSsyND4+Ml0sdG1feWRheTpIRUFQMzJbdG0rMjg+PjJdLHRtX2lzZHN0OkhFQVAzMlt0bSszMj4+Ml0sdG1fZ210b2ZmOkhFQVAzMlt0bSszNj4+Ml0sdG1fem9uZTp0bV96b25lP1VURjhUb1N0cmluZyh0bV96b25lKTpcIlwifTt2YXIgcGF0dGVybj1VVEY4VG9TdHJpbmcoZm9ybWF0KTt2YXIgRVhQQU5TSU9OX1JVTEVTXzE9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzEpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzFbcnVsZV0pfXZhciBXRUVLREFZUz1bXCJTdW5kYXlcIixcIk1vbmRheVwiLFwiVHVlc2RheVwiLFwiV2VkbmVzZGF5XCIsXCJUaHVyc2RheVwiLFwiRnJpZGF5XCIsXCJTYXR1cmRheVwiXTt2YXIgTU9OVEhTPVtcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFwiSnVseVwiLFwiQXVndXN0XCIsXCJTZXB0ZW1iZXJcIixcIk9jdG9iZXJcIixcIk5vdmVtYmVyXCIsXCJEZWNlbWJlclwiXTtmdW5jdGlvbiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxjaGFyYWN0ZXIpe3ZhciBzdHI9dHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIj92YWx1ZS50b1N0cmluZygpOnZhbHVlfHxcIlwiO3doaWxlKHN0ci5sZW5ndGg8ZGlnaXRzKXtzdHI9Y2hhcmFjdGVyWzBdK3N0cn1yZXR1cm4gc3RyfWZ1bmN0aW9uIGxlYWRpbmdOdWxscyh2YWx1ZSxkaWdpdHMpe3JldHVybiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxcIjBcIil9ZnVuY3Rpb24gY29tcGFyZUJ5RGF5KGRhdGUxLGRhdGUyKXtmdW5jdGlvbiBzZ24odmFsdWUpe3JldHVybiB2YWx1ZTwwPy0xOnZhbHVlPjA/MTowfXZhciBjb21wYXJlO2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRGdWxsWWVhcigpLWRhdGUyLmdldEZ1bGxZZWFyKCkpKT09PTApe2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRNb250aCgpLWRhdGUyLmdldE1vbnRoKCkpKT09PTApe2NvbXBhcmU9c2duKGRhdGUxLmdldERhdGUoKS1kYXRlMi5nZXREYXRlKCkpfX1yZXR1cm4gY29tcGFyZX1mdW5jdGlvbiBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoKXtzd2l0Y2goamFuRm91cnRoLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gamFuRm91cnRoO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKXt2YXIgdGhpc0RhdGU9X19hZGREYXlzKG5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsMSksZGF0ZS50bV95ZGF5KTt2YXIgamFuRm91cnRoVGhpc1llYXI9bmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSwwLDQpO3ZhciBqYW5Gb3VydGhOZXh0WWVhcj1uZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpKzEsMCw0KTt2YXIgZmlyc3RXZWVrU3RhcnRUaGlzWWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoVGhpc1llYXIpO3ZhciBmaXJzdFdlZWtTdGFydE5leHRZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhOZXh0WWVhcik7aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIsdGhpc0RhdGUpPD0wKXtpZihjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnROZXh0WWVhcix0aGlzRGF0ZSk8PTApe3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpKzF9ZWxzZXtyZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKX19ZWxzZXtyZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKS0xfX12YXIgRVhQQU5TSU9OX1JVTEVTXzI9e1wiJWFcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gV0VFS0RBWVNbZGF0ZS50bV93ZGF5XS5zdWJzdHJpbmcoMCwzKX0sXCIlQVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldfSxcIiViXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIE1PTlRIU1tkYXRlLnRtX21vbl0uc3Vic3RyaW5nKDAsMyl9LFwiJUJcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXX0sXCIlQ1wiOmZ1bmN0aW9uKGRhdGUpe3ZhciB5ZWFyPWRhdGUudG1feWVhcisxOTAwO3JldHVybiBsZWFkaW5nTnVsbHMoeWVhci8xMDB8MCwyKX0sXCIlZFwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5LDIpfSxcIiVlXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdTb21ldGhpbmcoZGF0ZS50bV9tZGF5LDIsXCIgXCIpfSxcIiVnXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJUdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKX0sXCIlSFwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9ob3VyLDIpfSxcIiVJXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIHR3ZWx2ZUhvdXI9ZGF0ZS50bV9ob3VyO2lmKHR3ZWx2ZUhvdXI9PTApdHdlbHZlSG91cj0xMjtlbHNlIGlmKHR3ZWx2ZUhvdXI+MTIpdHdlbHZlSG91ci09MTI7cmV0dXJuIGxlYWRpbmdOdWxscyh0d2VsdmVIb3VyLDIpfSxcIiVqXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXkrX19hcnJheVN1bShfX2lzTGVhcFllYXIoZGF0ZS50bV95ZWFyKzE5MDApP19fTU9OVEhfREFZU19MRUFQOl9fTU9OVEhfREFZU19SRUdVTEFSLGRhdGUudG1fbW9uLTEpLDMpfSxcIiVtXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21vbisxLDIpfSxcIiVNXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21pbiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKGRhdGUpe2lmKGRhdGUudG1faG91cj49MCYmZGF0ZS50bV9ob3VyPDEyKXtyZXR1cm5cIkFNXCJ9ZWxzZXtyZXR1cm5cIlBNXCJ9fSxcIiVTXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX3NlYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3dkYXl8fDd9LFwiJVVcIjpmdW5jdGlvbihkYXRlKXt2YXIgamFuRmlyc3Q9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCwxKTt2YXIgZmlyc3RTdW5kYXk9amFuRmlyc3QuZ2V0RGF5KCk9PT0wP2phbkZpcnN0Ol9fYWRkRGF5cyhqYW5GaXJzdCw3LWphbkZpcnN0LmdldERheSgpKTt2YXIgZW5kRGF0ZT1uZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCxkYXRlLnRtX21vbixkYXRlLnRtX21kYXkpO2lmKGNvbXBhcmVCeURheShmaXJzdFN1bmRheSxlbmREYXRlKTwwKXt2YXIgZmVicnVhcnlGaXJzdFVudGlsRW5kTW9udGg9X19hcnJheVN1bShfX2lzTGVhcFllYXIoZW5kRGF0ZS5nZXRGdWxsWWVhcigpKT9fX01PTlRIX0RBWVNfTEVBUDpfX01PTlRIX0RBWVNfUkVHVUxBUixlbmREYXRlLmdldE1vbnRoKCktMSktMzE7dmFyIGZpcnN0U3VuZGF5VW50aWxFbmRKYW51YXJ5PTMxLWZpcnN0U3VuZGF5LmdldERhdGUoKTt2YXIgZGF5cz1maXJzdFN1bmRheVVudGlsRW5kSmFudWFyeStmZWJydWFyeUZpcnN0VW50aWxFbmRNb250aCtlbmREYXRlLmdldERhdGUoKTtyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguY2VpbChkYXlzLzcpLDIpfXJldHVybiBjb21wYXJlQnlEYXkoZmlyc3RTdW5kYXksamFuRmlyc3QpPT09MD9cIjAxXCI6XCIwMFwifSxcIiVWXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIGphbkZvdXJ0aFRoaXNZZWFyPW5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsNCk7dmFyIGphbkZvdXJ0aE5leHRZZWFyPW5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAxLDAsNCk7dmFyIGZpcnN0V2Vla1N0YXJ0VGhpc1llYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aFRoaXNZZWFyKTt2YXIgZmlyc3RXZWVrU3RhcnROZXh0WWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoTmV4dFllYXIpO3ZhciBlbmREYXRlPV9fYWRkRGF5cyhuZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCwwLDEpLGRhdGUudG1feWRheSk7aWYoY29tcGFyZUJ5RGF5KGVuZERhdGUsZmlyc3RXZWVrU3RhcnRUaGlzWWVhcik8MCl7cmV0dXJuXCI1M1wifWlmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydE5leHRZZWFyLGVuZERhdGUpPD0wKXtyZXR1cm5cIjAxXCJ9dmFyIGRheXNEaWZmZXJlbmNlO2lmKGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIuZ2V0RnVsbFllYXIoKTxkYXRlLnRtX3llYXIrMTkwMCl7ZGF5c0RpZmZlcmVuY2U9ZGF0ZS50bV95ZGF5KzMyLWZpcnN0V2Vla1N0YXJ0VGhpc1llYXIuZ2V0RGF0ZSgpfWVsc2V7ZGF5c0RpZmZlcmVuY2U9ZGF0ZS50bV95ZGF5KzEtZmlyc3RXZWVrU3RhcnRUaGlzWWVhci5nZXREYXRlKCl9cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmNlaWwoZGF5c0RpZmZlcmVuY2UvNyksMil9LFwiJXdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV93ZGF5fSxcIiVXXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIGphbkZpcnN0PW5ldyBEYXRlKGRhdGUudG1feWVhciwwLDEpO3ZhciBmaXJzdE1vbmRheT1qYW5GaXJzdC5nZXREYXkoKT09PTE/amFuRmlyc3Q6X19hZGREYXlzKGphbkZpcnN0LGphbkZpcnN0LmdldERheSgpPT09MD8xOjctamFuRmlyc3QuZ2V0RGF5KCkrMSk7dmFyIGVuZERhdGU9bmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsZGF0ZS50bV9tb24sZGF0ZS50bV9tZGF5KTtpZihjb21wYXJlQnlEYXkoZmlyc3RNb25kYXksZW5kRGF0ZSk8MCl7dmFyIGZlYnJ1YXJ5Rmlyc3RVbnRpbEVuZE1vbnRoPV9fYXJyYXlTdW0oX19pc0xlYXBZZWFyKGVuZERhdGUuZ2V0RnVsbFllYXIoKSk/X19NT05USF9EQVlTX0xFQVA6X19NT05USF9EQVlTX1JFR1VMQVIsZW5kRGF0ZS5nZXRNb250aCgpLTEpLTMxO3ZhciBmaXJzdE1vbmRheVVudGlsRW5kSmFudWFyeT0zMS1maXJzdE1vbmRheS5nZXREYXRlKCk7dmFyIGRheXM9Zmlyc3RNb25kYXlVbnRpbEVuZEphbnVhcnkrZmVicnVhcnlGaXJzdFVudGlsRW5kTW9udGgrZW5kRGF0ZS5nZXREYXRlKCk7cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmNlaWwoZGF5cy83KSwyKX1yZXR1cm4gY29tcGFyZUJ5RGF5KGZpcnN0TW9uZGF5LGphbkZpcnN0KT09PTA/XCIwMVwiOlwiMDBcIn0sXCIleVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybihkYXRlLnRtX3llYXIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV95ZWFyKzE5MDB9LFwiJXpcIjpmdW5jdGlvbihkYXRlKXt2YXIgb2ZmPWRhdGUudG1fZ210b2ZmO3ZhciBhaGVhZD1vZmY+PTA7b2ZmPU1hdGguYWJzKG9mZikvNjA7b2ZmPW9mZi82MCoxMDArb2ZmJTYwO3JldHVybihhaGVhZD9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiK29mZikuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fem9uZX0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzIpe2lmKHBhdHRlcm4uaW5jbHVkZXMocnVsZSkpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzJbcnVsZV0oZGF0ZSkpfX12YXIgYnl0ZXM9aW50QXJyYXlGcm9tU3RyaW5nKHBhdHRlcm4sZmFsc2UpO2lmKGJ5dGVzLmxlbmd0aD5tYXhzaXplKXtyZXR1cm4gMH13cml0ZUFycmF5VG9NZW1vcnkoYnl0ZXMscyk7cmV0dXJuIGJ5dGVzLmxlbmd0aC0xfWZ1bmN0aW9uIF9zdHJmdGltZV9sKHMsbWF4c2l6ZSxmb3JtYXQsdG0pe3JldHVybiBfc3RyZnRpbWUocyxtYXhzaXplLGZvcm1hdCx0bSl9ZnVuY3Rpb24gX3dlYm5uQ3JlYXRlR3JhcGhCdWlsZGVyKGNvbnRleHRJZCl7dmFyIGNvbnRleHQ9V2ViTk4ubWdyQ29udGV4dC5nZXQoY29udGV4dElkKTt2YXIgYnVpbGRlcj1uZXcgTUxHcmFwaEJ1aWxkZXIoY29udGV4dCk7cmV0dXJuIFdlYk5OLm1nckdyYXBoQnVpbGRlci5jcmVhdGUoYnVpbGRlcil9ZnVuY3Rpb24gX3dlYm5uQ3JlYXRlTmFtZWRJbnB1dHMoKXt2YXIgaW5wdXRzPXt9O3JldHVybiBXZWJOTi5tZ3JOYW1lZElucHV0cy5jcmVhdGUoaW5wdXRzKX1mdW5jdGlvbiBfd2Vibm5DcmVhdGVOYW1lZE9wZXJhbmRzKCl7dmFyIG9wZXJhbmRzPXt9O3JldHVybiBXZWJOTi5tZ3JOYW1lZE9wZXJhbmRzLmNyZWF0ZShvcGVyYW5kcyl9ZnVuY3Rpb24gX3dlYm5uQ3JlYXRlTmFtZWRPdXRwdXRzKCl7dmFyIG91dHB1dHM9e307cmV0dXJuIFdlYk5OLm1nck5hbWVkT3V0cHV0cy5jcmVhdGUob3V0cHV0cyl9V2ViTk4uaW5pdE1hbmFnZXJzKCk7ZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksZG9udEFkZE51bGwsbGVuZ3RoKXt2YXIgbGVuPWxlbmd0aD4wP2xlbmd0aDpsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkrMTt2YXIgdThhcnJheT1uZXcgQXJyYXkobGVuKTt2YXIgbnVtQnl0ZXNXcml0dGVuPXN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksdThhcnJheSwwLHU4YXJyYXkubGVuZ3RoKTtpZihkb250QWRkTnVsbCl1OGFycmF5Lmxlbmd0aD1udW1CeXRlc1dyaXR0ZW47cmV0dXJuIHU4YXJyYXl9dmFyIGFzbUxpYnJhcnlBcmc9e1wiYVwiOl9fX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24sXCJjXCI6X19fY3hhX2F0ZXhpdCxcImZcIjpfX19jeGFfdGhyZWFkX2F0ZXhpdCxcImJcIjpfX19jeGFfdGhyb3csXCJMXCI6X19fc3lzX2FjY2VzcyxcIm1cIjpfX19zeXNfZmNudGw2NCxcIlJcIjpfX19zeXNfZnN0YXQ2NCxcIk1cIjpfX19zeXNfZ2V0ZGVudHM2NCxcInFcIjpfX19zeXNfZ2V0cGlkLFwiRFwiOl9fX3N5c19pb2N0bCxcIk5cIjpfX19zeXNfbHN0YXQ2NCxcIlFcIjpfX19zeXNfbWtkaXIsXCJQXCI6X19fc3lzX21tYXAyLFwiT1wiOl9fX3N5c19tdW5tYXAsXCJsXCI6X19fc3lzX29wZW4sXCJLXCI6X19fc3lzX3JlYWRsaW5rLFwiSVwiOl9fX3N5c19ybWRpcixcInNcIjpfX19zeXNfc3RhdDY0LFwiSlwiOl9fX3N5c191bmxpbmssXCJqXCI6X2Fib3J0LFwidVwiOl9jbG9ja19nZXR0aW1lLFwielwiOl9kaWZmdGltZSxcInZhXCI6X2RsY2xvc2UsXCJpXCI6X2RsZXJyb3IsXCJ3YVwiOl9kbG9wZW4sXCJ1YVwiOl9kbHN5bSxcIlNcIjpfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXCJDXCI6X2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcImtcIjpfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcIkhcIjpfZW1zY3JpcHRlbl90aHJlYWRfc2xlZXAsXCJzYVwiOl9lbXNjcmlwdGVuX3dlYm5uX2NyZWF0ZV9jb250ZXh0LFwiRlwiOl9lbnZpcm9uX2dldCxcIkdcIjpfZW52aXJvbl9zaXplc19nZXQsXCJoXCI6X2ZkX2Nsb3NlLFwiRVwiOl9mZF9mZHN0YXRfZ2V0LFwib1wiOl9mZF9yZWFkLFwiQlwiOl9mZF9zZWVrLFwicFwiOl9mZF93cml0ZSxcImFhXCI6X2dldHRpbWVvZmRheSxcIkFcIjpfZ210aW1lX3IsXCJuXCI6X2xvY2FsdGltZV9yLFwieVwiOl9ta3RpbWUsXCJ4XCI6X21sQ29udGV4dFJlZmVyZW5jZSxcIndcIjpfbWxDb250ZXh0UmVsZWFzZSxcInBhXCI6X21sR3JhcGhCdWlsZGVyQWRkLFwib2FcIjpfbWxHcmFwaEJ1aWxkZXJBdmVyYWdlUG9vbDJkLFwibmFcIjpfbWxHcmFwaEJ1aWxkZXJCYXRjaE5vcm0sXCJtYVwiOl9tbEdyYXBoQnVpbGRlckJ1aWxkU3luYyxcImxhXCI6X21sR3JhcGhCdWlsZGVyQ29uY2F0LFwia2FcIjpfbWxHcmFwaEJ1aWxkZXJDb25zdGFudCxcImphXCI6X21sR3JhcGhCdWlsZGVyQ29udjJkLFwiaWFcIjpfbWxHcmFwaEJ1aWxkZXJHZW1tLFwiaGFcIjpfbWxHcmFwaEJ1aWxkZXJJbnB1dCxcImdhXCI6X21sR3JhcGhCdWlsZGVyTWF0bXVsLFwiZmFcIjpfbWxHcmFwaEJ1aWxkZXJNYXhQb29sMmQsXCJ0XCI6X21sR3JhcGhCdWlsZGVyUmVsZWFzZSxcImVhXCI6X21sR3JhcGhCdWlsZGVyUmVsdSxcImRhXCI6X21sR3JhcGhCdWlsZGVyUmVzaGFwZSxcInJhXCI6X21sR3JhcGhDb21wdXRlU3luYyxcInFhXCI6X21sR3JhcGhSZWZlcmVuY2UsXCJ2XCI6X21sR3JhcGhSZWxlYXNlLFwiYmFcIjpfbWxOYW1lZElucHV0c1JlbGVhc2UsXCJjYVwiOl9tbE5hbWVkSW5wdXRzU2V0LFwiX1wiOl9tbE5hbWVkT3BlcmFuZHNSZWxlYXNlLFwiJFwiOl9tbE5hbWVkT3BlcmFuZHNTZXQsXCJZXCI6X21sTmFtZWRPdXRwdXRzUmVsZWFzZSxcIlpcIjpfbWxOYW1lZE91dHB1dHNTZXQsXCJlXCI6X21sT3BlcmFuZFJlZmVyZW5jZSxcImRcIjpfbWxPcGVyYW5kUmVsZWFzZSxcIlRcIjpfcHRocmVhZF9jcmVhdGUsXCJyXCI6X3B0aHJlYWRfam9pbixcInRhXCI6X3N0cmZ0aW1lLFwiZ1wiOl9zdHJmdGltZV9sLFwiWFwiOl93ZWJubkNyZWF0ZUdyYXBoQnVpbGRlcixcIldcIjpfd2Vibm5DcmVhdGVOYW1lZElucHV0cyxcIlZcIjpfd2Vibm5DcmVhdGVOYW1lZE9wZXJhbmRzLFwiVVwiOl93ZWJubkNyZWF0ZU5hbWVkT3V0cHV0c307dmFyIGFzbT1jcmVhdGVXYXNtKCk7dmFyIF9fX3dhc21fY2FsbF9jdG9ycz1Nb2R1bGVbXCJfX193YXNtX2NhbGxfY3RvcnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19fd2FzbV9jYWxsX2N0b3JzPU1vZHVsZVtcIl9fX3dhc21fY2FsbF9jdG9yc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJ5YVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEluaXQ9TW9kdWxlW1wiX09ydEluaXRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEluaXQ9TW9kdWxlW1wiX09ydEluaXRcIl09TW9kdWxlW1wiYXNtXCJdW1wiemFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1Nb2R1bGVbXCJfT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9uc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJBYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFNlc3Npb25PcHRpb25zQXBwZW5kRXhlY3V0aW9uUHJvdmlkZXJXZWJOTj1Nb2R1bGVbXCJfT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRTZXNzaW9uT3B0aW9uc0FwcGVuZEV4ZWN1dGlvblByb3ZpZGVyV2ViTk49TW9kdWxlW1wiX09ydFNlc3Npb25PcHRpb25zQXBwZW5kRXhlY3V0aW9uUHJvdmlkZXJXZWJOTlwiXT1Nb2R1bGVbXCJhc21cIl1bXCJCYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9TW9kdWxlW1wiX09ydEFkZFNlc3Npb25Db25maWdFbnRyeVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJDYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1Nb2R1bGVbXCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9TW9kdWxlW1wiX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9uc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJEYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydENyZWF0ZVNlc3Npb249TW9kdWxlW1wiX09ydENyZWF0ZVNlc3Npb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVNlc3Npb249TW9kdWxlW1wiX09ydENyZWF0ZVNlc3Npb25cIl09TW9kdWxlW1wiYXNtXCJdW1wiRWFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRSZWxlYXNlU2Vzc2lvbj1Nb2R1bGVbXCJfT3J0UmVsZWFzZVNlc3Npb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VTZXNzaW9uPU1vZHVsZVtcIl9PcnRSZWxlYXNlU2Vzc2lvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJGYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldElucHV0Q291bnQ9TW9kdWxlW1wiX09ydEdldElucHV0Q291bnRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldElucHV0Q291bnQ9TW9kdWxlW1wiX09ydEdldElucHV0Q291bnRcIl09TW9kdWxlW1wiYXNtXCJdW1wiR2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRHZXRPdXRwdXRDb3VudD1Nb2R1bGVbXCJfT3J0R2V0T3V0cHV0Q291bnRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldE91dHB1dENvdW50PU1vZHVsZVtcIl9PcnRHZXRPdXRwdXRDb3VudFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJIYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldElucHV0TmFtZT1Nb2R1bGVbXCJfT3J0R2V0SW5wdXROYW1lXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRHZXRJbnB1dE5hbWU9TW9kdWxlW1wiX09ydEdldElucHV0TmFtZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJJYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydEdldE91dHB1dE5hbWU9TW9kdWxlW1wiX09ydEdldE91dHB1dE5hbWVcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydEdldE91dHB1dE5hbWU9TW9kdWxlW1wiX09ydEdldE91dHB1dE5hbWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiSmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRGcmVlPU1vZHVsZVtcIl9PcnRGcmVlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRGcmVlPU1vZHVsZVtcIl9PcnRGcmVlXCJdPU1vZHVsZVtcImFzbVwiXVtcIkthXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0Q3JlYXRlVGVuc29yPU1vZHVsZVtcIl9PcnRDcmVhdGVUZW5zb3JcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydENyZWF0ZVRlbnNvcj1Nb2R1bGVbXCJfT3J0Q3JlYXRlVGVuc29yXCJdPU1vZHVsZVtcImFzbVwiXVtcIkxhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0R2V0VGVuc29yRGF0YT1Nb2R1bGVbXCJfT3J0R2V0VGVuc29yRGF0YVwiXT1mdW5jdGlvbigpe3JldHVybihfT3J0R2V0VGVuc29yRGF0YT1Nb2R1bGVbXCJfT3J0R2V0VGVuc29yRGF0YVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJNYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJlbGVhc2VUZW5zb3I9TW9kdWxlW1wiX09ydFJlbGVhc2VUZW5zb3JcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VUZW5zb3I9TW9kdWxlW1wiX09ydFJlbGVhc2VUZW5zb3JcIl09TW9kdWxlW1wiYXNtXCJdW1wiTmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRDcmVhdGVSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVSdW5PcHRpb25zXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRDcmVhdGVSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRDcmVhdGVSdW5PcHRpb25zXCJdPU1vZHVsZVtcImFzbVwiXVtcIk9hXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfT3J0QWRkUnVuQ29uZmlnRW50cnk9TW9kdWxlW1wiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRBZGRSdW5Db25maWdFbnRyeT1Nb2R1bGVbXCJfT3J0QWRkUnVuQ29uZmlnRW50cnlcIl09TW9kdWxlW1wiYXNtXCJdW1wiUGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9PcnRSZWxlYXNlUnVuT3B0aW9ucz1Nb2R1bGVbXCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX09ydFJlbGVhc2VSdW5PcHRpb25zPU1vZHVsZVtcIl9PcnRSZWxlYXNlUnVuT3B0aW9uc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJRYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX09ydFJ1bj1Nb2R1bGVbXCJfT3J0UnVuXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9PcnRSdW49TW9kdWxlW1wiX09ydFJ1blwiXT1Nb2R1bGVbXCJhc21cIl1bXCJSYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9tYWxsb2M9TW9kdWxlW1wiX21hbGxvY1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJTYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19fZXJybm9fbG9jYXRpb249TW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX19fZXJybm9fbG9jYXRpb249TW9kdWxlW1wiX19fZXJybm9fbG9jYXRpb25cIl09TW9kdWxlW1wiYXNtXCJdW1wiVGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9mcmVlPU1vZHVsZVtcIl9mcmVlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9mcmVlPU1vZHVsZVtcIl9mcmVlXCJdPU1vZHVsZVtcImFzbVwiXVtcIlVhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbWVtc2V0PU1vZHVsZVtcIl9tZW1zZXRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21lbXNldD1Nb2R1bGVbXCJfbWVtc2V0XCJdPU1vZHVsZVtcImFzbVwiXVtcIlZhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2dldF90em5hbWU9TW9kdWxlW1wiX19nZXRfdHpuYW1lXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZ2V0X3R6bmFtZT1Nb2R1bGVbXCJfX2dldF90em5hbWVcIl09TW9kdWxlW1wiYXNtXCJdW1wiV2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9fZ2V0X2RheWxpZ2h0PU1vZHVsZVtcIl9fZ2V0X2RheWxpZ2h0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9fZ2V0X2RheWxpZ2h0PU1vZHVsZVtcIl9fZ2V0X2RheWxpZ2h0XCJdPU1vZHVsZVtcImFzbVwiXVtcIlhhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX2dldF90aW1lem9uZT1Nb2R1bGVbXCJfX2dldF90aW1lem9uZVwiXT1mdW5jdGlvbigpe3JldHVybihfX2dldF90aW1lem9uZT1Nb2R1bGVbXCJfX2dldF90aW1lem9uZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJZYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tTYXZlPU1vZHVsZVtcInN0YWNrU2F2ZVwiXT1mdW5jdGlvbigpe3JldHVybihzdGFja1NhdmU9TW9kdWxlW1wic3RhY2tTYXZlXCJdPU1vZHVsZVtcImFzbVwiXVtcIlphXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja1Jlc3RvcmU9TW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrUmVzdG9yZT1Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl09TW9kdWxlW1wiYXNtXCJdW1wiX2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIHN0YWNrQWxsb2M9TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1mdW5jdGlvbigpe3JldHVybihzdGFja0FsbG9jPU1vZHVsZVtcInN0YWNrQWxsb2NcIl09TW9kdWxlW1wiYXNtXCJdW1wiJGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9tZW1hbGlnbj1Nb2R1bGVbXCJfbWVtYWxpZ25cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21lbWFsaWduPU1vZHVsZVtcIl9tZW1hbGlnblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJhYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtNb2R1bGVbXCJVVEY4VG9TdHJpbmdcIl09VVRGOFRvU3RyaW5nO01vZHVsZVtcInN0cmluZ1RvVVRGOFwiXT1zdHJpbmdUb1VURjg7TW9kdWxlW1wibGVuZ3RoQnl0ZXNVVEY4XCJdPWxlbmd0aEJ5dGVzVVRGODtNb2R1bGVbXCJzdGFja1NhdmVcIl09c3RhY2tTYXZlO01vZHVsZVtcInN0YWNrUmVzdG9yZVwiXT1zdGFja1Jlc3RvcmU7TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1zdGFja0FsbG9jO3ZhciBjYWxsZWRSdW47ZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIjt0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK3N0YXR1cytcIilcIjt0aGlzLnN0YXR1cz1zdGF0dXN9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyfTtmdW5jdGlvbiBydW4oYXJncyl7YXJncz1hcmdzfHxhcmd1bWVudHNfO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1mdW5jdGlvbiBkb1J1bigpe2lmKGNhbGxlZFJ1bilyZXR1cm47Y2FsbGVkUnVuPXRydWU7TW9kdWxlW1wiY2FsbGVkUnVuXCJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2lmKE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKU1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7cG9zdFJ1bigpfWlmKE1vZHVsZVtcInNldFN0YXR1c1wiXSl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiUnVubmluZy4uLlwiKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKX0sMSk7ZG9SdW4oKX0sMSl9ZWxzZXtkb1J1bigpfX1Nb2R1bGVbXCJydW5cIl09cnVuO2lmKE1vZHVsZVtcInByZUluaXRcIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlSW5pdFwiXT1bTW9kdWxlW1wicHJlSW5pdFwiXV07d2hpbGUoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGg+MCl7TW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpfX1ydW4oKTtcblxuXG4gIHJldHVybiBvcnRXYXNtLnJlYWR5XG59XG4pO1xufSkoKTtcbmlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG4gIG1vZHVsZS5leHBvcnRzID0gb3J0V2FzbTtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9ydFdhc207IH0pO1xuZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuICBleHBvcnRzW1wib3J0V2FzbVwiXSA9IG9ydFdhc207XG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGV2ZW50IGVtaXR0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQSBtaW5pbWFsIGV2ZW50IGVtaXR0ZXIuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIExpc3RlbmVyXHJcbiAqIEBwYXJhbSB7Kn0gW2N0eF0gTGlzdGVuZXIgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2dCwgZm4sIGN0eCkge1xyXG4gICAgKHRoaXMuX2xpc3RlbmVyc1tldnRdIHx8ICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgZm4gIDogZm4sXHJcbiAgICAgICAgY3R4IDogY3R4IHx8IHRoaXNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBvciBhbnkgbWF0Y2hpbmcgbGlzdGVuZXJzIGlmIGFyZ3VtZW50cyBhcmUgb21pdHRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIEV2ZW50IG5hbWUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBpZiBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIExpc3RlbmVyIHRvIHJlbW92ZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIG9mIGBldnRgIGlmIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldnQsIGZuKSB7XHJcbiAgICBpZiAoZXZ0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdHMgYW4gZXZlbnQgYnkgY2FsbGluZyBpdHMgbGlzdGVuZXJzIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGkgPSAxO1xyXG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgVVRGOCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0ZjggPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFVURjggYnl0ZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG51dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIGxlbiA9IDAsXHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOClcclxuICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXHJcbiAgICAgICAgICAgIGxlbiArPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhGQzAwKSA9PT0gMHhEODAwICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBsZW4gKz0gNDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgbGVuICs9IDM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIFVURjggYnl0ZXMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcclxuICovXHJcbnV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdLFxyXG4gICAgICAgIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgaWYgKHQgPCAxMjgpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcclxuICAgICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweEQ4MDAgKyAodCA+PiAxMCk7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweERDMDAgKyAodCAmIDEwMjMpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcgYXMgVVRGOCBieXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlcyB3cml0dGVuXHJcbiAqL1xyXG51dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgYzEsIC8vIGNoYXJhY3RlciAxXHJcbiAgICAgICAgYzI7IC8vIGNoYXJhY3RlciAyXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgICAgICB8IDE5MjtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgYzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNGRikgPDwgMTApICsgKGMyICYgMHgwM0ZGKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggICAgICB8IDI0MDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgICAgICB8IDIyNDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuIiwiLy8vIEBmaWxlXG4vLy8gQGFkZHRvZ3JvdXAgZmxhdGJ1ZmZlcnNfamF2YXNjcmlwdF9hcGlcbi8vLyBAe1xuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICpcbiAqIE5lZWQgdG8gc3VwcHJlc3MgJ2dsb2JhbCB0aGlzJyBlcnJvciBzbyB0aGUgTm9kZS5qcyBleHBvcnQgbGluZSBkb2Vzbid0IGNhdXNlXG4gKiBjbG9zdXJlIGNvbXBpbGUgdG8gZXJyb3Igb3V0LlxuICogQHN1cHByZXNzIHtnbG9iYWxUaGlzfVxuICovXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBmbGF0YnVmZmVycyA9IHt9O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLk9mZnNldDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcixcbiAqICAgYmJfcG9zOiBudW1iZXJcbiAqIH19XG4gKi9cbmZsYXRidWZmZXJzLlRhYmxlO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUID0gMjtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLlNJWkVPRl9JTlQgPSA0O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCA9IDQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEggPSA0O1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkVuY29kaW5nID0ge1xuICBVVEY4X0JZVEVTOiAxLFxuICBVVEYxNl9TVFJJTkc6IDJcbn07XG5cbi8qKlxuICogQHR5cGUge0ludDMyQXJyYXl9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuaW50MzIgPSBuZXcgSW50MzJBcnJheSgyKTtcblxuLyoqXG4gKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRidWZmZXJzLmludDMyLmJ1ZmZlcik7XG5cbi8qKlxuICogQHR5cGUge0Zsb2F0NjRBcnJheX1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5mbG9hdDY0ID0gbmV3IEZsb2F0NjRBcnJheShmbGF0YnVmZmVycy5pbnQzMi5idWZmZXIpO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID0gbmV3IFVpbnQxNkFycmF5KG5ldyBVaW50OEFycmF5KFsxLCAwXSkuYnVmZmVyKVswXSA9PT0gMTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKi9cbmZsYXRidWZmZXJzLkxvbmcgPSBmdW5jdGlvbihsb3csIGhpZ2gpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICovXG4gIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5Mb25nLmNyZWF0ZSA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICAvLyBTcGVjaWFsLWNhc2UgemVybyB0byBhdm9pZCBHQyBvdmVyaGVhZCBmb3IgZGVmYXVsdCB2YWx1ZXNcbiAgcmV0dXJuIGxvdyA9PSAwICYmIGhpZ2ggPT0gMCA/IGZsYXRidWZmZXJzLkxvbmcuWkVSTyA6IG5ldyBmbGF0YnVmZmVycy5Mb25nKGxvdywgaGlnaCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcucHJvdG90eXBlLnRvRmxvYXQ2NCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMubG93ID4+PiAwKSArIHRoaXMuaGlnaCAqIDB4MTAwMDAwMDAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IG90aGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMubG93ID09IG90aGVyLmxvdyAmJiB0aGlzLmhpZ2ggPT0gb3RoZXIuaGlnaDtcbn07XG5cbi8qKlxuICogQHR5cGUgeyFmbGF0YnVmZmVycy5Mb25nfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcuWkVSTyA9IG5ldyBmbGF0YnVmZmVycy5Mb25nKDAsIDApO1xuXG4vLy8gQGVuZGNvbmRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIENyZWF0ZSBhIEZsYXRCdWZmZXJCdWlsZGVyLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaW5pdGlhbF9zaXplXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIgPSBmdW5jdGlvbihvcHRfaW5pdGlhbF9zaXplKSB7XG4gIGlmICghb3B0X2luaXRpYWxfc2l6ZSkge1xuICAgIHZhciBpbml0aWFsX3NpemUgPSAxMDI0O1xuICB9IGVsc2Uge1xuICAgIHZhciBpbml0aWFsX3NpemUgPSBvcHRfaW5pdGlhbF9zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iYiA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUoaW5pdGlhbF9zaXplKTtcblxuICAvKipcbiAgICogUmVtYWluaW5nIHNwYWNlIGluIHRoZSBCeXRlQnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zcGFjZSA9IGluaXRpYWxfc2l6ZTtcblxuICAvKipcbiAgICogTWluaW11bSBhbGlnbm1lbnQgZW5jb3VudGVyZWQgc28gZmFyLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5taW5hbGlnbiA9IDE7XG5cbiAgLyoqXG4gICAqIFRoZSB2dGFibGUgZm9yIHRoZSBjdXJyZW50IHRhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZ0YWJsZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgZmllbGRzIHdlJ3JlIGFjdHVhbGx5IHVzaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBhcmUgY3VycmVudGx5IHNlcmlhbGl6aW5nIGEgdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTdGFydGluZyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgc3RydWN0L3RhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG9mZnNldHMgb2YgYWxsIHZ0YWJsZXMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudnRhYmxlcyA9IFtdO1xuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGN1cnJlbnQgdmVjdG9yIGJlaW5nIGJ1aWx0LlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcblxuICAvKipcbiAgICogRmFsc2Ugb21pdHMgZGVmYXVsdCB2YWx1ZXMgZnJvbSB0aGUgc2VyaWFsaXplZCBkYXRhXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xufTtcblxuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iYi5jbGVhcigpO1xuICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpO1xuICB0aGlzLm1pbmFsaWduID0gMTtcbiAgdGhpcy52dGFibGUgPSBudWxsO1xuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG4gIHRoaXMub2JqZWN0X3N0YXJ0ID0gMDtcbiAgdGhpcy52dGFibGVzID0gW107XG4gIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XG4gIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSW4gb3JkZXIgdG8gc2F2ZSBzcGFjZSwgZmllbGRzIHRoYXQgYXJlIHNldCB0byB0aGVpciBkZWZhdWx0IHZhbHVlXG4gKiBkb24ndCBnZXQgc2VyaWFsaXplZCBpbnRvIHRoZSBidWZmZXIuIEZvcmNpbmcgZGVmYXVsdHMgcHJvdmlkZXMgYVxuICogd2F5IHRvIG1hbnVhbGx5IGRpc2FibGUgdGhpcyBvcHRpbWl6YXRpb24uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZURlZmF1bHRzIHRydWUgYWx3YXlzIHNlcmlhbGl6ZXMgZGVmYXVsdCB2YWx1ZXNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuZm9yY2VEZWZhdWx0cyA9IGZ1bmN0aW9uKGZvcmNlRGVmYXVsdHMpIHtcbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZvcmNlRGVmYXVsdHM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQnl0ZUJ1ZmZlciByZXByZXNlbnRpbmcgdGhlIEZsYXRCdWZmZXIuIE9ubHkgY2FsbCB0aGlzIGFmdGVyIHlvdSd2ZVxuICogY2FsbGVkIGZpbmlzaCgpLiBUaGUgYWN0dWFsIGRhdGEgc3RhcnRzIGF0IHRoZSBCeXRlQnVmZmVyJ3MgY3VycmVudCBwb3NpdGlvbixcbiAqIG5vdCBuZWNlc3NhcmlseSBhdCAwLlxuICpcbiAqIEByZXR1cm5zIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5kYXRhQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJiO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gKiBjYWxsZWQgZmluaXNoKCkuXG4gKlxuICogQHJldHVybnMgeyFVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksIHRoaXMuYmIucG9zaXRpb24oKSArIHRoaXMub2Zmc2V0KCkpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFByZXBhcmUgdG8gd3JpdGUgYW4gZWxlbWVudCBvZiBgc2l6ZWAgYWZ0ZXIgYGFkZGl0aW9uYWxfYnl0ZXNgIGhhdmUgYmVlblxuICogd3JpdHRlbiwgZS5nLiBpZiB5b3Ugd3JpdGUgYSBzdHJpbmcsIHlvdSBuZWVkIHRvIGFsaWduIHN1Y2ggdGhlIGludCBsZW5ndGhcbiAqIGZpZWxkIGlzIGFsaWduZWQgdG8gNCBieXRlcywgYW5kIHRoZSBzdHJpbmcgZGF0YSBmb2xsb3dzIGl0IGRpcmVjdGx5LiBJZiBhbGxcbiAqIHlvdSBuZWVkIHRvIGRvIGlzIGFsaWdubWVudCwgYGFkZGl0aW9uYWxfYnl0ZXNgIHdpbGwgYmUgMC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGlzIGlzIHRoZSBvZiB0aGUgbmV3IGVsZW1lbnQgdG8gd3JpdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZGRpdGlvbmFsX2J5dGVzIFRoZSBwYWRkaW5nIHNpemVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUucHJlcCA9IGZ1bmN0aW9uKHNpemUsIGFkZGl0aW9uYWxfYnl0ZXMpIHtcbiAgLy8gVHJhY2sgdGhlIGJpZ2dlc3QgdGhpbmcgd2UndmUgZXZlciBhbGlnbmVkIHRvLlxuICBpZiAoc2l6ZSA+IHRoaXMubWluYWxpZ24pIHtcbiAgICB0aGlzLm1pbmFsaWduID0gc2l6ZTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGFtb3VudCBvZiBhbGlnbm1lbnQgbmVlZGVkIHN1Y2ggdGhhdCBgc2l6ZWAgaXMgcHJvcGVybHlcbiAgLy8gYWxpZ25lZCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2BcbiAgdmFyIGFsaWduX3NpemUgPSAoKH4odGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSArIGFkZGl0aW9uYWxfYnl0ZXMpKSArIDEpICYgKHNpemUgLSAxKTtcblxuICAvLyBSZWFsbG9jYXRlIHRoZSBidWZmZXIgaWYgbmVlZGVkLlxuICB3aGlsZSAodGhpcy5zcGFjZSA8IGFsaWduX3NpemUgKyBzaXplICsgYWRkaXRpb25hbF9ieXRlcykge1xuICAgIHZhciBvbGRfYnVmX3NpemUgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gICAgdGhpcy5iYiA9IGZsYXRidWZmZXJzLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYik7XG4gICAgdGhpcy5zcGFjZSArPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSBvbGRfYnVmX3NpemU7XG4gIH1cblxuICB0aGlzLnBhZChhbGlnbl9zaXplKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVfc2l6ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihieXRlX3NpemUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlX3NpemU7IGkrKykge1xuICAgIHRoaXMuYmIud3JpdGVJbnQ4KC0tdGhpcy5zcGFjZSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UgLT0gMSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQxNih0aGlzLnNwYWNlIC09IDIsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UgLT0gNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUZsb2F0NjQodGhpcy5zcGFjZSAtPSA4LCB2YWx1ZSk7XG59O1xuLy8vIEBlbmRjb25kXG5cbi8qKlxuICogQWRkIGFuIGBpbnQ4YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGludDhgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50OCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMucHJlcCgxLCAwKTtcbiAgdGhpcy53cml0ZUludDgodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYGludDE2YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGludDE2YCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDE2ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDIsIDApO1xuICB0aGlzLndyaXRlSW50MTYodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYGludDMyYCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGludDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDQsIDApO1xuICB0aGlzLndyaXRlSW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYGludDY0YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gdmFsdWUgVGhlIGBpbnQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMucHJlcCg4LCAwKTtcbiAgdGhpcy53cml0ZUludDY0KHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgYGZsb2F0MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgZmxvYXQzMmAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDQsIDApO1xuICB0aGlzLndyaXRlRmxvYXQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGBmbG9hdDY0YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGZsb2F0NjRgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMucHJlcCg4LCAwKTtcbiAgdGhpcy53cml0ZUZsb2F0NjQodmFsdWUpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ4ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEludDgodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MTYgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50MTYodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MzIgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50MzIodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ2NCA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgIXZhbHVlLmVxdWFscyhkZWZhdWx0VmFsdWUpKSB7XG4gICAgdGhpcy5hZGRJbnQ2NCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDMyID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEZsb2F0MzIodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2NCA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRGbG9hdDY0KHZhbHVlKTtcbiAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSB2YWx1ZVxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZE9mZnNldCA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRPZmZzZXQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJ1Y3RzIGFyZSBzdG9yZWQgaW5saW5lLCBzbyBub3RoaW5nIGFkZGl0aW9uYWwgaXMgYmVpbmcgYWRkZWQuIGBkYCBpcyBhbHdheXMgMC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkU3RydWN0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5uZXN0ZWQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJ1Y3R1cmVzIGFyZSBhbHdheXMgc3RvcmVkIGlubGluZSwgdGhleSBuZWVkIHRvIGJlIGNyZWF0ZWQgcmlnaHRcbiAqIHdoZXJlIHRoZXkncmUgdXNlZC4gIFlvdSdsbCBnZXQgdGhpcyBhc3NlcnRpb24gZmFpbHVyZSBpZiB5b3VcbiAqIGNyZWF0ZWQgaXQgZWxzZXdoZXJlLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBvYmogVGhlIG9mZnNldCBvZiB0aGUgY3JlYXRlZCBvYmplY3RcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUubmVzdGVkID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogIT0gdGhpcy5vZmZzZXQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBub3QgYmUgY3JlYXRpbmcgYW55IG90aGVyIG9iamVjdCwgc3RyaW5nIG9yIHZlY3RvclxuICogd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIGNvbnN0cnVjdGVkXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLm5vdE5lc3RlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc05lc3RlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdnRhYmxlIGF0IGB2b2Zmc2V0YCB0byB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnNsb3QgPSBmdW5jdGlvbih2b2Zmc2V0KSB7XG4gIHRoaXMudnRhYmxlW3ZvZmZzZXRdID0gdGhpcy5vZmZzZXQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLk9mZnNldH0gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlO1xufTtcblxuLyoqXG4gKiBEb3VibGVzIHRoZSBzaXplIG9mIHRoZSBiYWNraW5nIEJ5dGVCdWZmZXIgYW5kIGNvcGllcyB0aGUgb2xkIGRhdGEgdG93YXJkc1xuICogdGhlIGVuZCBvZiB0aGUgbmV3IGJ1ZmZlciAoc2luY2Ugd2UgYnVpbGQgdGhlIGJ1ZmZlciBiYWNrd2FyZHMpLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn0gYmIgVGhlIGN1cnJlbnQgYnVmZmVyIHdpdGggdGhlIGV4aXN0aW5nIGRhdGFcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn0gQSBuZXcgYnl0ZSBidWZmZXIgd2l0aCB0aGUgb2xkIGRhdGEgY29waWVkXG4gKiB0byBpdC4gVGhlIGRhdGEgaXMgbG9jYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gKlxuICogdWludDhBcnJheS5zZXQoKSBmb3JtYWxseSB0YWtlcyB7QXJyYXk8bnVtYmVyPnxBcnJheUJ1ZmZlclZpZXd9LCBzbyB0byBwYXNzXG4gKiBpdCBhIHVpbnQ4QXJyYXkgd2UgbmVlZCB0byBzdXBwcmVzcyB0aGUgdHlwZSBjaGVjazpcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJiKSB7XG4gIHZhciBvbGRfYnVmX3NpemUgPSBiYi5jYXBhY2l0eSgpO1xuXG4gIC8vIEVuc3VyZSB3ZSBkb24ndCBncm93IGJleW9uZCB3aGF0IGZpdHMgaW4gYW4gaW50LlxuICBpZiAob2xkX2J1Zl9zaXplICYgMHhDMDAwMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuJyk7XG4gIH1cblxuICB2YXIgbmV3X2J1Zl9zaXplID0gb2xkX2J1Zl9zaXplIDw8IDE7XG4gIHZhciBuYmIgPSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLmFsbG9jYXRlKG5ld19idWZfc2l6ZSk7XG4gIG5iYi5zZXRQb3NpdGlvbihuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICBuYmIuYnl0ZXMoKS5zZXQoYmIuYnl0ZXMoKSwgbmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcbiAgcmV0dXJuIG5iYjtcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBBZGRzIG9uIG9mZnNldCwgcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2lsbCBiZSB3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBvZmZzZXQgVGhlIG9mZnNldCB0byBhZGQuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZE9mZnNldCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICB0aGlzLnByZXAoZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCwgMCk7IC8vIEVuc3VyZSBhbGlnbm1lbnQgaXMgYWxyZWFkeSBkb25lLlxuICB0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKSAtIG9mZnNldCArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFN0YXJ0IGVuY29kaW5nIGEgbmV3IG9iamVjdCBpbiB0aGUgYnVmZmVyLiAgVXNlcnMgd2lsbCBub3QgdXN1YWxseSBuZWVkIHRvXG4gKiBjYWxsIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGdlbmVyYXRlIGhlbHBlciBtZXRob2RzXG4gKiB0aGF0IGNhbGwgdGhpcyBtZXRob2QgaW50ZXJuYWxseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtZmllbGRzXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0T2JqZWN0ID0gZnVuY3Rpb24obnVtZmllbGRzKSB7XG4gIHRoaXMubm90TmVzdGVkKCk7XG4gIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsKSB7XG4gICAgdGhpcy52dGFibGUgPSBbXTtcbiAgfVxuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSBudW1maWVsZHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtZmllbGRzOyBpKyspIHtcbiAgICB0aGlzLnZ0YWJsZVtpXSA9IDA7IC8vIFRoaXMgd2lsbCBwdXNoIGFkZGl0aW9uYWwgZWxlbWVudHMgYXMgbmVlZGVkXG4gIH1cbiAgdGhpcy5pc05lc3RlZCA9IHRydWU7XG4gIHRoaXMub2JqZWN0X3N0YXJ0ID0gdGhpcy5vZmZzZXQoKTtcbn07XG5cbi8qKlxuICogRmluaXNoIG9mZiB3cml0aW5nIHRoZSBvYmplY3QgdGhhdCBpcyB1bmRlciBjb25zdHJ1Y3Rpb24uXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLk9mZnNldH0gVGhlIG9mZnNldCB0byB0aGUgb2JqZWN0IGluc2lkZSBgZGF0YUJ1ZmZlcmBcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuZW5kT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsIHx8ICF0aGlzLmlzTmVzdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0Jyk7XG4gIH1cblxuICB0aGlzLmFkZEludDMyKDApO1xuICB2YXIgdnRhYmxlbG9jID0gdGhpcy5vZmZzZXQoKTtcblxuICAvLyBUcmltIHRyYWlsaW5nIHplcm9lcy5cbiAgdmFyIGkgPSB0aGlzLnZ0YWJsZV9pbl91c2UgLSAxO1xuICBmb3IgKDsgaSA+PSAwICYmIHRoaXMudnRhYmxlW2ldID09IDA7IGktLSkge31cbiAgdmFyIHRyaW1tZWRfc2l6ZSA9IGkgKyAxO1xuXG4gIC8vIFdyaXRlIG91dCB0aGUgY3VycmVudCB2dGFibGUuXG4gIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgIC8vIE9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlLlxuICAgIHRoaXMuYWRkSW50MTYodGhpcy52dGFibGVbaV0gIT0gMCA/IHZ0YWJsZWxvYyAtIHRoaXMudnRhYmxlW2ldIDogMCk7XG4gIH1cblxuICB2YXIgc3RhbmRhcmRfZmllbGRzID0gMjsgLy8gVGhlIGZpZWxkcyBiZWxvdzpcbiAgdGhpcy5hZGRJbnQxNih2dGFibGVsb2MgLSB0aGlzLm9iamVjdF9zdGFydCk7XG4gIHZhciBsZW4gPSAodHJpbW1lZF9zaXplICsgc3RhbmRhcmRfZmllbGRzKSAqIGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVDtcbiAgdGhpcy5hZGRJbnQxNihsZW4pO1xuXG4gIC8vIFNlYXJjaCBmb3IgYW4gZXhpc3RpbmcgdnRhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBleGlzdGluZ192dGFibGUgPSAwO1xuICB2YXIgdnQxID0gdGhpcy5zcGFjZTtcbm91dGVyX2xvb3A6XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdnQyID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy52dGFibGVzW2ldO1xuICAgIGlmIChsZW4gPT0gdGhpcy5iYi5yZWFkSW50MTYodnQyKSkge1xuICAgICAgZm9yICh2YXIgaiA9IGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVDsgaiA8IGxlbjsgaiArPSBmbGF0YnVmZmVycy5TSVpFT0ZfU0hPUlQpIHtcbiAgICAgICAgaWYgKHRoaXMuYmIucmVhZEludDE2KHZ0MSArIGopICE9IHRoaXMuYmIucmVhZEludDE2KHZ0MiArIGopKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXJfbG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXhpc3RpbmdfdnRhYmxlID0gdGhpcy52dGFibGVzW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXN0aW5nX3Z0YWJsZSkge1xuICAgIC8vIEZvdW5kIGEgbWF0Y2g6XG4gICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jO1xuXG4gICAgLy8gUG9pbnQgdGFibGUgdG8gZXhpc3RpbmcgdnRhYmxlLlxuICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLCBleGlzdGluZ192dGFibGUgLSB2dGFibGVsb2MpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIG1hdGNoOlxuICAgIC8vIEFkZCB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgdnRhYmxlIHRvIHRoZSBsaXN0IG9mIHZ0YWJsZXMuXG4gICAgdGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSk7XG5cbiAgICAvLyBQb2ludCB0YWJsZSB0byBjdXJyZW50IHZ0YWJsZS5cbiAgICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jLCB0aGlzLm9mZnNldCgpIC0gdnRhYmxlbG9jKTtcbiAgfVxuXG4gIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHZ0YWJsZWxvYztcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBGaW5hbGl6ZSBhIGJ1ZmZlciwgcG9pdGluZyB0byB0aGUgZ2l2ZW4gYHJvb3RfdGFibGVgLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSByb290X3RhYmxlXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9maWxlX2lkZW50aWZpZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaXplX3ByZWZpeFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyLCBvcHRfc2l6ZV9wcmVmaXgpIHtcbiAgdmFyIHNpemVfcHJlZml4ID0gb3B0X3NpemVfcHJlZml4ID8gZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIIDogMDtcbiAgaWYgKG9wdF9maWxlX2lkZW50aWZpZXIpIHtcbiAgICB2YXIgZmlsZV9pZGVudGlmaWVyID0gb3B0X2ZpbGVfaWRlbnRpZmllcjtcbiAgICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArXG4gICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIICsgc2l6ZV9wcmVmaXgpO1xuICAgIGlmIChmaWxlX2lkZW50aWZpZXIubGVuZ3RoICE9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcbiAgICAgICAgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMud3JpdGVJbnQ4KGZpbGVfaWRlbnRpZmllci5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcmVwKHRoaXMubWluYWxpZ24sIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgKyBzaXplX3ByZWZpeCk7XG4gIHRoaXMuYWRkT2Zmc2V0KHJvb3RfdGFibGUpO1xuICBpZiAoc2l6ZV9wcmVmaXgpIHtcbiAgICB0aGlzLmFkZEludDMyKHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2UpO1xuICB9XG4gIHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSk7XG59O1xuXG4vKipcbiAqIEZpbmFsaXplIGEgc2l6ZSBwcmVmaXhlZCBidWZmZXIsIHBvaW50aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHJvb3RfdGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2ZpbGVfaWRlbnRpZmllclxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2hTaXplUHJlZml4ZWQgPSBmdW5jdGlvbiAocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICB0aGlzLmZpbmlzaChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyLCB0cnVlKTtcbn07XG5cbi8vLyBAY29uZCBGTEFUQlVGRkVSU19JTlRFUk5BTFxuLyoqXG4gKiBUaGlzIGNoZWNrcyBhIHJlcXVpcmVkIGZpZWxkIGhhcyBiZWVuIHNldCBpbiBhIGdpdmVuIHRhYmxlIHRoYXQgaGFzXG4gKiBqdXN0IGJlZW4gY29uc3RydWN0ZWQuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHRhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUucmVxdWlyZWRGaWVsZCA9IGZ1bmN0aW9uKHRhYmxlLCBmaWVsZCkge1xuICB2YXIgdGFibGVfc3RhcnQgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0YWJsZTtcbiAgdmFyIHZ0YWJsZV9zdGFydCA9IHRhYmxlX3N0YXJ0IC0gdGhpcy5iYi5yZWFkSW50MzIodGFibGVfc3RhcnQpO1xuICB2YXIgb2sgPSB0aGlzLmJiLnJlYWRJbnQxNih2dGFibGVfc3RhcnQgKyBmaWVsZCkgIT0gMDtcblxuICAvLyBJZiB0aGlzIGZhaWxzLCB0aGUgY2FsbGVyIHdpbGwgc2hvdyB3aGF0IGZpZWxkIG5lZWRzIHRvIGJlIHNldC5cbiAgaWYgKCFvaykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpZWxkICcgKyBmaWVsZCArICcgbXVzdCBiZSBzZXQnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBhIG5ldyBhcnJheS92ZWN0b3Igb2Ygb2JqZWN0cy4gIFVzZXJzIHVzdWFsbHkgd2lsbCBub3QgY2FsbFxuICogdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgY3JlYXRlIGEgc3RhcnQvZW5kXG4gKiBtZXRob2QgZm9yIHZlY3RvciB0eXBlcyBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZWxlbV9zaXplIFRoZSBzaXplIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1fZWxlbXMgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudCBvZiB0aGUgYXJyYXlcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRWZWN0b3IgPSBmdW5jdGlvbihlbGVtX3NpemUsIG51bV9lbGVtcywgYWxpZ25tZW50KSB7XG4gIHRoaXMubm90TmVzdGVkKCk7XG4gIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IG51bV9lbGVtcztcbiAgdGhpcy5wcmVwKGZsYXRidWZmZXJzLlNJWkVPRl9JTlQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7XG4gIHRoaXMucHJlcChhbGlnbm1lbnQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7IC8vIEp1c3QgaW4gY2FzZSBhbGlnbm1lbnQgPiBpbnQuXG59O1xuXG4vKipcbiAqIEZpbmlzaCBvZmYgdGhlIGNyZWF0aW9uIG9mIGFuIGFycmF5IGFuZCBhbGwgaXRzIGVsZW1lbnRzLiBUaGUgYXJyYXkgbXVzdCBiZVxuICogY3JlYXRlZCB3aXRoIGBzdGFydFZlY3RvcmAuXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLk9mZnNldH0gVGhlIG9mZnNldCBhdCB3aGljaCB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxuICogc3RhcnRzLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5lbmRWZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyk7XG4gIHJldHVybiB0aGlzLm9mZnNldCgpO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiBhIFVpbnQ4QXJyYXkgaXMgcGFzc2VkXG4gKiBpbnN0ZWFkIG9mIGEgc3RyaW5nLCBpdCBpcyBhc3N1bWVkIHRvIGNvbnRhaW4gdmFsaWQgVVRGLTggZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHMgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge2ZsYXRidWZmZXJzLk9mZnNldH0gVGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBlbmNvZGVkIHN0cmluZyBzdGFydHNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nID0gZnVuY3Rpb24ocykge1xuICBpZiAocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgdXRmOCA9IHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHV0ZjggPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHMubGVuZ3RoKSB7XG4gICAgICB2YXIgY29kZVBvaW50O1xuXG4gICAgICAvLyBEZWNvZGUgVVRGLTE2XG4gICAgICB2YXIgYSA9IHMuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGEgPCAweEQ4MDAgfHwgYSA+PSAweERDMDApIHtcbiAgICAgICAgY29kZVBvaW50ID0gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNvZGVQb2ludCA9IChhIDw8IDEwKSArIGIgKyAoMHgxMDAwMCAtICgweEQ4MDAgPDwgMTApIC0gMHhEQzAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5jb2RlIFVURi04XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICB1dGY4LnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goXG4gICAgICAgICAgICAgICgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCxcbiAgICAgICAgICAgICAgKChjb2RlUG9pbnQgPj4gMTIpICYgMHgzRikgfCAweDgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgzRikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICB1dGY4LnB1c2goKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hZGRJbnQ4KDApO1xuICB0aGlzLnN0YXJ0VmVjdG9yKDEsIHV0ZjgubGVuZ3RoLCAxKTtcbiAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlIC09IHV0ZjgubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZnNldCA9IHRoaXMuc3BhY2UsIGJ5dGVzID0gdGhpcy5iYi5ieXRlcygpOyBpIDwgdXRmOC5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHV0ZjhbaV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuZW5kVmVjdG9yKCk7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGF2b2lkIGdlbmVyYXRlZCBjb2RlIGRlcGVuZGluZyBvbiB0aGlzIGZpbGUgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICByZXR1cm4gZmxhdGJ1ZmZlcnMuTG9uZy5jcmVhdGUobG93LCBoaWdoKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBhcnJheSBvZiBieXRlcyAoYFVpbnQ4QXJyYXlgKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYnl0ZXNfID0gYnl0ZXM7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgYWxsb2NhdGUgYSBuZXcgQnl0ZUJ1ZmZlciB3aXRoIGEgZ2l2ZW4gc2l6ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZV9zaXplXG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUgPSBmdW5jdGlvbihieXRlX3NpemUpIHtcbiAgcmV0dXJuIG5ldyBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ5dGVfc2l6ZSkpO1xufTtcblxuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wb3NpdGlvbl8gPSAwO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVuZGVybHlpbmcgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ieXRlc187XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucG9zaXRpb25fO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGJ1ZmZlcidzIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gIHRoaXMucG9zaXRpb25fID0gcG9zaXRpb247XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnVmZmVyJ3MgY2FwYWNpdHkuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY2FwYWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KG9mZnNldCkgPDwgMjQgPj4gMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLnJlYWRVaW50MTYob2Zmc2V0KSA8PCAxNiA+PiAxNjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDggfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDNdIDw8IDI0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLnJlYWRJbnQzMihvZmZzZXQpID4+PiAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkxvbmcodGhpcy5yZWFkSW50MzIob2Zmc2V0KSwgdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIG5ldyBmbGF0YnVmZmVycy5Mb25nKHRoaXMucmVhZFVpbnQzMihvZmZzZXQpLCB0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBmbGF0YnVmZmVycy5pbnQzMlswXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gIHJldHVybiBmbGF0YnVmZmVycy5mbG9hdDMyWzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gIGZsYXRidWZmZXJzLmludDMyW2ZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID8gMSA6IDBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCk7XG4gIHJldHVybiBmbGF0YnVmZmVycy5mbG9hdDY0WzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcnxib29sZWFufSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIHRoaXMuYnl0ZXNfW29mZnNldF0gPSAvKiogQHR5cGUge251bWJlcn0gKi8odmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPSB2YWx1ZSA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCB2YWx1ZS5sb3cpO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0ICsgNCwgdmFsdWUuaGlnaCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQsIHZhbHVlLmxvdyk7XG4gICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgZmxhdGJ1ZmZlcnMuZmxvYXQzMlswXSA9IHZhbHVlO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBmbGF0YnVmZmVycy5pbnQzMlswXSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIGZsYXRidWZmZXJzLmZsb2F0NjRbMF0gPSB2YWx1ZTtcbiAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAwIDogMV0pO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0ICsgNCwgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpbGUgaWRlbnRpZmllci4gICBCZWhhdmlvciBpcyB1bmRlZmluZWQgZm9yIEZsYXRCdWZmZXJzIHdob3NlXG4gKiBzY2hlbWEgZG9lcyBub3QgaW5jbHVkZSBhIGZpbGVfaWRlbnRpZmllciAobGlrZWx5IHBvaW50cyBhdCBwYWRkaW5nIG9yIHRoZVxuICogc3RhcnQgb2YgYSB0aGUgcm9vdCB2dGFibGUpLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuZ2V0QnVmZmVySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5ieXRlc18ubGVuZ3RoIDwgdGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICtcbiAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLicpO1xuICB9XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fICsgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBMb29rIHVwIGEgZmllbGQgaW4gdGhlIHZ0YWJsZSwgcmV0dXJuIGFuIG9mZnNldCBpbnRvIHRoZSBvYmplY3QsIG9yIDAgaWYgdGhlXG4gKiBmaWVsZCBpcyBub3QgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYmJfcG9zXG4gKiBAcGFyYW0ge251bWJlcn0gdnRhYmxlX29mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19vZmZzZXQgPSBmdW5jdGlvbihiYl9wb3MsIHZ0YWJsZV9vZmZzZXQpIHtcbiAgdmFyIHZ0YWJsZSA9IGJiX3BvcyAtIHRoaXMucmVhZEludDMyKGJiX3Bvcyk7XG4gIHJldHVybiB2dGFibGVfb2Zmc2V0IDwgdGhpcy5yZWFkSW50MTYodnRhYmxlKSA/IHRoaXMucmVhZEludDE2KHZ0YWJsZSArIHZ0YWJsZV9vZmZzZXQpIDogMDtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhbnkgVGFibGUtZGVyaXZlZCB0eXBlIHRvIHBvaW50IHRvIHRoZSB1bmlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuVGFibGV9IHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtmbGF0YnVmZmVycy5UYWJsZX1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX191bmlvbiA9IGZ1bmN0aW9uKHQsIG9mZnNldCkge1xuICB0LmJiX3BvcyA9IG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gIHQuYmIgPSB0aGlzO1xuICByZXR1cm4gdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgSmF2YVNjcmlwdCBzdHJpbmcgZnJvbSBVVEYtOCBkYXRhIHN0b3JlZCBpbnNpZGUgdGhlIEZsYXRCdWZmZXIuXG4gKiBUaGlzIGFsbG9jYXRlcyBhIG5ldyBzdHJpbmcgYW5kIGNvbnZlcnRzIHRvIHdpZGUgY2hhcnMgdXBvbiBlYWNoIGFjY2Vzcy5cbiAqXG4gKiBUbyBhdm9pZCB0aGUgY29udmVyc2lvbiB0byBVVEYtMTYsIHBhc3MgZmxhdGJ1ZmZlcnMuRW5jb2RpbmcuVVRGOF9CWVRFUyBhc1xuICogdGhlIFwib3B0aW9uYWxFbmNvZGluZ1wiIGFyZ3VtZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmcgY29udmVyc2lvbiB0b1xuICogYW5kIGZyb20gVVRGLTE2IHdoZW4gdGhlIGRhdGEgd2lsbCBqdXN0IGJlIHBhY2thZ2VkIGJhY2sgdXAgaW4gYW5vdGhlclxuICogRmxhdEJ1ZmZlciBsYXRlciBvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkVuY29kaW5nPX0gb3B0X2VuY29kaW5nIERlZmF1bHRzIHRvIFVURjE2X1NUUklOR1xuICogQHJldHVybnMge3N0cmluZ3whVWludDhBcnJheX1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19zdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQsIG9wdF9lbmNvZGluZykge1xuICBvZmZzZXQgKz0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcblxuICB2YXIgbGVuZ3RoID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgaSA9IDA7XG5cbiAgb2Zmc2V0ICs9IGZsYXRidWZmZXJzLlNJWkVPRl9JTlQ7XG5cbiAgaWYgKG9wdF9lbmNvZGluZyA9PT0gZmxhdGJ1ZmZlcnMuRW5jb2RpbmcuVVRGOF9CWVRFUykge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzXy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gIH1cblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBjb2RlUG9pbnQ7XG5cbiAgICAvLyBEZWNvZGUgVVRGLThcbiAgICB2YXIgYSA9IHRoaXMucmVhZFVpbnQ4KG9mZnNldCArIGkrKyk7XG4gICAgaWYgKGEgPCAweEMwKSB7XG4gICAgICBjb2RlUG9pbnQgPSBhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYiA9IHRoaXMucmVhZFVpbnQ4KG9mZnNldCArIGkrKyk7XG4gICAgICBpZiAoYSA8IDB4RTApIHtcbiAgICAgICAgY29kZVBvaW50ID1cbiAgICAgICAgICAoKGEgJiAweDFGKSA8PCA2KSB8XG4gICAgICAgICAgKGIgJiAweDNGKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgICAgaWYgKGEgPCAweEYwKSB7XG4gICAgICAgICAgY29kZVBvaW50ID1cbiAgICAgICAgICAgICgoYSAmIDB4MEYpIDw8IDEyKSB8XG4gICAgICAgICAgICAoKGIgJiAweDNGKSA8PCA2KSB8XG4gICAgICAgICAgICAoYyAmIDB4M0YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICAgKChhICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICgoYiAmIDB4M0YpIDw8IDEyKSB8XG4gICAgICAgICAgICAoKGMgJiAweDNGKSA8PCA2KSB8XG4gICAgICAgICAgICAoZCAmIDB4M0YpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5jb2RlIFVURi0xNlxuICAgIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMCxcbiAgICAgICAgKGNvZGVQb2ludCAmICgoMSA8PCAxMCkgLSAxKSkgKyAweERDMDApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSByZWxhdGl2ZSBvZmZzZXQgc3RvcmVkIGF0IFwib2Zmc2V0XCJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faW5kaXJlY3QgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3RhcnQgb2YgZGF0YSBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3IgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCkgKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UOyAvLyBkYXRhIHN0YXJ0cyBhZnRlciB0aGUgbGVuZ3RoXG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcl9sZW4gPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2hhc19pZGVudGlmaWVyID0gZnVuY3Rpb24oaWRlbnQpIHtcbiAgaWYgKGlkZW50Lmxlbmd0aCAhPSBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICAgICAgICAgICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgIGlmIChpZGVudC5jaGFyQ29kZUF0KGkpICE9IHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICsgaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGF2b2lkIGdlbmVyYXRlZCBjb2RlIGRlcGVuZGluZyBvbiB0aGlzIGZpbGUgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY3JlYXRlTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICByZXR1cm4gZmxhdGJ1ZmZlcnMuTG9uZy5jcmVhdGUobG93LCBoaWdoKTtcbn07XG5cbi8vIEV4cG9ydHMgZm9yIE5vZGUuanMgYW5kIFJlcXVpcmVKU1xuZXhwb3J0IHsgZmxhdGJ1ZmZlcnMgfTtcblxuLy8vIEBlbmRjb25kXG4vLy8gQH1cbiIsIlwidXNlIHN0cmljdFwiO1xyXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG52YXIgR3VpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEd1aWQoZ3VpZCkge1xyXG4gICAgICAgIGlmICghZ3VpZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gR3VpZC5FTVBUWTtcclxuICAgICAgICBpZiAoZ3VpZCAmJiBHdWlkLmlzR3VpZChndWlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZ3VpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBHdWlkLmlzR3VpZCA9IGZ1bmN0aW9uIChndWlkKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZ3VpZC50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiBndWlkICYmIChndWlkIGluc3RhbmNlb2YgR3VpZCB8fCBHdWlkLnZhbGlkYXRvci50ZXN0KHZhbHVlKSk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWlkKFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpKTtcclxuICAgIH07XHJcbiAgICBHdWlkLmNyZWF0ZUVtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3VpZChcImVtcHR5Z3VpZFwiKTtcclxuICAgIH07XHJcbiAgICBHdWlkLnBhcnNlID0gZnVuY3Rpb24gKGd1aWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEd1aWQoZ3VpZCk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5yYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtHdWlkLmdlbigyKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMyldLmpvaW4oXCItXCIpO1xyXG4gICAgfTtcclxuICAgIEd1aWQuZ2VuID0gZnVuY3Rpb24gKGNvdW50KSB7XHJcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIG91dCArPSAoKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKSB8IDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgLy8gQ29tcGFyaW5nIHN0cmluZyBgdmFsdWVgIGFnYWluc3QgcHJvdmlkZWQgYGd1aWRgIHdpbGwgYXV0by1jYWxsXHJcbiAgICAgICAgLy8gdG9TdHJpbmcgb24gYGd1aWRgIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgcmV0dXJuIEd1aWQuaXNHdWlkKG90aGVyKSAmJiB0aGlzLnZhbHVlID09PSBvdGhlci50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IEd1aWQuRU1QVFk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBHdWlkLnZhbGlkYXRvciA9IG5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLCBcImlcIik7XHJcbiAgICBHdWlkLkVNUFRZID0gXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIjtcclxuICAgIHJldHVybiBHdWlkO1xyXG59KCkpO1xyXG5leHBvcnRzLkd1aWQgPSBHdWlkO1xyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IExvbmc7XHJcblxyXG4vKipcclxuICogd2FzbSBvcHRpbWl6YXRpb25zLCB0byBkbyBuYXRpdmUgaTY0IG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpZGVcclxuICovXHJcbnZhciB3YXNtID0gbnVsbDtcclxuXHJcbnRyeSB7XHJcbiAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFtcclxuICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXHJcbiAgXSkpLCB7fSkuZXhwb3J0cztcclxufSBjYXRjaCAoZSkge1xyXG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cclxuICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAqIEBleHBvcnRzIExvbmdcclxuICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcclxufVxyXG5cclxuLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cclxuLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcclxuLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbi8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcclxuLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcclxuLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbi8vXHJcbi8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcclxuLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbi8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxyXG4vLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXHJcbi8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4vL1xyXG4vLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cclxuXHJcbi8qKlxyXG4gKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAY29uc3RcclxuICogQHByaXZhdGVcclxuICovXHJcbkxvbmcucHJvdG90eXBlLl9faXNMb25nX187XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XHJcbiAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUludCA9IGZyb21JbnQ7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgaWYgKGlzTmFOKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKCh2YWx1ZSAlIFRXT19QV1JfMzJfREJMKSB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcclxuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcclxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcclxuICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIilcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcclxuICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICB9XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcblxyXG4gICAgdmFyIHA7XHJcbiAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xyXG4gICAgZWxzZSBpZiAocCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFpFUk87XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XHJcbiAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpO1xyXG4gICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcclxuXHJcbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcclxuLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBaRVJPID0gZnJvbUludCgwKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5aRVJPID0gWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlVaRVJPID0gVVpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBPTkUgPSBmcm9tSW50KDEpO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuT05FID0gT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlVPTkUgPSBVT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTkVHX09ORSA9IE5FR19PTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4N0ZGRkZGRkZ8MCwgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHhGRkZGRkZGRnwwLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQG92ZXJyaWRlXHJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiAnMCc7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcclxuICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXHJcbiAgICAgICAgcmVtID0gdGhpcztcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgIGlmIChyZW0uaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcclxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcclxuICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcclxuICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy5lcShvdGhlcikpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxyXG4gICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xyXG4gICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cclxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcclxuICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XHJcblxyXG4gICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcclxuICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKVxyXG4gICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSB3YXNtLm11bCh0aGlzLmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5oaWdoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcblxyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcclxuXHJcbiAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XHJcblxyXG4gICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKiBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMzIgKiBiMDA7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEwMCAqIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXHJcbiAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcclxuICAgICAgICB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICByZXMgPSBaRVJPO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXHJcbiAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICByZXR1cm4gVU9ORTtcclxuICAgICAgICByZXMgPSBVWkVSTztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xyXG4gICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXHJcbiAgICByZW0gPSB0aGlzO1xyXG4gICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcclxuICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXHJcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXHJcbiAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgIGRlbHRhID0gKGxvZzIgPD0gNDgpID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcclxuXHJcbiAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcclxuICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xyXG4gICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgaWYgKG51bUJpdHMgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHtcclxuICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xyXG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDI0XHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xyXG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGhpID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBsbyA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZlxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcclxuICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzBdICAgICAgIHxcclxuICAgICAgICBieXRlc1sxXSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzNdIDw8IDI0LFxyXG4gICAgICAgIGJ5dGVzWzRdICAgICAgIHxcclxuICAgICAgICBieXRlc1s1XSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzddIDw8IDI0LFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbNF0gPDwgMjQgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbN10sXHJcbiAgICAgICAgYnl0ZXNbMF0gPDwgMjQgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1syXSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbM10sXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcbiIsIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIik7XG5cbi8vIENvbW1vbiBhbGlhc2VzXG52YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xuXG4vLyBFeHBvcnRlZCByb290IG5hbWVzcGFjZVxudmFyICRyb290ID0gJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSA9IHt9KTtcblxuJHJvb3Qub25ueCA9IChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZSBvbm54LlxuICAgICAqIEBleHBvcnRzIG9ubnhcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgdmFyIG9ubnggPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFZlcnNpb24gZW51bS5cbiAgICAgKiBAbmFtZSBvbm54LlZlcnNpb25cbiAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfU1RBUlRfVkVSU0lPTj0wIF9TVEFSVF9WRVJTSU9OIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxN18xMF8xMD0xIElSX1ZFUlNJT05fMjAxN18xMF8xMCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTdfMTBfMzA9MiBJUl9WRVJTSU9OXzIwMTdfMTBfMzAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE3XzExXzM9MyBJUl9WRVJTSU9OXzIwMTdfMTFfMyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfMV8yMj00IElSX1ZFUlNJT05fMjAxOV8xXzIyIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT049NSBJUl9WRVJTSU9OIHZhbHVlXG4gICAgICovXG4gICAgb25ueC5WZXJzaW9uID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiX1NUQVJUX1ZFUlNJT05cIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiSVJfVkVSU0lPTl8yMDE3XzEwXzEwXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIklSX1ZFUlNJT05fMjAxN18xMF8zMFwiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJJUl9WRVJTSU9OXzIwMTdfMTFfM1wiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJJUl9WRVJTSU9OXzIwMTlfMV8yMlwiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJJUl9WRVJTSU9OXCJdID0gNTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5BdHRyaWJ1dGVQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBBdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIEF0dHJpYnV0ZVByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3JlZkF0dHJOYW1lXSBBdHRyaWJ1dGVQcm90byByZWZBdHRyTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBBdHRyaWJ1dGVQcm90byBkb2NTdHJpbmdcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGV8bnVsbH0gW3R5cGVdIEF0dHJpYnV0ZVByb3RvIHR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2ZdIEF0dHJpYnV0ZVByb3RvIGZcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbaV0gQXR0cmlidXRlUHJvdG8gaVxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3NdIEF0dHJpYnV0ZVByb3RvIHNcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbdF0gQXR0cmlidXRlUHJvdG8gdFxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSUdyYXBoUHJvdG98bnVsbH0gW2ddIEF0dHJpYnV0ZVByb3RvIGdcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZmxvYXRzXSBBdHRyaWJ1dGVQcm90byBmbG9hdHNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtpbnRzXSBBdHRyaWJ1dGVQcm90byBpbnRzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPFVpbnQ4QXJyYXk+fG51bGx9IFtzdHJpbmdzXSBBdHRyaWJ1dGVQcm90byBzdHJpbmdzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPnxudWxsfSBbdGVuc29yc10gQXR0cmlidXRlUHJvdG8gdGVuc29yc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPnxudWxsfSBbZ3JhcGhzXSBBdHRyaWJ1dGVQcm90byBncmFwaHNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQXR0cmlidXRlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBBdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byByZWZBdHRyTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSByZWZBdHRyTmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5yZWZBdHRyTmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGRvY1N0cmluZy5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gdHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlfSB0eXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnR5cGUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBmLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGkuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBpXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmkgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gcy5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5zID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gdC5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yUHJvdG98bnVsbHx1bmRlZmluZWR9IHRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGcuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSUdyYXBoUHJvdG98bnVsbHx1bmRlZmluZWR9IGdcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGZsb2F0cy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGZsb2F0c1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5mbG9hdHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBpbnRzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBpbnRzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmludHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBzdHJpbmdzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48VWludDhBcnJheT59IHN0cmluZ3NcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuc3RyaW5ncyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHRlbnNvcnMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUZW5zb3JQcm90bz59IHRlbnNvcnNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudGVuc29ycyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIGdyYXBocy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUdyYXBoUHJvdG8+fSBncmFwaHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZ3JhcGhzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBBdHRyaWJ1dGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklBdHRyaWJ1dGVQcm90b30gbWVzc2FnZSBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZlwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDUgPSovMjEpLmZsb2F0KG1lc3NhZ2UuZik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQ2NChtZXNzYWdlLmkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuYnl0ZXMobWVzc2FnZS5zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLmVuY29kZShtZXNzYWdlLnQsIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki80MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ1wiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZywgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXRzICE9IG51bGwgJiYgbWVzc2FnZS5mbG9hdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLzU4KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmZsb2F0KG1lc3NhZ2UuZmxvYXRzW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnRzICE9IG51bGwgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82NikuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50NjQobWVzc2FnZS5pbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5ieXRlcyhtZXNzYWdlLnN0cmluZ3NbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29ycyAhPSBudWxsICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UudGVuc29yc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmdyYXBocyAhPSBudWxsICYmIG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZ3JhcGhzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuZ3JhcGhzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLzEwNikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIwLCB3aXJlVHlwZSAwID0qLzE2MCkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjEsIHdpcmVUeXBlIDIgPSovMTcwKS5zdHJpbmcobWVzc2FnZS5yZWZBdHRyTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQXR0cmlidXRlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG99IG1lc3NhZ2UgQXR0cmlidXRlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhbiBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlZkF0dHJOYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZmxvYXRzICYmIG1lc3NhZ2UuZmxvYXRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnRzICYmIG1lc3NhZ2UuaW50cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5ncyAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3MucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudGVuc29ycyAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvcnMucHVzaCgkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmdyYXBocyAmJiBtZXNzYWdlLmdyYXBocy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHMucHVzaCgkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gQXR0cmlidXRlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5BdHRyaWJ1dGVQcm90b30gQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYW4gQXR0cmlidXRlUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yZWZBdHRyTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyZWZBdHRyTmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucmVmQXR0ck5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyZWZBdHRyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmYgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImY6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaSkgJiYgIShtZXNzYWdlLmkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnMgJiYgdHlwZW9mIG1lc3NhZ2Uucy5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInM6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5nKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImcuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmbG9hdHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZsb2F0c1tpXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0czogbnVtYmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50c1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmludHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0pICYmICEobWVzc2FnZS5pbnRzW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRzW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludHM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJpbmdzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdzW2ldICYmIHR5cGVvZiBtZXNzYWdlLnN0cmluZ3NbaV0ubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nc1tpXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nczogYnVmZmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVuc29yc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlbnNvcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JhcGhzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZ3JhcGhzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmdyYXBoc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImdyYXBocy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVmQXR0ck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlZkF0dHJOYW1lID0gU3RyaW5nKG9iamVjdC5yZWZBdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlVOREVGSU5FRFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRkxPQVRcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIklOVFwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU1RSSU5HXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJURU5TT1JcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkdSQVBIXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGTE9BVFNcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIklOVFNcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNUUklOR1NcIjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRFTlNPUlNcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkdSQVBIU1wiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZiA9IE51bWJlcihvYmplY3QuZik7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IHBhcnNlSW50KG9iamVjdC5pLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmkgPSBvYmplY3QuaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaS5sb3cgPj4+IDAsIG9iamVjdC5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zLCBtZXNzYWdlLnMgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucykpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucyA9IG9iamVjdC5zO1xuICAgICAgICAgICAgaWYgKG9iamVjdC50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KG9iamVjdC50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZmxvYXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5mbG9hdHMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5mbG9hdHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0c1tpXSA9IE51bWJlcihvYmplY3QuZmxvYXRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuaW50cykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuaW50cykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmludHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaW50c1tpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pbnRzW2ldKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRzW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzW2ldID0gcGFyc2VJbnQob2JqZWN0LmludHNbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRzW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzW2ldID0gb2JqZWN0LmludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50c1tpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50c1tpXSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaW50c1tpXS5sb3cgPj4+IDAsIG9iamVjdC5pbnRzW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnN0cmluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnN0cmluZ3MpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zdHJpbmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJpbmdzW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3Quc3RyaW5nc1tpXSwgbWVzc2FnZS5zdHJpbmdzW2ldID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LnN0cmluZ3NbaV0pKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5zdHJpbmdzW2ldLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nc1tpXSA9IG9iamVjdC5zdHJpbmdzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC50ZW5zb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50ZW5zb3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50ZW5zb3JzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvcnNbaV0gPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnRlbnNvcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZ3JhcGhzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5ncmFwaHMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhcGhzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZ3JhcGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmdyYXBoc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBoc1tpXSA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ncmFwaHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYW4gQXR0cmlidXRlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguQXR0cmlidXRlUHJvdG99IG1lc3NhZ2UgQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZ3JhcGhzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZiA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnMgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucyA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3Qucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdC50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QuZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIlVOREVGSU5FRFwiIDogMDtcbiAgICAgICAgICAgICAgICBvYmplY3QucmVmQXR0ck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5mID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmYpID8gU3RyaW5nKG1lc3NhZ2UuZikgOiBtZXNzYWdlLmY7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaSkgOiBtZXNzYWdlLmk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5pKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmkubG93ID4+PiAwLCBtZXNzYWdlLmkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuaTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucyA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zLCAwLCBtZXNzYWdlLnMubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5zKSA6IG1lc3NhZ2UucztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZyA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXRzICYmIG1lc3NhZ2UuZmxvYXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXRzW2pdID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmZsb2F0c1tqXSkgPyBTdHJpbmcobWVzc2FnZS5mbG9hdHNbal0pIDogbWVzc2FnZS5mbG9hdHNbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnRzICYmIG1lc3NhZ2UuaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50c1tqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnRzW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaW50c1tqXSkgOiBtZXNzYWdlLmludHNbal07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnRzW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmludHNbal0pIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaW50c1tqXS5sb3cgPj4+IDAsIG1lc3NhZ2UuaW50c1tqXS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5ncyAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ3Nbal0gPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uuc3RyaW5nc1tqXSwgMCwgbWVzc2FnZS5zdHJpbmdzW2pdLmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2Uuc3RyaW5nc1tqXSkgOiBtZXNzYWdlLnN0cmluZ3Nbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JzICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudGVuc29yc1tqXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS50ZW5zb3JzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmdyYXBocyAmJiBtZXNzYWdlLmdyYXBocy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZ3JhcGhzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmdyYXBocy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBoc1tqXSA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmdyYXBoc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVttZXNzYWdlLnR5cGVdIDogbWVzc2FnZS50eXBlO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlZkF0dHJOYW1lID0gbWVzc2FnZS5yZWZBdHRyTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQXR0cmlidXRlUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVUeXBlIGVudW0uXG4gICAgICAgICAqIEBuYW1lIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVxuICAgICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVU5ERUZJTkVEPTAgVU5ERUZJTkVEIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGTE9BVD0xIEZMT0FUIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQ9MiBJTlQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklORz0zIFNUUklORyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVEVOU09SPTQgVEVOU09SIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBHUkFQSD01IEdSQVBIIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGTE9BVFM9NiBGTE9BVFMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVFM9NyBJTlRTIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkdTPTggU1RSSU5HUyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVEVOU09SUz05IFRFTlNPUlMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdSQVBIUz0xMCBHUkFQSFMgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIlVOREVGSU5FRFwiXSA9IDA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiRkxPQVRcIl0gPSAxO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIklOVFwiXSA9IDI7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiU1RSSU5HXCJdID0gMztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJURU5TT1JcIl0gPSA0O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIkdSQVBIXCJdID0gNTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJGTE9BVFNcIl0gPSA2O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklOVFNcIl0gPSA3O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIlNUUklOR1NcIl0gPSA4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIlRFTlNPUlNcIl0gPSA5O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJHUkFQSFNcIl0gPSAxMDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZVByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlZhbHVlSW5mb1Byb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBWYWx1ZUluZm9Qcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0eXBlXSBWYWx1ZUluZm9Qcm90byB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIFZhbHVlSW5mb1Byb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBWYWx1ZUluZm9Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklWYWx1ZUluZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmFsdWVJbmZvUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZUluZm9Qcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlSW5mb1Byb3RvIHR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS50eXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVJbmZvUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZUluZm9Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLmVuY29kZShtZXNzYWdlLnR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZhbHVlSW5mb1Byb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVmFsdWVJbmZvUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguTm9kZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTm9kZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElOb2RlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPnxudWxsfSBbaW5wdXRdIE5vZGVQcm90byBpbnB1dFxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtvdXRwdXRdIE5vZGVQcm90byBvdXRwdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIE5vZGVQcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtvcFR5cGVdIE5vZGVQcm90byBvcFR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gTm9kZVByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz58bnVsbH0gW2F0dHJpYnV0ZV0gTm9kZVByb3RvIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBOb2RlUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE5vZGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTm9kZVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJTm9kZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTm9kZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBpbnB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG91dHB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IG91dHB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLm91dHB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG9wVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBvcFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5vcFR5cGUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gZG9tYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz59IGF0dHJpYnV0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmF0dHJpYnV0ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBOb2RlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTm9kZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTm9kZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovMzQpLnN0cmluZyhtZXNzYWdlLm9wVHlwZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5lbmNvZGUobWVzc2FnZS5hdHRyaWJ1dGVbaV0sIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki80MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTm9kZVByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTm9kZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE5vZGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk5vZGVQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vcFR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlLnB1c2goJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE5vZGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Ob2RlUHJvdG99IE5vZGVQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBOb2RlUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuaW5wdXRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uub3V0cHV0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3V0cHV0OiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5vdXRwdXRbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3V0cHV0OiBzdHJpbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5vcFR5cGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcFR5cGU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhdHRyaWJ1dGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeShtZXNzYWdlLmF0dHJpYnV0ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIE5vZGVQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguTm9kZVByb3RvfSBOb2RlUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54Lk5vZGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Ob2RlUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmlucHV0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXRbaV0gPSBTdHJpbmcob2JqZWN0LmlucHV0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Qub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXRbaV0gPSBTdHJpbmcob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5vcFR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm9wVHlwZSA9IFN0cmluZyhvYmplY3Qub3BUeXBlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9tYWluICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSBTdHJpbmcob2JqZWN0LmRvbWFpbik7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuYXR0cmlidXRlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYXR0cmlidXRlW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVtpXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYXR0cmlidXRlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIE5vZGVQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BUeXBlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXRbal0gPSBtZXNzYWdlLmlucHV0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0W2pdID0gbWVzc2FnZS5vdXRwdXRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcFR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5vcFR5cGUgPSBtZXNzYWdlLm9wVHlwZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QobWVzc2FnZS5hdHRyaWJ1dGVbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgTm9kZVByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBOb2RlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguTW9kZWxQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIE1vZGVsUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSU1vZGVsUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbaXJWZXJzaW9uXSBNb2RlbFByb3RvIGlyVmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gTW9kZWxQcm90byBvcHNldEltcG9ydFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcHJvZHVjZXJOYW1lXSBNb2RlbFByb3RvIHByb2R1Y2VyTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcHJvZHVjZXJWZXJzaW9uXSBNb2RlbFByb3RvIHByb2R1Y2VyVmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBNb2RlbFByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFttb2RlbFZlcnNpb25dIE1vZGVsUHJvdG8gbW9kZWxWZXJzaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIE1vZGVsUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ3JhcGhdIE1vZGVsUHJvdG8gZ3JhcGhcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz58bnVsbH0gW21ldGFkYXRhUHJvcHNdIE1vZGVsUHJvdG8gbWV0YWRhdGFQcm9wc1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNb2RlbFByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBNb2RlbFByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJTW9kZWxQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklNb2RlbFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBNb2RlbFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGlyVmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGlyVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuaXJWZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gb3BzZXRJbXBvcnQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fSBvcHNldEltcG9ydFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUub3BzZXRJbXBvcnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIHByb2R1Y2VyTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9kdWNlck5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLnByb2R1Y2VyTmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gcHJvZHVjZXJWZXJzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb2R1Y2VyVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUucHJvZHVjZXJWZXJzaW9uID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBkb21haW4uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5kb21haW4gPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIG1vZGVsVmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IG1vZGVsVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUubW9kZWxWZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBncmFwaC5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gZ3JhcGhcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmdyYXBoID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBtZXRhZGF0YVByb3BzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IG1ldGFkYXRhUHJvcHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLm1ldGFkYXRhUHJvcHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IE1vZGVsUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguTW9kZWxQcm90b30gTW9kZWxQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbFByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTW9kZWxQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk1vZGVsUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90b30gbWVzc2FnZSBNb2RlbFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaXJWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5pclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLnByb2R1Y2VyTmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuc3RyaW5nKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubW9kZWxWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDAgPSovNDApLmludDY0KG1lc3NhZ2UubW9kZWxWZXJzaW9uKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5HcmFwaFByb3RvLmVuY29kZShtZXNzYWdlLmdyYXBoLCB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAhPSBudWxsICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0sIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgIT0gbnVsbCAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTW9kZWxQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk1vZGVsUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90b30gbWVzc2FnZSBNb2RlbFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTW9kZWxQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlyVmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3BzZXRJbXBvcnQgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0LnB1c2goJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlclZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHMucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uKSAmJiAhKG1lc3NhZ2UuaXJWZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmlyVmVyc2lvbi5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlyVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeShtZXNzYWdlLm9wc2V0SW1wb3J0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BzZXRJbXBvcnQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcm9kdWNlck5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9kdWNlck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJvZHVjZXJWZXJzaW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uKSAmJiAhKG1lc3NhZ2UubW9kZWxWZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1vZGVsVmVyc2lvbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLm1vZGVsVmVyc2lvbi5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1vZGVsVmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JhcGhcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KG1lc3NhZ2UuZ3JhcGgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JhcGguXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm1ldGFkYXRhUHJvcHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkobWVzc2FnZS5tZXRhZGF0YVByb3BzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibWV0YWRhdGFQcm9wcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgTW9kZWxQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5Nb2RlbFByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk1vZGVsUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaXJWZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmlyVmVyc2lvbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pclZlcnNpb24pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlyVmVyc2lvbiA9IHBhcnNlSW50KG9iamVjdC5pclZlcnNpb24sIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBvYmplY3QuaXJWZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaXJWZXJzaW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlyVmVyc2lvbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaXJWZXJzaW9uLmxvdyA+Pj4gMCwgb2JqZWN0LmlyVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5vcHNldEltcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3BzZXRJbXBvcnQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3BzZXRJbXBvcnRbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KG9iamVjdC5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5wcm9kdWNlck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByb2R1Y2VyTmFtZSA9IFN0cmluZyhvYmplY3QucHJvZHVjZXJOYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucHJvZHVjZXJWZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlclZlcnNpb24gPSBTdHJpbmcob2JqZWN0LnByb2R1Y2VyVmVyc2lvbik7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvbWFpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5tb2RlbFZlcnNpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0Lm1vZGVsVmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5tb2RlbFZlcnNpb24gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gcGFyc2VJbnQob2JqZWN0Lm1vZGVsVmVyc2lvbiwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QubW9kZWxWZXJzaW9uID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9IG9iamVjdC5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5tb2RlbFZlcnNpb24gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9kZWxWZXJzaW9uID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5tb2RlbFZlcnNpb24ubG93ID4+PiAwLCBvYmplY3QubW9kZWxWZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5ncmFwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZ3JhcGggIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZ3JhcGg6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubWV0YWRhdGFQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QubWV0YWRhdGFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubWV0YWRhdGFQcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5tZXRhZGF0YVByb3BzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5tZXRhZGF0YVByb3BzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTW9kZWxQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54Lk1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pclZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pclZlcnNpb24pIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXJWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmlyVmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pclZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLmlyVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wcm9kdWNlck5hbWUgPSBtZXNzYWdlLnByb2R1Y2VyTmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9IG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tb2RlbFZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5tb2RlbFZlcnNpb24pIDogbWVzc2FnZS5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLm1vZGVsVmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5tb2RlbFZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLm1vZGVsVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnRbal0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChtZXNzYWdlLm9wc2V0SW1wb3J0W2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE1vZGVsUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gTW9kZWxQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBba2V5XSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGtleVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdmFsdWVdIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gdmFsdWVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3RyaW5nU3RyaW5nRW50cnlQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nU3RyaW5nRW50cnlQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ga2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGtleVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5wcm90b3R5cGUua2V5ID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nU3RyaW5nRW50cnlQcm90byB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5wcm90b3R5cGUudmFsdWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90b30gbWVzc2FnZSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5rZXkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXk6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IFN0cmluZyhvYmplY3Qua2V5KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gU3RyaW5nKG9iamVjdC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IG1lc3NhZ2UgU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gbWVzc2FnZS5rZXk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yQW5ub3RhdGlvbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3RlbnNvck5hbWVdIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbcXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc10gVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvckFubm90YXRpb24ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZW5zb3JOYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLnByb3RvdHlwZS50ZW5zb3JOYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvckFubm90YXRpb24gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JBbm5vdGF0aW9uKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UudGVuc29yTmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICE9IG51bGwgJiYgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JBbm5vdGF0aW9ufSBtZXNzYWdlIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yTmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgJiYgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2goJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZW5zb3JOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVuc29yTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlbnNvck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvck5hbWUgPSBTdHJpbmcob2JqZWN0LnRlbnNvck5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JOYW1lID0gbWVzc2FnZS50ZW5zb3JOYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yQW5ub3RhdGlvbiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBUZW5zb3JBbm5vdGF0aW9uO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LkdyYXBoUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHcmFwaFByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElHcmFwaFByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSU5vZGVQcm90bz58bnVsbH0gW25vZGVdIEdyYXBoUHJvdG8gbm9kZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gR3JhcGhQcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPnxudWxsfSBbaW5pdGlhbGl6ZXJdIEdyYXBoUHJvdG8gaW5pdGlhbGl6ZXJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gR3JhcGhQcm90byBkb2NTdHJpbmdcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fG51bGx9IFtpbnB1dF0gR3JhcGhQcm90byBpbnB1dFxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz58bnVsbH0gW291dHB1dF0gR3JhcGhQcm90byBvdXRwdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fG51bGx9IFt2YWx1ZUluZm9dIEdyYXBoUHJvdG8gdmFsdWVJbmZvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVRlbnNvckFubm90YXRpb24+fG51bGx9IFtxdWFudGl6YXRpb25Bbm5vdGF0aW9uXSBHcmFwaFByb3RvIHF1YW50aXphdGlvbkFubm90YXRpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgR3JhcGhQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgR3JhcGhQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUdyYXBoUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JR3JhcGhQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gR3JhcGhQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gbm9kZS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSU5vZGVQcm90bz59IG5vZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm5vZGUgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gaW5pdGlhbGl6ZXIuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUZW5zb3JQcm90bz59IGluaXRpYWxpemVyXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5pbml0aWFsaXplciA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBpbnB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPn0gaW5wdXRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBvdXRwdXQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IG91dHB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUub3V0cHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byB2YWx1ZUluZm8uXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IHZhbHVlSW5mb1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUudmFsdWVJbmZvID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBxdWFudGl6YXRpb25Bbm5vdGF0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVGVuc29yQW5ub3RhdGlvbj59IHF1YW50aXphdGlvbkFubm90YXRpb25cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnF1YW50aXphdGlvbkFubm90YXRpb24gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEdyYXBoUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguR3JhcGhQcm90b30gR3JhcGhQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmFwaFByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR3JhcGhQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkdyYXBoUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JR3JhcGhQcm90b30gbWVzc2FnZSBHcmFwaFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAhPSBudWxsICYmIG1lc3NhZ2Uubm9kZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguTm9kZVByb3RvLmVuY29kZShtZXNzYWdlLm5vZGVbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKG1lc3NhZ2UuaW5pdGlhbGl6ZXJbaV0sIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki80MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84Mikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShtZXNzYWdlLmlucHV0W2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2Uub3V0cHV0W2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEyLCB3aXJlVHlwZSAyID0qLzk4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2UudmFsdWVJbmZvW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLzEwNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24uZW5jb2RlKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR3JhcGhQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkdyYXBoUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JR3JhcGhQcm90b30gbWVzc2FnZSBHcmFwaFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEdyYXBoUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguR3JhcGhQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm5vZGUgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlLnB1c2goJHJvb3Qub25ueC5Ob2RlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemVyLnB1c2goJHJvb3Qub25ueC5UZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0LnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0LnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvLnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uICYmIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5wdXNoKCRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEdyYXBoUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIEdyYXBoUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vZGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibm9kZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJub2RlOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguTm9kZVByb3RvLnZlcmlmeShtZXNzYWdlLm5vZGVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJub2RlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXplclwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmluaXRpYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbml0aWFsaXplci5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlSW5mbyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS52YWx1ZUluZm8pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlSW5mb1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlSW5mby5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5HcmFwaFByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkdyYXBoUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qubm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ub2RlW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZVtpXSA9ICRyb290Lm9ubnguTm9kZVByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm5vZGVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXplcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pbml0aWFsaXplcltpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pbnB1dFtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5wdXQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dFtpXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5wdXRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Qub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5vdXRwdXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3V0cHV0W2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5vdXRwdXQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXRbaV0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3Qob2JqZWN0Lm91dHB1dFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnZhbHVlSW5mbykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnZhbHVlSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZUluZm9baV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnZhbHVlSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlSW5mb1tpXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3QudmFsdWVJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb25baV0gPSAkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24uZnJvbU9iamVjdChvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEdyYXBoUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5HcmFwaFByb3RvfSBtZXNzYWdlIEdyYXBoUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vZGUgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5ub2RlW2pdID0gJHJvb3Qub25ueC5Ob2RlUHJvdG8udG9PYmplY3QobWVzc2FnZS5ub2RlW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemVyICYmIG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXJbal0gPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5pdGlhbGl6ZXJbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0W2pdID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChtZXNzYWdlLmlucHV0W2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dFtqXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QobWVzc2FnZS5vdXRwdXRbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICYmIG1lc3NhZ2UudmFsdWVJbmZvLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudmFsdWVJbmZvLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWVJbmZvW2pdID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChtZXNzYWdlLnZhbHVlSW5mb1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uICYmIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbltqXSA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi50b09iamVjdChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb25bal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBHcmFwaFByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdyYXBoUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBUZW5zb3JQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtkaW1zXSBUZW5zb3JQcm90byBkaW1zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtkYXRhVHlwZV0gVGVuc29yUHJvdG8gZGF0YVR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fG51bGx9IFtzZWdtZW50XSBUZW5zb3JQcm90byBzZWdtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Zsb2F0RGF0YV0gVGVuc29yUHJvdG8gZmxvYXREYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2ludDMyRGF0YV0gVGVuc29yUHJvdG8gaW50MzJEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPFVpbnQ4QXJyYXk+fG51bGx9IFtzdHJpbmdEYXRhXSBUZW5zb3JQcm90byBzdHJpbmdEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcnxMb25nPnxudWxsfSBbaW50NjREYXRhXSBUZW5zb3JQcm90byBpbnQ2NERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIFRlbnNvclByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gVGVuc29yUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbcmF3RGF0YV0gVGVuc29yUHJvdG8gcmF3RGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbZXh0ZXJuYWxEYXRhXSBUZW5zb3JQcm90byBleHRlcm5hbERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbnxudWxsfSBbZGF0YUxvY2F0aW9uXSBUZW5zb3JQcm90byBkYXRhTG9jYXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZG91YmxlRGF0YV0gVGVuc29yUHJvdG8gZG91YmxlRGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW3VpbnQ2NERhdGFdIFRlbnNvclByb3RvIHVpbnQ2NERhdGFcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvclByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvclByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGltcy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gZGltc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kaW1zID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGF0YVR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZGF0YVR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZGF0YVR5cGUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBzZWdtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fG51bGx8dW5kZWZpbmVkfSBzZWdtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBmbG9hdERhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZmxvYXREYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gaW50MzJEYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gaW50MzJEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmludDMyRGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHN0cmluZ0RhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxVaW50OEFycmF5Pn0gc3RyaW5nRGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5zdHJpbmdEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gaW50NjREYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBpbnQ2NERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuaW50NjREYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHJhd0RhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHJhd0RhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGV4dGVybmFsRGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fSBleHRlcm5hbERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGF0YUxvY2F0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbn0gZGF0YUxvY2F0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRhdGFMb2NhdGlvbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGRvdWJsZURhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBkb3VibGVEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRvdWJsZURhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byB1aW50NjREYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSB1aW50NjREYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnVpbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQ2NChtZXNzYWdlLmRpbXNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50MzIobWVzc2FnZS5kYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zZWdtZW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmVuY29kZShtZXNzYWdlLnNlZ21lbnQsIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5mbG9hdChtZXNzYWdlLmZsb2F0RGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmludDMyKG1lc3NhZ2UuaW50MzJEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5ieXRlcyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLzU4KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmludDY0KG1lc3NhZ2UuaW50NjREYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJhd0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDksIHdpcmVUeXBlIDIgPSovNzQpLmJ5dGVzKG1lc3NhZ2UucmF3RGF0YSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTAsIHdpcmVUeXBlIDIgPSovODIpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmRvdWJsZShtZXNzYWdlLmRvdWJsZURhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnVpbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMSwgd2lyZVR5cGUgMiA9Ki85MCkuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDY0KG1lc3NhZ2UudWludDY0RGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEyLCB3aXJlVHlwZSAyID0qLzk4KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUobWVzc2FnZS5leHRlcm5hbERhdGFbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTMsIHdpcmVUeXBlIDIgPSovMTA2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YUxvY2F0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDE0LCB3aXJlVHlwZSAwID0qLzExMikuaW50MzIobWVzc2FnZS5kYXRhTG9jYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXMucHVzaChyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZsb2F0RGF0YSAmJiBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW50MzJEYXRhICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdEYXRhICYmIG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YS5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmludDY0RGF0YSAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yYXdEYXRhID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YS5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kb3VibGVEYXRhICYmIG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvdWJsZURhdGEucHVzaChyZWFkZXIuZG91YmxlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YS5wdXNoKHJlYWRlci5kb3VibGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudWludDY0RGF0YSAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhLnB1c2gocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90b30gVGVuc29yUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3JQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbXNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kaW1zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldKSAmJiAhKG1lc3NhZ2UuZGltc1tpXSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kYXRhVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGFUeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zZWdtZW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5KG1lc3NhZ2Uuc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzZWdtZW50LlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mbG9hdERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZmxvYXREYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZmxvYXREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXREYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mbG9hdERhdGFbaV0gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50MzJEYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW50MzJEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50MzJEYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50MzJEYXRhW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludDMyRGF0YTogaW50ZWdlcltdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ0RhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJpbmdEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdEYXRhW2ldICYmIHR5cGVvZiBtZXNzYWdlLnN0cmluZ0RhdGFbaV0ubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nRGF0YTogYnVmZmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludDY0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnQ2NERhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnQ2NERhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnQ2NERhdGFbaV0pICYmICEobWVzc2FnZS5pbnQ2NERhdGFbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50NjREYXRhW2ldLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50NjREYXRhW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJhd0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnJhd0RhdGEgJiYgdHlwZW9mIG1lc3NhZ2UucmF3RGF0YS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5yYXdEYXRhKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJhd0RhdGE6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImV4dGVybmFsRGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmV4dGVybmFsRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImV4dGVybmFsRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnkobWVzc2FnZS5leHRlcm5hbERhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJleHRlcm5hbERhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YUxvY2F0aW9uXCIpKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5kYXRhTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhTG9jYXRpb246IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb3VibGVEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvdWJsZURhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kb3VibGVEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRvdWJsZURhdGFbaV0gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudWludDY0RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ1aW50NjREYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudWludDY0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudWludDY0RGF0YVtpXSkgJiYgIShtZXNzYWdlLnVpbnQ2NERhdGFbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudWludDY0RGF0YVtpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidWludDY0RGF0YTogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlRlbnNvclByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRpbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmRpbXMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmRpbXNbaV0gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZGltc1tpXSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltc1tpXSA9IHBhcnNlSW50KG9iamVjdC5kaW1zW2ldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltc1tpXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltc1tpXSA9IG9iamVjdC5kaW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmRpbXNbaV0ubG93ID4+PiAwLCBvYmplY3QuZGltc1tpXS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kYXRhVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YVR5cGUgPSBvYmplY3QuZGF0YVR5cGUgfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5zZWdtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zZWdtZW50ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zZWdtZW50OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZWdtZW50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmZyb21PYmplY3Qob2JqZWN0LnNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5mbG9hdERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZsb2F0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5mbG9hdERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhW2ldID0gTnVtYmVyKG9iamVjdC5mbG9hdERhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnQzMkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmludDMyRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnQzMkRhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50MzJEYXRhW2ldID0gb2JqZWN0LmludDMyRGF0YVtpXSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnN0cmluZ0RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnN0cmluZ0RhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zdHJpbmdEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJpbmdEYXRhW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3Quc3RyaW5nRGF0YVtpXSwgbWVzc2FnZS5zdHJpbmdEYXRhW2ldID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LnN0cmluZ0RhdGFbaV0pKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5zdHJpbmdEYXRhW2ldLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9IG9iamVjdC5zdHJpbmdEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnQ2NERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmludDY0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaW50NjREYXRhW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludDY0RGF0YVtpXSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBwYXJzZUludChvYmplY3QuaW50NjREYXRhW2ldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBvYmplY3QuaW50NjREYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludDY0RGF0YVtpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnQ2NERhdGFbaV0ubG93ID4+PiAwLCBvYmplY3QuaW50NjREYXRhW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmF3RGF0YSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnJhd0RhdGEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnJhd0RhdGEsIG1lc3NhZ2UucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5yYXdEYXRhKSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5yYXdEYXRhLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yYXdEYXRhID0gb2JqZWN0LnJhd0RhdGE7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmV4dGVybmFsRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZXh0ZXJuYWxEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmV4dGVybmFsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5leHRlcm5hbERhdGFbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGFbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChvYmplY3QuZXh0ZXJuYWxEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC5kYXRhTG9jYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJERUZBVUxUXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVYVEVSTkFMXCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb3VibGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kb3VibGVEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZG91YmxlRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhW2ldID0gTnVtYmVyKG9iamVjdC5kb3VibGVEYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QudWludDY0RGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudWludDY0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnVpbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UudWludDY0RGF0YVtpXSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC51aW50NjREYXRhW2ldKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSBwYXJzZUludChvYmplY3QudWludDY0RGF0YVtpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnVpbnQ2NERhdGFbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSBvYmplY3QudWludDY0RGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC51aW50NjREYXRhW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LnVpbnQ2NERhdGFbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVGVuc29yUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG99IG1lc3NhZ2UgVGVuc29yUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGF0YVR5cGUgPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZWdtZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJhd0RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QucmF3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QucmF3RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhTG9jYXRpb24gPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIkRFRkFVTFRcIiA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGltc1tqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1zW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZGltc1tqXSkgOiBtZXNzYWdlLmRpbXNbal07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1zW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmRpbXNbal0pIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZGltc1tqXS5sb3cgPj4+IDAsIG1lc3NhZ2UuZGltc1tqXS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRhdGFUeXBlID0gbWVzc2FnZS5kYXRhVHlwZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNlZ21lbnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2VnbWVudFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Quc2VnbWVudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC50b09iamVjdChtZXNzYWdlLnNlZ21lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXREYXRhICYmIG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXREYXRhW2pdID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmZsb2F0RGF0YVtqXSkgPyBTdHJpbmcobWVzc2FnZS5mbG9hdERhdGFbal0pIDogbWVzc2FnZS5mbG9hdERhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludDMyRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnQzMkRhdGFbal0gPSBtZXNzYWdlLmludDMyRGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgJiYgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdEYXRhW2pdID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnN0cmluZ0RhdGFbal0sIDAsIG1lc3NhZ2Uuc3RyaW5nRGF0YVtqXS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ0RhdGFbal0pIDogbWVzc2FnZS5zdHJpbmdEYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50NjREYXRhICYmIG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50NjREYXRhW2pdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmludDY0RGF0YVtqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludDY0RGF0YVtqXSkgOiBtZXNzYWdlLmludDY0RGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmludDY0RGF0YVtqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5pbnQ2NERhdGFbal0pIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaW50NjREYXRhW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS5pbnQ2NERhdGFbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuaW50NjREYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmF3RGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnJhd0RhdGEsIDAsIG1lc3NhZ2UucmF3RGF0YS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnJhd0RhdGEpIDogbWVzc2FnZS5yYXdEYXRhO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAmJiBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRvdWJsZURhdGFbal0gPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZG91YmxlRGF0YVtqXSkgPyBTdHJpbmcobWVzc2FnZS5kb3VibGVEYXRhW2pdKSA6IG1lc3NhZ2UuZG91YmxlRGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnVpbnQ2NERhdGEgJiYgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS51aW50NjREYXRhW2pdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS51aW50NjREYXRhW2pdKSA6IG1lc3NhZ2UudWludDY0RGF0YVtqXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnVpbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UudWludDY0RGF0YVtqXSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS51aW50NjREYXRhW2pdLmxvdyA+Pj4gMCwgbWVzc2FnZS51aW50NjREYXRhW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbWVzc2FnZS51aW50NjREYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leHRlcm5hbERhdGEgJiYgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5leHRlcm5hbERhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5leHRlcm5hbERhdGFbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS5leHRlcm5hbERhdGFbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YUxvY2F0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZGF0YUxvY2F0aW9uID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3Qub25ueC5UZW5zb3JQcm90by5EYXRhTG9jYXRpb25bbWVzc2FnZS5kYXRhTG9jYXRpb25dIDogbWVzc2FnZS5kYXRhTG9jYXRpb247XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFRlbnNvclByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YVR5cGUgZW51bS5cbiAgICAgICAgICogQG5hbWUgb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVxuICAgICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVU5ERUZJTkVEPTAgVU5ERUZJTkVEIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGTE9BVD0xIEZMT0FUIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UOD0yIFVJTlQ4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQ4PTMgSU5UOCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDE2PTQgVUlOVDE2IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQxNj01IElOVDE2IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQzMj02IElOVDMyIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlQ2ND03IElOVDY0IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkc9OCBTVFJJTkcgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEJPT0w9OSBCT09MIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGTE9BVDE2PTEwIEZMT0FUMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERPVUJMRT0xMSBET1VCTEUgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQzMj0xMiBVSU5UMzIgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQ2ND0xMyBVSU5UNjQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IENPTVBMRVg2ND0xNCBDT01QTEVYNjQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IENPTVBMRVgxMjg9MTUgQ09NUExFWDEyOCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQkZMT0FUMTY9MTYgQkZMT0FUMTYgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLkRhdGFUeXBlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJVTkRFRklORURcIl0gPSAwO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkZMT0FUXCJdID0gMTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJVSU5UOFwiXSA9IDI7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiSU5UOFwiXSA9IDM7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiVUlOVDE2XCJdID0gNDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJJTlQxNlwiXSA9IDU7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiSU5UMzJcIl0gPSA2O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklOVDY0XCJdID0gNztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJTVFJJTkdcIl0gPSA4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIkJPT0xcIl0gPSA5O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJGTE9BVDE2XCJdID0gMTA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMV0gPSBcIkRPVUJMRVwiXSA9IDExO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTJdID0gXCJVSU5UMzJcIl0gPSAxMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEzXSA9IFwiVUlOVDY0XCJdID0gMTM7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNF0gPSBcIkNPTVBMRVg2NFwiXSA9IDE0O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTVdID0gXCJDT01QTEVYMTI4XCJdID0gMTU7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNl0gPSBcIkJGTE9BVDE2XCJdID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIFRlbnNvclByb3RvLlNlZ21lbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFNlZ21lbnQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJU2VnbWVudFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbYmVnaW5dIFNlZ21lbnQgYmVnaW5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2VuZF0gU2VnbWVudCBlbmRcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VnbWVudC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZWdtZW50LlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVNlZ21lbnRcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNlZ21lbnQocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VnbWVudCBiZWdpbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBiZWdpblxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQucHJvdG90eXBlLmJlZ2luID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VnbWVudCBlbmQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gZW5kXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5wcm90b3R5cGUuZW5kID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBTZWdtZW50IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudCBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VnbWVudCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5iZWdpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDY0KG1lc3NhZ2UuYmVnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVuZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbmRcIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50NjQobWVzc2FnZS5lbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTZWdtZW50IG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudH0gbWVzc2FnZSBTZWdtZW50IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmVnaW4gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFNlZ21lbnQgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWZXJpZmllcyBhIFNlZ21lbnQgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5iZWdpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iZWdpbikgJiYgIShtZXNzYWdlLmJlZ2luICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmJlZ2luLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYmVnaW46IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVuZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbmRcIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZW5kKSAmJiAhKG1lc3NhZ2UuZW5kICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVuZC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVuZC5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgU2VnbWVudCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5iZWdpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmJlZ2luID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmJlZ2luKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5iZWdpbiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmVnaW4gPSBwYXJzZUludChvYmplY3QuYmVnaW4sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5iZWdpbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmVnaW4gPSBvYmplY3QuYmVnaW47XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuYmVnaW4gPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJlZ2luID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5iZWdpbi5sb3cgPj4+IDAsIG9iamVjdC5iZWdpbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuZW5kID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmVuZCkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZW5kID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmQgPSBwYXJzZUludChvYmplY3QuZW5kLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZW5kID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbmQgPSBvYmplY3QuZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmVuZCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5kID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5lbmQubG93ID4+PiAwLCBvYmplY3QuZW5kLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFNlZ21lbnQgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gbWVzc2FnZSBTZWdtZW50XG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJlZ2luID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW5kID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW5kID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5iZWdpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmJlZ2luID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJlZ2luID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuYmVnaW4pIDogbWVzc2FnZS5iZWdpbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJlZ2luID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmJlZ2luKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmJlZ2luLmxvdyA+Pj4gMCwgbWVzc2FnZS5iZWdpbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5iZWdpbjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW5kXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZW5kID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmVuZCkgOiBtZXNzYWdlLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5lbmQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZW5kLmxvdyA+Pj4gMCwgbWVzc2FnZS5lbmQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRoaXMgU2VnbWVudCB0byBKU09OLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBTZWdtZW50O1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhTG9jYXRpb24gZW51bS5cbiAgICAgICAgICogQG5hbWUgb25ueC5UZW5zb3JQcm90by5EYXRhTG9jYXRpb25cbiAgICAgICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IERFRkFVTFQ9MCBERUZBVUxUIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFWFRFUk5BTD0xIEVYVEVSTkFMIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5EYXRhTG9jYXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIkRFRkFVTFRcIl0gPSAwO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkVYVEVSTkFMXCJdID0gMTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvclByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlRlbnNvclNoYXBlUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBUZW5zb3JTaGFwZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPnxudWxsfSBbZGltXSBUZW5zb3JTaGFwZVByb3RvIGRpbVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUZW5zb3JTaGFwZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBUZW5zb3JTaGFwZVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JTaGFwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBUZW5zb3JTaGFwZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGltID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclNoYXBlUHJvdG8gZGltLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb24+fSBkaW1cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8ucHJvdG90eXBlLmRpbSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yU2hhcGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvclNoYXBlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfSBtZXNzYWdlIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gIT0gbnVsbCAmJiBtZXNzYWdlLmRpbS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5lbmNvZGUobWVzc2FnZS5kaW1baV0sIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfSBtZXNzYWdlIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZGltICYmIG1lc3NhZ2UuZGltLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbS5wdXNoKCRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkobWVzc2FnZS5kaW1baV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW0uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRpbSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGltKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltW2ldID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KG9iamVjdC5kaW1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltID0gW107XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gJiYgbWVzc2FnZS5kaW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1bal0gPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnRvT2JqZWN0KG1lc3NhZ2UuZGltW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yU2hhcGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2RpbVZhbHVlXSBEaW1lbnNpb24gZGltVmFsdWVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkaW1QYXJhbV0gRGltZW5zaW9uIGRpbVBhcmFtXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZGVub3RhdGlvbl0gRGltZW5zaW9uIGRlbm90YXRpb25cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGltZW5zaW9uLlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRGltZW5zaW9uLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSURpbWVuc2lvblxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIERpbWVuc2lvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaW1lbnNpb24gZGltVmFsdWUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gZGltVmFsdWVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kaW1WYWx1ZSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiBkaW1QYXJhbS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZGltUGFyYW1cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kaW1QYXJhbSA9IFwiXCI7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGltZW5zaW9uIGRlbm90YXRpb24uXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRlbm90YXRpb25cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS5kZW5vdGF0aW9uID0gXCJcIjtcblxuICAgICAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiB2YWx1ZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge1wiZGltVmFsdWVcInxcImRpbVBhcmFtXCJ8dW5kZWZpbmVkfSB2YWx1ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGltZW5zaW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJkaW1WYWx1ZVwiLCBcImRpbVBhcmFtXCJdKSxcbiAgICAgICAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRGltZW5zaW9uIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gRGltZW5zaW9uIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGltZW5zaW9uKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgRGltZW5zaW9uIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbn0gbWVzc2FnZSBEaW1lbnNpb24gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1WYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDY0KG1lc3NhZ2UuZGltVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVBhcmFtICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLmRpbVBhcmFtKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuc3RyaW5nKG1lc3NhZ2UuZGVub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBEaW1lbnNpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltUGFyYW0gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIERpbWVuc2lvbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcmlmaWVzIGEgRGltZW5zaW9uIG1lc3NhZ2UuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1WYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZSkgJiYgIShtZXNzYWdlLmRpbVZhbHVlICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbVZhbHVlLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltVmFsdWUuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1QYXJhbSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kaW1QYXJhbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW1QYXJhbTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBEaW1lbnNpb24gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gRGltZW5zaW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5kaW1WYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmRpbVZhbHVlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbVZhbHVlKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1WYWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltVmFsdWUgPSBwYXJzZUludChvYmplY3QuZGltVmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1WYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltVmFsdWUgPSBvYmplY3QuZGltVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVZhbHVlID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1WYWx1ZS5sb3cgPj4+IDAsIG9iamVjdC5kaW1WYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZGltUGFyYW0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1QYXJhbSA9IFN0cmluZyhvYmplY3QuZGltUGFyYW0pO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZGVub3RhdGlvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm90YXRpb24gPSBTdHJpbmcob2JqZWN0LmRlbm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBEaW1lbnNpb24gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBtZXNzYWdlIERpbWVuc2lvblxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGVub3RhdGlvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbVZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbVZhbHVlID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZGltVmFsdWUpIDogbWVzc2FnZS5kaW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbVZhbHVlID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmRpbVZhbHVlKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbVZhbHVlLmxvdyA+Pj4gMCwgbWVzc2FnZS5kaW1WYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5kaW1WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkaW1WYWx1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1QYXJhbSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1QYXJhbVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltUGFyYW0gPSBtZXNzYWdlLmRpbVBhcmFtO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImRpbVBhcmFtXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRlbm90YXRpb24gPSBtZXNzYWdlLmRlbm90YXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgdGhpcyBEaW1lbnNpb24gdG8gSlNPTi5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gRGltZW5zaW9uO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBUZW5zb3JTaGFwZVByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlR5cGVQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFR5cGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVHlwZVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcnxudWxsfSBbdGVuc29yVHlwZV0gVHlwZVByb3RvIHRlbnNvclR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2Rlbm90YXRpb25dIFR5cGVQcm90byBkZW5vdGF0aW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFR5cGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVHlwZVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJVHlwZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVR5cGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVHlwZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZVByb3RvIHRlbnNvclR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVHlwZVByb3RvLklUZW5zb3J8bnVsbHx1bmRlZmluZWR9IHRlbnNvclR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnByb3RvdHlwZS50ZW5zb3JUeXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZVByb3RvIGRlbm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZGVub3RhdGlvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8ucHJvdG90eXBlLmRlbm90YXRpb24gPSBcIlwiO1xuXG4gICAgICAgIC8vIE9uZU9mIGZpZWxkIG5hbWVzIGJvdW5kIHRvIHZpcnR1YWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gdmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge1widGVuc29yVHlwZVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR5cGVQcm90by5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJ0ZW5zb3JUeXBlXCJdKSxcbiAgICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBUeXBlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90b30gVHlwZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHlwZVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHlwZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVHlwZVByb3RvfSBtZXNzYWdlIFR5cGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5lbmNvZGUobWVzc2FnZS50ZW5zb3JUeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUeXBlUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVHlwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90b30gVHlwZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub3RhdGlvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFR5cGVQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBUeXBlUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IudmVyaWZ5KG1lc3NhZ2UudGVuc29yVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlbnNvclR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgVHlwZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG99IFR5cGVQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC50ZW5zb3JUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50ZW5zb3JUeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29yVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KG9iamVjdC50ZW5zb3JUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZGVub3RhdGlvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub3RhdGlvbiA9IFN0cmluZyhvYmplY3QuZGVub3RhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVHlwZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvclR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLnRvT2JqZWN0KG1lc3NhZ2UudGVuc29yVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInRlbnNvclR5cGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVub3RhdGlvblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZGVub3RhdGlvbiA9IG1lc3NhZ2UuZGVub3RhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVHlwZVByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFR5cGVQcm90by5UZW5zb3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvci5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZWxlbVR5cGVdIFRlbnNvciBlbGVtVHlwZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx9IFtzaGFwZV0gVGVuc29yIHNoYXBlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvci5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVRlbnNvclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gVGVuc29yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbnNvciBlbGVtVHlwZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IucHJvdG90eXBlLmVsZW1UeXBlID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZW5zb3Igc2hhcGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx8dW5kZWZpbmVkfSBzaGFwZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5wcm90b3R5cGUuc2hhcGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcn0gbWVzc2FnZSBUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDMyKG1lc3NhZ2UuZWxlbVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uuc2hhcGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcn0gbWVzc2FnZSBUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvciBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvciBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3JcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWZXJpZmllcyBhIFRlbnNvciBtZXNzYWdlLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZWxlbVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZWxlbVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGFwZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvciBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9IG9iamVjdC5lbGVtVHlwZSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNoYXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvciBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBtZXNzYWdlIFRlbnNvclxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbGVtVHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zaGFwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSBtZXNzYWdlLmVsZW1UeXBlO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2hhcGUgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8udG9PYmplY3QobWVzc2FnZS5zaGFwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgdGhpcyBUZW5zb3IgdG8gSlNPTi5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBUZW5zb3I7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFR5cGVQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5PcGVyYXRvclNldElkUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gT3BlcmF0b3JTZXRJZFByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFt2ZXJzaW9uXSBPcGVyYXRvclNldElkUHJvdG8gdmVyc2lvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBPcGVyYXRvclNldElkUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcGVyYXRvclNldElkUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBPcGVyYXRvclNldElkUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVyYXRvclNldElkUHJvdG8gZG9tYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZXJhdG9yU2V0SWRQcm90byB2ZXJzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gdmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8ucHJvdG90eXBlLnZlcnNpb24gPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRvclNldElkUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JT3BlcmF0b3JTZXRJZFByb3RvfSBtZXNzYWdlIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLmRvbWFpbik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24pICYmICEobWVzc2FnZS52ZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvbWFpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC52ZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLnZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBwYXJzZUludChvYmplY3QudmVyc2lvbiwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gb2JqZWN0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LnZlcnNpb24ubG93ID4+PiAwLCBvYmplY3QudmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IG1lc3NhZ2UuZG9tYWluO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52ZXJzaW9uID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnZlcnNpb24pIDogbWVzc2FnZS52ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UudmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS52ZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wZXJhdG9yU2V0SWRQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gT3BlcmF0b3JTZXRJZFByb3RvO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gb25ueDtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gJHJvb3Q7XG4iLCIvLyBtaW5pbWFsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXgtbWluaW1hbFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1pbnRlcm5hbC1tb2R1bGVzICovXG5pbXBvcnQge0JhY2tlbmQsIEluZmVyZW5jZVNlc3Npb24sIFNlc3Npb25IYW5kbGVyfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0IHtTZXNzaW9ufSBmcm9tICcuL29ubnhqcy9zZXNzaW9uJztcbmltcG9ydCB7T25ueGpzU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vb25ueGpzL3Nlc3Npb24taGFuZGxlcic7XG5cbmNsYXNzIE9ubnhqc0JhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBhc3luYyBpbml0KCk6IFByb21pc2U8dm9pZD4ge31cblxuICBhc3luYyBjcmVhdGVTZXNzaW9uSGFuZGxlcihwYXRoT3JCdWZmZXI6IHN0cmluZ3xVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFNlc3Npb25IYW5kbGVyPiB7XG4gICAgLy8gTk9URTogU2Vzc2lvbi5Db25maWcoZnJvbSBvbm54LmpzKSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMoZnJvbVxuICAgIC8vIG9ubnhydW50aW1lLWNvbW1vbikuXG4gICAgLy8gICAgICAgSW4gZnV0dXJlIHdlIHNob3VsZCByZW1vdmUgU2Vzc2lvbi5Db25maWcgYW5kIHVzZSBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLlxuICAgIC8vICAgICAgIEN1cnJlbnRseSB3ZSBhbGxvdyB0aGlzIHRvIGhhcHBlbiB0byBtYWtlIHRlc3QgcnVubmVyIHdvcmsuXG4gICAgY29uc3Qgc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKG9wdGlvbnMgYXMgdW5rbm93biBhcyBTZXNzaW9uLkNvbmZpZyk7XG5cbiAgICAvLyB0eXBlc2NyaXB0IGNhbm5vdCBtZXJnZSBtZXRob2Qgb3ZlcnJpZGUgY29ycmVjdGx5IChzbyBmYXIgaW4gNC4yLjMpLiBuZWVkIGlmLWVsc2UgdG8gY2FsbCB0aGUgbWV0aG9kLlxuICAgIGlmICh0eXBlb2YgcGF0aE9yQnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgYXdhaXQgc2Vzc2lvbi5sb2FkTW9kZWwocGF0aE9yQnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgc2Vzc2lvbi5sb2FkTW9kZWwocGF0aE9yQnVmZmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9ubnhqc1Nlc3Npb25IYW5kbGVyKHNlc3Npb24pO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvbm54anNCYWNrZW5kID0gbmV3IE9ubnhqc0JhY2tlbmQoKTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3JlYWRGaWxlfSBmcm9tICdmcyc7XG5pbXBvcnQge0JhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQge2NwdXN9IGZyb20gJ29zJztcbmltcG9ydCB7cHJvbWlzaWZ5fSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHtPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vd2FzbS9zZXNzaW9uLWhhbmRsZXInO1xuaW1wb3J0IHtpbml0aWFsaXplV2ViQXNzZW1ibHl9IGZyb20gJy4vd2FzbS93YXNtLWZhY3RvcnknO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20uc2ltZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20uc2ltZCA9IHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIGNvbnN0IG51bUNwdUxvZ2ljYWxDb3JlcyA9IHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgIGVudi53YXNtLm51bVRocmVhZHMgPSBNYXRoLm1pbig0LCBNYXRoLmNlaWwoKG51bUNwdUxvZ2ljYWxDb3JlcyB8fCAxKSAvIDIpKTtcbiAgfVxufTtcblxuY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgYXN5bmMgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBwb3B1bGF0ZSB3YXNtIGZsYWdzXG4gICAgaW5pdGlhbGl6ZUZsYWdzKCk7XG5cbiAgICAvLyBpbml0IHdhc21cbiAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHkoKTtcbiAgfVxuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlcj47XG4gIGNyZWF0ZVNlc3Npb25IYW5kbGVyKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyPjtcbiAgYXN5bmMgY3JlYXRlU2Vzc2lvbkhhbmRsZXIocGF0aE9yQnVmZmVyOiBzdHJpbmd8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGxldCBidWZmZXI6IFVpbnQ4QXJyYXk7XG4gICAgaWYgKHR5cGVvZiBwYXRoT3JCdWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBub2RlXG4gICAgICAgIGJ1ZmZlciA9IGF3YWl0IHByb21pc2lmeShyZWFkRmlsZSkocGF0aE9yQnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJyb3dzZXJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChwYXRoT3JCdWZmZXIpO1xuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgaGFuZGxlci5sb2FkTW9kZWwoYnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmV4cG9ydCAqIGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQge3JlZ2lzdGVyQmFja2VuZH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7b25ueGpzQmFja2VuZH0gZnJvbSAnLi9iYWNrZW5kLW9ubnhqcyc7XG5pbXBvcnQge3dhc21CYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtd2FzbSc7XG5cbnJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAxKTtcbnJlZ2lzdGVyQmFja2VuZCgnd2FzbScsIHdhc21CYWNrZW5kLCAyKTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgTG9uZyBmcm9tICdsb25nJztcbmltcG9ydCB7b25ueH0gZnJvbSAnb25ueC1wcm90byc7XG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQgb3J0RmJzID0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztcblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcbmltcG9ydCB7TG9uZ1V0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBBdHRyaWJ1dGUge1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDogbnVtYmVyO1xuICAgIGludDogbnVtYmVyO1xuICAgIHN0cmluZzogc3RyaW5nO1xuICAgIHRlbnNvcjogVGVuc29yO1xuICAgIGZsb2F0czogbnVtYmVyW107XG4gICAgaW50czogbnVtYmVyW107XG4gICAgc3RyaW5nczogc3RyaW5nW107XG4gICAgdGVuc29yczogVGVuc29yW107XG4gIH1cblxuICBleHBvcnQgdHlwZSBEYXRhVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xufVxuXG50eXBlIFZhbHVlVHlwZXMgPSBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbQXR0cmlidXRlLkRhdGFUeXBlXTtcblxudHlwZSBWYWx1ZSA9IFtWYWx1ZVR5cGVzLCBBdHRyaWJ1dGUuRGF0YVR5cGVdO1xuXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlIHtcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlczogb25ueC5JQXR0cmlidXRlUHJvdG9bXXxvcnRGYnMuQXR0cmlidXRlW118bnVsbHx1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgIGlmIChhdHRyaWJ1dGVzICE9PSBudWxsICYmIGF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlcy5zZXQoYXR0ci5uYW1lLCBbQXR0cmlidXRlLmdldFZhbHVlKGF0dHIpLCBBdHRyaWJ1dGUuZ2V0VHlwZShhdHRyKV0pO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlcy5zZXQoYXR0ci5uYW1lKCkhLCBbQXR0cmlidXRlLmdldFZhbHVlKGF0dHIpLCBBdHRyaWJ1dGUuZ2V0VHlwZShhdHRyKV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYXR0cmlidXRlcy5zaXplIDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkdXBsaWNhdGVkIGF0dHJpYnV0ZSBuYW1lcycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldChrZXk6IHN0cmluZywgdHlwZTogQXR0cmlidXRlLkRhdGFUeXBlLCB2YWx1ZTogVmFsdWVUeXBlcyk6IHZvaWQge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMuc2V0KGtleSwgW3ZhbHVlLCB0eXBlXSk7XG4gIH1cbiAgZGVsZXRlKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgfVxuICBnZXRGbG9hdChrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydmbG9hdCddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2Zsb2F0JywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldEludChrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydpbnQnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdpbnQnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0U3RyaW5nKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ3N0cmluZyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3N0cmluZycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRUZW5zb3Ioa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsndGVuc29yJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAndGVuc29yJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldEZsb2F0cyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydmbG9hdHMnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdmbG9hdHMnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0SW50cyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWydpbnRzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnaW50cycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRTdHJpbmdzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ3N0cmluZ3MnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdzdHJpbmdzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFRlbnNvcnMoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsndGVuc29ycyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3RlbnNvcnMnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQ8ViBleHRlbmRzIEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFtBdHRyaWJ1dGUuRGF0YVR5cGVdPihcbiAgICAgIGtleTogc3RyaW5nLCB0eXBlOiBBdHRyaWJ1dGUuRGF0YVR5cGUsIGRlZmF1bHRWYWx1ZT86IFYpOiBWIHtcbiAgICBjb25zdCB2YWx1ZUFuZFR5cGUgPSB0aGlzLl9hdHRyaWJ1dGVzLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZUFuZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlcXVpcmVkIGF0dHJpYnV0ZSBub3QgZm91bmQ6ICR7a2V5fWApO1xuICAgIH1cbiAgICBpZiAodmFsdWVBbmRUeXBlWzFdICE9PSB0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7dHlwZX0gYnV0IGdvdCAke3ZhbHVlQW5kVHlwZVsxXX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlQW5kVHlwZVswXSBhcyBWO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VHlwZShhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90b3xvcnRGYnMuQXR0cmlidXRlKTogQXR0cmlidXRlLkRhdGFUeXBlIHtcbiAgICBjb25zdCB0eXBlID0gYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8gPyAoYXR0cikudHlwZSA6IChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpLnR5cGUoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0JztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVDpcbiAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1I6XG4gICAgICAgIHJldHVybiAndGVuc29yJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUUzpcbiAgICAgICAgcmV0dXJuICdmbG9hdHMnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UUzpcbiAgICAgICAgcmV0dXJuICdpbnRzJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6XG4gICAgICAgIHJldHVybiAnc3RyaW5ncyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1JTOlxuICAgICAgICByZXR1cm4gJ3RlbnNvcnMnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhdHRyaWJ1dGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIHlldDogJHtvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbdHlwZV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VmFsdWUoYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG98b3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8gPyBhdHRyLnR5cGUgOiAoYXR0ciBhcyBvcnRGYnMuQXR0cmlidXRlKS50eXBlKCk7XG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEggfHwgYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ3JhcGggYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlTm9DaGVjayhhdHRyKTtcblxuICAgIC8vIGNhc3QgTE9ORyB0byBudW1iZXJcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQgJiYgTG9uZ1V0aWwuaXNMb25nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIExvbmdVdGlsLmxvbmdUb051bWJlcih2YWx1ZSBhcyBMb25nIHwgZmxhdGJ1ZmZlcnMuTG9uZyk7XG4gICAgfVxuXG4gICAgLy8gY2FzdCBMT05HW10gdG8gbnVtYmVyW11cbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTKSB7XG4gICAgICBjb25zdCBhcnIgPSAodmFsdWUgYXMgQXJyYXk8bnVtYmVyfExvbmd8ZmxhdGJ1ZmZlcnMuTG9uZz4pO1xuICAgICAgY29uc3QgbnVtYmVyVmFsdWU6IG51bWJlcltdID0gbmV3IEFycmF5PG51bWJlcj4oYXJyLmxlbmd0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1heWJlTG9uZyA9IGFycltpXTtcbiAgICAgICAgbnVtYmVyVmFsdWVbaV0gPSBMb25nVXRpbC5sb25nVG9OdW1iZXIobWF5YmVMb25nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bWJlclZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90byB0byBvbm54anMuVGVuc29yXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SKSB7XG4gICAgICByZXR1cm4gYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8gPyBUZW5zb3IuZnJvbVByb3RvKHZhbHVlIGFzIG9ubnguSVRlbnNvclByb3RvKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZW5zb3IuZnJvbU9ydFRlbnNvcih2YWx1ZSBhcyBvcnRGYnMuVGVuc29yKTtcbiAgICB9XG5cbiAgICAvLyBjYXN0IG9ubnguVGVuc29yUHJvdG9bXSB0byBvbm54anMuVGVuc29yW11cbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1JTKSB7XG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdGVuc29yUHJvdG9zID0gdmFsdWUgYXMgb25ueC5JVGVuc29yUHJvdG9bXTtcbiAgICAgICAgcmV0dXJuIHRlbnNvclByb3Rvcy5tYXAodmFsdWUgPT4gVGVuc29yLmZyb21Qcm90byh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChhdHRyIGluc3RhbmNlb2Ygb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgICAgICBjb25zdCB0ZW5zb3JQcm90b3MgPSB2YWx1ZSBhcyBvcnRGYnMuVGVuc29yW107XG4gICAgICAgIHJldHVybiB0ZW5zb3JQcm90b3MubWFwKHZhbHVlID0+IFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FzdCBVaW50OEFycmF5IHRvIHN0cmluZ1xuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORykge1xuICAgICAgLy8gc3RyaW5nIGluIG9ubnggYXR0cmlidXRlIGlzIG9mIHVpbnQ4YXJyYXkgdHlwZSwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGl0IHRvIHN0cmluZyBiZWxvdy4gV2hpbGUgaW4gb3J0IGZvcm1hdCxcbiAgICAgIC8vIHN0cmluZyBhdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmcsIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVlZGVkLlxuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBvbm54LkF0dHJpYnV0ZVByb3RvKSB7XG4gICAgICAgIGNvbnN0IHV0ZjhTdHJpbmcgPSB2YWx1ZSBhcyBVaW50OEFycmF5O1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odXRmOFN0cmluZy5idWZmZXIsIHV0ZjhTdHJpbmcuYnl0ZU9mZnNldCwgdXRmOFN0cmluZy5ieXRlTGVuZ3RoKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhc3QgVWludDhBcnJheVtdIHRvIHN0cmluZ1tdXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUykge1xuICAgICAgLy8gc3RyaW5ncyBpbiBvbm54IGF0dHJpYnV0ZSBpcyByZXR1cm5lZCBhcyB1aW50OGFycmF5W10sIHNvIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBzdHJpbmdbXSBiZWxvdy4gV2hpbGUgaW4gb3J0XG4gICAgICAvLyBmb3JtYXQgc3RyaW5ncyBhdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmdbXSwgc28gbm8gY29udmVyc2lvbiBpcyBuZWVkZWQuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdXRmOFN0cmluZ3MgPSB2YWx1ZSBhcyBVaW50OEFycmF5W107XG4gICAgICAgIHJldHVybiB1dGY4U3RyaW5ncy5tYXAoXG4gICAgICAgICAgICB1dGY4U3RyaW5nID0+IEJ1ZmZlci5mcm9tKHV0ZjhTdHJpbmcuYnVmZmVyLCB1dGY4U3RyaW5nLmJ5dGVPZmZzZXQsIHV0ZjhTdHJpbmcuYnl0ZUxlbmd0aCkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlIGFzIFZhbHVlVHlwZXM7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2soYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG98b3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2YgKG9ubnguQXR0cmlidXRlUHJvdG8pID8gdGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdChhdHRyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoYXR0ciBhcyBvcnRGYnMuQXR0cmlidXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvKSB7XG4gICAgc3dpdGNoIChhdHRyLnR5cGUhKSB7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZjtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuaTtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuIGF0dHIucztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuIGF0dHIudDtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIOlxuICAgICAgICByZXR1cm4gYXR0ci5nO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gYXR0ci5mbG9hdHM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gYXR0ci5pbnRzO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuIGF0dHIuc3RyaW5ncztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiBhdHRyLnRlbnNvcnM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSFM6XG4gICAgICAgIHJldHVybiBhdHRyLmdyYXBocztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW2F0dHIudHlwZSFdfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoYXR0cjogb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAoYXR0ci50eXBlKCkpIHtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiBhdHRyLmYoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gYXR0ci5pKCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuIGF0dHIucygpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5URU5TT1I6XG4gICAgICAgIHJldHVybiBhdHRyLnQoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuR1JBUEg6XG4gICAgICAgIHJldHVybiBhdHRyLmcoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gYXR0ci5mbG9hdHNBcnJheSgpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5JTlRTOiB7XG4gICAgICAgIGNvbnN0IGludHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyLmludHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgaW50cy5wdXNoKGF0dHIuaW50cyhpKSEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRzO1xuICAgICAgfVxuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5TVFJJTkdTOiB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyLnN0cmluZ3NMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgc3RyaW5ncy5wdXNoKGF0dHIuc3RyaW5ncyhpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICB9XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6IHtcbiAgICAgICAgY29uc3QgdGVuc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIudGVuc29yc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICB0ZW5zb3JzLnB1c2goYXR0ci50ZW5zb3JzKGkpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcnM7XG4gICAgICB9XG4gICAgICAvLyBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpcbiAgICAgIC8vIFRPRE86IFN1YmdyYXBoIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgLy8gY29uc3QgZ3JhcGhzID0gW107XG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuZ3JhcGhzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgLy8gICBncmFwaHMucHVzaChhdHRyLmdyYXBocyhpKSEpO1xuICAgICAgLy8gfVxuICAgICAgLy8gcmV0dXJuIGdyYXBocztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7b3J0RmJzLkF0dHJpYnV0ZVR5cGVbYXR0ci50eXBlKCldfWApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYXR0cmlidXRlczogTWFwPHN0cmluZywgVmFsdWU+O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7V2ViR0xCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmRzL2JhY2tlbmQtd2ViZ2wnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge09wU2V0fSBmcm9tICcuL29wc2V0JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi9zZXNzaW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGluZmVyZW5jZSBoYW5kbGVyLiBpdCB3aWxsIGJlIGNhbGxlZCBhcyB0aGUgbGFzdCBzdGVwIGluIFNlc3Npb24ucnVuKClcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uSGFuZGxlciB7XG4gIC8qKlxuICAgKiB0cmFuc2Zvcm0gdGhlIGdyYXBoIGF0IGluaXRpYWxpemF0aW9uIHRpbWVcbiAgICogQHBhcmFtIGdyYXBoVHJhbnNmb3JtZXIgdGhlIGdyYXBoIHRyYW5zZm9ybWVyIHRvIG1hbmlwdWxhdGUgdGhlIG1vZGVsIGdyYXBoXG4gICAqL1xuICB0cmFuc2Zvcm1HcmFwaD8oZ3JhcGhUcmFuc2Zvcm1lcjogR3JhcGguVHJhbnNmb3JtZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgSW5mZXJlbmNlSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uLnJ1bigpIGNhbGxcbiAgICovXG4gIGNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKTogSW5mZXJlbmNlSGFuZGxlcjtcblxuICAvKipcbiAgICogZGlzcG9zZSB0aGUgc2Vzc2lvbiBoYW5kbGVyLiBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgc2Vzc2lvbiBpcyBiZWluZyBkaXNwb3NlZCBleHBsaWNpdGx5XG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBvcGVyYXRvciBmcm9tIHRoZSBuYW1lIGFuZCBvcHNldCB2ZXJzaW9uOyBiYWNrZW5kIHNwZWNpZmljXG4gICAqIEBwYXJhbSBub2RlIHRoZSBub2RlIHRvIHJlc29sdmVcbiAgICogQHBhcmFtIG9wc2V0cyBhIGxpc3Qgb2Ygb3BzZXRzIHRoYXQgZXhwb3J0ZWQgZnJvbSB0aGUgbW9kZWxcbiAgICogQHBhcmFtIGdyYXBoIHRoZSBjb21wbGV0ZWx5IGluaXRpYWxpemVkIGdyYXBoXG4gICAqL1xuICByZXNvbHZlKG5vZGU6IEdyYXBoLk5vZGUsIG9wc2V0czogcmVhZG9ubHkgT3BTZXRbXSwgZ3JhcGg6IEdyYXBoKTogT3BlcmF0b3I7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGxldCdzIHRoZSBzZXNzaW9uSGFuZGxlciBrbm93IHRoYXQgdGhlIGdyYXBoIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlXG4gICAqIEBwYXJhbSBncmFwaCB0aGUgY29tcGxldGVseSBpbml0aWFsaXplZCBncmFwaFxuICAgKi9cbiAgb25HcmFwaEluaXRpYWxpemVkPyhncmFwaDogR3JhcGgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgY29ycmVzcG9uZGluZyBiYWNrZW5kXG4gICAqL1xuICByZWFkb25seSBiYWNrZW5kOiBCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgc2Vzc2lvbiBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBpbml0aWFsaXplIHRoZSBiYWNrZW5kLiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UsIHdoZW4gdGhlIGZpcnN0IHRpbWUgdGhlXG4gICAqIGJhY2tlbmQgaXQgdG8gYmUgdXNlZFxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpOiBib29sZWFufFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBTZXNzaW9uSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uIG9iamVjdCdzIGxpZmVjeWNsZVxuICAgKi9cbiAgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoY29udGV4dDogU2Vzc2lvbi5Db250ZXh0KTogU2Vzc2lvbkhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGJhY2tlbmQuIGN1cnJlbnRseSB0aGlzIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG4vLyBjYWNoZXMgYWxsIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2VzXG5jb25zdCBiYWNrZW5kc0NhY2hlOiBNYXA8c3RyaW5nLCBCYWNrZW5kPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IGJhY2tlbmQ6IHtbbmFtZTogc3RyaW5nXTogQmFja2VuZH0gPSB7XG4gIHdlYmdsOiBuZXcgV2ViR0xCYWNrZW5kKCksXG59O1xuXG4vKipcbiAqIFJlc29sdmUgYSByZWZlcmVuY2UgdG8gdGhlIGJhY2tlbmQuIElmIGEgaGludCBpcyBzcGVjaWZpZWQsIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBiYWNrZW5kIHdpbGwgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVCYWNrZW5kKGhpbnQ/OiBzdHJpbmd8cmVhZG9ubHkgc3RyaW5nW10pOiBQcm9taXNlPEJhY2tlbmQ+IHtcbiAgaWYgKCFoaW50KSB7XG4gICAgcmV0dXJuIHJlc29sdmVCYWNrZW5kKFsnd2ViZ2wnXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaGludHMgPSB0eXBlb2YgaGludCA9PT0gJ3N0cmluZycgPyBbaGludF0gOiBoaW50O1xuXG4gICAgZm9yIChjb25zdCBiYWNrZW5kSGludCBvZiBoaW50cykge1xuICAgICAgY29uc3QgY2FjaGUgPSBiYWNrZW5kc0NhY2hlLmdldChiYWNrZW5kSGludCk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYWNrZW5kID0gYXdhaXQgdHJ5TG9hZEJhY2tlbmQoYmFja2VuZEhpbnQpO1xuICAgICAgaWYgKGJhY2tlbmQpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdubyBhdmFpbGFibGUgYmFja2VuZCB0byB1c2UnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdHJ5TG9hZEJhY2tlbmQoYmFja2VuZEhpbnQ6IHN0cmluZyk6IFByb21pc2U8QmFja2VuZHx1bmRlZmluZWQ+IHtcbiAgY29uc3QgYmFja2VuZE9iaiA9IGJhY2tlbmQ7XG5cbiAgaWYgKHR5cGVvZiBiYWNrZW5kT2JqW2JhY2tlbmRIaW50XSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNCYWNrZW5kKGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdKSkge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBiYWNrZW5kT2JqW2JhY2tlbmRIaW50XTtcbiAgICBsZXQgaW5pdCA9IGJhY2tlbmQuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcgJiYgJ3RoZW4nIGluIGluaXQpIHtcbiAgICAgIGluaXQgPSBhd2FpdCBpbml0O1xuICAgIH1cbiAgICBpZiAoaW5pdCkge1xuICAgICAgYmFja2VuZHNDYWNoZS5zZXQoYmFja2VuZEhpbnQsIGJhY2tlbmQpO1xuICAgICAgcmV0dXJuIGJhY2tlbmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCYWNrZW5kKG9iajogdW5rbm93bikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBvID0gb2JqIGFzIGFueTtcblxuICAvLyBjaGVjayBpZiBhbiBvYmplY3QgaXMgYSBCYWNrZW5kIGluc3RhbmNlXG4gIGlmIChcbiAgICAgICdpbml0aWFsaXplJyBpbiBvICYmIHR5cGVvZiBvLmluaXRpYWxpemUgPT09ICdmdW5jdGlvbicgJiYgICAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSgpXG4gICAgICAnY3JlYXRlU2Vzc2lvbkhhbmRsZXInIGluIG8gJiYgdHlwZW9mIG8uY3JlYXRlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicgJiYgIC8vIGNyZWF0ZVNlc3Npb25IYW5kbGVyKClcbiAgICAgICdkaXNwb3NlJyBpbiBvICYmIHR5cGVvZiBvLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zZSgpXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgdHlwZSBCYWNrZW5kVHlwZSA9IEJhY2tlbmQ7XG5leHBvcnQgdHlwZSBTZXNzaW9uSGFuZGxlclR5cGUgPSBSZXR1cm5UeXBlPEJhY2tlbmRUeXBlWydjcmVhdGVTZXNzaW9uSGFuZGxlciddPjtcbmV4cG9ydCB0eXBlIEluZmVyZW5jZUhhbmRsZXJUeXBlID0gUmV0dXJuVHlwZTxTZXNzaW9uSGFuZGxlclR5cGVbJ2NyZWF0ZUluZmVyZW5jZUhhbmRsZXInXT47XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQge0JhY2tlbmQsIFNlc3Npb25IYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi9pbnN0cnVtZW50JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi4vc2Vzc2lvbic7XG5cbmltcG9ydCB7V2ViR0xTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi93ZWJnbC9zZXNzaW9uLWhhbmRsZXInO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5pbXBvcnQge2NyZWF0ZVdlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC93ZWJnbC1jb250ZXh0LWZhY3RvcnknO1xuXG4vKipcbiAqIFdlYkdMQmFja2VuZCBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGFsbCBXZWJHTCBvcGVhcnRpb25zXG4gKiBXaGVuIGl0IHN0YXJ0cyBpdCBjcmVhdGVkIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIGFuZCBvdGhlciBtYWluIGZyYW1ld29yayBjb21wb25lbnRzIHN1Y2ggYXMgUHJvZ3JhbSBhbmQgVGV4dHVyZSBNYW5hZ2Vyc1xuICovXG5leHBvcnQgY2xhc3MgV2ViR0xCYWNrZW5kIGltcGxlbWVudHMgQmFja2VuZCB7XG4gIGdsQ29udGV4dDogV2ViR0xDb250ZXh0O1xuXG4gIGdldCBjb250ZXh0SWQoKTogJ3dlYmdsJ3wnd2ViZ2wyJ3x1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuY29udGV4dElkO1xuICB9XG4gIHNldCBjb250ZXh0SWQodmFsdWU6ICd3ZWJnbCd8J3dlYmdsMid8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmNvbnRleHRJZCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG1hdG11bE1heEJhdGNoU2l6ZSgpOiBudW1iZXJ8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZTtcbiAgfVxuICBzZXQgbWF0bXVsTWF4QmF0Y2hTaXplKHZhbHVlOiBudW1iZXJ8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHRleHR1cmVDYWNoZU1vZGUoKTogJ2luaXRpYWxpemVyT25seSd8J2Z1bGwnfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlO1xuICB9XG4gIHNldCB0ZXh0dXJlQ2FjaGVNb2RlKHZhbHVlOiAnaW5pdGlhbGl6ZXJPbmx5J3wnZnVsbCd8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLnRleHR1cmVDYWNoZU1vZGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBwYWNrKCk6IGJvb2xlYW58dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLnBhY2s7XG4gIH1cbiAgc2V0IHBhY2sodmFsdWU6IGJvb2xlYW58dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLnBhY2sgPSB2YWx1ZTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZ2xDb250ZXh0ID0gY3JlYXRlV2ViR0xDb250ZXh0KHRoaXMuY29udGV4dElkKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXRtdWxNYXhCYXRjaFNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplID0gMTY7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMudGV4dHVyZUNhY2hlTW9kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVNb2RlID0gJ2Z1bGwnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhY2sgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLnBhY2sgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgTG9nZ2VyLnNldFdpdGhFbnYoZW52KTtcblxuICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgJ1dlYkdMQmFja2VuZCcsXG4gICAgICAgICAgYENyZWF0ZWQgV2ViR0xDb250ZXh0OiAke3R5cGVvZiB0aGlzLmdsQ29udGV4dH0gd2l0aCBtYXRtdWxNYXhCYXRjaFNpemU6ICR7XG4gICAgICAgICAgICAgIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplfTsgdGV4dHVyZUNhY2hlTW9kZTogJHt0aGlzLnRleHR1cmVDYWNoZU1vZGV9OyBwYWNrOiAke3RoaXMucGFja30uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnV2ViR0xCYWNrZW5kJywgYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHtlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpOiBTZXNzaW9uSGFuZGxlciB7XG4gICAgcmV0dXJuIG5ldyBXZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsIGNvbnRleHQpO1xuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuZGlzcG9zZSgpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBcnJheVV0aWwsIEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7c3F1ZWV6ZVNoYXBlfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZUxheW91dH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge2dlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2dlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzLH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlLCBnZXRTcXVlZXplZFBhcmFtcywgc3F1ZWV6ZUlucHV0U2hhcGV9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgZGF0YSB0eXBlcyBhbmQgcm91dGluZXMgZm9yIG1hbmlwdWxhdGluZ1xuICogY29vcmRpbmF0ZXMgYW5kIG1hcHBpbmcgdG8vZnJvbSB0ZW5zb3IgaW5kaWNlc1xuICovXG5leHBvcnQgY2xhc3MgQ29vcmRzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICByZXR1cm5UeXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9mZnNldFRvQ29vcmRzKCksXG4gICAgICAuLi50aGlzLmNvb3Jkc1RvT2Zmc2V0KCksXG4gICAgICAuLi50aGlzLnRvVmVjKCksXG4gICAgICAuLi50aGlzLnZhbHVlRnJvbSgpLFxuICAgICAgLy8gVE9ETyByZXR1cm4gdGhlc2Ugb25seSB3aGVuIHBhY2tpbmcgaXMgZW5hYmxlZC5cbiAgICAgIC4uLnRoaXMuZ2V0Q29tbW9uVXRpbEZ1bmNzKCksXG4gICAgICAuLi50aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSxcbiAgICAgIC4uLnRoaXMuZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KClcbiAgICB9O1xuICB9XG4gIGdldEN1c3RvbVR5cGVzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBtYXAgZnJvbVxuICAgKiAyRCBub3JtYWx6aWVkIGNvb3JkaW5hdGVzIChzLHQpIHRvIGEgZmxhdCBvZmZzZXRcbiAgICovXG4gIHByb3RlY3RlZCBvZmZzZXRUb0Nvb3JkcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSAnb2Zmc2V0VG9Db29yZHMnO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRUb0Nvb3JkczogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgJHtmdW5jTmFtZX0oaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgfVxuICAgICAgYClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYW4gbWFwIGZyb21cbiAgICogMkQgbm9ybWFsemllZCBjb29yZGluYXRlcyAocyx0KSB0byBhIGZsYXQgb2Zmc2V0XG4gICAqL1xuICBwcm90ZWN0ZWQgY29vcmRzVG9PZmZzZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2Nvb3Jkc1RvT2Zmc2V0JztcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRzVG9PZmZzZXQ6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBpbnQgJHtmdW5jTmFtZX0odmVjMiBjb29yZHMsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XG4gICAgICAgIGZsb2F0IHQgPSBjb29yZHMudCAqIGZsb2F0KGhlaWdodCk7XG4gICAgICAgIGludCBvZmZzZXQgPSBpbnQodCkgKiB3aWR0aCArIGludChzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGApXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3Igb3V0cHV0IHNhbXBsZXIuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgaWYgKG91dHB1dExheW91dC5pc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dHB1dExheW91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dHB1dExheW91dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb2RlIGZvciBwYWNrZWQgb3V0cHV0IHNhbXBsZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dHB1dExheW91dDogVGV4dHVyZUxheW91dCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2dldE91dHB1dENvb3Jkcyc7XG4gICAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRQYWNrZWQxRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5nZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFBhY2tlZE5EQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAvLyBUT0RPIHdlIG5lZWQgdGhpcyB0byBwcm9wZXJseSByZXR1cm4gYSBwYWNrZWQgdmVjNCBmcm9tIGtlcm5lbHMuXG4gICAgLy8gUmVwbGFjZSBhbGwgJ3tnbHNsLm91dHB1dH0gPSByZXN1bHQnIHdpdGggJ3NldE91dHB1dChyZXN1bHQpJyBpbiBhbGwga2VybmVscy5cbiAgICBjb25zdCBmbG9hdFRleHR1cmVTZXRSR0JBU291cmNlID0gYFxuICAgICAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2YWw7XG4gICAgICB9XG4gICAgYDtcbiAgICBjb25zdCBmbG9hdFRleHR1cmVTZXRSR0JBRnVuY05hbWUgPSAnZmxvYXRUZXh0dXJlU2V0UkdCQSc7XG4gICAgcmVzdWx0W2Zsb2F0VGV4dHVyZVNldFJHQkFGdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoZmxvYXRUZXh0dXJlU2V0UkdCQVNvdXJjZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgdW5wYWNrZWQgb3V0cHV0IHNhbXBsZXIuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dFNoYXBlID0gb3V0cHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0VGV4U2hhcGUgPSBbb3V0cHV0TGF5b3V0LndpZHRoLCBvdXRwdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgY29uc3QgZnVuY05hbWUgPSAnZ2V0T3V0cHV0Q29vcmRzJztcbiAgICBzd2l0Y2ggKG91dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkMURDb29yZHMob3V0U2hhcGUgYXMgW251bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgICB0aGlzLmdldE91dHB1dFVucGFja2VkMkRDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQzRENvb3JkcyhvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhcbiAgICAgICAgICAgIG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkNURDb29yZHMoXG4gICAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkNkRDb29yZHMoXG4gICAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3V0cHV0IGRpbWVuc2lvbmFsaXR5OiAke291dFNoYXBlLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAvLyBUT0RPIHdlIG5lZWQgdGhpcyB0byBwcm9wZXJseSByZXR1cm4gYSBwYWNrZWQgdmVjNCBmcm9tIGtlcm5lbHMuXG4gICAgLy8gUmVwbGFjZSBhbGwgJ3tnbHNsLm91dHB1dH0gPSByZXN1bHQnIHdpdGggJ3NldE91dHB1dChyZXN1bHQpJyBpbiBhbGwga2VybmVscy5cbiAgICBjb25zdCBmbG9hdFRleHR1cmVTZXRSU291cmNlID0gYFxuICAgICAgICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQodmFsLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIGA7XG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkZ1bmNOYW1lID0gJ2Zsb2F0VGV4dHVyZVNldFInO1xuICAgIHJlc3VsdFtmbG9hdFRleHR1cmVTZXRSRnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGZsb2F0VGV4dHVyZVNldFJTb3VyY2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGFyIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTogR2xzbExpYlJvdXRpbmUge1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogMUQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQxRENvb3JkcyhzaGFwZTogW251bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGlmIChwYWNrZWRUZXhTaGFwZVswXSA9PT0gMSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueSAqICR7cGFja2VkVGV4U2hhcGVbMV19LjApO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAocGFja2VkVGV4U2hhcGVbMV0gPT09IDEpIHtcbiAgICAgIHNvdXJjZSA9IGBcbiAgICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiBpbnQoVGV4Q29vcmRzLnggKiAke3BhY2tlZFRleFNoYXBlWzBdfS4wKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgc291cmNlID0gYFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueCk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIDJEIHBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0UGFja2VkMkRDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBpZiAoQXJyYXlVdGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIHJldHVybiAyICogaXZlYzIoVGV4Q29vcmRzLnh5ICogdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IHRleFNoYXBlO1xuICAgIC8vIHRleGVscyBuZWVkZWQgdG8gYWNjb21tb2RhdGUgYSBsb2dpY2FsIHJvd1xuICAgIGNvbnN0IHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVsxXSAvIDIpO1xuXG4gICAgLyoqXG4gICAgICogZ2V0T3V0cHV0Q29vcmRzXG4gICAgICpcbiAgICAgKiByZXNUZXhSQzogVGhlIHJvd3MgYW5kIGNvbHVtbnMgb2YgdGhlIHRleGVscy4gSWYgeW91IG1vdmUgb3ZlciBvbmVcbiAgICAgKiB0ZXhlbCB0byB0aGUgcmlnaHQgaW4gdGhlIHBhY2tlZCB0ZXh0dXJlLCB5b3UgYXJlIG1vdmluZyBvdmVyIG9uZSBjb2x1bW5cbiAgICAgKiAobm90IHR3bykuXG4gICAgICpcbiAgICAgKiBpbmRleDogVGhlIHRleGVsIGluZGV4XG4gICAgICovXG4gICAgc291cmNlID0gYFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7cGFja2VkVGV4U2hhcGVbMF19LCAke3BhY2tlZFRleFNoYXBlWzFdfSkpO1xuXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSkgKiAyO1xuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSk7XG5cbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIDNEIHBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcbiAgICBjb25zdCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBNYXRoLmNlaWwoc2hhcGVbMl0gLyAyKTtcbiAgICBjb25zdCB0ZXhlbHNJbkJhdGNoID0gdGV4ZWxzSW5Mb2dpY2FsUm93ICogTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7cGFja2VkVGV4U2hhcGVbMF19LCAke3BhY2tlZFRleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3BhY2tlZFRleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG5cbiAgICAgICAgICBpbnQgYiA9IGluZGV4IC8gJHt0ZXhlbHNJbkJhdGNofTtcbiAgICAgICAgICBpbmRleCAtPSBiICogJHt0ZXhlbHNJbkJhdGNofTtcblxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcbiAgICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSkgKiAyO1xuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSk7XG5cbiAgICAgICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5EIHBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0UGFja2VkTkRDb29yZHMoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuXG4gICAgY29uc3QgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdIC8gMik7XG4gICAgY29uc3QgdGV4ZWxzSW5CYXRjaCA9IHRleGVsc0luTG9naWNhbFJvdyAqIE1hdGguY2VpbChzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSAvIDIpO1xuICAgIGxldCB0ZXhlbHNJbkJhdGNoTiA9IHRleGVsc0luQmF0Y2g7XG4gICAgbGV0IGJhdGNoZXMgPSAnJztcbiAgICBsZXQgY29vcmRzID0gJ2IsIHIsIGMnO1xuXG4gICAgZm9yIChsZXQgYiA9IDI7IGIgPCBzaGFwZS5sZW5ndGggLSAxOyBiKyspIHtcbiAgICAgIHRleGVsc0luQmF0Y2hOICo9IHNoYXBlW3NoYXBlLmxlbmd0aCAtIGIgLSAxXTtcbiAgICAgIGJhdGNoZXMgPSBgXG4gICAgICBpbnQgYiR7Yn0gPSBpbmRleCAvICR7dGV4ZWxzSW5CYXRjaE59O1xuICAgICAgaW5kZXggLT0gYiR7Yn0gKiAke3RleGVsc0luQmF0Y2hOfTtcbiAgICBgICsgYmF0Y2hlcztcbiAgICAgIGNvb3JkcyA9IGBiJHtifSwgYCArIGNvb3JkcztcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgaXZlYyR7c2hhcGUubGVuZ3RofSBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3BhY2tlZFRleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG5cbiAgICAgICAgJHtiYXRjaGVzfVxuXG4gICAgICAgIGludCBiID0gaW5kZXggLyAke3RleGVsc0luQmF0Y2h9O1xuICAgICAgICBpbmRleCAtPSBiICogJHt0ZXhlbHNJbkJhdGNofTtcblxuICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXG4gICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7dGV4ZWxzSW5Mb2dpY2FsUm93fSk7XG5cbiAgICAgICAgcmV0dXJuIGl2ZWMke3NoYXBlLmxlbmd0aH0oJHtjb29yZHN9KTtcbiAgICAgIH1cbiAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCAxRCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyhzaGFwZTogW251bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgcmV0dXJuIHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDJEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHtzaGFwZVsxXX07XG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3NoYXBlWzFdfTtcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDNEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgICR7Y29vcmRzRnJvbUluZGV4U25pcHBldH1cbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDREIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOlxuICAgICAgR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCcsICdkMiddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkNURDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTpcbiAgICAgIEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID1cbiAgICAgICAgc3RyaWRlc1xuICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUyID0gaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaSArIDFdfSA9IGluZGV4IC0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICBgaW5kZXggLT0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgICAgIHJldHVybiBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW1xuICAgIG51bWJlciwgbnVtYmVyXG4gIF0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJywgJ2QyJywgJ2QzJywgJ2Q0J107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9XG4gICAgICAgIHN0cmlkZXNcbiAgICAgICAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMiA9IGkgPT09IHN0cmlkZXMubGVuZ3RoIC0gMSA/XG4gICAgICAgICAgICAgICAgICBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2kgKyAxXX0gPSBpbmRleCAtICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWAgOlxuICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtsaW5lMX07ICR7bGluZTJ9O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgc291cmNlID0gYFxuICAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XG4gICAgICAgfVxuICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgY29tbW9uIFVWIGNvb3JkcyBjb21wdXRhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRDb21tb25VdGlsRnVuY3MoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBsZXQgZnVuY05hbWUgPSAndXZGcm9tRmxhdCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgdmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC8gdGV4TnVtUjtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcbiAgICAgIC8vIFRPRE86IHN3YXAgdGV4UiwgdGV4QyBvcmRlciBpbiBmb2xsb3dpbmcgZnVuY3Rpb24gc28gcm93IGlzIGNvcnJlc3BvbmRpbmcgdG8gdSBhbmQgY29sdW1uIGlzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgIC8vICAgICAgIHYuXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcbiAgICB9XG4gICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tMUQnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tMkQnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gICAgICAgIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIGZ1bmNOYW1lID0gJ3BhY2tlZFVWZnJvbTNEJztcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcbiAgICAgICAgICBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIGZ1bmNOYW1lID0gJ3NhbXBsZVRleHR1cmUnO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XG4gICAgICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0odGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xuICAgICAgICB9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIGlucHV0c1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5zYW1wbGVycy5mb3JFYWNoKChzYW1wbGVyTmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldO1xuICAgICAgY29uc3QgZnVuY05hbWUgPSBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUoc2FtcGxlck5hbWUpO1xuICAgICAgaWYgKGlucHV0TGF5b3V0LmlzUGFja2VkKSB7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIHNhbXBsZXJOYW1lLCBpbnB1dExheW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIHNhbXBsZXJOYW1lLCBpbnB1dExheW91dCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dENvb3JkRnVuY05hbWUgPSBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3JkcyhzYW1wbGVyTmFtZSk7XG4gICAgICBpZiAoaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGggPD0gb3V0cHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dExheW91dC5pc1BhY2tlZCkge1xuICAgICAgICAgIHJlc3VsdFtvdXRDb29yZEZ1bmNOYW1lXSA9XG4gICAgICAgICAgICAgIHRoaXMuZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKG91dENvb3JkRnVuY05hbWUsIGlucHV0TGF5b3V0LCBvdXRwdXRMYXlvdXQsIHNhbXBsZXJOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbb3V0Q29vcmRGdW5jTmFtZV0gPVxuICAgICAgICAgICAgICB0aGlzLmdldFVucGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKG91dENvb3JkRnVuY05hbWUsIGlucHV0TGF5b3V0LCBvdXRwdXRMYXlvdXQsIHNhbXBsZXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIG91dHB1dCBjb29yZGluYXRlcyBvZiBzYW1wbGVyc1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgIGZ1bmNOYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG5hbWU6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBpblNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleE5hbWUgPSBuYW1lO1xuICAgIGNvbnN0IHRleEZ1bmNTbmlwcGV0ID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHRleE5hbWUpO1xuXG4gICAgY29uc3QgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgb3V0UmFuayA9IG91dFNoYXBlLmxlbmd0aDtcblxuICAgIGNvbnN0IGJyb2FkY2FzdERpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpO1xuXG4gICAgY29uc3QgdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dFJhbmspO1xuICAgIGNvbnN0IHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgICBsZXQgY29vcmRzU25pcHBldDogc3RyaW5nO1xuICAgIGNvbnN0IGZpZWxkcyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXTtcblxuICAgIGlmIChpblJhbmsgPT09IDApIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9IGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gYnJvYWRjYXN0RGltcy5tYXAoZCA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5TaGFwZS5tYXAoKHMsIGkpID0+IGBjb29yZHMuJHtmaWVsZHNbaSArIHJhbmtEaWZmXX1gKS5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIGxldCBvdXRwdXQgPSAncmV0dXJuIG91dHB1dFZhbHVlOyc7XG4gICAgY29uc3QgaW5TaXplID0gU2hhcGVVdGlsLnNpemUoaW5TaGFwZSk7XG4gICAgY29uc3QgaXNJbnB1dFNjYWxhciA9IGluU2l6ZSA9PT0gMTtcbiAgICBjb25zdCBvdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0U2hhcGUpO1xuICAgIGNvbnN0IGlzT3V0cHV0U2NhbGFyID0gb3V0U2l6ZSA9PT0gMTtcblxuICAgIGlmIChpblJhbmsgPT09IDEgJiYgIWlzSW5wdXRTY2FsYXIgJiYgIWlzT3V0cHV0U2NhbGFyKSB7XG4gICAgICBvdXRwdXQgPSBgXG4gICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS55eSk7XG4gICAgICBgO1xuICAgIH0gZWxzZSBpZiAoaXNJbnB1dFNjYWxhciAmJiAhaXNPdXRwdXRTY2FsYXIpIHtcbiAgICAgIGlmIChvdXRSYW5rID09PSAxKSB7XG4gICAgICAgIG91dHB1dCA9IGBcbiAgICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54LCBvdXRwdXRWYWx1ZS54LCAwLiwgMC4pO1xuICAgICAgICBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gYFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngpO1xuICAgICAgICBgO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJvd3MgPSBpblJhbmsgLSAyO1xuICAgICAgY29uc3QgY29scyA9IGluUmFuayAtIDE7XG5cbiAgICAgIGlmIChicm9hZGNhc3REaW1zLmluZGV4T2Yocm93cykgPiAtMSAmJiBicm9hZGNhc3REaW1zLmluZGV4T2YoY29scykgPiAtMSkge1xuICAgICAgICBvdXRwdXQgPSAncmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7JztcbiAgICAgIH0gZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKHJvd3MpID4gLTEpIHtcbiAgICAgICAgb3V0cHV0ID0gJ3JldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnksICcgK1xuICAgICAgICAgICAgJ291dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpOyc7XG4gICAgICB9IGVsc2UgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihjb2xzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopOyc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICR7dHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgdmVjNCBvdXRwdXRWYWx1ZSA9ICR7dGV4RnVuY1NuaXBwZXR9KCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gICAgICAgICR7b3V0cHV0fVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdGluZyBzbmlwcGV0cyBmb3IgdW5wYWNrZWQgb3V0cHV0IGNvb3JkaW5hdGVzIG9mIHNhbXBsZXJzXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgICBmdW5jTmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCwgb3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgb3V0VGV4U2hhcGUgPSBbb3V0cHV0TGF5b3V0LndpZHRoLCBvdXRwdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBpblRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGluUmFuayA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZShuYW1lKTtcblxuICAgIGlmIChpblJhbmsgPT09IG91dFJhbmsgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKGluVGV4U2hhcGUsIG91dFRleFNoYXBlKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgVGV4Q29vcmRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBbJ3gnLCAneScsICd6JywgJ3cnLCAndScsICd2J107XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2ZpZWxkc1tkICsgcmFua0RpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGxldCB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubWFwKChzLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgICByZXR1cm4gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBwYWNrZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgc3dpdGNoIChpbnB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lLCBuYW1lKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QoZnVuY05hbWUsIG5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIHVucGFja2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IG1vcmUgZGltZW5zaW9uYWxpdGllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke3NoYXBlLmxlbmd0aH0tRGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgc2NhbGFyIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgdmVjNCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMV0sIHRleFNoYXBlWzBdXTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxuICAgICAgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19LCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMUQnXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1DfS4wLCAke3RleE51bVJ9LjApO1xuICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgICAgfWA7XG5cbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUocGFja2VkU2FtcGxlcik7XG4gICAgfVxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCgke3BhY2tlZFRleFNoYXBlWzFdfSwgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7dmFsdWVzUGVyUm93fSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTJEJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGtlcHREaW1zID0gWzEsIDJdO1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYicsICdyb3cnLCAnY29sJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgICAgY29uc3Qgc2FtcGxlclJvdXRpbmUgPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KTtcbiAgICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgJHtzYW1wbGVyUm91dGluZS5yb3V0aW5lQm9keX1cbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgIH0gYDtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgc2FtcGxlclJvdXRpbmUuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgY29uc3QgdGV4TnVtUiA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSBwYWNrZWRUZXhTaGFwZVsxXTtcblxuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgdmVjNCAke2Z1bmNOYW1lfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxuICAgICAgICAke3RleE51bUN9LCAke3RleE51bVJ9LCAke3RleGVsc0luQmF0Y2h9LCAke3ZhbHVlc1BlclJvd30sIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7fWA7XG4gICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRCddKTtcbiAgfVxuICAvKlxuICAgKiBQYWNrZWQgTkQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyTkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcbiAgICBjb25zdCB0ZXhOdW1SID0gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgY29uc3QgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMV0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMl0gLyAyKTtcbiAgICBsZXQgcGFyYW1zID0gJ2ludCBiLCBpbnQgcm93LCBpbnQgY29sJztcbiAgICBsZXQgaW5kZXggPSBgYiAqICR7dGV4ZWxzSW5CYXRjaH0gKyAocm93IC8gMikgKiAke3ZhbHVlc1BlclJvd30gKyAoY29sIC8gMilgO1xuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgcmFuayAtIDE7IGIrKykge1xuICAgICAgcGFyYW1zID0gYGludCBiJHtifSwgYCArIHBhcmFtcztcbiAgICAgIHRleGVsc0luQmF0Y2ggKj0gc2hhcGVbcmFuayAtIGIgLSAxXTtcbiAgICAgIGluZGV4ID0gYGIke2J9ICogJHt0ZXhlbHNJbkJhdGNofSArIGAgKyBpbmRleDtcbiAgICB9XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KCR7cGFyYW1zfSkge1xuICAgICAgaW50IGluZGV4ID0gJHtpbmRleH07XG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gJHt0ZXhOdW1DfTtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogJHt0ZXhOdW1DfTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtQ30sICR7dGV4TnVtUn0pO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCBzY2FsYXIgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBbdGV4TnVtUiwgdGV4TnVtQ10gPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgaWYgKHRleE51bVIgPT09IDEgJiYgdGV4TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgaW50IG9mZnNldF8ke25hbWV9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleE51bVJ9LCAke3RleE51bUN9KTtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBvZmZzZXRfJHtuYW1lfSk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMUQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHROdW1SID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG5cbiAgICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgaWYgKHROdW1DID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7dE51bVJ9LjAsIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG4gICAgaWYgKHROdW1SID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHt0TnVtQ30uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3ROdW1SfSwgJHt0TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcblxuICAgIC8vIFRPRE86IG1vZGlmeSByb3cvY29sIG9yZGVyIGZvciBvdGhlciBkaW1lbnNpb25zLlxuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LmhlaWdodCwgaW5wdXRMYXlvdXQud2lkdGhdO1xuXG4gICAgaWYgKHRleFNoYXBlICE9IG51bGwgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVswXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1SfS4wLCAke3RleE51bUN9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ2NvbCcsICdyb3cnXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke3RleE51bVJ9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHt0ZXhOdW1DfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtzaGFwZVsxXX0gKyByb3c7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICBzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDNEIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl07XG5cbiAgICBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYmF0Y2gnLCAnY29sJywgJ3JvdyddO1xuICAgICAgLy8gRGVlcCBjb3B5IG9mIGlucHV0IHRleHR1cmUgbGF5b3V0LlxuICAgICAgY29uc3QgbmV3SW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0TGF5b3V0KSk7XG4gICAgICBuZXdJbnB1dExheW91dC51bnBhY2tlZFNoYXBlID0gbmV3SW5wdXRTaGFwZTtcbiAgICAgIGNvbnN0IHJvdXRpbmUgPSB0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpO1xuICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGUgbG9naWMgaGVyZSB0byBtYWtlIGl0IHNpbXBsZXJcbiAgICAgIGNvbnN0IHJldkRpbXMgPSBrZXB0RGltcy5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHtyb3V0aW5lLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCByZXZEaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCByb3V0aW5lLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICAgICAgaW50IGluZGV4ID0gZGVwdGggKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIHJvdztcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNEQgc25pcHBldC5cbiAgICovXG5cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjREKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgICAvL1xuICAgIC8vIFRPRE86IHJlLWVuYWJsZSB0aGlzIHNob3J0Y3V0IG9uY2UgdGhlIGluZGV4IGNhbGN1bGF0aW9uIGJ1ZyBpcyBmaXhlZC5cbiAgICAvL1xuICAgIC8vIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICAvLyBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgLy8gICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAvLyAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInXTtcbiAgICAvLyAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAvLyAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgIC8vICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG4gICAgLy8gICBjb25zdCBzb3VyY2UgPSBgXG4gICAgLy8gICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgIC8vICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgIC8vICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIGA7XG4gICAgLy8gICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgIC8vICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArXG4gICAgICAgICAgICAgIGRlcHRoMiAqICR7c3RyaWRlMn0gKyBkZXB0aDtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA1RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjVEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzaGFwZVs0XTtcbiAgICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM10gKiBzdHJpZGUzO1xuICAgIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcblxuICAgIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgZGVwdGgzICogJHtzdHJpZGUzfSArIGRlcHRoMjtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjZEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTQgPSBzaGFwZVs1XTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF0gKiBzdHJpZGU0O1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgY29uc3QgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMicsICdkZXB0aDMnLCAnZGVwdGg0J107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy51dkZyb21GbGF0J10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSBpbnB1dExheW91dC53aWR0aDtcbiAgICBjb25zdCB0ZXhOdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgICBkZXB0aDIgKiAke3N0cmlkZTN9ICsgZGVwdGgzICogJHtzdHJpZGU0fSArIGRlcHRoNDtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIG1hcCBmcm9tIHRoZSBnaXZlbiB0ZXh0dXJlIGNvb3JkaWFudGVzIChzLHQpXG4gICAqIHRvIGxvZ2ljYWwgaW5kaWNlcyBmb3IgdGhlIG91dHB1dFxuICAgKiBUaGVyZSB3aWxsIG9ubHkgYmUgb25lIHNpbmdsZSB2YXJpYXRpb24gb2YgdGhpc1xuICAgKiBBbHNvIHNlZSBjb29yZHNUb09mZnNldCBhbmQgb2Zmc2V0VG9JbmRpY2VzIGZvciBpbnB1dC1zcGVjaWZpYyB2ZXJzaW9uc1xuICAgKi9cbiAgcHJvdGVjdGVkIHRvVmVjKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXQuc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHN0cmlkZXMgPSBvdXRwdXQuc3RyaWRlcztcbiAgICBjb25zdCB4U2NhbGUgPSBvdXRwdXQud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gb3V0cHV0LmhlaWdodDtcblxuICAgIGNvbnN0IHN0cmlkZXNCbG9jayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgICBjWyR7aX1dID0gb2Zmc2V0IC8gJHtzdHJpZGVzW2ldfTtgKTtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgb2Zmc2V0IC09IGNbJHtpfV0gKiAke3N0cmlkZXNbaV19O2ApO1xuICAgIH1cbiAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIGNbJHtyYW5rIC0gMX1dID0gb2Zmc2V0O2ApO1xuICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICB2b2lkIHRvVmVjKHZlYzIgdGV4Q29vcmRzLCBvdXQgaW50IGNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KHRleENvb3JkcywgJHt4U2NhbGV9LCAke3lTY2FsZX0pO1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICAgIHZvaWQgdG9WZWMoaW50IG9mZnNldCwgb3V0IGludCBjWyR7cmFua31dKSB7XG4gICAgICAgICR7c3RyaWRlc0Jsb2NrLmpvaW4oJycpfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHt0b1ZlYzogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHksIFsnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSl9O1xuICB9XG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgdmFsdWUgZ2V0dGVyIGZ1bmN0aW9ucyBnZW5lcmF0ZWQgZm9yIGVhY2ggaW5wdXRcbiAgICogRWFjaCBmdW5jdGlvbiBpcyBoYXJkd2lyZWQgdG8gdGhlIG5hbWUgYW5kIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0XG4gICAqIEFuICdfVCcgdmFyaWF0aW9uIGlzIGFsc28gcHJvZHVjZWQgd2hpY2ggYWNjZXNzZXMgdmFsdWVzIGFzIGlmIHRoZVxuICAgKiBpbnB1dCB3YXMgdHJhbnNwb3NlZFxuICAgKi9cbiAgcHJvdGVjdGVkIHZhbHVlRnJvbSgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm87XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5zYW1wbGVycy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV07XG4gICAgICBjb25zdCBzaGFwZSA9IGxheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCA+IDAgPyBsYXlvdXQudW5wYWNrZWRTaGFwZSA6IGxheW91dC5zaGFwZTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgZnVuY05hbWUgPSBgXyR7bmFtZX1gO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgICB0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShuYW1lLCByYW5rLCBsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHQsIGZhbHNlKSxcbiAgICAgICAgICBbYHNoYXBlVXRpbHMuaW5kaWNlc1RvT2Zmc2V0JHtmdW5jTmFtZX1gLCAnY29vcmRpbmF0ZXMub2Zmc2V0VG9Db29yZHMnLCAnZnJhZ2NvbG9yLmdldENvbG9yQXNGbG9hdCddKTtcbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUgKyAnX1QnO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgICB0aGlzLmdldFZhbHVlRnJvbVNpbmdsZShuYW1lLCByYW5rLCBsYXlvdXQud2lkdGgsIGxheW91dC5oZWlnaHQsIHRydWUpLFxuICAgICAgICAgIFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2Z1bmNOYW1lfWAsICdjb29yZGluYXRlcy5vZmZzZXRUb0Nvb3JkcycsICdmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0J10pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFByb2R1Y2VzIG9uZSB2YWx1ZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBuYW1lIGFuZCByYW5rIGdpdmVuXG4gICAqIElmIGEgdHJhbnNwb3NlIGlzIHNldCBwcm9wZXIgb2Zmc2V0VG9Db29yZHMgbWFwcGluZyB3aWxsIGJlIHVzZWRcbiAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHJhbmsgcmFuayBvZiB0aGUgaW5wdXRcbiAgICogQHBhcmFtIHRyYW5zcG9zZSB3aGV0aGVyIG9yIG5vdCBzaG91bGQgZ2VuZXJhdGUgYSB0cmFuc3Bvc2UgdmFyaWF0aW9uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VmFsdWVGcm9tU2luZ2xlKHZhck5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgdHJhbnNwb3NlOiBib29sZWFuKTpcbiAgICAgIHN0cmluZyB7XG4gICAgbGV0IG5hbWUgPSBgXyR7dmFyTmFtZX1gO1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJ19UJztcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gYFxuICAgICAgICBmbG9hdCAke25hbWV9KGludCBtWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldCR7bmFtZX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KCR7dmFyTmFtZX0sIGNvb3JkcykpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgcGFja2VkIHZhbHVlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIG5hbWUgYW5kIHJhbmsgZ2l2ZW5cbiAgICogSWYgYSB0cmFuc3Bvc2UgaXMgc2V0IHByb3BlciBvZmZzZXRUb0Nvb3JkcyBtYXBwaW5nIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmFuayByYW5rIG9mIHRoZSBpbnB1dFxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIHdoZXRoZXIgb3Igbm90IHNob3VsZCBnZW5lcmF0ZSBhIHRyYW5zcG9zZSB2YXJpYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRWYWx1ZUZyb20odmFyTmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0cmFuc3Bvc2U6IGJvb2xlYW4pOlxuICAgICAgc3RyaW5nIHtcbiAgICBsZXQgbmFtZSA9IGBfJHt2YXJOYW1lfV9QYWNrYDtcbiAgICBpZiAodHJhbnNwb3NlKSB7XG4gICAgICBuYW1lID0gbmFtZSArICdfVCc7XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgdmVjNCAke25hbWV9KGludCBtWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF8ke3Zhck5hbWV9KG0pO1xuICAgICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3dpZHRofSwgJHtoZWlnaHR9KTtcbiAgICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHt2YXJOYW1lfSwgY29vcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtQcm9ncmFtSW5mb30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1dlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC1jb250ZXh0JztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5leHBvcnQgZW51bSBGdW5jdGlvblR5cGUge1xuICBWYWx1ZUJhc2VkLFxuICBQb3NpdGlvbmFsXG59XG5leHBvcnQgaW50ZXJmYWNlIEdsc2xGdW5jdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb25UeXBlPiB7XG4gIGJvZHk6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiBUO1xufVxuZXhwb3J0IHR5cGUgR2xzbFZhbHVlRnVuY3Rpb24gPSBHbHNsRnVuY3Rpb248RnVuY3Rpb25UeXBlLlZhbHVlQmFzZWQ+O1xuZXhwb3J0IGludGVyZmFjZSBHbHNsUG9zaXRpb25hbEZ1bmN0aW9uIGV4dGVuZHMgR2xzbEZ1bmN0aW9uPEZ1bmN0aW9uVHlwZS5Qb3NpdGlvbmFsPiB7XG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCBjbGFzcyBHbHNsQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCwgcHVibGljIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbykge31cbn1cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7fVxuICBhYnN0cmFjdCBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX07XG4gIGFic3RyYWN0IGdldEN1c3RvbVR5cGVzKCk6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfTtcbn1cblxuLy8gYWJzdHJhY3Rpb24gdG8gcmVwcmVzZW50IGEgR0xTTCBsaWJyYXJ5IHJvdXRpbmUgYW5kIGl0J3MgZGVwZW5kZW5jaWVzXG5leHBvcnQgY2xhc3MgR2xzbExpYlJvdXRpbmUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcm91dGluZUJvZHk6IHN0cmluZywgcHVibGljIGRlcGVuZGVuY2llcz86IHN0cmluZ1tdKSB7fVxufVxuXG4vLyBhYnN0cmFjdGlvbiB0byByZXByZXNlbnQgYSBHTFNMIGxpYnJhcnkgcm91dGluZSBhbmQgaXQncyBkZXBlbmRlbmNpZXMgQVMgR1JBUEggTm9kZXNcbi8vIHRoaXMgbGV2ZWwgb2YgYWJzdHJhY3Rpb24gaXMgdXNlZCB0byB0b3BvbG9naWNhbGx5IHNvcnQgcm91dGluZXMgYmVmb3JlIGZyYWdtZW50IHNoYWRlIGluY2x1c2lvblxuZXhwb3J0IGNsYXNzIEdsc2xMaWJSb3V0aW5lTm9kZSB7XG4gIGRlcGVuZGVuY2llczogR2xzbExpYlJvdXRpbmVOb2RlW107XG4gIHJvdXRpbmVCb2R5OiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcsIHJvdXRpbmVCb2R5Pzogc3RyaW5nLCBkZXBlbmRlbmNpZXM/OiBHbHNsTGliUm91dGluZU5vZGVbXSkge1xuICAgIGlmIChkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChyb3V0aW5lQm9keSkge1xuICAgICAgdGhpcy5yb3V0aW5lQm9keSA9IHJvdXRpbmVCb2R5O1xuICAgIH1cbiAgfVxuICBhZGREZXBlbmRlbmN5KG5vZGU6IEdsc2xMaWJSb3V0aW5lTm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0b3BvbG9naWNhbGx5IHNvcnQgR0xTTCBsaWJyYXJ5IHJvdXRpbmVzIChncmFwaCBub2RlcyBhYnN0cmFjdGlvbikgYmVmb3JlIHNoYWRlciBzY3JpcHQgaW5jbHVzaW9uXG5leHBvcnQgY2xhc3MgVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzIHtcbiAgc3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyhub2RlczogR2xzbExpYlJvdXRpbmVOb2RlW10pOiBHbHNsTGliUm91dGluZU5vZGVbXSB7XG4gICAgaWYgKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgY3ljbGVDaGVjayA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGFscmVhZHlUcmF2ZXJzZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8R2xzbExpYlJvdXRpbmVOb2RlPigpO1xuXG4gICAgdGhpcy5jcmVhdGVPcmRlcmVkTm9kZXMobm9kZXMsIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWF0ZU9yZGVyZWROb2RlcyhcbiAgICAgIGdyYXBoTm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLCBjeWNsZUNoZWNrOiBTZXQ8c3RyaW5nPiwgYWxyZWFkeVRyYXZlcnNlZDogU2V0PHN0cmluZz4sXG4gICAgICByZXN1bHQ6IEdsc2xMaWJSb3V0aW5lTm9kZVtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmRmc1RyYXZlcnNlKGdyYXBoTm9kZXNbaV0sIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZGZzVHJhdmVyc2UoXG4gICAgICByb290OiBHbHNsTGliUm91dGluZU5vZGUsIGN5Y2xlQ2hlY2s6IFNldDxzdHJpbmc+LCBhbHJlYWR5VHJhdmVyc2VkOiBTZXQ8c3RyaW5nPiwgcmVzdWx0OiBHbHNsTGliUm91dGluZU5vZGVbXSkge1xuICAgIC8vIGlmIHRoaXMgcm9vdCBoYXMgYWxyZWFkeSBiZWVuIHRyYXZlcnNlZCByZXR1cm5cbiAgICBpZiAoIXJvb3QgfHwgYWxyZWFkeVRyYXZlcnNlZC5oYXMocm9vdC5uYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGN5Y2xpYyBkZXBlbmRlbmN5IGhhcyBiZWVuIGRldGVjdGVkXG4gICAgaWYgKGN5Y2xlQ2hlY2suaGFzKHJvb3QubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhblxcJ3QgdG9wb2xvZ2ljYWxseSBzb3J0IHJvdXRpbmVzIG5lZWRlZCBmb3Igc2hhZGVyLicpO1xuICAgIH1cblxuICAgIC8vIGhvbGQgdGhpcyBub2RlIHRvIGRldGVjdCBjeWNsZXMgaWYgYW55XG4gICAgY3ljbGVDaGVjay5hZGQocm9vdC5uYW1lKTtcblxuICAgIC8vIHRyYXZlcnNlIGNoaWxkcmVuIGluIGEgZGZzIGZhc2hpb25cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSByb290LmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRmc1RyYXZlcnNlKGRlcGVuZGVuY2llc1tpXSwgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gcmVzdWx0IGhvbGRlclxuICAgIHJlc3VsdC5wdXNoKHJvb3QpO1xuXG4gICAgLy8gbWFyayB0aGlzIG5vZGUgYXMgdHJhdmVyc2VkIHNvIHRoYXQgd2UgZG9uJ3QgdHJhdmVyc2UgZnJvbSB0aGlzIGFnYWluXG4gICAgYWxyZWFkeVRyYXZlcnNlZC5hZGQocm9vdC5uYW1lKTtcblxuICAgIC8vIHJlbGVhc2UgdGhlIGhvbGRcbiAgICBjeWNsZUNoZWNrLmRlbGV0ZShyb290Lm5hbWUpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogVGhpcyBHTFNMIGxpYnJhcnkgaGFuZGxlcyByb3V0aW5lcyBjb252ZXJ0aW5nXG4gKiBmbG9hdDMyIHRvL2Zyb20gVW5zaWduZWQgYnl0ZSBvciBmbG9hdCAxNlxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RpbmdHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuZW5jb2RlRmxvYXQzMigpLCAuLi50aGlzLmRlY29kZUZsb2F0MzIoKX07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGVuY29kZUZsb2F0MzIoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xuICAgICAgICByZXR1cm4gdmVjNChmLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBkZWNvZGVGbG9hdDMyKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVjb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYGhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcbiAgICAgICAgcmV0dXJuIHJnYmEucjtcbiAgICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSByb3V0aW5lIHRvIGVuY29kZSBlbmNvZGUgYSAzMmJpdCBmbG9hdCB0byBhIHZlYzQgKG9mIHVuc2lnbmVkIGJ5dGVzKVxuICAgKiBAY3JlZGl0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDU5OTYyL2hvdy1kby1pLWNvbnZlcnQtYS12ZWM0LXJnYmEtdmFsdWUtdG8tYS1mbG9hdFxuICAgKi9cbiAgcHJvdGVjdGVkIGVuY29kZVVpbnQ4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBlbmRpYW5uZXNzID0gRW5jb2RpbmdHbHNsTGliLmlzTGl0dGxlRW5kaWFuKCkgPyAncmdiYS5yZ2JhPXJnYmEuYWJncjsnIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcbiAgICAgICAgaGlnaHAgZmxvYXQgRiA9IGFicyhmKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSAoZXhwMigtIEV4cG9uZW50KSAqIEYpO1xuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XG4gICAgICAgIGhpZ2hwIHZlYzQgcmdiYTtcbiAgICAgICAgcmdiYVswXSA9IDEyOC4wICogU2lnbiAgKyBmbG9vcihFeHBvbmVudCpleHAyKC0xLjApKTtcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcbiAgICAgICAgcmdiYVsyXSA9IGZsb29yKG1vZChmbG9vcihNYW50aXNzYSpleHAyKDIzLjAgLTguMCkpLGV4cDIoOC4wKSkpO1xuICAgICAgICByZ2JhWzNdID0gZmxvb3IoZXhwMigyMy4wKSptb2QoTWFudGlzc2EsZXhwMigtMTUuMCkpKTtcbiAgICAgICAgJHtlbmRpYW5uZXNzfVxuICAgICAgICByZ2JhID0gcmdiYSAvIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIFswLDFdXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSByb3V0aW5lIHRvIGVuY29kZSBhIHZlYzQgb2YgdW5zaWduZWQgYnl0ZXMgdG8gZmxvYXQzMlxuICAgKiBAY3JlZGl0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDU5OTYyL2hvdy1kby1pLWNvbnZlcnQtYS12ZWM0LXJnYmEtdmFsdWUtdG8tYS1mbG9hdFxuICAgKi9cbiAgcHJvdGVjdGVkIGRlY29kZVVpbnQ4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBlbmRpYW5uZXNzID0gRW5jb2RpbmdHbHNsTGliLmlzTGl0dGxlRW5kaWFuKCkgPyAncmdiYS5yZ2JhPXJnYmEuYWJncjsnIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xuICAgICAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7IC8vIHZhbHVlcyBuZWVkIHRvIGJlIGRlLW5vcm1hbGl6ZWQgZnJvbSBbMCwxXSB0byBbMCwyNTVdXG4gICAgICAgICAgJHtlbmRpYW5uZXNzfVxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcbiAgICAgICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzBdLDEyOC4wKSArIHN0ZXAoMTI4LjAscmdiYVsxXSkgLSAxMjcuMDtcbiAgICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzFdLDEyOC4wKSo2NTUzNi4wICsgcmdiYVsyXSoyNTYuMCArcmdiYVszXSArIGZsb2F0KDB4ODAwMDAwKTtcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcbiAgICAgICAgICByZXR1cm4gUmVzdWx0O1xuICAgICAgfVxuICAgICAgICBgKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIG1hY2hpbmUgaXMgbGl0dGxlIGVuZGlhbiBvciBub3RcbiAgICogQGNyZWRpdDogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vVG9vVGFsbE5hdGUvNDc1MDk1M1xuICAgKi9cbiAgc3RhdGljIGlzTGl0dGxlRW5kaWFuKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgY29uc3QgYSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgYVswXSA9IDB4ZGVhZGJlZWY7XG4gICAgaWYgKGNbMF0gPT09IDB4ZWYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY1swXSA9PT0gMHhkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZW5kaWFubmVzcycpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuXG4vKipcbiAqIFRoaXMgR0xTTCBsaWJyYXJ5IGhhbmRsZXMgcm91dGluZXMgYXJvdW5kIHJlYWRpbmcgYSB0ZXhsZXQgYW5kIHdyaXRpbmcgdG8gaXRcbiAqIFJlYWRpbmcgYW5kIHdyaXRpbmcgY291bGQgYmUgbW9yZSB0aGFuIGp1c3QgZGVhbGluZyB3aXRoIG9uZSBjaGFubmVsXG4gKiBJdCBtYXkgcmVxdWlyZSBlbmNvZGluZy9kZWNvZGluZyB0by9mcm9tIDQgY2hhbm5lbHMgaW50byBvbmVcbiAqL1xuZXhwb3J0IGNsYXNzIEZyYWdDb2xvckdsc2xMaWIgZXh0ZW5kcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7Li4udGhpcy5zZXRGcmFnQ29sb3IoKSwgLi4udGhpcy5nZXRDb2xvckFzRmxvYXQoKX07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIHNldEZyYWdDb2xvcigpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhZ0NvbG9yOiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgICAgYFxuICAgICAgICB2b2lkIHNldEZyYWdDb2xvcihmbG9hdCB2YWx1ZSkge1xuICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSBlbmNvZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgICAgICAgWydlbmNvZGluZy5lbmNvZGUnXSlcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRDb2xvckFzRmxvYXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb2xvckFzRmxvYXQ6IG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgICBgXG4gICAgICAgIGZsb2F0IGdldENvbG9yQXNGbG9hdCh2ZWM0IGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlKGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICAgIFsnZW5jb2RpbmcuZGVjb2RlJ10pXG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNvbnN0IElOTElORV9GVU5DX0RFRl9SRUdFWCA9IC9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207XG5jb25zdCBGVU5DX0NBTExfUkVHRVggPSAnKFxcXFx3Kyk/XFxcXHMrKFtfMC05YS16QS1aXSspXFxcXHMrPVxcXFxzK19fRlVOQ19fXFxcXCgoLiopXFxcXClcXFxccyo7Jztcbi8qKlxuICogR0xTTCBwcmVwcm9jZXNzb3IgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBAaW5saW5lIGRpcmVjdGl2ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VJbmxpbmVzKHNjcmlwdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaW5saW5lRGVmczoge1tuYW1lOiBzdHJpbmddOiB7cGFyYW1zOiBBcnJheTx7dHlwZTogc3RyaW5nOyBuYW1lOiBzdHJpbmd9fG51bGw+OyBib2R5OiBzdHJpbmd9fSA9IHt9O1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBJTkxJTkVfRlVOQ19ERUZfUkVHRVguZXhlYyhzY3JpcHQpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoWzNdXG4gICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgICAgICAgIC5tYXAocyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gcy50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zICYmIHRva2Vucy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogdG9rZW5zWzBdLCBuYW1lOiB0b2tlbnNbMV19O1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYgIT09IG51bGwpO1xuICAgIGlubGluZURlZnNbbWF0Y2hbMl1dID0ge3BhcmFtcywgYm9keTogbWF0Y2hbNF19O1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBpbmxpbmVEZWZzKSB7XG4gICAgY29uc3QgcmVnZXhTdHJpbmcgPSBGVU5DX0NBTExfUkVHRVgucmVwbGFjZSgnX19GVU5DX18nLCBuYW1lKTtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTdHJpbmcsICdnbScpO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHNjcmlwdCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWF0Y2hbMV07XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IG1hdGNoWzJdO1xuICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbM10uc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IGRlY2xMaW5lID0gKHR5cGUpID8gYCR7dHlwZX0gJHt2YXJpYWJsZX07YCA6ICcnO1xuICAgICAgbGV0IG5ld0JvZHk6IHN0cmluZyA9IGlubGluZURlZnNbbmFtZV0uYm9keTtcbiAgICAgIGxldCBwYXJhbVJlZGVjTGluZSA9ICcnO1xuICAgICAgaW5saW5lRGVmc1tuYW1lXS5wYXJhbXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHBhcmFtUmVkZWNMaW5lICs9IGAke3YudHlwZX0gJHt2Lm5hbWV9ID0gJHtwYXJhbXNbaV19O1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV3Qm9keSA9IGAke3BhcmFtUmVkZWNMaW5lfVxcbiAke25ld0JvZHl9YDtcbiAgICAgIG5ld0JvZHkgPSBuZXdCb2R5LnJlcGxhY2UoJ3JldHVybicsIGAke3ZhcmlhYmxlfSA9IGApO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBgXG4gICAgICAke2RlY2xMaW5lfVxuICAgICAge1xuICAgICAgICAke25ld0JvZHl9XG4gICAgICB9XG4gICAgICBgO1xuICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UobWF0Y2hbMF0sIHJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoSU5MSU5FX0ZVTkNfREVGX1JFR0VYLCAnJyk7XG4gIHJldHVybiBzY3JpcHQ7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmVOb2RlLCBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXN9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge3JlcGxhY2VJbmxpbmVzfSBmcm9tICcuL2dsc2wtZnVuY3Rpb24taW5saW5lcic7XG5pbXBvcnQge2dsc2xSZWdpc3RyeX0gZnJvbSAnLi9nbHNsLXJlZ2lzdGVyZWQtbGlicyc7XG5pbXBvcnQge2dldERlZmF1bHRGcmFnU2hhZGVyTWFpbiwgZ2V0RnJhZ1NoYWRlclByZWFtYmxlfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFZhcmlhYmxlSW5mb30gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1dlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC1jb250ZXh0JztcblxuLyoqXG4gKiBQcmVwcm9jZXNzb3IgZm9yIHRoZSBhZGRpdGlvbnMgdG8gdGhlIEdMU0wgbGFuZ3VhZ2VcbiAqIEl0IGRlYWxzIHdpdGg6XG4gKiAgQGluY2x1ZGUgZGlyZWN0aXZlc1xuICogIEBpbmxpbmVcbiAqICBMb29wIHVucm9sbGluZyAobm90IGltcGxlbWVudGVkKVxuICogIE1hY3JvIHJlc29sdXRpb24gKG5vdCBpbXBsZW1lbnRlZClcbiAqL1xuZXhwb3J0IGNsYXNzIEdsc2xQcmVwcm9jZXNzb3Ige1xuICByZWFkb25seSBjb250ZXh0OiBHbHNsQ29udGV4dDtcbiAgcmVhZG9ubHkgbGliczoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGlifSA9IHt9O1xuICByZWFkb25seSBnbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDoge1tyb3V0aW5lTmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmVOb2RlfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKGdsQ29udGV4dDogV2ViR0xDb250ZXh0LCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8pIHtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgR2xzbENvbnRleHQoZ2xDb250ZXh0LCBwcm9ncmFtSW5mbyk7XG5cbiAgICAvLyBjb25zdHJ1Y3QgR2xzbExpYnNcbiAgICBPYmplY3Qua2V5cyhnbHNsUmVnaXN0cnkpLmZvckVhY2goKG5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgbGliID0gbmV3IGdsc2xSZWdpc3RyeVtuYW1lXSh0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5saWJzW25hbWVdID0gbGliO1xuICAgIH0pO1xuXG4gICAgLy8gY29uc3RydWN0IEdsc2xSb3V0aW5lRGVwZW5kZW5jeUdyYXBoXG4gICAgY29uc3QgbWFwID0gdGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaDtcbiAgICBmb3IgKGNvbnN0IGxpYk5hbWUgaW4gdGhpcy5saWJzKSB7XG4gICAgICBjb25zdCBsaWIgPSB0aGlzLmxpYnNbbGliTmFtZV07XG4gICAgICBjb25zdCByb3V0aW5lc0luTGliID0gbGliLmdldEZ1bmN0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCByb3V0aW5lIGluIHJvdXRpbmVzSW5MaWIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbGliTmFtZSArICcuJyArIHJvdXRpbmU7XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZTogR2xzbExpYlJvdXRpbmVOb2RlO1xuICAgICAgICBpZiAobWFwW2tleV0pIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG1hcFtrZXldO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnJvdXRpbmVCb2R5ID0gcm91dGluZXNJbkxpYltyb3V0aW5lXS5yb3V0aW5lQm9keTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZSA9IG5ldyBHbHNsTGliUm91dGluZU5vZGUoa2V5LCByb3V0aW5lc0luTGliW3JvdXRpbmVdLnJvdXRpbmVCb2R5KTtcbiAgICAgICAgICBtYXBba2V5XSA9IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJvdXRpbmVzSW5MaWJbcm91dGluZV0uZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbWFwW2RlcGVuZGVuY2llc1tpXV0pIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBHbHNsTGliUm91dGluZU5vZGUoZGVwZW5kZW5jaWVzW2ldKTtcbiAgICAgICAgICAgICAgbWFwW2RlcGVuZGVuY2llc1tpXV0gPSBub2RlO1xuICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hZGREZXBlbmRlbmN5KG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUuYWRkRGVwZW5kZW5jeShtYXBbZGVwZW5kZW5jaWVzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJlcHJvY2VzcygpOiBzdHJpbmcge1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvO1xuICAgIGxldCBzb3VyY2UgPSBwcm9ncmFtSW5mby5zaGFkZXJTb3VyY2U7XG5cbiAgICAvLyBhcHBlbmQgbWFpbigpIGZ1bmN0aW9uXG4gICAgaWYgKCF0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaGFzTWFpbikge1xuICAgICAgc291cmNlID0gYCR7c291cmNlfVxuICAgICAgJHtnZXREZWZhdWx0RnJhZ1NoYWRlck1haW4odGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uLCBwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoKX1gO1xuICAgIH1cbiAgICAvLyByZXBsYWNlIGlubGluZXNcbiAgICBzb3VyY2UgPSByZXBsYWNlSW5saW5lcyhzb3VyY2UpO1xuXG4gICAgLy8gY29uY2F0IGZpbmFsIHNvdXJjZSBzdHJpbmdcbiAgICByZXR1cm4gYCR7Z2V0RnJhZ1NoYWRlclByZWFtYmxlKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbil9XG4gICAgJHt0aGlzLmdldFVuaWZvcm1zKHByb2dyYW1JbmZvLnNhbXBsZXJzLCBwcm9ncmFtSW5mby52YXJpYWJsZXMpfVxuICAgICR7dGhpcy5nZXRJbXBvcnRzKHNvdXJjZSl9XG4gICAgJHtzb3VyY2V9YDtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRJbXBvcnRzKHNjcmlwdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCByb3V0aW5lc0luY2x1ZGVkID0gdGhpcy5zZWxlY3RHbHNsTGliUm91dGluZXNUb0JlSW5jbHVkZWQoc2NyaXB0KTtcblxuICAgIGlmIChyb3V0aW5lc0luY2x1ZGVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCByb3V0aW5lcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGluZXNJbmNsdWRlZC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHJvdXRpbmVzSW5jbHVkZWRbaV0ucm91dGluZUJvZHkpIHtcbiAgICAgICAgcm91dGluZXMgKz0gcm91dGluZXNJbmNsdWRlZFtpXS5yb3V0aW5lQm9keSArICdcXG4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGJvZHkgZm9yIHRoZSBHbHNsIExpYnJhcnkgcm91dGluZTogJHtyb3V0aW5lc0luY2x1ZGVkW2ldLm5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRpbmVzO1xuICB9XG4gIHByaXZhdGUgc2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkKHNjcmlwdDogc3RyaW5nKTogR2xzbExpYlJvdXRpbmVOb2RlW10ge1xuICAgIGNvbnN0IG5vZGVzOiBHbHNsTGliUm91dGluZU5vZGVbXSA9IFtdO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaCkuZm9yRWFjaChjbGFzc0FuZFJvdXRpbmUgPT4ge1xuICAgICAgY29uc3Qgcm91dGluZSA9IGNsYXNzQW5kUm91dGluZS5zcGxpdCgnLicpWzFdO1xuICAgICAgaWYgKHNjcmlwdC5pbmRleE9mKHJvdXRpbmUpICE9PSAtMSkge1xuICAgICAgICBub2Rlcy5wdXNoKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGhbY2xhc3NBbmRSb3V0aW5lXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzLnJldHVybk9yZGVyZWROb2Rlcyhub2Rlcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VW5pZm9ybXMoc2FtcGxlcnM/OiBzdHJpbmdbXSwgdmFyaWFibGVzPzogVmFyaWFibGVJbmZvW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHVuaWZvcm1MaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoc2FtcGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBvZiBzYW1wbGVycykge1xuICAgICAgICB1bmlmb3JtTGluZXMucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgJHtzYW1wbGVyfTtgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgICAgdW5pZm9ybUxpbmVzLnB1c2goXG4gICAgICAgICAgICBgdW5pZm9ybSAke3ZhcmlhYmxlLnR5cGV9ICR7dmFyaWFibGUubmFtZX0ke3ZhcmlhYmxlLmFycmF5TGVuZ3RoID8gYFske3ZhcmlhYmxlLmFycmF5TGVuZ3RofV1gIDogJyd9O2ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pZm9ybUxpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtDb29yZHNHbHNsTGlifSBmcm9tICcuL2dsc2wtY29vcmRpbmF0ZS1saWInO1xuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYn0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7RW5jb2RpbmdHbHNsTGlifSBmcm9tICcuL2dsc2wtZW5jb2RpbmctbGliJztcbmltcG9ydCB7RnJhZ0NvbG9yR2xzbExpYn0gZnJvbSAnLi9nbHNsLWZyYWdjb2xvci1saWInO1xuaW1wb3J0IHtTaGFwZVV0aWxzR2xzbExpYn0gZnJvbSAnLi9nbHNsLXNoYXBlLXV0aWxzLWxpYic7XG5pbXBvcnQge1ZlY0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC12ZWMtbGliJztcblxuZXhwb3J0IGNvbnN0IGdsc2xSZWdpc3RyeToge1tuYW1lOiBzdHJpbmddOiBuZXcgKGNvbnRleHQ6IEdsc2xDb250ZXh0KSA9PiBHbHNsTGlifSA9IHtcbiAgJ2VuY29kaW5nJzogRW5jb2RpbmdHbHNsTGliLFxuICAnZnJhZ2NvbG9yJzogRnJhZ0NvbG9yR2xzbExpYixcbiAgJ3ZlYyc6IFZlY0dsc2xMaWIsXG4gICdzaGFwZVV0aWxzJzogU2hhcGVVdGlsc0dsc2xMaWIsXG4gICdjb29yZGluYXRlcyc6IENvb3Jkc0dsc2xMaWIsXG4gIC8vICAnYXJyYXlzJzogQXJyYXlHbHNsU0xpYlxufTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZX0gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcblxuLyoqXG4gKiBHTFNMIExpYnJhcnkgcmVzcG9uc2libGUgZm9yIGRhdGEgdHlwZXMgYW5kIHJvdXRpbmVzIGZvciBtYW5pcHVsYXRpbmdcbiAqIGNvb3JkaW5hdGVzIGFuZCBtYXBwaW5nIHRvL2Zyb20gdGVuc29yIGluZGljZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXBlVXRpbHNHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5iY2FzdEluZGV4KCksXG4gICAgICAuLi50aGlzLmJjYXN0TWF0bXVsSW5kZXgoKSxcbiAgICAgIC4uLnRoaXMub2Zmc2V0VG9JbmRpY2VzKCksXG4gICAgICAuLi50aGlzLmluZGljZXNUb09mZnNldCgpLFxuICAgICAgLi4udGhpcy5pbmNyZW1lbnRJbmRpY2VzKClcbiAgICB9O1xuICB9XG4gIGdldEN1c3RvbVR5cGVzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBwcm90ZWN0ZWQgYmNhc3RJbmRleCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm87XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHByb2dyYW1JbmZvLm91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5zYW1wbGVycy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPD0gb3V0cHV0UmFuaykge1xuICAgICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBvdXRwdXRSYW5rIC0gcmFuaztcbiAgICAgICAgY29uc3QgZnVuY05hbWUgPSBgYmNhc3RJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgICBibG9jayArPSBgXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtpfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2RpbU9mZnNldCArIGl9XSksICR7c2hhcGVbaV19LjApICk7XG4gICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7ZnVuY05hbWV9IChpbnQgYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgYmNhc3RNYXRtdWxJbmRleCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm87XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHByb2dyYW1JbmZvLm91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5zYW1wbGVycy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGlmICghKHNoYXBlLmxlbmd0aCA8IDIgfHwgc2hhcGUubGVuZ3RoID4gb3V0cHV0UmFuaykpIHtcbiAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGltT2Zmc2V0ID0gb3V0cHV0UmFuayAtIHJhbms7XG4gICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gYGJjYXN0TWF0bXVsSW5kaWNlc18ke25hbWV9YDtcbiAgICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7ICsraSkge1xuICAgICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2l9XSA9IGludCggbW9kKGZsb2F0KGJjYXN0ZWRJbmRpY2VzWyR7ZGltT2Zmc2V0ICsgaX1dKSwgJHtzaGFwZVtpXX0uMCkgKTtcbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmdW5jTmFtZX0oaW50IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFua31dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICByZWFsSW5kaWNlc1ske3JhbmsgLSAxfV0gPSBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmsgLSAxfV07XG4gICAgICAgICAgcmVhbEluZGljZXNbJHtyYW5rIC0gMn1dID0gYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rIC0gMn1dO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgaW5kaWNlc1RvT2Zmc2V0KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXS5zdHJpZGVzO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBpbmRpY2VzVG9PZmZzZXRfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYGluZGljZXNUb09mZnNldF8ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMuc2xpY2UoKS5yZXZlcnNlKCkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBpbmRleFRvT2Zmc2V0U2luZ2xlKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgbGV0IGJsb2NrID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBvZmZzZXQgKz0gaW5kaWNlc1ske2l9XSAqICR7c3RyaWRlc1tpXX07XG4gICAgICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICBpbnQgJHtuYW1lfShpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGA7XG4gIH1cbiAgcHJvdGVjdGVkIG9mZnNldFRvSW5kaWNlcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcHJvZ3JhbUluZm8gPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm87XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5zYW1wbGVycy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBzaGFwZSA9IHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0uc3RyaWRlcztcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgZnVuY05hbWUgPSBgb2Zmc2V0VG9JbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShTaGFwZVV0aWxzR2xzbExpYi5vZmZzZXRUb0luZGljZXNTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYG9mZnNldFRvSW5kaWNlc18ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLm9mZnNldFRvSW5kaWNlc1NpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcy5zbGljZSgpLnJldmVyc2UoKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIG9mZnNldFRvSW5kaWNlc1NpbmdsZShuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlciwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHN0cmlkZXNCbG9jayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgaW5kaWNlc1ske2l9XSA9IG9mZnNldCAvICR7c3RyaWRlc1tpXX07YCk7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7aX1dICogJHtzdHJpZGVzW2ldfTtgKTtcbiAgICB9XG4gICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgaW5kaWNlc1ske3JhbmsgLSAxfV0gPSBvZmZzZXQ7YCk7XG4gICAgcmV0dXJuIGBcbiAgICAgIHZvaWQgJHtuYW1lfShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgJHtzdHJpZGVzQmxvY2suam9pbignJyl9XG4gICAgICB9XG4gICAgICBgO1xuICB9XG4gIHByb3RlY3RlZCBpbmNyZW1lbnRJbmRpY2VzKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLnNhbXBsZXJzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldLnNoYXBlO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGZ1bmNOYW1lID0gYGluY3JlbWVudEluZGljZXNfJHtuYW1lfWA7XG4gICAgICBsZXQgc2hhcGVJbml0ID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICBzaGFwZUluaXQgKz0gYFxuICAgICAgICBzaGFwZVske2l9XSA9ICR7c2hhcGVbaV19O2A7XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7ZnVuY05hbWV9KGludCBheGlzLCBvdXQgaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgc2hhcGVbJHtyYW5rfV07XG4gICAgICAgICAgJHtzaGFwZUluaXR9O1xuICAgICAgICAgIGZvcihpbnQgaSA9ICR7cmFua30gLTEgOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYoaSA+IGF4aXMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaW5kaWNlc1tpXSArPSAxO1xuICAgICAgICAgICAgaWYoaW5kaWNlc1tpXSA8IHNoYXBlW2ldKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlc1tpXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKipcbiAqIHJlcHJlc2VudCBhIHZlcnNpb24gaXJyZWxldmFudCBhYnN0cmFjdGlvbiBvZiBmb3IgR0xTTCBzb3VyY2UgY29kZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdsc2wge1xuICByZWFkb25seSB2ZXJzaW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGF0dHJpYnV0ZTogc3RyaW5nO1xuICByZWFkb25seSB2YXJ5aW5nVmVydGV4OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZhcnlpbmdGcmFnOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRleHR1cmUyRDogc3RyaW5nO1xuICByZWFkb25seSBvdXRwdXQ6IHN0cmluZztcbiAgcmVhZG9ubHkgb3V0cHV0RGVjbGFyYXRpb246IHN0cmluZztcbn1cblxuY29uc3QgR0xTTF9FU18yXzA6IEdsc2wgPSB7XG4gIHZlcnNpb246ICcnLFxuICBhdHRyaWJ1dGU6ICdhdHRyaWJ1dGUnLFxuICB2YXJ5aW5nVmVydGV4OiAndmFyeWluZycsXG4gIHZhcnlpbmdGcmFnOiAndmFyeWluZycsXG4gIHRleHR1cmUyRDogJ3RleHR1cmUyRCcsXG4gIG91dHB1dDogJ2dsX0ZyYWdDb2xvcicsXG4gIG91dHB1dERlY2xhcmF0aW9uOiAnJyxcbn07XG5jb25zdCBHTFNMX0VTXzNfMDogR2xzbCA9IHtcbiAgdmVyc2lvbjogJyN2ZXJzaW9uIDMwMCBlcycsXG4gIGF0dHJpYnV0ZTogJ2luJyxcbiAgdmFyeWluZ1ZlcnRleDogJ291dCcsXG4gIHZhcnlpbmdGcmFnOiAnaW4nLFxuICB0ZXh0dXJlMkQ6ICd0ZXh0dXJlJyxcbiAgb3V0cHV0OiAnb3V0cHV0Q29sb3InLFxuICBvdXRwdXREZWNsYXJhdGlvbjogJ291dCB2ZWM0IG91dHB1dENvbG9yOycsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xzbCh2ZXJzaW9uOiAxfDIpIHtcbiAgcmV0dXJuIHZlcnNpb24gPT09IDEgPyBHTFNMX0VTXzJfMCA6IEdMU0xfRVNfM18wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGV4U2hhZGVyU291cmNlKHZlcnNpb246IDF8Mik6IHN0cmluZyB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHZlcnNpb24pO1xuICByZXR1cm4gYCR7Z2xzbC52ZXJzaW9ufVxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICAgJHtnbHNsLmF0dHJpYnV0ZX0gdmVjMyBwb3NpdGlvbjtcbiAgICAgICR7Z2xzbC5hdHRyaWJ1dGV9IHZlYzIgdGV4dHVyZUNvb3JkO1xuXG4gICAgICAke2dsc2wudmFyeWluZ1ZlcnRleH0gdmVjMiBUZXhDb29yZHM7XG5cbiAgICAgIHZvaWQgbWFpbigpXG4gICAgICB7XG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApO1xuICAgICAgICAgIFRleENvb3JkcyA9IHRleHR1cmVDb29yZDtcbiAgICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ1NoYWRlclByZWFtYmxlKHZlcnNpb246IDF8Mik6IHN0cmluZyB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHZlcnNpb24pO1xuICByZXR1cm4gYCR7Z2xzbC52ZXJzaW9ufVxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XG4gICAgJHtnbHNsLnZhcnlpbmdGcmFnfSB2ZWMyIFRleENvb3JkcztcbiAgICAke2dsc2wub3V0cHV0RGVjbGFyYXRpb259XG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgIC8vIEN1c3RvbSB2ZWN0b3IgdHlwZXMgdG8gaGFuZGxlIGhpZ2hlciBkaW1lbmFsaXRpZXMuXG4gICAgc3RydWN0IGl2ZWM1XG4gICAge1xuICAgICAgaW50IHg7XG4gICAgICBpbnQgeTtcbiAgICAgIGludCB6O1xuICAgICAgaW50IHc7XG4gICAgICBpbnQgdTtcbiAgICB9O1xuXG4gICAgc3RydWN0IGl2ZWM2XG4gICAge1xuICAgICAgaW50IHg7XG4gICAgICBpbnQgeTtcbiAgICAgIGludCB6O1xuICAgICAgaW50IHc7XG4gICAgICBpbnQgdTtcbiAgICAgIGludCB2O1xuICAgIH07XG5cbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcbiAgICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XG4gICAgfVxuXG4gICAgYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRGcmFnU2hhZGVyTWFpbih2ZXJzaW9uOiAxfDIsIG91dHB1dFNoYXBlTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBnbHNsID0gZ2V0R2xzbCh2ZXJzaW9uKTtcbiAgcmV0dXJuIGBcbiAgdm9pZCBtYWluKCkge1xuICAgIGludCBpbmRpY2VzWyR7b3V0cHV0U2hhcGVMZW5ndGh9XTtcbiAgICB0b1ZlYyhUZXhDb29yZHMsIGluZGljZXMpO1xuICAgIHZlYzQgcmVzdWx0ID0gdmVjNChwcm9jZXNzKGluZGljZXMpKTtcbiAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgfVxuICBgO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgdmVjIHJvdXRpbmVzXG4gKiBWZWMgaXMgYW4gdmFyaWJsZSBsZW5ndGggaW50IGFycmF5LiBUaGUgbGVuZ3RoIGlzIGZpeGVkIGF0IHRoZSB0aW1lIG9mXG4gKiBnZW5lcmF0aW5nIHRoZSBsaWJyYXJ5IGZ1bmN0aW9ucyBmcm9tIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWNHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCksIC4uLnRoaXMuY29weVZlYygpLCAuLi50aGlzLnNldFZlY0l0ZW0oKSwgLi4udGhpcy5nZXRWZWNJdGVtKCl9O1xuICB9XG4gIHByb3RlY3RlZCBiaW5hcnlWZWNGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgbmFtZU9wOiB7W25hbWU6IHN0cmluZ106IHN0cmluZ30gPSB7YWRkOiAnKz0nLCBzdWI6ICctPScsIG11bDogJyo9JywgZGl2OiAnLz0nfTtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5hbWVPcCkge1xuICAgICAgY29uc3QgZm5hbWUgPSBgJHtuYW1lfVZlY2A7XG4gICAgICBsZXQgYXNzaWdubWVudEJsb2NrID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICBhc3NpZ25tZW50QmxvY2sgKz0gYFxuICAgICAgICAgIGRlc3RbJHtpfV0gJHtuYW1lT3BbbmFtZV19IHNyY1ske2l9XTtcbiAgICAgICAgICBgO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2ZuYW1lfShpbnQgc3JjWyR7cmFua31dLCBvdXQgaW50IGRlc3RbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Fzc2lnbm1lbnRCbG9ja31cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmVzdWx0W2ZuYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBjb3B5VmVjKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBhc3NpZ25tZW50QmxvY2sgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgYXNzaWdubWVudEJsb2NrICs9IGBcbiAgICAgICAgZGVzdFske2l9XSA9IHNyY1ske2l9XTtcbiAgICAgICAgYDtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIHZvaWQgY29weVZlYyhpbnQgc3JjWyR7cmFua31dLCBvdXQgaW50IGRlc3RbJHtyYW5rfV0pIHtcbiAgICAgICAgJHthc3NpZ25tZW50QmxvY2t9XG4gICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiB7Y29weVZlYzogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXRWZWNJdGVtKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBibG9jayA9IGBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSR7cmFua30gKyBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XG4gICAgICAgIGA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7aX0pXG4gICAgICAgICAgICBtWyR7aX1dID0gdmFsdWU7XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1bJHtyYW5rIC0gMX1dID0gdmFsdWU7XG4gICAgICAgIGA7XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIHZvaWQgc2V0VmVjSXRlbShvdXQgaW50IG1bJHtyYW5rfV0sIGludCBpbmRleCwgaW50IHZhbHVlKSB7XG4gICAgICAgICR7YmxvY2t9XG4gICAgICB9XG4gICAgICAgIGA7XG4gICAgcmV0dXJuIHtzZXRWZWNJdGVtOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRWZWNJdGVtKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBibG9jayA9IGBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSAke3Jhbmt9ICsgaW5kZXg7XG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICBgO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PSAke2l9KVxuICAgICAgICAgICAgcmV0dXJuIG1bJHtpfV07XG4gICAgICBgO1xuICAgIH1cbiAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtWyR7cmFuayAtIDF9XTtcbiAgICAgICAgYDtcbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgaW50IGdldFZlY0l0ZW0oaW50IG1bJHtyYW5rfV0sIGludCBpbmRleCkge1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIHtnZXRWZWNJdGVtOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi8uLi9iYWNrZW5kJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTFBhY2t9IGZyb20gJy4vb3BzL3BhY2snO1xuXG5pbXBvcnQge1dlYkdMVWludDhFbmNvZGV9IGZyb20gJy4vb3BzL3VpbnQ4LWVuY29kZSc7XG5pbXBvcnQge1dlYkdMVW5wYWNrfSBmcm9tICcuL29wcy91bnBhY2snO1xuaW1wb3J0IHtXZWJHTFNlc3Npb25IYW5kbGVyfSBmcm9tICcuL3Nlc3Npb24taGFuZGxlcic7XG5pbXBvcnQge0VuY29kZXJ9IGZyb20gJy4vdGV4dHVyZS1kYXRhLWVuY29kZXInO1xuaW1wb3J0IHtXaWR0aEhlaWdodFByZWZzfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7QXJ0aWZhY3QsIFJ1bkRhdGEsIFRleHR1cmVEYXRhLCBUZXh0dXJlTGF5b3V0LCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7Z2V0UGFja2VkU2hhcGV9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xJbmZlcmVuY2VIYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlSGFuZGxlciB7XG4gIHByaXZhdGUgcGFja2VkVGV4dHVyZURhdGFDYWNoZTogTWFwPFRlbnNvci5JZCwgVGV4dHVyZURhdGE+O1xuICBwcml2YXRlIHVucGFja2VkVGV4dHVyZURhdGFDYWNoZTogTWFwPFRlbnNvci5JZCwgVGV4dHVyZURhdGE+O1xuICBwcml2YXRlIHBhY2sydW5wYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICBwcml2YXRlIHVucGFjazJwYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc2Vzc2lvbjogV2ViR0xTZXNzaW9uSGFuZGxlcikge1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcblxuICAgIHRoaXMucGFjazJ1bnBhY2tNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2sycGFja01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJ1bihvcDogV2ViR0xPcGVyYXRvciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qob3ApO1xuICAgIGlmICghYXJ0aWZhY3QpIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gb3AuY3JlYXRlUHJvZ3JhbUluZm8odGhpcywgaW5wdXRzKTtcbiAgICAgIGlmICghcHJvZ3JhbUluZm8ubmFtZSkge1xuICAgICAgICBwcm9ncmFtSW5mby5uYW1lID0gb3AuY29uc3RydWN0b3I/Lm5hbWU7XG4gICAgICB9XG4gICAgICBhcnRpZmFjdCA9IHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtSW5mbyk7XG4gICAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qob3AsIGFydGlmYWN0KTtcbiAgICB9XG4gICAgY29uc3QgcnVuRGF0YSA9IG9wLmNyZWF0ZVJ1bkRhdGEodGhpcywgYXJ0aWZhY3QucHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBydW5EYXRhKTtcbiAgICByZXR1cm4gW3J1bkRhdGEub3V0cHV0VGV4dHVyZURhdGEudGVuc29yXTtcbiAgfVxuXG4gIGNoZWNrQW5kVXBkYXRlVGV4dHVyZUZvcm0oYXJ0aWZhY3Q6IEFydGlmYWN0LCBydW5EYXRhOiBSdW5EYXRhKSB7XG4gICAgLy8gcGFjay91bnBhY2sgaW5wdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydW5EYXRhLmlucHV0VGV4dHVyZURhdGFzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IHJ1bkRhdGEuaW5wdXRUZXh0dXJlRGF0YXNbaV07XG4gICAgICBpZiAoaW5wdXQuaXNQYWNrZWQgJiYgIWFydGlmYWN0LnByb2dyYW1JbmZvLmV4cGVjdFBhY2tlZElucHV0cykge1xuICAgICAgICBydW5EYXRhLmlucHV0VGV4dHVyZURhdGFzW2ldID0gdGhpcy51bnBhY2soaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmICghaW5wdXQuaXNQYWNrZWQgJiYgYXJ0aWZhY3QucHJvZ3JhbUluZm8uZXhwZWN0UGFja2VkSW5wdXRzKSB7XG4gICAgICAgIHJ1bkRhdGEuaW5wdXRUZXh0dXJlRGF0YXNbaV0gPSB0aGlzLnBhY2soaW5wdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBydW5Qcm9ncmFtKGFydGlmYWN0OiBBcnRpZmFjdCwgcnVuRGF0YTogUnVuRGF0YSkge1xuICAgIHRoaXMuY2hlY2tBbmRVcGRhdGVUZXh0dXJlRm9ybShhcnRpZmFjdCwgcnVuRGF0YSk7XG5cbiAgICAvLyBvdXRwdXQgc2hvdWxkIG1hdGNoXG4gICAgaWYgKCEhcnVuRGF0YS5vdXRwdXRUZXh0dXJlRGF0YS5pc1BhY2tlZCAhPT0gISFhcnRpZmFjdC5wcm9ncmFtSW5mby5leHBlY3RQYWNrZWRPdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dCBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bihhcnRpZmFjdCwgcnVuRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZURhdGEgb2JqZWN0IGZyb20gYSB0ZW5zb3IuXG4gICAqIFVzYWdlID0gRW5jb2Rlci5Vc2FnZS5VcGxvYWRPbmx5LlxuICAgKiBJZiBhIHJlbGF0ZWQgdGV4dHVyZSBkYXRhIGlzIGZvdW5kIGluIGNhY2hlLCByZXR1cm5zIGl0O1xuICAgKiBPdGhlcndpc2U6XG4gICAqICAgQ3JlYXRlcyBhIG5ldyB0ZXh0dXJlIGxheW91dCBpZiBub3QgcHJvdmlkZWQ7XG4gICAqICAgQ3JlYXRlcyBXZWJHTFRleHR1cmUgd2l0aCB0aGUgbGF5b3V0O1xuICAgKiAgIFVwbG9hZCB0ZW5zb3IgZGF0YSB0byB0aGUgdGV4dHVyZTtcbiAgICogICBDcmVhdGVzIGEgdGV4dHVyZSBkYXRhIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHRlbnNvci5cbiAgICogQHBhcmFtIHRlbnNvciB0aGUgdGVuc29yIHdpdGggZGF0YSB0byB1cGxvYWRcbiAgICovXG4gIGdldE9yQ3JlYXRlVGV4dHVyZURhdGEodGVuc29yOiBUZW5zb3IsIGxheW91dD86IFRleHR1cmVMYXlvdXQsIGlzUGFja2VkID0gZmFsc2UpIHtcbiAgICBsZXQgdGQgPSB0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIGlzUGFja2VkKTtcbiAgICBpZiAoIXRkKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnSW5mZXJlbmNlSGFuZGxlcicsIGBDcmVhdGluZyBuZXcgVGV4dHVyZURhdGEgZm9yIGRpbXM6IFske3RlbnNvci5kaW1zfV1gKTtcbiAgICAgIGlmICghbGF5b3V0KSB7XG4gICAgICAgIGxheW91dCA9IHRoaXMuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh0ZW5zb3IuZGltcy5zbGljZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGRvbid0IGZpbmQgdGhlIHRleHR1cmUgZGF0YSB3aXRoIHNwZWNpZmljIHBhY2sgbW9kZSBpbiB0aGUgY2FjaGUsIHRyeSB3aXRoIHRoZSBkaWZmZXJlbnRcbiAgICAgIC8vIHBhY2sgbW9kZSB0byBzZWUgaWYgdGhlIHRlbnNvciBpcyBjYWNoZWQgdXNpbmcgdGhhdCBwYWNrIG1vZGUuIElmIHN1Y2NlZWQsIHdlIGNhbiByZXR1cm4gdGhpc1xuICAgICAgLy8gdGVuc29yIGRhdGEgYW5kIGxhdGVyIGFwcGx5IGEgcGFjay91bnBhY2sgb3Agb24gdGhpcyB0ZXh0dXJlLCBubyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaGVyZS5cbiAgICAgIHRkID0gdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCAhaXNQYWNrZWQpO1xuICAgICAgaWYgKCF0ZCkge1xuICAgICAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgICAgICBjb25zdCB1bnBhY2tlZFRleHR1cmVMYXlvdXQgPSB0aGlzLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0ZW5zb3IsIDEsIGZhbHNlLCBbXSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgdW5wYWNrZWRUZXh0dXJlRGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoXG4gICAgICAgICAgICAgIHVucGFja2VkVGV4dHVyZUxheW91dCwgdGVuc29yLnR5cGUsIHRlbnNvci5udW1iZXJEYXRhLCB0ZW5zb3IsIEVuY29kZXIuVXNhZ2UuVXBsb2FkT25seSk7XG4gICAgICAgICAgdGQgPSB0aGlzLnBhY2sodW5wYWNrZWRUZXh0dXJlRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGQgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGxheW91dCwgdGVuc29yLnR5cGUsIHRlbnNvci5udW1iZXJEYXRhLCB0ZW5zb3IsIEVuY29kZXIuVXNhZ2UuVXBsb2FkT25seSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ0luZmVyZW5jZUhhbmRsZXInLCBgUmV0cmlldmluZyBUZXh0dXJlRGF0YSBmcm9tIGNhY2hlOiBbJHt0ZW5zb3IuZGltc31dYCk7XG4gICAgfVxuICAgIHJldHVybiB0ZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlRGF0YSBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSB0eXBlIGFuZCB0ZXh0dXJlIGxheW91dC5cbiAgICogVXNhZ2UgPSBFbmNvZGVyLlVzYWdlLkRlZmF1bHQuXG4gICAqIEBwYXJhbSBkYXRhVHlwZSB0aGUgdGVuc29yIGRhdGEgdHlwZVxuICAgKi9cbiAgY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KGxheW91dDogVGV4dHVyZUxheW91dCwgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSk6IFRleHR1cmVEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShsYXlvdXQsIGRhdGFUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlRGF0YSBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGRhdGEgYW5kIGJpbmQgdG8gdGhlIGdpdmVuIHRlbnNvci5cbiAgICogVXNhZ2UgPSBFbmNvZGVyLlVzYWdlLlVwbG9hZE9ubHkuXG4gICAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gaXMgYSBoYWNrIGZvciBDb252IGltcGxlbWVudGF0aW9uLiBzaG91bGQgcmVtb3ZlIHRoaXMgZnVuY3Rpb24sIGFmdGVyIHJld3JpdGluZyBDb252XG4gICAqIGltcGxlbWVudGF0aW9uIGJ5IEdyYXBoLlRyYW5zZm9ybWVyXG4gICAqIEBwYXJhbSBkYXRhVHlwZSB0aGUgdGVuc29yIGRhdGEgdHlwZVxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYWN0dWFsIGRhdGEgdG8gdXBsb2FkXG4gICAqIEBwYXJhbSB0ZW5zb3IgdGhlIHRlbnNvciB0byBiaW5kLiB0ZW5zb3IncyBkYXRhIGlzIGlnbm9yZWQuXG4gICAqL1xuICBjcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKFxuICAgICAgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBkYXRhOiBUZW5zb3IuTnVtYmVyVHlwZSwgdGVuc29yOiBUZW5zb3IpOiBUZXh0dXJlRGF0YSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEobGF5b3V0LCBkYXRhVHlwZSwgZGF0YSwgdGVuc29yLCBFbmNvZGVyLlVzYWdlLlVwbG9hZE9ubHkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlRGF0YShcbiAgICAgIGxheW91dDogVGV4dHVyZUxheW91dCwgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgZGF0YT86IFRlbnNvci5OdW1iZXJUeXBlLCB0ZW5zb3I/OiBUZW5zb3IsXG4gICAgICB1c2FnZT86IEVuY29kZXIuVXNhZ2UpOiBUZXh0dXJlRGF0YSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ0luZmVyZW5jZUhhbmRsZXInLCBgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeShsYXlvdXQpfV1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KGRhdGFUeXBlLCBsYXlvdXQsIGRhdGEsIHVzYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGxheW91dCwgZGF0YVR5cGUsIHRleHR1cmUsIHRlbnNvcik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZURhdGEgb2JqZWN0LCB1c2luZyB0aGUgZ2l2ZW4gdGV4dHVyZS5cbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjcmVhdGUgbmV3IHRleHR1cmUuIFVzdWFsbHkgdXNlZCBpbiBzY2VuYXJpb3MgdXNpbmcgdGV4dHVyZSBzaGFyaW5nLiAoZWcuIFJlc2hhcGUpXG4gICAqIEBwYXJhbSBkYXRhVHlwZSB0aGUgdGVuc29yIGRhdGEgdHlwZVxuICAgKiBAcGFyYW0gdGV4dHVyZSB0aGUgV2ViR0xUZXh0dXJlIG9iamVjdCB0byBzaGFyZVxuICAgKiBAcGFyYW0gdGVuc29ySWQgdGhlIHRlbnNvciBJRCBvZiB0aGUgc2hhcmVkIHRlbnNvciBkYXRhXG4gICAqL1xuICBjcmVhdGVTaGFyZWRUZXh0dXJlRGF0YShcbiAgICAgIGxheW91dDogVGV4dHVyZUxheW91dCwgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB0ZW5zb3JJZD86IFRlbnNvci5JZCk6IFRleHR1cmVEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGxheW91dCwgZGF0YVR5cGUsIHRleHR1cmUsIHVuZGVmaW5lZCwgdGVuc29ySWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKFxuICAgICAgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHRlbnNvcj86IFRlbnNvciwgdGVuc29ySWQ/OiBUZW5zb3IuSWQpIHtcbiAgICBjb25zdCB0ZXh0dXJlRGF0YTogVGV4dHVyZURhdGEgPSB7XG4gICAgICAuLi5sYXlvdXQsXG4gICAgICB0ZW5zb3I6IHRlbnNvciB8fFxuICAgICAgICAgIG5ldyBUZW5zb3IoXG4gICAgICAgICAgICAgICAgICBsYXlvdXQudW5wYWNrZWRTaGFwZSwgZGF0YVR5cGUsIChfaWQ6IFRlbnNvci5JZCkgPT4gdGhpcy5yZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YSksIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdGVuc29ySWQpLFxuICAgICAgdGV4dHVyZVxuICAgIH07XG4gICAgdGhpcy5zZXRUZXh0dXJlRGF0YSh0ZXh0dXJlRGF0YS50ZW5zb3IuZGF0YUlkLCB0ZXh0dXJlRGF0YSwgbGF5b3V0LmlzUGFja2VkKTtcbiAgICByZXR1cm4gdGV4dHVyZURhdGE7XG4gIH1cblxuICBnZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZDogVGVuc29yLklkLCBpc1BhY2tlZCA9IGZhbHNlKTogVGV4dHVyZURhdGF8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodGVuc29ySWQpID9cbiAgICAgICAgdGhpcy5zZXNzaW9uLmdldFRleHR1cmVEYXRhKHRlbnNvcklkLCBpc1BhY2tlZCkgOlxuICAgICAgICBpc1BhY2tlZCA/IHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpIDogdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKTtcbiAgfVxuICBzZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZDogVGVuc29yLklkLCB0ZDogVGV4dHVyZURhdGEsIGlzUGFja2VkID0gZmFsc2UpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodGVuc29ySWQpKSB7XG4gICAgICB0aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEodGVuc29ySWQsIHRkLCBpc1BhY2tlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIChpc1BhY2tlZCA/IHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZSA6IHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlKS5zZXQodGVuc29ySWQsIHRkKTtcbiAgICB9XG4gIH1cbiAgaXNUZXh0dXJlTGF5b3V0Q2FjaGVkKHRlbnNvcjogVGVuc29yLCBpc1BhY2tlZCA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCBpc1BhY2tlZCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRleHR1cmVMYXlvdXQgb2JqZWN0IGZyb20gYSB0ZW5zb3IuIElmIGEgcmVsYXRlZCB0ZXh0dXJlIGRhdGEgaXMgZm91bmQsIHJldHVybnMgdGhlIGNhY2hlZCB0ZXh0dXJlIGxheW91dC5cbiAgICovXG4gIGdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChcbiAgICAgIHRlbnNvcjogVGVuc29yLCBjaGFubmVsczogMXw0ID0gMSwgaXNQYWNrZWQgPSBmYWxzZSwgdW5wYWNrZWRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgcmV2ZXJzZVdIID0gZmFsc2UpOiBUZXh0dXJlTGF5b3V0IHtcbiAgICBjb25zdCB0ZCA9IHRoaXMuZ2V0VGV4dHVyZURhdGEodGVuc29yLmRhdGFJZCwgaXNQYWNrZWQpO1xuICAgIGlmICh0ZCkge1xuICAgICAgcmV0dXJuIHRkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKFxuICAgICAgICBjaGFubmVscyA9PT0gMSB8fCBpc1BhY2tlZCA/IHRlbnNvci5kaW1zIDogZ2V0UGFja2VkU2hhcGUodGVuc29yLmRpbXMpLCBjaGFubmVscywgdW5wYWNrZWRTaGFwZSxcbiAgICAgICAgaXNQYWNrZWQgfHwgcmV2ZXJzZVdIID8ge2lzUGFja2VkLCByZXZlcnNlV0h9IDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlTGF5b3V0IG9iamVjdCBmcm9tIHNoYXBlLlxuICAgKi9cbiAgY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShcbiAgICAgIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgY2hhbm5lbHM6IDF8NCA9IDEsIHVucGFja2VkU2hhcGU/OiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFRleHR1cmVMYXlvdXQge1xuICAgIGNvbnN0IGlzUGFja2VkID0gISEocHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQpO1xuICAgIGNvbnN0IFt0ZXhXaWR0aCwgdGV4SGVpZ2h0XSA9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneS5jb21wdXRlVGV4dHVyZVdIKGlzUGFja2VkID8gdW5wYWNrZWRTaGFwZSB8fCBzaGFwZSA6IHNoYXBlLCBwcmVmcyk7XG4gICAgbGV0IFt3aWR0aCwgaGVpZ2h0XSA9IFt0ZXhXaWR0aCwgdGV4SGVpZ2h0XTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMucmV2ZXJzZVdIKSB7XG4gICAgICB3aWR0aCA9IHRleEhlaWdodDtcbiAgICAgIGhlaWdodCA9IHRleFdpZHRoO1xuICAgIH1cbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGxldCBpbmZlcnJlZERpbXMgPSBzaGFwZS5zbGljZSgwKTtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgaW5mZXJyZWREaW1zID0gWzFdO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIC8vIHVucGFja2VkU2hhcGUgd2lsbCB0YWtlIGBzaGFwZWAgYW5kIG5vdCBgaW5mZXJyZWREaW1zYCBzbyBhcyB0byBjcmVhdGUgYSBzY2FsYXIgVGVuc29yIGlmIG5lZWQgYmVcbiAgICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgICB9IGVsc2UgaWYgKGlzUGFja2VkKSB7XG4gICAgICBpZiAoY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIHBhY2tlZCB0ZXh0dXJlIG11c3QgYmUgNC1jaGFubmVsJyk7XG4gICAgICB9XG4gICAgICB1bnBhY2tlZFNoYXBlID0gc2hhcGU7XG4gICAgICBpZiAocmFuayA+IDApIHtcbiAgICAgICAgaW5mZXJyZWREaW1zW3JhbmsgLSAxXSA9IE1hdGguY2VpbChpbmZlcnJlZERpbXNbcmFuayAtIDFdIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAocmFuayA+IDEpIHtcbiAgICAgICAgaW5mZXJyZWREaW1zW3JhbmsgLSAyXSA9IE1hdGguY2VpbChpbmZlcnJlZERpbXNbcmFuayAtIDJdIC8gMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdW5wYWNrZWRTaGFwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnBhY2tlZCBzaGFwZSBpcyBuZWVkZWQgd2hlbiB1c2luZyBjaGFubmVscyA+IDEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgY2hhbm5lbHMsXG4gICAgICBpc1BhY2tlZCxcbiAgICAgIHNoYXBlOiBpbmZlcnJlZERpbXMsXG4gICAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW5mZXJyZWREaW1zKSxcbiAgICAgIHVucGFja2VkU2hhcGUsXG4gICAgICByZXZlcnNlZFdIOiAocHJlZnMgJiYgcHJlZnMucmV2ZXJzZVdIKVxuICAgIH07XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jbGVhckFjdGl2ZVRleHR1cmVzKCk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2godGQgPT4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkKSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2godGQgPT4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkKSk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICByZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YTogVGV4dHVyZURhdGEpOiBUZW5zb3IuTnVtYmVyVHlwZSB7XG4gICAgaWYgKHRleHR1cmVEYXRhLmlzUGFja2VkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkVGV4dHVyZSh0aGlzLnVucGFjayh0ZXh0dXJlRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZCkge1xuICAgICAgY29uc3Qgb3AgPSBuZXcgV2ViR0xVaW50OEVuY29kZSgpO1xuICAgICAgY29uc3QgdWludDhURCA9IG9wLnJ1bkludGVybmFsKHRoaXMsIHRleHR1cmVEYXRhKTtcbiAgICAgIHJldHVybiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQodWludDhURCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUodGV4dHVyZURhdGEsIHRleHR1cmVEYXRhLnRlbnNvci50eXBlLCB0ZXh0dXJlRGF0YS5jaGFubmVscyk7XG4gIH1cblxuICBwYWNrKGlucHV0OiBUZXh0dXJlRGF0YSk6IFRleHR1cmVEYXRhIHtcbiAgICBjb25zdCBjYWNoZWRJZCA9IHRoaXMudW5wYWNrMnBhY2tNYXAuZ2V0KGlucHV0LnRlbnNvci5kYXRhSWQpO1xuICAgIGlmIChjYWNoZWRJZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQoY2FjaGVkSWQpITtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gYCR7aW5wdXQuc2hhcGV9YDtcbiAgICBsZXQgb3AgPSB0aGlzLnNlc3Npb24ucGFja09wQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFvcCkge1xuICAgICAgb3AgPSBuZXcgV2ViR0xQYWNrKCk7XG4gICAgICB0aGlzLnNlc3Npb24ucGFja09wQ2FjaGUuc2V0KGtleSwgb3ApO1xuICAgIH1cbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qob3ApO1xuICAgIGlmICghYXJ0aWZhY3QpIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JbmZvID0gb3AuY3JlYXRlUHJvZ3JhbUluZm8odGhpcywgW2lucHV0LnRlbnNvcl0pO1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8pO1xuICAgICAgdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KG9wLCBhcnRpZmFjdCk7XG4gICAgfVxuICAgIGNvbnN0IHJ1bkRhdGEgPSBvcC5jcmVhdGVSdW5EYXRhKHRoaXMsIGFydGlmYWN0LnByb2dyYW1JbmZvLCBbaW5wdXQudGVuc29yXSk7XG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBydW5EYXRhKTtcbiAgICB0aGlzLnVucGFjazJwYWNrTWFwLnNldChpbnB1dC50ZW5zb3IuZGF0YUlkLCBydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvci5kYXRhSWQpO1xuICAgIHJldHVybiBydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhO1xuICB9XG5cbiAgdW5wYWNrKGlucHV0OiBUZXh0dXJlRGF0YSk6IFRleHR1cmVEYXRhIHtcbiAgICBjb25zdCBjYWNoZWRJZCA9IHRoaXMucGFjazJ1bnBhY2tNYXAuZ2V0KGlucHV0LnRlbnNvci5kYXRhSWQpO1xuICAgIGlmIChjYWNoZWRJZCkge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldChjYWNoZWRJZCkhO1xuICAgIH1cbiAgICAvLyBGb3IgdW5wYWNrZWQga2VybmVsLCBjYWNoZSBpdCBieSB1c2luZyBpbnB1dCdzIHVucGFja2VkU2hhcGUgYXMgY2FjaGUga2V5LlxuICAgIC8vIE5vdGUgdGhhdCB3ZSBuZWVkIHRvIHVzZSBpbnB1dC51bnBhY2tlZFNoYXBlIGluc3RlYWQgb2YgaW5wdXQuc2hhcGUgaGVyZSxcbiAgICAvLyBhcyB0aGUgc2hhcGUgaW5mZXJzIHRoZSBwYWNrZWQgdGV4dHVyZSBzaGFwZS4gRGlmZmVyZW50IHVucGFja2VkU2hhcGUgY2FuIGhhdmUgdGhlXG4gICAgLy8gc2FtZSBwYWNrZWQgdGV4dHVyZSBzaGFwZS4gRm9yIGV4YW1wbGUsIGZvciB1bnBhY2tlZCBzaGFwZSwgYm90aCBbMiwgM10gYW5kXG4gICAgLy8gWzIsIDRdIGhhcyB0aGUgc2FtZSBwYWNrZWQgc2hhcGUgWzEsIDJdLCBidXQgdGhvc2UgdHdvIHNoYXBlcyBzaG91bGQgaGF2ZSBkaWZmZXJlbnRcbiAgICAvLyB1bnBhY2sgc2hhZGVycy5cbiAgICBjb25zdCBrZXkgPSBgJHtpbnB1dC51bnBhY2tlZFNoYXBlfWA7XG4gICAgbGV0IG9wID0gdGhpcy5zZXNzaW9uLnVucGFja09wQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFvcCkge1xuICAgICAgb3AgPSBuZXcgV2ViR0xVbnBhY2soKTtcbiAgICAgIHRoaXMuc2Vzc2lvbi51bnBhY2tPcENhY2hlLnNldChrZXksIG9wKTtcbiAgICB9XG4gICAgbGV0IGFydGlmYWN0ID0gdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KG9wKTtcbiAgICBpZiAoIWFydGlmYWN0KSB7XG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IG9wLmNyZWF0ZVByb2dyYW1JbmZvKHRoaXMsIFtpbnB1dC50ZW5zb3JdKTtcbiAgICAgIGFydGlmYWN0ID0gdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW1JbmZvKTtcbiAgICAgIHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdChvcCwgYXJ0aWZhY3QpO1xuICAgIH1cbiAgICBjb25zdCBydW5EYXRhID0gb3AuY3JlYXRlUnVuRGF0YSh0aGlzLCBhcnRpZmFjdC5wcm9ncmFtSW5mbywgW2lucHV0LnRlbnNvcl0pO1xuICAgIHRoaXMucnVuUHJvZ3JhbShhcnRpZmFjdCwgcnVuRGF0YSk7XG4gICAgdGhpcy5wYWNrMnVucGFja01hcC5zZXQoaW5wdXQudGVuc29yLmRhdGFJZCwgcnVuRGF0YS5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3IuZGF0YUlkKTtcbiAgICByZXR1cm4gcnVuRGF0YS5vdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RkxPQVRfVFlQRVMsIE5VTUJFUl9UWVBFU30gZnJvbSAnLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7T3BTZXR9IGZyb20gJy4uLy4uL29wc2V0JztcblxuaW1wb3J0IHtXZWJHTEJhdGNoTm9ybWFsaXphdGlvbn0gZnJvbSAnLi9vcHMvYmF0Y2gtbm9ybWFsaXphdGlvbic7XG5pbXBvcnQgKiBhcyBiaW5hcnlPcHMgZnJvbSAnLi9vcHMvYmluYXJ5LW9wJztcbmltcG9ydCB7V2ViR0xDbGlwfSBmcm9tICcuL29wcy9jbGlwJztcbmltcG9ydCB7V2ViR0xDb25jYXR9IGZyb20gJy4vb3BzL2NvbmNhdCc7XG5pbXBvcnQge1dlYkdMQ29udn0gZnJvbSAnLi9vcHMvY29udic7XG5pbXBvcnQge1dlYkdMRGVwdGhUb1NwYWNlfSBmcm9tICcuL29wcy9kZXB0aC10by1zcGFjZSc7XG5pbXBvcnQge1dlYkdMRHJvcG91dH0gZnJvbSAnLi9vcHMvZHJvcG91dCc7XG5pbXBvcnQge1dlYkdMRWx1fSBmcm9tICcuL29wcy9lbHUnO1xuaW1wb3J0IHtXZWJHTEZsYXR0ZW59IGZyb20gJy4vb3BzL2ZsYXR0ZW4nO1xuaW1wb3J0IHtXZWJHTEdhdGhlcn0gZnJvbSAnLi9vcHMvZ2F0aGVyJztcbmltcG9ydCB7V2ViR0xHZW1tfSBmcm9tICcuL29wcy9nZW1tJztcbmltcG9ydCB7V2ViR0xJbWFnZVNjYWxlcn0gZnJvbSAnLi9vcHMvaW1hZ2Utc2NhbGVyJztcbmltcG9ydCB7V2ViR0xJbnN0YW5jZU5vcm1hbGl6YXRpb259IGZyb20gJy4vb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0IHtXZWJHTExlYWt5UmVsdX0gZnJvbSAnLi9vcHMvbGVha3ktcmVsdSc7XG5pbXBvcnQge1dlYkdMTWF0TXVsfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHtXZWJHTFBhZH0gZnJvbSAnLi9vcHMvcGFkJztcbmltcG9ydCB7V2ViR0xBdmVyYWdlUG9vbCwgV2ViR0xHbG9iYWxBdmVyYWdlUG9vbCwgV2ViR0xHbG9iYWxNYXhQb29sLCBXZWJHTE1heFBvb2x9IGZyb20gJy4vb3BzL3Bvb2wnO1xuaW1wb3J0ICogYXMgcmVkdWNlT3BzIGZyb20gJy4vb3BzL3JlZHVjZSc7XG5pbXBvcnQge1dlYkdMUmVzaGFwZX0gZnJvbSAnLi9vcHMvcmVzaGFwZSc7XG5pbXBvcnQge1dlYkdMUmVzaXplUGFja2VkfSBmcm9tICcuL29wcy9yZXNpemUtcGFja2VkJztcbmltcG9ydCB7V2ViR0xTaGFwZX0gZnJvbSAnLi9vcHMvc2hhcGUnO1xuaW1wb3J0IHtXZWJHTFNsaWNlLCBXZWJHTFNsaWNlVjEwfSBmcm9tICcuL29wcy9zbGljZSc7XG5pbXBvcnQge1dlYkdMU29mdG1heH0gZnJvbSAnLi9vcHMvc29mdG1heCc7XG5pbXBvcnQge1dlYkdMU3BsaXR9IGZyb20gJy4vb3BzL3NwbGl0JztcbmltcG9ydCB7V2ViR0xTcXVlZXplfSBmcm9tICcuL29wcy9zcXVlZXplJztcbmltcG9ydCB7V2ViR0xTdW19IGZyb20gJy4vb3BzL3N1bSc7XG5pbXBvcnQge1dlYkdMVGlsZX0gZnJvbSAnLi9vcHMvdGlsZSc7XG5pbXBvcnQge1dlYkdMVHJhbnNwb3NlfSBmcm9tICcuL29wcy90cmFuc3Bvc2UnO1xuaW1wb3J0ICogYXMgdW5hcnlPcHMgZnJvbSAnLi9vcHMvdW5hcnktb3AnO1xuaW1wb3J0IHtXZWJHTFVuc3F1ZWV6ZX0gZnJvbSAnLi9vcHMvdW5zcXVlZXplJztcbmltcG9ydCB7V2ViR0xVcHNhbXBsZX0gZnJvbSAnLi9vcHMvdXBzYW1wbGUnO1xuXG5leHBvcnQgY29uc3QgV0VCR0xfT1BfUkVTT0xWRV9SVUxFUzogcmVhZG9ubHkgT3BTZXQuUmVzb2x2ZVJ1bGVbXSA9IFtcbiAgWydBYnMnLCAnJywgJzYrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChOVU1CRVJfVFlQRVMsIHVuYXJ5T3BzLmdsc2xBYnMoKSldLFxuICBbJ0Fjb3MnLCAnJywgJzcrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbEFjb3MoKSldLFxuICBbJ0FkZCcsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoTlVNQkVSX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbEFkZCgpKV0sXG4gIFsnQW5kJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChbJ2Jvb2wnXSwgYmluYXJ5T3BzLmdsc2xBbmQoKSldLFxuICBbJ0FzaW4nLCAnJywgJzcrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbEFzaW4oKSldLFxuICBbJ0F0YW4nLCAnJywgJzcrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbEF0YW4oKSldLFxuICBbJ0F2ZXJhZ2VQb29sJywgJycsICc3LTEwJywgKCkgPT4gbmV3IFdlYkdMQXZlcmFnZVBvb2woKV0sICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBBdmVyYWdlUG9vbC0xMFxuICBbJ0JhdGNoTm9ybWFsaXphdGlvbicsICcnLCAnNysnLCAoKSA9PiBuZXcgV2ViR0xCYXRjaE5vcm1hbGl6YXRpb24oKV0sXG4gIFsnQ2VpbCcsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsQ2VpbCgpKV0sXG4gIFsnQ2xpcCcsICcnLCAnNi0xMCcsICgpID0+IG5ldyBXZWJHTENsaXAoKV0sXG4gIFsnQ29uY2F0JywgJycsICc0KycsICgpID0+IG5ldyBXZWJHTENvbmNhdCgpXSxcbiAgWydDb252JywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTENvbnYoKV0sXG4gIFsnQ29zJywgJycsICc3KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xDb3MoKSldLFxuICBbJ0RpdicsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoTlVNQkVSX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbERpdigpKV0sXG4gIFsnRHJvcG91dCcsICcnLCAnNysnLCAoKSA9PiBuZXcgV2ViR0xEcm9wb3V0KCldLFxuICBbJ0RlcHRoVG9TcGFjZScsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xEZXB0aFRvU3BhY2UoKV0sXG4gIFsnRXF1YWwnLCAnJywgJzcrJywgKCkgPT4gbmV3IGJpbmFyeU9wcy5XZWJHTEJpbmFyeU9wKE5VTUJFUl9UWVBFUywgYmluYXJ5T3BzLmdsc2xFcXVhbCgpLCB1bmRlZmluZWQsICdib29sJyldLFxuICBbJ0VsdScsICcnLCAnNisnLCAoKSA9PiBuZXcgV2ViR0xFbHUoKV0sXG4gIFsnRXhwJywgJycsICc2KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xFeHAoKSldLFxuICBbJ0ZsYXR0ZW4nLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMRmxhdHRlbigpXSxcbiAgWydGbG9vcicsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsRmxvb3IoKSldLFxuICBbJ0dhdGhlcicsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xHYXRoZXIoKV0sXG4gIFsnR2VtbScsICcnLCAnNy0xMCcsICgpID0+IG5ldyBXZWJHTEdlbW0oZmFsc2UpXSxcbiAgWydHZW1tJywgJycsICcxMSsnLCAoKSA9PiBuZXcgV2ViR0xHZW1tKHRydWUpXSxcbiAgWydHbG9iYWxBdmVyYWdlUG9vbCcsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xHbG9iYWxBdmVyYWdlUG9vbCgpXSxcbiAgWydHbG9iYWxNYXhQb29sJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTEdsb2JhbE1heFBvb2woKV0sXG4gIFsnR3JlYXRlcicsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoTlVNQkVSX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbEdyZWF0ZXIoKSwgdW5kZWZpbmVkLCAnYm9vbCcpXSxcbiAgWydJZGVudGl0eScsICcnLCAnMSsnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKE5VTUJFUl9UWVBFUywgdW5hcnlPcHMuZ2xzbElkZW50aXR5KCkpXSxcbiAgWydJbWFnZVNjYWxlcicsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xJbWFnZVNjYWxlcigpXSxcbiAgWydJbnN0YW5jZU5vcm1hbGl6YXRpb24nLCAnJywgJzYrJywgKCkgPT4gbmV3IFdlYkdMSW5zdGFuY2VOb3JtYWxpemF0aW9uKCldLFxuICBbJ0xlYWt5UmVsdScsICcnLCAnNisnLCAoKSA9PiBuZXcgV2ViR0xMZWFreVJlbHUoKV0sXG4gIFsnTGVzcycsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoTlVNQkVSX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbExlc3MoKSwgdW5kZWZpbmVkLCAnYm9vbCcpXSxcbiAgWydMb2cnLCAnJywgJzYrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbExvZygpKV0sXG4gIFsnTWF0TXVsJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTE1hdE11bCgpXSxcbiAgWydNYXhQb29sJywgJycsICcxLTknLCAoKSA9PiBuZXcgV2ViR0xNYXhQb29sKCldLCAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXG4gIFsnTXVsJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChOVU1CRVJfVFlQRVMsIGJpbmFyeU9wcy5nbHNsTXVsKCkpXSxcbiAgWydOZWcnLCAnJywgJzYrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChOVU1CRVJfVFlQRVMsIHVuYXJ5T3BzLmdsc2xOZWcoKSldLFxuICBbJ05vdCcsICcnLCAnMSsnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKFsnYm9vbCddLCB1bmFyeU9wcy5nbHNsTm90KCkpXSxcbiAgWydPcicsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoWydib29sJ10sIGJpbmFyeU9wcy5nbHNsT3IoKSldLFxuICBbJ1BhZCcsICcnLCAnMi0xMCcsICgpID0+IG5ldyBXZWJHTFBhZCgpXSxcbiAgWydQb3cnLCAnJywgJzcrJywgKCkgPT4gbmV3IGJpbmFyeU9wcy5XZWJHTEJpbmFyeU9wKEZMT0FUX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbFBvdygpKV0sXG4gIFsnUFJlbHUnLCAnJywgJzcrJywgKCkgPT4gbmV3IGJpbmFyeU9wcy5XZWJHTEJpbmFyeU9wKEZMT0FUX1RZUEVTLCBiaW5hcnlPcHMuZ2xzbFBSZWx1KCkpXSxcbiAgWydSZWR1Y2VMb2dTdW0nLCAnJywgJzErJywgKCkgPT4gbmV3IHJlZHVjZU9wcy5XZWJHTFJlZHVjZUxvZ1N1bSgpXSxcbiAgWydSZWR1Y2VNYXgnLCAnJywgJzErJywgKCkgPT4gbmV3IHJlZHVjZU9wcy5XZWJHTFJlZHVjZU1heCgpXSxcbiAgWydSZWR1Y2VNZWFuJywgJycsICcxKycsICgpID0+IG5ldyByZWR1Y2VPcHMuV2ViR0xSZWR1Y2VNZWFuKCldLFxuICBbJ1JlZHVjZU1pbicsICcnLCAnMSsnLCAoKSA9PiBuZXcgcmVkdWNlT3BzLldlYkdMUmVkdWNlTWluKCldLFxuICBbJ1JlZHVjZVByb2QnLCAnJywgJzErJywgKCkgPT4gbmV3IHJlZHVjZU9wcy5XZWJHTFJlZHVjZVByb2QoKV0sXG4gIFsnUmVkdWNlU3VtJywgJycsICcxKycsICgpID0+IG5ldyByZWR1Y2VPcHMuV2ViR0xSZWR1Y2VTdW0oKV0sXG4gIFsnUmVkdWNlU3VtU3F1YXJlJywgJycsICcxKycsICgpID0+IG5ldyByZWR1Y2VPcHMuV2ViR0xSZWR1Y2VTdW1TcXVhcmUoKV0sXG4gIFsnUmVsdScsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsUmVsdSgpKV0sXG4gIFsnUmVzaGFwZScsICcnLCAnNSsnLCAoKSA9PiBuZXcgV2ViR0xSZXNoYXBlKCldLFxuICBbJ1Jlc2l6ZScsICcnLCAnMTAnLCAoKSA9PiBuZXcgV2ViR0xSZXNpemVQYWNrZWQoMTApXSxcbiAgWydSZXNpemUnLCAnJywgJzExKycsICgpID0+IG5ldyBXZWJHTFJlc2l6ZVBhY2tlZCgxMSldLFxuICBbJ1NoYXBlJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTFNoYXBlKCldLFxuICBbJ1NpZ21vaWQnLCAnJywgJzYrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbFNpZ21vaWQoKSldLFxuICBbJ1NpbicsICcnLCAnNysnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsU2luKCkpXSxcbiAgWydTbGljZScsICcnLCAnMTArJywgKCkgPT4gbmV3IFdlYkdMU2xpY2VWMTAoKV0sICAvLyBUT0RPOiBzdXBwb3J0ICdzdGVwcycgZm9yIFNsaWNlLTEwXG4gIFsnU2xpY2UnLCAnJywgJzEtOScsICgpID0+IG5ldyBXZWJHTFNsaWNlKCldLFxuICBbJ1NvZnRtYXgnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMU29mdG1heCgpXSxcbiAgLy8gJ1NwbGl0JyBvcGVyYXRvciBoYXMgYW4gb3B0aW9uYWwgYXR0cmlidXRlICdzcGxpdCdcbiAgLy8gdGhpcyBhdHRyaWJ1dGUgZGV0ZXJtaW5lcyBob3cgdGhlIHNwZWNpZmllZCBheGlzIG9mIGlucHV0IGRhdGFcbiAgLy8gaXMgc3BsaXQuIFdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBtaXNzaW5nLCB3ZSBuZWVkIHRoZSBjb3VudCBvZiBudW1iZXIgb2Ygb3V0cHV0c1xuICAvLyBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgdGhlICdzcGxpdCcgYXR0cmlidXRlIGZyb20gdGhlIHJ1bnRpbWUgaW5wdXQgdG8gdGhlIE9wZXJhdG9yXG4gIFsnU3BsaXQnLCAnJywgJzIrJywgKG5vZGUpID0+IG5ldyBXZWJHTFNwbGl0KG5vZGUub3V0cHV0cy5sZW5ndGgpXSxcbiAgWydTcXJ0JywgJycsICc2KycsICgpID0+IG5ldyB1bmFyeU9wcy5XZWJHTFVuYXJ5T3AoRkxPQVRfVFlQRVMsIHVuYXJ5T3BzLmdsc2xTcXJ0KCkpXSxcbiAgWydTcXVlZXplJywgJycsICcxKycsICgpID0+IG5ldyBXZWJHTFNxdWVlemUoKV0sXG4gIFsnU3ViJywgJycsICc3KycsICgpID0+IG5ldyBiaW5hcnlPcHMuV2ViR0xCaW5hcnlPcChOVU1CRVJfVFlQRVMsIGJpbmFyeU9wcy5nbHNsU3ViKCkpXSxcbiAgWydTdW0nLCAnJywgJzYrJywgKCkgPT4gbmV3IFdlYkdMU3VtKCldLCAgLy8gVE9ETzogc3VwcG9ydCBtdWx0aWRpcmVjdGlvbmFsIGJyb2FkY2FzdCBmb3IgU3VtLThcbiAgWydUYW4nLCAnJywgJzcrJywgKCkgPT4gbmV3IHVuYXJ5T3BzLldlYkdMVW5hcnlPcChGTE9BVF9UWVBFUywgdW5hcnlPcHMuZ2xzbFRhbigpKV0sXG4gIFsnVGFuaCcsICcnLCAnNisnLCAoKSA9PiBuZXcgdW5hcnlPcHMuV2ViR0xVbmFyeU9wKEZMT0FUX1RZUEVTLCB1bmFyeU9wcy5nbHNsVGFuaCgpKV0sXG4gIFsnVGlsZScsICcnLCAnNisnLCAoKSA9PiBuZXcgV2ViR0xUaWxlKCldLFxuICBbJ1RyYW5zcG9zZScsICcnLCAnMSsnLCAoKSA9PiBuZXcgV2ViR0xUcmFuc3Bvc2UoKV0sXG4gIFsnVXBzYW1wbGUnLCAnJywgJzctOCcsICgpID0+IG5ldyBXZWJHTFVwc2FtcGxlKDcpXSxcbiAgWydVcHNhbXBsZScsICcnLCAnOScsICgpID0+IG5ldyBXZWJHTFVwc2FtcGxlKDkpXSxcbiAgWydVbnNxdWVlemUnLCAnJywgJzErJywgKCkgPT4gbmV3IFdlYkdMVW5zcXVlZXplKCldLFxuICBbJ1hvcicsICcnLCAnNysnLCAoKSA9PiBuZXcgYmluYXJ5T3BzLldlYkdMQmluYXJ5T3AoWydib29sJ10sIGJpbmFyeU9wcy5nbHNsWG9yKCkpXSxcbl07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCYXRjaE5vcm1hbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wcy9iYXRjaC1ub3JtYWxpemF0aW9uJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xCYXRjaE5vcm1hbGl6YXRpb24gZXh0ZW5kcyBCYXRjaE5vcm1hbGl6YXRpb24ge1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBpbnB1dExheW91dHMgPSBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHNjYWxlID0gaW5wdXRMYXlvdXRzWzFdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3NjYWxlLndpZHRofSwgJHtzY2FsZS5oZWlnaHR9KTtcbiAgICAgICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oTWVhbiwgcG9zaXRpb24pKTtcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oVmFyaWFuY2UsIHBvc2l0aW9uKSk7XG4gICAgICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcblxuICAgICAgICByZXR1cm4gc2NhbGUgKiAoIChfQShpbmRpY2VzKSAtIG1lYW4pIC8gc3FydCh2YXJpYW5jZSArIGZsb2F0KCR7dGhpcy5lcHNpbG9ufSkpICkgKyBiO1xuICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0cyxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnLCAnU2NhbGUnLCAnQicsICdNZWFuJywgJ1ZhcmlhbmNlJ10sXG4gICAgICBzaGFkZXJTb3VyY2VcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICBpbnB1dHMuc2xpY2UoMSkuZm9yRWFjaCh0ID0+IGlucHV0VERzLnB1c2goaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQpKSk7XG4gICAgY29uc3Qgb3V0cHV0VEQgPSBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKTtcbiAgICByZXR1cm4ge2lucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcywgb3V0cHV0VGV4dHVyZURhdGE6IG91dHB1dFRELCB1bmlmb3JtRGF0YToge319O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCaW5hcnlPcH0gZnJvbSAnLi4vLi4vLi4vb3BzL2JpbmFyeS1vcCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7RnVuY3Rpb25UeXBlLCBHbHNsVmFsdWVGdW5jdGlvbn0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEJpbmFyeU9wIGV4dGVuZHMgQmluYXJ5T3AgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcHJpdmF0ZSB1c2VQYWNrZWRUZXh0dXJlPzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHR5cGVDb25zdHJhaW50OiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSwgcHJvdGVjdGVkIGdsc2xGdW5jOiBHbHNsVmFsdWVGdW5jdGlvbiwgb3BUeXBlPzogc3RyaW5nLFxuICAgICAgcmVzdWx0VHlwZT86IFRlbnNvci5EYXRhVHlwZSkge1xuICAgIHN1cGVyKHR5cGVDb25zdHJhaW50LCBvcFR5cGUsIHJlc3VsdFR5cGUpO1xuICB9XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpO1xuXG4gICAgLy8gVE9ETyBmaXggYmNhc3QgaW4gcGFja2VkIG1vZGUuXG4gICAgaWYgKHRoaXMudXNlUGFja2VkVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVzZVBhY2tlZFRleHR1cmUgPSAhaXNCcm9hZGNhc3QgJiYgaGFuZGxlci5zZXNzaW9uLnBhY2s7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRMYXlvdXRzID0gdGhpcy51c2VQYWNrZWRUZXh0dXJlID9cbiAgICAgICAgaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQsIDQsIHRydWUsIHQuZGltcywgdHJ1ZSkpIDpcbiAgICAgICAgaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQpKTtcbiAgICBjb25zdCBvdXB1dExheW91dCA9IHRoaXMudXNlUGFja2VkVGV4dHVyZSA/XG4gICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dHNbMF0uZGltcywgNCwgaW5wdXRzWzBdLmRpbXMsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSkgOlxuICAgICAgICBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoaW5wdXRzWzBdLmRpbXMpO1xuXG4gICAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgZmFsc2UpO1xuICAgICAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnMnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBhUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBiUmFuayA9IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGlucHV0c1sxXS5kaW1zLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBhQmNhc3QgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDAgPyAnYmNhc3RJbmRpY2VzX0EoaW5kaWNlcywgYWluZGljZXMpOycgOiAnYWluZGljZXNbMF0gPSAwOyc7XG4gICAgICBjb25zdCBiQmNhc3QgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyAnYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpOycgOiAnYmluZGljZXNbMF0gPSAwOyc7XG5cbiAgICAgIC8vIFRPRE86IGZvciBwYWNrZWQgdGVuc29ycywgd2UgbmVlZCB0byBpbXBsZW1lbnQgbG9naWMgdG8gY2FjdWxhdGUgdGV4dENvb3JkcyBmb3IgYnJvYWRjYXN0IHRlbnNvclxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHt0aGlzLmdsc2xGdW5jLmJvZHl9XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7b3V0cHV0UmFua31dKSB7XG4gICAgICAgIGludCBhaW5kaWNlc1ske2FSYW5rfV07XG4gICAgICAgIGludCBiaW5kaWNlc1ske2JSYW5rfV07XG4gICAgICAgICR7YUJjYXN0fVxuICAgICAgICAke2JCY2FzdH1cbiAgICAgICAgcmV0dXJuICR7dGhpcy5nbHNsRnVuYy5uYW1lfShfQShhaW5kaWNlcyksIF9CKGJpbmRpY2VzKSk7XG4gICAgfWA7XG4gICAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLnVzZVBhY2tlZFRleHR1cmUgP1xuICAgICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSwgNCwgb3V0cHV0U2hhcGUsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSkgOlxuICAgICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0TGF5b3V0cyxcbiAgICAgICAgb3V0cHV0TGF5b3V0LFxuICAgICAgICBzYW1wbGVyczogWydBJywgJ0InXSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRoaXMudXNlUGFja2VkVGV4dHVyZSxcbiAgICAgICAgZXhwZWN0UGFja2VkT3V0cHV0czogdGhpcy51c2VQYWNrZWRUZXh0dXJlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dGhpcy5nbHNsRnVuYy5ib2R5fVxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzQgdjEgPSAke2dsc2wudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpO1xuICAgICAgdmVjNCB2MiA9ICR7Z2xzbC50ZXh0dXJlMkR9KEIsIFRleENvb3Jkcyk7XG4gICAgICB2ZWM0IHJlc3VsdCA9ICR7dGhpcy5nbHNsRnVuYy5uYW1lfSh2MSwgdjIpO1xuICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgfVxuICAgIGA7XG5cbiAgICBpZiAodGhpcy51c2VQYWNrZWRUZXh0dXJlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgICBpbnB1dExheW91dHMsXG4gICAgICAgIG91dHB1dExheW91dDogb3VwdXRMYXlvdXQsXG4gICAgICAgIHNhbXBsZXJzOiBbJ0EnLCAnQiddLFxuICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICAgIGV4cGVjdFBhY2tlZElucHV0czogdHJ1ZSxcbiAgICAgICAgZXhwZWN0UGFja2VkT3V0cHV0czogdHJ1ZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgICAgaW5wdXRMYXlvdXRzLFxuICAgICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbnB1dHNbMF0uZGltcyksXG4gICAgICAgIHNhbXBsZXJzOiBbJ0EnLCAnQiddLFxuICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSB0aGlzLnVzZVBhY2tlZFRleHR1cmUgP1xuICAgICAgICBpbnB1dHMubWFwKCh0KSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCwgMSwgZmFsc2UsIFtdLCB0cnVlKSkpIDpcbiAgICAgICAgaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQoXG4gICAgICAgICAgcHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCB0aGlzLnJlc3VsdFR5cGUgPyB0aGlzLnJlc3VsdFR5cGUgOiBpbnB1dHNbMF0udHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQWRkKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdhZGRfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHYxICsgdjI7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbERpdigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZGl2Xyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhIC8gYjtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAvIHYyO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xNdWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ211bF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAqIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgKiB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsU3ViKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdzdWJfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHYxIC0gdjI7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEVxdWFsKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdlcXVhbF8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoYSA9PSBiKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KGVxdWFsKHYxLCB2MikpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xHcmVhdGVyKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdncmVhdGVyXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdChhID4gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNCggdjEuciA+IHYyLnIgLFxuICAgICAgdjEuZyA+IHYyLmcsXG4gICAgICB2MS5iID4gdjIuYixcbiAgICAgIHYxLmEgPiB2Mi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbExlc3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2xlc3NfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPCBiKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KCB2MS5yIDwgdjIuciAsXG4gICAgICAgICAgICAgICAgdjEuZyA8IHYyLmcsXG4gICAgICAgICAgICAgICAgdjEuYiA8IHYyLmIsXG4gICAgICAgICAgICAgICAgdjEuYSA8IHYyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQW5kKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdhbmRfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpICYmIGJvb2woYikgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xuICAgIHJldHVybiB2ZWM0KCBiMS5yICYmIGIyLnIgLFxuICAgICAgICAgICAgICAgIGIxLmcgJiYgYjIuZyxcbiAgICAgICAgICAgICAgICBiMS5iICYmIGIyLmIsXG4gICAgICAgICAgICAgICAgYjEuYSAmJiBiMi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE9yKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdvcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgfHwgYm9vbChiKSApO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XG4gICAgYnZlYzQgYjIgPSBidmVjNCh2Mik7XG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgfHwgYjIuciAsXG4gICAgICAgICAgICAgICAgYjEuZyB8fCBiMi5nLFxuICAgICAgICAgICAgICAgIGIxLmIgfHwgYjIuYixcbiAgICAgICAgICAgICAgICBiMS5hIHx8IGIyLmEgKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsWG9yKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICd4b3JfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpIF5eIGJvb2woYikgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xuICAgIHJldHVybiB2ZWM0KCBiMS5yIF5eIGIyLnIgLFxuICAgICAgICAgICAgICAgIGIxLmcgXl4gYjIuZyxcbiAgICAgICAgICAgICAgICBiMS5iIF5eIGIyLmIsXG4gICAgICAgICAgICAgICAgYjEuYSBeXiBiMi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFBvdygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpbkJpbmFyeSgncG93Jyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFBSZWx1KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdwcmVsdV8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSA8IDAuMCA/IGEgKiBiOiBhO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoXG4gICAgICB2MS5yIDwgMC4wID8gdjEuciAqIHYyLnI6IHYxLnIsXG4gICAgICB2MS5nIDwgMC4wID8gdjEuZyAqIHYyLmc6IHYxLmcsXG4gICAgICB2MS5iIDwgMC4wID8gdjEuYiAqIHYyLmI6IHYxLmIsXG4gICAgICB2MS5hIDwgMC4wID8gdjEuYSAqIHYyLmE6IHYxLmFcbiAgICAgICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5cbmZ1bmN0aW9uIGdsc2xCdWlsdGluQmluYXJ5KGZuYW1lOiBzdHJpbmcpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSBgJHtmbmFtZX1fYDtcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KGEsIGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuICR7Zm5hbWV9KHYxLCB2Mik7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtDbGlwfSBmcm9tICcuLi8uLi8uLi9vcHMvY2xpcCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMQ2xpcCBleHRlbmRzIENsaXAgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBjb25zdCBmbG9hdCBtaW4gPSBmbG9hdCgke3RoaXMubWlufSk7XG4gICAgICBjb25zdCBmbG9hdCBtYXggPSBmbG9hdCgke3RoaXMubWF4fSk7XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHYgPSAke2dsc2wudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpLnI7XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNChjbGFtcCh2LCBtaW4sIG1heCkpO1xuICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKV0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1swXSldO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtDb25jYXR9IGZyb20gJy4uLy4uLy4uL29wcy9jb25jYXQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7Z2V0Q2hhbm5lbHMsIHVucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xQYWNrZWRDb25jYXQgZXh0ZW5kcyBDb25jYXQgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgaWYgKHRoaXMuYXhpcyA+PSBpbnB1dFNoYXBlLmxlbmd0aCB8fCB0aGlzLmF4aXMgPCAoLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHknKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpcyA8IDApIHtcbiAgICAgIHRoaXMuYXhpcyA9IGlucHV0U2hhcGUubGVuZ3RoICsgdGhpcy5heGlzO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYWxsIG9mIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4ZXMgbWF0Y2ggZWFjaCBvdGhlclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3Igd2hpbGUgd2UgZG8gdGhhdFxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YU5TaGFwZSA9IGlucHV0c1tpXS5kaW1zLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBheGlzSW5kZXggPSAwOyBheGlzSW5kZXggPCBpbnB1dFNoYXBlLmxlbmd0aDsgYXhpc0luZGV4KyspIHtcbiAgICAgICAgLy8gYWRkIHRvIHRoZSBwbGFjZWhvbGRlciBmb3IgY29tcHV0aW5nIG91dHB1dCBzaGFwZVxuICAgICAgICBpZiAoYXhpc0luZGV4ID09PSB0aGlzLmF4aXMpIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZVt0aGlzLmF4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgYWxsIG5vbi1jYW5jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBjb29yZHMgPSBnZXRDaGFubmVscygnY29vcmRzJywgcmFuayk7XG4gICAgY29uc3QgZHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgICBjb25zdCB1bnBhY2tDaGFubmVsID0gdW5wYWNrRnJvbUNoYW5uZWwoKTtcblxuICAgIGNvbnN0IHNoYXBlcyA9IGlucHV0cy5tYXAoaSA9PiBpLmRpbXMpO1xuICAgIGNvbnN0IGFsbEdsQ2hhbm5lbHMgPSBbJ3gnLCAneScsICd6JywgJ3cnLCAndScsICd2J107XG4gICAgY29uc3QgY2hhbm5lbHMgPSBhbGxHbENoYW5uZWxzLnNsaWNlKDAsIHJhbmspO1xuICAgIGNvbnN0IG9mZnNldHM6IG51bWJlcltdID0gbmV3IEFycmF5KHNoYXBlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBzYW1wbGVycyA9IGlucHV0cy5tYXAoKHYsIGkpID0+IGBYJHtpfWApO1xuXG4gICAgb2Zmc2V0c1swXSA9IHNoYXBlc1swXVt0aGlzLmF4aXNdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldW3RoaXMuYXhpc107XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbm5lbCA9IGNoYW5uZWxzW3RoaXMuYXhpc107XG4gICAgY29uc3QgbGFzdENoYW5uZWxzID0gY2hhbm5lbHMuc2xpY2UoLTIpO1xuICAgIGNvbnN0IGFsbENoYW5uZWxzID0gY2hhbm5lbHMuam9pbigpO1xuXG4gICAgbGV0IGdldFZhbHVlU25pcHBldCA9IGBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1swXX0pIHtcbiAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgIGdldFgwKCR7YWxsQ2hhbm5lbHN9KSwgdmVjMigke2xhc3RDaGFubmVscy5qb2luKCl9KSk7XG4gICAgICB9YDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNoaWZ0ID0gb2Zmc2V0c1tpIC0gMV07XG4gICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICAgIGlmICgke2NoYW5uZWx9IDwgJHtvZmZzZXRzW2ldfSAgJiYgJHtjaGFubmVsfSA+PSAke29mZnNldHNbaSAtIDFdfSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICAgIGdldFgke2l9KCR7dGhpcy5nZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgICAgdmVjMigke3RoaXMuZ2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChsYXN0Q2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KX0pKTtcbiAgICAgICAgICB9YDtcbiAgICB9XG4gICAgY29uc3QgbGFzdEluZGV4ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgY29uc3Qgc2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgZ2V0VmFsdWVTbmlwcGV0ICs9IGBcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFgke2xhc3RJbmRleH0oJHt0aGlzLmdldFNoaWZ0ZWRDaGFubmVsc1NuaXBwZXQoY2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KX0pLFxuICAgICAgICAgICAgdmVjMigke3RoaXMuZ2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChsYXN0Q2hhbm5lbHMsIGNoYW5uZWwsIHNoaWZ0KX0pKTtgO1xuXG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAke3VucGFja0NoYW5uZWx9XG4gICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Y2hhbm5lbHMubWFwKHggPT4gJ2ludCAnICsgeCl9KSB7XG4gICAgICAgICAgJHtnZXRWYWx1ZVNuaXBwZXR9XG4gICAgICAgIH1cblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtkdHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHthbGxHbENoYW5uZWxzW3JhbmsgLSAxXX07XG4gICAgICAgICAgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tyYW5rIC0gMV19ID0gY29vcmRzLiR7YWxsR2xDaGFubmVsc1tyYW5rIC0gMl19O1xuICAgICAgICAgIGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDJdfSA9IGxhc3REaW07XG5cbiAgICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoZ2V0VmFsdWUoJHtjb29yZHN9KSwgMC4sIDAuLCAwLik7XG5cbiAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19ID0gJHtjb29yZHNbcmFuayAtIDFdfSArIDE7XG4gICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0VmFsdWUoJHtjb29yZHN9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMl19ID0gJHtjb29yZHNbcmFuayAtIDJdfSArIDE7XG4gICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAyXX0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtjb29yZHN9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19ID0gJHtjb29yZHNbcmFuayAtIDFdfSAtIDE7XG4gICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAyXX0gJiZcbiAgICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDFdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDFdfSkge1xuICAgICAgICAgICAgcmVzdWx0LmIgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgYDtcblxuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0LCA0LCB0cnVlLCB0LmRpbXMsIHRydWUpKSxcbiAgICAgIG91dHB1dExheW91dDpcbiAgICAgICAgICBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUsIDQsIG91dHB1dFNoYXBlLCB7aXNQYWNrZWQ6IHRydWUsIHJldmVyc2VXSDogdHJ1ZX0pLFxuICAgICAgc2FtcGxlcnMsXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkSW5wdXRzOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkT3V0cHV0czogdHJ1ZVxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSwgdHJ1ZSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc25pcHBldCB0byBzaGlmdCBhIGdpdmVuIGNoYW5uZWwgaW4gYSBsaXN0IG9mIGNoYW5uZWxzIGJ5IHNoaWZ0XG4gICAqXG4gICAqIGkuZTogcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZm9ybSAneCwgeS1bc2hpZnRdLCB6JyB3aGVyZSBhbnkgb25lIGNoYW5uZWwgY2FuXG4gICAqIGhhdmUgdGhlIHNoaWZ0IGFwcGxpZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChjaGFubmVsczogc3RyaW5nW10sIGNoYW5uZWw6IHN0cmluZywgc2hpZnQ6IG51bWJlcikge1xuICAgIGNvbnN0IGNoYW5uZWxJZHggPSBjaGFubmVscy5pbmRleE9mKGNoYW5uZWwpO1xuICAgIGNvbnN0IHJlcyA9IGNoYW5uZWxzLm1hcCgoYywgaWR4KSA9PiB7XG4gICAgICBpZiAoaWR4ID09PSBjaGFubmVsSWR4KSB7XG4gICAgICAgIHJldHVybiBgJHtjfSAtICR7c2hpZnR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXMuam9pbigpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0NvbmNhdH0gZnJvbSAnLi4vLi4vLi4vb3BzL2NvbmNhdCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7V2ViR0xQYWNrZWRDb25jYXR9IGZyb20gJy4vY29uY2F0LXBhY2tlZCc7XG5cbi8vIFdlIHByb3ZpZGUgYSB3cmFwcGVyIGNsYXNzIHNvIHRoYXQgdGhlIGtlcm5lbCBjYW4gc3dpdGNoIGJldHdlZW4gcGFja2VkIGFuZCB1bnBhY2tlZCBkZXBlbmRpbmcgb24gdGhlIGlucHV0cyBvbiB0aGVcbi8vIGZseS5cbmV4cG9ydCBjbGFzcyBXZWJHTENvbmNhdCBleHRlbmRzIENvbmNhdCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICB1bnBhY2tlZEltcGw6IFdlYkdMVW5wYWNrZWRDb25jYXQ7XG4gIHBhY2tlZEltcGw6IFdlYkdMUGFja2VkQ29uY2F0O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudW5wYWNrZWRJbXBsID0gbmV3IFdlYkdMVW5wYWNrZWRDb25jYXQoKTtcbiAgICB0aGlzLnBhY2tlZEltcGwgPSBuZXcgV2ViR0xQYWNrZWRDb25jYXQoKTtcbiAgfVxuXG4gIC8vIE5vIG5lZWQgdG8gY2FsbCBzdXBlciBzaW5jZSB0aGlzIGNsYXNzIG9ubHkgc2VydmVzIGFzIGEgd3JhcHBlci5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLnVucGFja2VkSW1wbC5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMucGFja2VkSW1wbC5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2sgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMucGFja2VkSW1wbCwgaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMudW5wYWNrZWRJbXBsLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBpZiAoaGFuZGxlci5zZXNzaW9uLnBhY2sgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFja2VkSW1wbC5jcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tlZEltcGwuY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXRzKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGlmIChoYW5kbGVyLnNlc3Npb24ucGFjayAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRJbXBsLmNyZWF0ZVJ1bkRhdGEoaGFuZGxlciwgcHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja2VkSW1wbC5jcmVhdGVSdW5EYXRhKGhhbmRsZXIsIHByb2dyYW1JbmZvLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IGNsYXNzIFdlYkdMVW5wYWNrZWRDb25jYXQgZXh0ZW5kcyBDb25jYXQgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgaWYgKHRoaXMuYXhpcyA+PSBpbnB1dFNoYXBlLmxlbmd0aCB8fCB0aGlzLmF4aXMgPCAoLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXhpcyBzcGVjaWZpZWQgZm9yIGNvbmNhdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHknKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpcyA8IDApIHtcbiAgICAgIHRoaXMuYXhpcyA9IGlucHV0U2hhcGUubGVuZ3RoICsgdGhpcy5heGlzO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYWxsIG9mIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4ZXMgbWF0Y2ggZWFjaCBvdGhlclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3Igd2hpbGUgd2UgZG8gdGhhdFxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGF0YU5TaGFwZSA9IGlucHV0c1tpXS5kaW1zLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBheGlzSW5kZXggPSAwOyBheGlzSW5kZXggPCBpbnB1dFNoYXBlLmxlbmd0aDsgYXhpc0luZGV4KyspIHtcbiAgICAgICAgLy8gYWRkIHRvIHRoZSBwbGFjZWhvbGRlciBmb3IgY29tcHV0aW5nIG91dHB1dCBzaGFwZVxuICAgICAgICBpZiAoYXhpc0luZGV4ID09PSB0aGlzLmF4aXMpIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZVt0aGlzLmF4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgYWxsIG5vbi1jYW5jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTWV0aG9kID0gJyc7XG4gICAgLy8gaW4gbW9zdCBjYXNlcyBsaW5lYXIgc2VhcmNoIGlzIHN1ZmZpY2llbnQsIGFzIGluIG1vc3Qgc2NlbmFyaW9zLCBvbmx5IDIgdGVuc29ycyBhcmUgY29uY2F0ZW5hdGVkXG4gICAgaWYgKGlucHV0cy5sZW5ndGggPCA1KSB7XG4gICAgICBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTWV0aG9kID0gdGhpcy5nZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKGlucHV0cy5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTWV0aG9kID0gdGhpcy5nZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzQmluYXJ5U2VhcmNoKGlucHV0cy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGNvbnN0IGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZCA9IHRoaXMuZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlTWV0aG9kKGlucHV0cy5sZW5ndGgsIHJhbmspO1xuICAgIGNvbnN0IGdldFZhbHVlRnJvbUFycmF5SW5kZXhNZXRob2QgPSB0aGlzLmdldFZhbHVlRnJvbUFycmF5SW5kZXhNZXRob2QoaW5wdXRzLmxlbmd0aCk7XG4gICAgY29uc3Qgc2FtcGxlcnMgPSBpbnB1dHMubWFwKCh2LCBpKSA9PiBgWCR7aX1gKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2ZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZH1cbiAgICAgICR7Z2V0VmFsdWVGcm9tQXJyYXlJbmRleE1ldGhvZH1cbiAgICAgICR7Z2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc01ldGhvZH1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IHRleHR1cmVJbmRleCA9IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzIChpbmRpY2VzWyR7dGhpcy5heGlzfV0pO1xuXG4gICAgICAgIGlmKHRleHR1cmVJbmRleCAhPSAwKSB7XG4gICAgICAgICAgaW5kaWNlc1ske3RoaXMuYXhpc31dID0gaW5kaWNlc1ske1xuICAgICAgICB0aGlzLmF4aXN9XSAtIGludChnZXRWYWx1ZUZyb21BcnJheUluZGV4KHNpemVJbkNvbmNhdEF4aXMsIHRleHR1cmVJbmRleC1pbnQoMSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUodGV4dHVyZUluZGV4LCBpbmRpY2VzKTtcbiAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSksXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVycyxcbiAgICAgIHZhcmlhYmxlczogW3tuYW1lOiAnc2l6ZUluQ29uY2F0QXhpcycsIHR5cGU6ICdpbnQnLCBhcnJheUxlbmd0aDogaW5wdXRzLmxlbmd0aH1dLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihwcm9ncmFtSW5mby5pbnB1dExheW91dHMubGVuZ3RoKTtcbiAgICBsZXQgcHJldmlvdXNTdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwcmV2aW91c1N1bSArPSBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0uc2hhcGVbdGhpcy5heGlzXTtcbiAgICAgIHNpemVJbkNvbmNhdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcbiAgICB9XG4gICAgY29uc3QgdW5pZm9ybURhdGEgPSB7c2l6ZUluQ29uY2F0QXhpc307XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhXG4gICAgfTtcbiAgfVxuICBwcml2YXRlIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNMaW5lYXJTZWFyY2gobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgaW50IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzKGludCBpbmRleCkge1xuICAgICAgZm9yKGludCBpPTA7IGk8JHtudW1iZXJPZlRlbnNvcnN9OyBpKyspIHtcbiAgICAgICAgICBpZihpbmRleCA8IGludChzaXplSW5Db25jYXRBeGlzW2ldKSl7XG4gICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWA7XG4gIH1cblxuICAvLyBUT0RPOiBJbXBsZW1lbnQgQmluYXJ5U2VhcmNoIGluIEdMU0xcbiAgcHJpdmF0ZSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzQmluYXJ5U2VhcmNoKG51bWJlck9mVGVuc29yczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKG51bWJlck9mVGVuc29ycyk7XG4gIH1cblxuICBwcml2YXRlIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZChudW1iZXJPZlRlbnNvcnM6IG51bWJlciwgdGVuc29yUmFuazogbnVtYmVyKSB7XG4gICAgY29uc3QgY29kZUxpbmVzOiBzdHJpbmdbXSA9IFtgZmxvYXQgZmV0Y2hEYXRhRnJvbUNvcnJlY3RUZXh0dXJlKGludCB0ZXh0dXJlSW5kZXgsIGludCBpbmRpY2VzWyR7dGVuc29yUmFua31dKSB7YF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgICBgaWYgKHRleHR1cmVJbmRleCA9PSAke2l9KSB7IHJldHVybiBfWCR7aX0oaW5kaWNlcyk7IH1gKTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBlbHNlIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgICBgZWxzZSBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgJ1xcdCcgK1xuICAgICAgICAnfScpO1xuICAgIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIGdldFZhbHVlRnJvbUFycmF5SW5kZXhNZXRob2QoYXJyYXlSYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbYGludCBnZXRWYWx1ZUZyb21BcnJheUluZGV4KGludCBhcnJbJHthcnJheVJhbmt9XSwgaW50IGluZGV4KSB7YF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheVJhbms7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgICBgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuIGFyclske2l9XTsgfWApO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBhcnJheVJhbmsgLSAxKSB7XG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgICAgYGVsc2UgeyByZXR1cm4gYXJyWyR7aX1dOyB9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBlbHNlIGlmIChpbmRleCA9PSAke2l9KSB7IHJldHVybiBhcnJbJHtpfV07IH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICdcXHQnICtcbiAgICAgICAgJ30nKTtcblxuICAgIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7Q29udn0gZnJvbSAnLi4vLi4vLi4vb3BzL2NvbnYnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2Fzc2VydCwgUG9vbENvbnZVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtXZWJHTENvbnZ9IGZyb20gJy4vY29udic7XG5pbXBvcnQge1dlYkdMSW0yQ29sUGFja2VkfSBmcm9tICcuL2ltMmNvbC1wYWNrJztcbmltcG9ydCB7V2ViR0xNYXRNdWxQYWNrZWR9IGZyb20gJy4vbWF0bXVsLXBhY2snO1xuaW1wb3J0IHtXZWJHTFJlc2hhcGVQYWNrZWR9IGZyb20gJy4vcmVzaGFwZS1wYWNrZWQnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xDb252UGFja2VkIGV4dGVuZHMgQ29udiB7XG4gIHByb3RlY3RlZCBhcnRpZmFjdHM6IEFydGlmYWN0W107XG4gIHByb3RlY3RlZCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm9bXTtcbiAgcHJvdGVjdGVkIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcblxuICBwcml2YXRlIGtlcm5lbFJlc2hhcGUgPSBuZXcgV2ViR0xSZXNoYXBlUGFja2VkKCk7XG4gIHByaXZhdGUgaW0yY29sOiBXZWJHTEltMkNvbFBhY2tlZDtcbiAgcHJpdmF0ZSBtYXRtdWwgPSBuZXcgV2ViR0xNYXRNdWxQYWNrZWQoKTtcbiAgcHJpdmF0ZSBvdXRwdXRSZXNoYXBlID0gbmV3IFdlYkdMUmVzaGFwZVBhY2tlZCgpO1xuXG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXI7XG4gICAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICAgIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gICAgaWYgKHRoaXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGtzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmtlcm5lbFNoYXBlLnB1c2goa3NoYXBlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgICAgaW5wdXRzWzBdLmRpbXMsIHRoaXMuc3RyaWRlcywgdGhpcy5kaWxhdGlvbnMsIHRoaXMua2VybmVsU2hhcGUsIHRoaXMucGFkcywgdGhpcy5hdXRvUGFkKTtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgJ0NvbnYnLFxuICAgICAgICBgYXV0cFBhZDoke3RoaXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke3RoaXMuZGlsYXRpb25zfSwgZ3JvdXA6JHt0aGlzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgICAgICAgIHRoaXMua2VybmVsU2hhcGV9LCBwYWRzOiR7dGhpcy5wYWRzfSwgc3RyaWRlczoke3RoaXMuc3RyaWRlc31gKTtcblxuICAgIGlmICghdGhpcy5vdXRwdXRTaGFwZSkge1xuICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFdlYkdMQ29udi5jYWxjT3V0cHV0U2hhcGUoeHNoYXBlLCBrc2hhcGUsIHRoaXMuZGlsYXRpb25zLCB0aGlzLnBhZHMsIHRoaXMuc3RyaWRlcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltMmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmltMmNvbCA9IG5ldyBXZWJHTEltMkNvbFBhY2tlZCh0aGlzLm91dHB1dFNoYXBlLCBrc2hhcGUsIHRoaXMuZGlsYXRpb25zLCB0aGlzLnBhZHMsIHRoaXMuc3RyaWRlcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2YXRpb24pIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKHVuZGVmaW5lZCk7XG4gICAgICBhdHRyaWJ1dGVzLnNldCgnX19pbnRlcm5hbF9hY3RpdmF0aW9uJywgJ3N0cmluZycsICh0aGlzLmFjdGl2YXRpb24pKTtcbiAgICAgIHRoaXMubWF0bXVsLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8vIHNoYXBlIGZvciBrZXJuZWwgcmVzaGFwZVxuICAgIGNvbnN0IHNoYXBlID1cbiAgICAgICAgbmV3IFRlbnNvcihbMl0sICdpbnQzMicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuZXcgSW50MzJBcnJheShba3NoYXBlWzBdLCBrc2hhcGVbMV0gKiBrc2hhcGVbMl0gKiBrc2hhcGVbM11dKSk7XG4gICAgaWYgKCF0aGlzLmFydGlmYWN0cykge1xuICAgICAgdGhpcy5hcnRpZmFjdHMgPSBbXTtcbiAgICAgIHRoaXMucHJvZ3JhbUluZm8gPSBbXTtcbiAgICAgIHRoaXMucHJvZ3JhbUluZm9bMF0gPSB0aGlzLmltMmNvbC5jcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdLCBpbnB1dHNbMV1dKTtcbiAgICAgIHRoaXMuYXJ0aWZhY3RzWzBdID0gcHJvZ3JhbU1hbmFnZXIuYnVpbGQodGhpcy5wcm9ncmFtSW5mb1swXSk7XG5cbiAgICAgIHRoaXMucHJvZ3JhbUluZm9bMV0gPSB0aGlzLmtlcm5lbFJlc2hhcGUuY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgW2lucHV0c1sxXSwgc2hhcGVdKTtcbiAgICAgIHRoaXMuYXJ0aWZhY3RzWzFdID0gcHJvZ3JhbU1hbmFnZXIuYnVpbGQodGhpcy5wcm9ncmFtSW5mb1sxXSk7XG4gICAgfVxuXG4gICAgLy8gcnVuIGltMmNvbFxuICAgIGNvbnN0IHJ1bkRhdGFJbTJjb2wgPSB0aGlzLmltMmNvbC5jcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXIsIHRoaXMucHJvZ3JhbUluZm9bMF0sIFtpbnB1dHNbMF0sIGlucHV0c1sxXV0pO1xuICAgIGluZmVyZW5jZUhhbmRsZXIuY2hlY2tBbmRVcGRhdGVUZXh0dXJlRm9ybSh0aGlzLmFydGlmYWN0c1swXSwgcnVuRGF0YUltMmNvbCk7XG4gICAgcHJvZ3JhbU1hbmFnZXIucnVuKHRoaXMuYXJ0aWZhY3RzWzBdLCBydW5EYXRhSW0yY29sKTtcbiAgICBjb25zdCBpbTJjb2xPdXRwdXQgPSBydW5EYXRhSW0yY29sLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvcjtcblxuICAgIC8vIHJlc2hhcGUga2VybmVsXG4gICAgY29uc3QgcnVuRGF0YUtlcm5lbFJlc2hhcGUgPVxuICAgICAgICB0aGlzLmtlcm5lbFJlc2hhcGUuY3JlYXRlUnVuRGF0YShpbmZlcmVuY2VIYW5kbGVyLCB0aGlzLnByb2dyYW1JbmZvWzFdLCBbaW5wdXRzWzFdLCBzaGFwZV0pO1xuICAgIGluZmVyZW5jZUhhbmRsZXIuY2hlY2tBbmRVcGRhdGVUZXh0dXJlRm9ybSh0aGlzLmFydGlmYWN0c1sxXSwgcnVuRGF0YUtlcm5lbFJlc2hhcGUpO1xuICAgIHByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLmFydGlmYWN0c1sxXSwgcnVuRGF0YUtlcm5lbFJlc2hhcGUpO1xuICAgIGNvbnN0IGtlcm5lbFJlc2hhcGVkID0gcnVuRGF0YUtlcm5lbFJlc2hhcGUub3V0cHV0VGV4dHVyZURhdGEudGVuc29yO1xuXG4gICAgLy8gcnVuIG1hdG11bFxuICAgIGNvbnN0IGhhc0JpYXMgPSAoaW5wdXRzLmxlbmd0aCA9PT0gMyk7XG4gICAgYXNzZXJ0KHRoaXMuYXJ0aWZhY3RzLmxlbmd0aCA+IDEsICgpID0+ICdleHBlY3QgYXQgbGVhc3QgMiBhcnRpZmFjdHMgY3JlYXRlZCcpO1xuICAgIGlmICh0aGlzLmFydGlmYWN0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMucHJvZ3JhbUluZm9bMl0gPSB0aGlzLm1hdG11bC5jcmVhdGVQcm9ncmFtSW5mbyhcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLCBoYXNCaWFzID8gW2tlcm5lbFJlc2hhcGVkLCBpbTJjb2xPdXRwdXQsIGlucHV0c1syXV0gOiBba2VybmVsUmVzaGFwZWQsIGltMmNvbE91dHB1dF0pO1xuICAgICAgdGhpcy5hcnRpZmFjdHNbMl0gPSBwcm9ncmFtTWFuYWdlci5idWlsZCh0aGlzLnByb2dyYW1JbmZvWzJdKTtcbiAgICB9XG4gICAgY29uc3QgcnVuRGF0YU1hdG11bCA9IHRoaXMubWF0bXVsLmNyZWF0ZVJ1bkRhdGEoXG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIHRoaXMucHJvZ3JhbUluZm9bMl0sXG4gICAgICAgIGhhc0JpYXMgPyBba2VybmVsUmVzaGFwZWQsIGltMmNvbE91dHB1dCwgaW5wdXRzWzJdXSA6IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0XSk7XG4gICAgaW5mZXJlbmNlSGFuZGxlci5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKHRoaXMuYXJ0aWZhY3RzWzJdLCBydW5EYXRhTWF0bXVsKTtcbiAgICBwcm9ncmFtTWFuYWdlci5ydW4odGhpcy5hcnRpZmFjdHNbMl0sIHJ1bkRhdGFNYXRtdWwpO1xuICAgIGNvbnN0IG1hdG11bE91dHB1dCA9IHJ1bkRhdGFNYXRtdWwub3V0cHV0VGV4dHVyZURhdGEudGVuc29yO1xuXG4gICAgLy8gcmVzaGFwZSBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXRTaGFwZVRlbnNvciA9IG5ldyBUZW5zb3IoXG4gICAgICAgIFt0aGlzLm91dHB1dFNoYXBlLmxlbmd0aF0sICdpbnQzMicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICBuZXcgSW50MzJBcnJheShbdGhpcy5vdXRwdXRTaGFwZVswXSwgdGhpcy5vdXRwdXRTaGFwZVsxXSwgdGhpcy5vdXRwdXRTaGFwZVsyXSwgdGhpcy5vdXRwdXRTaGFwZVszXV0pKTtcblxuICAgIGFzc2VydCh0aGlzLmFydGlmYWN0cy5sZW5ndGggPiAyLCAoKSA9PiAnZXhwZWN0IGF0IGxlYXN0IDMgYXJ0aWZhY3RzIGNyZWF0ZWQnKTtcbiAgICBpZiAodGhpcy5hcnRpZmFjdHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB0aGlzLnByb2dyYW1JbmZvWzNdID0gdGhpcy5vdXRwdXRSZXNoYXBlLmNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIFttYXRtdWxPdXRwdXQsIG91dHB1dFNoYXBlVGVuc29yXSk7XG4gICAgICB0aGlzLmFydGlmYWN0c1szXSA9IHByb2dyYW1NYW5hZ2VyLmJ1aWxkKHRoaXMucHJvZ3JhbUluZm9bM10pO1xuICAgIH1cbiAgICBjb25zdCBydW5EYXRhT3V0cHV0UmVzaGFwZSA9XG4gICAgICAgIHRoaXMub3V0cHV0UmVzaGFwZS5jcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXIsIHRoaXMucHJvZ3JhbUluZm9bM10sIFttYXRtdWxPdXRwdXQsIG91dHB1dFNoYXBlVGVuc29yXSk7XG4gICAgaW5mZXJlbmNlSGFuZGxlci5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKHRoaXMuYXJ0aWZhY3RzWzNdLCBydW5EYXRhT3V0cHV0UmVzaGFwZSk7XG4gICAgcHJvZ3JhbU1hbmFnZXIucnVuKHRoaXMuYXJ0aWZhY3RzWzNdLCBydW5EYXRhT3V0cHV0UmVzaGFwZSk7XG4gICAgcmV0dXJuIFtydW5EYXRhT3V0cHV0UmVzaGFwZS5vdXRwdXRUZXh0dXJlRGF0YS50ZW5zb3JdO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge0NvbnZ9IGZyb20gJy4uLy4uLy4uL29wcy9jb252JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtQb29sQ29udlV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtBcnRpZmFjdCwgUHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFRleHR1cmVMYXlvdXQsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuLi93ZWJnbC1jb250ZXh0JztcblxuaW1wb3J0IHtXZWJHTENvbnZQYWNrZWR9IGZyb20gJy4vY29udi1wYWNrJztcbmltcG9ydCB7Z2V0QWN0aWNhdGlvblNuaXBwZXR9IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTENvbnYgZXh0ZW5kcyBDb252IHtcbiAgdW5wYWNrZWRHcm91cGVkQ29udkltcGw6IFdlYkdMVW5wYWNrZWRHcm91cGVkQ29udjtcbiAgdW5wYWNrZWRDb252SW1wbDogV2ViR0xVbnBhY2tlZENvbnY7XG4gIHBhY2tlZENvbnZJbXBsOiBXZWJHTENvbnZQYWNrZWQ7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVucGFja2VkR3JvdXBlZENvbnZJbXBsID0gbmV3IFdlYkdMVW5wYWNrZWRHcm91cGVkQ29udigpO1xuICAgIHRoaXMudW5wYWNrZWRDb252SW1wbCA9IG5ldyBXZWJHTFVucGFja2VkQ29udigpO1xuICAgIHRoaXMucGFja2VkQ29udkltcGwgPSBuZXcgV2ViR0xDb252UGFja2VkKCk7XG4gIH1cblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHN1cGVyLmluaXRpYWxpemUoYXR0cmlidXRlcyk7XG4gICAgdGhpcy51bnBhY2tlZEdyb3VwZWRDb252SW1wbC5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMudW5wYWNrZWRDb252SW1wbC5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuICAgIHRoaXMucGFja2VkQ29udkltcGwuaW5pdGlhbGl6ZShhdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgcGFja01vZGUgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucGFjaztcbiAgICBpZiAodGhpcy5ncm91cCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja2VkR3JvdXBlZENvbnZJbXBsLnJ1bihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICAgIH0gZWxzZSBpZiAocGFja01vZGUgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0ICYmIGlucHV0c1swXS5kaW1zWzBdID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRDb252SW1wbC5ydW4oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRDb252SW1wbC5ydW4oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgY2FsY091dHB1dFNoYXBlKFxuICAgICAgaW5wdXRTaGFwZTogbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSwgYWRqdXN0UGFkczogbnVtYmVyW10sXG4gICAgICBzdHJpZGVzOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICAgIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgyKTtcbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U3BhdGlhbFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xuICAgIGNvbnN0IGtlcm5lbFNwYXRpYWxTaGFwZSA9IGtlcm5lbFNoYXBlLnNsaWNlKDIpO1xuICAgIGNvbnN0IGRpbGF0ZWRLZXJuZWxTaGFwZSA9IGtlcm5lbFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyAodiAtIDEpICogKGRpbGF0aW9uc1tpXSAtIDEpKTtcbiAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcbiAgICBjb25zdCBvdXRwdXRTcGF0aWFsU2hhcGUgPVxuICAgICAgICBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQubWFwKCh2LCBpKSA9PiBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVsc10uY29uY2F0KC4uLm91dHB1dFNwYXRpYWxTaGFwZSk7XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVucGFja2VkR3JvdXBlZENvbnYgZXh0ZW5kcyBDb252IGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cblxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTsnIDogJyc7XG4gICAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMF0gLyB0aGlzLmdyb3VwO1xuICAgIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gICAgaWYgKHRoaXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHdTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmtlcm5lbFNoYXBlLnB1c2god1NoYXBlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgICAgaW5wdXRzWzBdLmRpbXMsIHRoaXMuc3RyaWRlcywgdGhpcy5kaWxhdGlvbnMsIHRoaXMua2VybmVsU2hhcGUsIHRoaXMucGFkcywgdGhpcy5hdXRvUGFkKTtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgJ0NvbnYnLFxuICAgICAgICBgYXV0cFBhZDoke3RoaXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke3RoaXMuZGlsYXRpb25zfSwgZ3JvdXA6JHt0aGlzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgICAgICAgIHRoaXMua2VybmVsU2hhcGV9LCBwYWRzOiR7dGhpcy5wYWRzfSwgc3RyaWRlczoke3RoaXMuc3RyaWRlc31gKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFdlYkdMQ29udi5jYWxjT3V0cHV0U2hhcGUoeFNoYXBlLCB3U2hhcGUsIHRoaXMuZGlsYXRpb25zLCB0aGlzLnBhZHMsIHRoaXMuc3RyaWRlcyk7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGljYXRpb25TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbik7XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7dGhpcy5zdHJpZGVzWzBdfSwgJHt0aGlzLnN0cmlkZXNbMV19KTtcbiAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHt0aGlzLnBhZHNbMF19LCAke3RoaXMucGFkc1sxXX0pO1xuICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICBpbnQgb3V0cHV0X2NoYW5uZWwgPSBjb29yZHMueTtcbiAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy56dyAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuXG4gICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcbiAgICAgIGZvciAoaW50IHdJbkNoYW5uZWwgPSAwOyB3SW5DaGFubmVsIDwgJHt3U2hhcGVbMV19OyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7d1NoYXBlWzFdfSArIHdJbkNoYW5uZWw7XG4gICAgICAgIGZvciAoaW50IHdIZWlnaHQgPSAwOyB3SGVpZ2h0IDwgJHt3U2hhcGVbMl19OyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBpbnQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqICR7dGhpcy5kaWxhdGlvbnNbMF19O1xuXG4gICAgICAgICAgaWYgKHhIZWlnaHQgPCAwIHx8IHhIZWlnaHQgPj0gJHt4U2hhcGVbMl19KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3dTaGFwZVszXX07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgICBpbnQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiAke3RoaXMuZGlsYXRpb25zWzFdfTtcbiAgICAgICAgICAgIGlmICh4V2lkdGggPCAwIHx8IHhXaWR0aCA+PSAke3hTaGFwZVszXX0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB4V2lkdGgsIHhIZWlnaHQpO1xuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAke3Byb2Nlc3NCaWFzfVxuICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQodmFsdWUsIC4wLCAuMCwgLjApO1xuICAgIH1cbmA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQpKSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQmlhcyddIDogWydYJywgJ1cnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xVbnBhY2tlZENvbnYgZXh0ZW5kcyBDb252IHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBwcm9ncmFtTWFuYWdlciA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlcjtcbiAgICBpZiAoIXRoaXMuYXJ0aWZhY3RzKSB7XG4gICAgICB0aGlzLmFydGlmYWN0cyA9IFtdO1xuICAgICAgY29uc3QgcHJvZ3JhbUluZm9zID0gdGhpcy5jcmVhdGVQcm9ncmFtSW5mb0FycmF5KGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1JbmZvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcnRpZmFjdCA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChwcm9ncmFtSW5mb3NbaV0pO1xuICAgICAgICB0aGlzLmFydGlmYWN0cy5wdXNoKGFydGlmYWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcnVuRGF0YUFycmF5ID0gdGhpcy5jcmVhdGVSdW5EYXRhQXJyYXkoaW5mZXJlbmNlSGFuZGxlciwgdGhpcy5hcnRpZmFjdHMubWFwKGEgPT4gYS5wcm9ncmFtSW5mbyksIGlucHV0cyk7XG4gICAgaW5mZXJlbmNlSGFuZGxlci5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKHRoaXMuYXJ0aWZhY3RzWzBdLCBydW5EYXRhQXJyYXlbMF0pO1xuICAgIHByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLmFydGlmYWN0c1swXSwgcnVuRGF0YUFycmF5WzBdKTtcbiAgICBwcm9ncmFtTWFuYWdlci5ydW4odGhpcy5hcnRpZmFjdHNbMV0sIHJ1bkRhdGFBcnJheVsxXSk7XG4gICAgcmV0dXJuIFtydW5EYXRhQXJyYXlbMV0ub3V0cHV0VGV4dHVyZURhdGEudGVuc29yXTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mb0FycmF5KGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvW10ge1xuICAgIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICAgIGlmICh0aGlzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3Qgd0RpbXMgPSBpbnB1dHNbMV0uZGltcztcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgd0RpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5rZXJuZWxTaGFwZS5wdXNoKHdEaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgICAgaW5wdXRzWzBdLmRpbXMsIHRoaXMuc3RyaWRlcywgdGhpcy5kaWxhdGlvbnMsIHRoaXMua2VybmVsU2hhcGUsIHRoaXMucGFkcywgdGhpcy5hdXRvUGFkKTtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgJ0NvbnYnLFxuICAgICAgICBgYXV0cFBhZDoke3RoaXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke3RoaXMuZGlsYXRpb25zfSwgZ3JvdXA6JHt0aGlzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgICAgICAgIHRoaXMua2VybmVsU2hhcGV9LCBwYWRzOiR7dGhpcy5wYWRzfSwgc3RyaWRlczoke3RoaXMuc3RyaWRlc31gKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFdlYkdMQ29udi5jYWxjT3V0cHV0U2hhcGUoeHNoYXBlLCBrc2hhcGUsIHRoaXMuZGlsYXRpb25zLCB0aGlzLnBhZHMsIHRoaXMuc3RyaWRlcyk7XG4gICAgY29uc3QgaW0yY29sUHJvZ3JhbUluZm8gPSB0aGlzLmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGRvdFByb2R1Y3RQcm9ncmFtSW5mbyA9XG4gICAgICAgIHRoaXMuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGltMmNvbFByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRzLCBvdXRwdXRTaGFwZSk7XG4gICAgcmV0dXJuIFtpbTJjb2xQcm9ncmFtSW5mbywgZG90UHJvZHVjdFByb2dyYW1JbmZvXTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhQXJyYXkoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mb3M6IFByb2dyYW1JbmZvW10sIGlucHV0czogVGVuc29yW10pOlxuICAgICAgUnVuRGF0YVtdIHtcbiAgICBjb25zdCBrID0gaW5wdXRzWzFdO1xuICAgIGNvbnN0IGIgPSBpbnB1dHMubGVuZ3RoID49IDMgPyBpbnB1dHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgbGV0IGtURCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0VGV4dHVyZURhdGEoay5kYXRhSWQpO1xuICAgIGlmICgha1REKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnQ29udicsICdEaWQgbm90IGZpbmQgdGhlIGFkanVzdGVkS2VybmVsIHRleHR1cmUgaW4gdGhlIGNhY2hlLiBDcmVhdGluZyByZXcuJyk7XG4gICAgICBjb25zdCBuZXdLZXJuZWxEYXRhID1cbiAgICAgICAgICBXZWJHTFVucGFja2VkQ29udi5wcmVwS2VybmVsRm9yRG90UHJvZHVjdChrLmRpbXMuc2xpY2UoKSwgdGhpcy5ncm91cCwgNCwgay5mbG9hdERhdGEgYXMgRmxvYXQzMkFycmF5KTtcbiAgICAgIC8vIGhhY2s6IHNob3VsZCB1c2UgZ3JhcGggdHJhbnNmb3JtZXIgdG8gcmV3cml0ZSBpbml0aWFsaXplciBLXG4gICAgICBrVEQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dEJpbmRUZW5zb3IoXG4gICAgICAgICAgcHJvZ3JhbUluZm9zWzFdLmlucHV0TGF5b3V0c1sxXSwgay50eXBlLCBuZXdLZXJuZWxEYXRhLCBrKTtcbiAgICB9XG4gICAgY29uc3QgcnVudERhdGFJbTJDb2wgPSB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogW2luZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0pXSxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mb3NbMF0ub3V0cHV0TGF5b3V0LCBpbnB1dHNbMF0udHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICAgIGNvbnN0IGlucHV0VERzID0gW3J1bnREYXRhSW0yQ29sLm91dHB1dFRleHR1cmVEYXRhLCBrVERdO1xuICAgIGlmIChiKSB7XG4gICAgICBpbnB1dFREcy5wdXNoKGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShiKSk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFREID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm9zWzFdLm91dHB1dExheW91dCwgaW5wdXRzWzBdLnR5cGUpO1xuICAgIGNvbnN0IHJ1bkRhdGFEb3RQcm9kdWN0ID0ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IG91dHB1dFRELFxuICAgICAgdW5pZm9ybURhdGE6IHt9LFxuICAgICAgZHJhdzogKGdsQ29udGV4dDogV2ViR0xDb250ZXh0LCBhcnRpZmFjdDogQXJ0aWZhY3QpID0+IHtcbiAgICAgICAgY29uc3QgZ2wgPSBnbENvbnRleHQuZ2w7XG4gICAgICAgIGNvbnN0IHNoYXJlZERpbSA9IGFydGlmYWN0LnByb2dyYW1JbmZvLnBhcmFtcyEuc2hhcmVkRGltIGFzIG51bWJlcjtcbiAgICAgICAgY29uc3Qgc2hhcmVkRGltUmVhZFNpemUgPSBhcnRpZmFjdC5wcm9ncmFtSW5mby5wYXJhbXMhLnNoYXJlZERpbVJlYWRTaXplIGFzIG51bWJlcjtcbiAgICAgICAgY29uc3Qgc2hhcmVkRGltT2Zmc2V0TG9jYXRpb24gPSBhcnRpZmFjdC51bmlmb3JtTG9jYXRpb25zLmZpbmQobCA9PiBsLm5hbWUgPT09ICdzaGFyZWREaW1PZmZzZXQnKSEubG9jYXRpb247XG4gICAgICAgIGxldCBibGVuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNoYXJlZERpbTsgayArPSBzaGFyZWREaW1SZWFkU2l6ZSkge1xuICAgICAgICAgIExvZ2dlci52ZXJib3NlKCdNYXRNdWwyRCcsIGBrID0gJHtrfSwgc2hhcmVkRGltOiAke3NoYXJlZERpbX0sIHJlYWRTaXplID0gJHtzaGFyZWREaW1SZWFkU2l6ZX1gKTtcbiAgICAgICAgICBpZiAoayA9PT0gc2hhcmVkRGltUmVhZFNpemUpIHtcbiAgICAgICAgICAgIGJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbENvbnRleHQuY2hlY2tFcnJvcigpO1xuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgICAgICAgICBnbENvbnRleHQuY2hlY2tFcnJvcigpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgICAgIGdsQ29udGV4dC5jaGVja0Vycm9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2wudW5pZm9ybTFpKHNoYXJlZERpbU9mZnNldExvY2F0aW9uLCBrKTtcbiAgICAgICAgICBnbENvbnRleHQuY2hlY2tFcnJvcigpO1xuICAgICAgICAgIGdsQ29udGV4dC5kcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxlbmQpIHtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICBnbENvbnRleHQuY2hlY2tFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gW3J1bnREYXRhSW0yQ29sLCBydW5EYXRhRG90UHJvZHVjdF07XG4gIH1cbiAgY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBvdXRwdXRTaGFwZTogbnVtYmVyW10pOlxuICAgICAgUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcblxuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgaW0yY29sRGltcyA9IFdlYkdMVW5wYWNrZWRDb252LmNhbGNJbTJDb2xEaW1zKHhzaGFwZSwga3NoYXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKFxuICAgICAgICBpbTJjb2xEaW1zLCA0LCBbaW0yY29sRGltc1swXSwgaW0yY29sRGltc1sxXSwgaW0yY29sRGltc1syXSwgaW0yY29sRGltc1szXSAqIDRdLCB7YnJlYWtBeGlzOiAzfSk7XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBjb25zdCBpbnQgWEMgPSAke3hzaGFwZVsxXX07XG4gICAgICBjb25zdCBpbnQgWEggPSAke3hzaGFwZVsyXX07XG4gICAgICBjb25zdCBpbnQgWFcgPSAke3hzaGFwZVszXX07XG4gICAgICBjb25zdCBpbnQgS0ggPSAke3RoaXMua2VybmVsU2hhcGVbMF19O1xuICAgICAgY29uc3QgaW50IEtXID0gJHt0aGlzLmtlcm5lbFNoYXBlWzFdfTtcbiAgICAgIGNvbnN0IGludCBkaWxhdGlvbkggPSAke3RoaXMuZGlsYXRpb25zWzBdfTtcbiAgICAgIGNvbnN0IGludCBkaWxhdGlvblcgPSAke3RoaXMuZGlsYXRpb25zWzFdfTtcbiAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHt0aGlzLnN0cmlkZXNbMF19O1xuICAgICAgY29uc3QgaW50IHN0cmlkZVcgPSAke3RoaXMuc3RyaWRlc1sxXX07XG4gICAgICBjb25zdCBpbnQgcGFkSCA9ICR7dGhpcy5wYWRzWzBdfTtcbiAgICAgIGNvbnN0IGludCBwYWRXID0gJHt0aGlzLnBhZHNbMV19O1xuICAgICAgY29uc3QgaW50IEtIS1cgPSBLSCpLVztcbiAgICAgIGNvbnN0IGludCBYQ0tIS1cgPSBYQyAqIEtIS1c7XG4gICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xuICAgICAgdmVjNCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBiICA9IGluZGljZXNbMF07IC8vIGJhdGNoIHNpemVcbiAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcbiAgICAgICAgaW50IG93ID0gaW5kaWNlc1syXSAqIHN0cmlkZVcgLSBwYWRXOyAvL291dHB1dCB3aWR0aFxuICAgICAgICBpbnQgcCA9IGluZGljZXNbM10gKiBvdXRwdXRDaGFubmVsczsgLy9wYXRjaFxuICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xuICAgICAgICBmb3IoaW50IGk9MDsgaSA8IG91dHB1dENoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgICBpZihwIDwgWENLSEtXKSB7XG4gICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XG4gICAgICAgICAgICBpbnQgcGF0Y2hIID0gKHAgLSBwYXRjaEMqS0hLVykgLyBLVztcbiAgICAgICAgICAgIGludCBwYXRjaFcgPSAocCAtIHBhdGNoQypLSEtXKSAtIHBhdGNoSCAqIEtXO1xuICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xuICAgICAgICAgICAgaW50IHh3MiA9IG93ICsgcGF0Y2hXICogZGlsYXRpb25XO1xuICAgICAgICAgICAgaW50IHhbJHt4c2hhcGUubGVuZ3RofV07XG4gICAgICAgICAgICB4WzBdID0gYjtcbiAgICAgICAgICAgIHhbMV0gPSBwYXRjaEM7XG4gICAgICAgICAgICB4WzJdID0geGgyO1xuICAgICAgICAgICAgeFszXSA9IHh3MjtcbiAgICAgICAgICAgIGlmKHhoMiA+PSAwICYmXG4gICAgICAgICAgICAgICAgeGgyIDwgWEggJiZcbiAgICAgICAgICAgICAgICB4dzIgPj0gMCAmJlxuICAgICAgICAgICAgICAgIHh3MiA8IFhXKSB7XG4gICAgICAgICAgICAgIHZhbHVlW2ldID0gX1goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICsrcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnSW0yQ29sJyxcbiAgICAgIGlucHV0TGF5b3V0czogW2luZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh4c2hhcGUpXSxcbiAgICAgIG91dHB1dExheW91dCxcbiAgICAgIHNhbXBsZXJzOiBbJ1gnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mbyhcbiAgICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW0yY29sTGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBpbnB1dHM6IFRlbnNvcltdLFxuICAgICAgb3V0cHV0U2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBhZGp1c3RlZEtlcm5lbFNoYXBlID0gW2tzaGFwZVswXSwgTWF0aC5jZWlsKCh4c2hhcGVbMV0gKiBrc2hhcGVbMl0gKiBrc2hhcGVbM10pIC8gNCldO1xuICAgIGNvbnN0IGtMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoXG4gICAgICAgIGFkanVzdGVkS2VybmVsU2hhcGUsIDQsIFthZGp1c3RlZEtlcm5lbFNoYXBlWzBdLCBhZGp1c3RlZEtlcm5lbFNoYXBlWzFdICogNF0sIHticmVha0F4aXM6IDF9KTtcblxuICAgIGxldCBiTGF5b3V0OiBUZXh0dXJlTGF5b3V0fHVuZGVmaW5lZDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgY29uc3QgaW5wdXRMYXlvdXRzID0gW2ltMmNvbExheW91dCwga0xheW91dF07XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGJMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoaW5wdXRzWzJdLmRpbXMuc2xpY2UoKSk7XG4gICAgICBpbnB1dExheW91dHMucHVzaChiTGF5b3V0KTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBpbml0VmFsdWUgPSAoaW5wdXRzLmxlbmd0aCA8IDMpID8gJzAuMCcgOiAnX0IoYiknO1xuICAgIGNvbnN0IHNoYXJlZERpbSA9IGltMmNvbExheW91dC5zaGFwZVszXTtcbiAgICBjb25zdCBibGVuZEVuYWJsZWQgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNCbGVuZFN1cHBvcnRlZCAmJiAhdGhpcy5hY3RpdmF0aW9uO1xuICAgIGNvbnN0IHNoYXJlZERpbVJlYWRTaXplID0gYmxlbmRFbmFibGVkICYmIGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLm1hdG11bE1heEJhdGNoU2l6ZSA/XG4gICAgICAgIHRoaXMuY2FsY1NoYXJlZERpbVJlYWRTaXplKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLm1hdG11bE1heEJhdGNoU2l6ZSwgc2hhcmVkRGltKSA6XG4gICAgICAgIHNoYXJlZERpbTtcbiAgICBjb25zdCBzYW1wbGVycyA9IFsnSW0yQ29sJywgJ0snXTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgc2FtcGxlcnMucHVzaCgnQicpO1xuICAgIH1cblxuICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpY2F0aW9uU25pcHBldCh0aGlzLmFjdGl2YXRpb24pO1xuXG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICBpbnQgYlsxXTtcbiAgICAgIGJbMF0gPSBpbmRpY2VzWzFdO1xuICAgICAgaW50IGltMmNvbFske2ltMmNvbExheW91dC5zaGFwZS5sZW5ndGh9XTtcbiAgICAgIGltMmNvbFswXSA9IGluZGljZXNbMF07XG4gICAgICBpbTJjb2xbMV0gPSBpbmRpY2VzWzJdO1xuICAgICAgaW0yY29sWzJdID0gaW5kaWNlc1szXTtcbiAgICAgIGludCBpbTJjb2xPZmZzZXQgPSBpbTJjb2xbMF0gKiAke2ltMmNvbExheW91dC5zdHJpZGVzWzBdfSArIGltMmNvbFsxXSAqICR7XG4gICAgICAgIGltMmNvbExheW91dC5zdHJpZGVzWzFdfSArIGltMmNvbFsyXSAqICR7aW0yY29sTGF5b3V0LnN0cmlkZXNbMl19ICsgc2hhcmVkRGltT2Zmc2V0O1xuICAgICAgaW50IGtlcm5lbE9mZnNldCA9IGluZGljZXNbMV0gKiAke2tMYXlvdXQuc3RyaWRlc1swXX0gKyBzaGFyZWREaW1PZmZzZXQ7XG4gICAgICBmbG9hdCB2YWx1ZSA9IHNoYXJlZERpbU9mZnNldCA9PSAwID8gJHtpbml0VmFsdWV9IDogMC4wO1xuICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3NoYXJlZERpbVJlYWRTaXplfTsgKytpKSB7XG4gICAgICAgIHZlYzIgaW0yY29sQ29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW0yY29sT2Zmc2V0LCAke2ltMmNvbExheW91dC53aWR0aH0sICR7aW0yY29sTGF5b3V0LmhlaWdodH0pO1xuICAgICAgICB2ZWMyIGtlcm5lbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGtlcm5lbE9mZnNldCwgJHtrTGF5b3V0LndpZHRofSwgJHtrTGF5b3V0LmhlaWdodH0pO1xuICAgICAgICB2YWx1ZSArPSBkb3QoJHtnbHNsLnRleHR1cmUyRH0oSW0yQ29sLCBpbTJjb2xDb29yZHMpLCAke2dsc2wudGV4dHVyZTJEfShLLCBrZXJuZWxDb29yZHMpKTtcbiAgICAgICAgKytpbTJjb2xPZmZzZXQ7XG4gICAgICAgICsra2VybmVsT2Zmc2V0O1xuICAgICAgfVxuICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdkb3RQcm9kdWN0JyxcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFtpbTJjb2xMYXlvdXQsIGtMYXlvdXQsIGJMYXlvdXQhXSA6IFtpbTJjb2xMYXlvdXQsIGtMYXlvdXRdLFxuICAgICAgb3V0cHV0TGF5b3V0LFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgc2FtcGxlcnMsXG4gICAgICB2YXJpYWJsZXM6IFt7bmFtZTogJ3NoYXJlZERpbU9mZnNldCcsIHR5cGU6ICdpbnQnfV0sXG4gICAgICBwYXJhbXM6IHtzaGFyZWREaW0sIHNoYXJlZERpbVJlYWRTaXplfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIHByZXBLZXJuZWxGb3JEb3RQcm9kdWN0KHNoYXBlOiBudW1iZXJbXSwgZ3JvdXA6IG51bWJlciwgY2hhbm5lbHM6IG51bWJlciwga2VybmVsOiBGbG9hdDMyQXJyYXkpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmIChncm91cCA9PT0gMSAmJiAoY2hhbm5lbHMgPT09IDEgfHwgKHNoYXBlWzJdICogc2hhcGVbM10pICUgY2hhbm5lbHMgPT09IDApKSB7XG4gICAgICByZXR1cm4ga2VybmVsO1xuICAgIH1cbiAgICBjb25zdCBudW1GZWF0dXJlTWFwcyA9IHNoYXBlWzBdO1xuICAgIGNvbnN0IG9sZFJvd1NpemUgPSBzaGFwZVsxXSAqIHNoYXBlWzJdICogc2hhcGVbM107XG4gICAgY29uc3QgbmV3Um93U2l6ZSA9IE1hdGguY2VpbChvbGRSb3dTaXplICogZ3JvdXAgLyBjaGFubmVscykgKiBjaGFubmVscztcbiAgICBjb25zdCBuZXdTaXplID0gbnVtRmVhdHVyZU1hcHMgKiBuZXdSb3dTaXplO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobmV3U2l6ZSk7XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPCBudW1GZWF0dXJlTWFwczsgKytmKSB7XG4gICAgICBjb25zdCBvbGRPZmZzZXQgPSBmICogb2xkUm93U2l6ZTtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IGYgKiBuZXdSb3dTaXplICsgZiAlIGdyb3VwICogb2xkUm93U2l6ZTtcbiAgICAgIGJ1ZmZlci5zZXQoa2VybmVsLnN1YmFycmF5KG9sZE9mZnNldCwgb2xkT2Zmc2V0ICsgb2xkUm93U2l6ZSksIG5ld09mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbiAgc3RhdGljIGNhbGNJbTJDb2xEaW1zKGlucHV0U2hhcGU6IG51bWJlcltdLCBrZXJuZWxTaGFwZTogbnVtYmVyW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSwgY2hhbm5lbHMgPSAxKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBbXG4gICAgICBvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdLFxuICAgICAgTWF0aC5jZWlsKGlucHV0U2hhcGVbMV0gKiBrZXJuZWxTaGFwZVsyXSAqIGtlcm5lbFNoYXBlWzNdIC8gY2hhbm5lbHMpXG4gICAgXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjYWxjU2hhcmVkRGltUmVhZFNpemUocHJlZmVycmVkQmF0Y2hTaXplOiBudW1iZXIsIHNoYXJlZERpbTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAocHJlZmVycmVkQmF0Y2hTaXplIDw9IDAgfHwgc2hhcmVkRGltIDwgcHJlZmVycmVkQmF0Y2hTaXplIHx8IHNoYXJlZERpbSAlIHByZWZlcnJlZEJhdGNoU2l6ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHNoYXJlZERpbTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWZlcnJlZEJhdGNoU2l6ZTtcbiAgfVxuICBwcm90ZWN0ZWQgY2FsY0Jsb2NrU2l6ZShvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBbbnVtYmVyLCBudW1iZXJdfHVuZGVmaW5lZCB7XG4gICAgY29uc3QgcHJlZmVycmVkUm93Q291bnQgPSA2NDtcbiAgICBjb25zdCBwcmVmZXJyZWRDb2xDb3VudCA9IDY0O1xuICAgIGlmIChvdXRwdXRMYXlvdXQuaGVpZ2h0IDwgcHJlZmVycmVkUm93Q291bnQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbcHJlZmVycmVkQ29sQ291bnQsIHByZWZlcnJlZFJvd0NvdW50XTtcbiAgfVxuICBwcm90ZWN0ZWQgYXJ0aWZhY3RzOiBBcnRpZmFjdFtdO1xuICBwcm90ZWN0ZWQgcmVhZFNpemUgPSA4O1xuICBwcm90ZWN0ZWQgYmxvY2tTaXplID0gNjQ7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0RlcHRoVG9TcGFjZX0gZnJvbSAnLi4vLi4vLi4vb3BzL2RlcHRoLXRvLXNwYWNlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBSdW5EYXRhfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi9yZXNoYXBlJztcbmltcG9ydCB7V2ViR0xUcmFuc3Bvc2V9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMRGVwdGhUb1NwYWNlIGV4dGVuZHMgRGVwdGhUb1NwYWNlIHtcbiAgcHJvdGVjdGVkIHRyYW5zcG9zZVByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbztcblxuICBwcm90ZWN0ZWQgdHJhbnNwb3NlQXJ0aWZhY3Q6IEFydGlmYWN0O1xuXG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgcHJvZ3JhbU1hbmFnZXIgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXI7XG4gICAgY29uc3QgdHJhbnNwb3NlUGVybSA9IHRoaXMubW9kZSA9PT0gJ0RDUicgPyBbMCwgMywgNCwgMSwgNSwgMl0gOiBbMCwgMSwgNCwgMiwgNSwgM107XG4gICAgY29uc3QgZmlyc3RSZXNoYXBlU2hhcGUgPSB0aGlzLm1vZGUgPT09ICdEQ1InID9cbiAgICAgICAgW1xuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzBdLCB0aGlzLmJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUsIGlucHV0c1swXS5kaW1zWzFdIC8gdGhpcy5ibG9ja3NpemVTcXIsIGlucHV0c1swXS5kaW1zWzJdLFxuICAgICAgICAgIGlucHV0c1swXS5kaW1zWzNdXG4gICAgICAgIF0gOlxuICAgICAgICBbXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1swXS5kaW1zWzFdIC8gdGhpcy5ibG9ja3NpemVTcXIsIHRoaXMuYmxvY2tzaXplLCB0aGlzLmJsb2Nrc2l6ZSwgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXNbM11cbiAgICAgICAgXTtcblxuICAgIGNvbnN0IHRyYW5zcG9zZSA9IG5ldyBXZWJHTFRyYW5zcG9zZSgpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKHVuZGVmaW5lZCk7XG4gICAgYXR0cmlidXRlcy5zZXQoJ3Blcm0nLCAnaW50cycsIHRyYW5zcG9zZVBlcm0pO1xuICAgIHRyYW5zcG9zZS5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRmlyc3QgcmVzaGFwZVxuXG4gICAgY29uc3QgZmlyc3RSZXNoYXBlZFRlbnNvciA9IHJlc2hhcGUoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBmaXJzdFJlc2hhcGVTaGFwZSk7XG5cbiAgICAvLyB0cmFuc3Bvc2VcbiAgICBpZiAoIXRoaXMudHJhbnNwb3NlUHJvZ3JhbUluZm8pIHtcbiAgICAgIHRoaXMudHJhbnNwb3NlUHJvZ3JhbUluZm8gPSB0cmFuc3Bvc2UuY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgW2ZpcnN0UmVzaGFwZWRUZW5zb3JdKTtcbiAgICAgIHRoaXMudHJhbnNwb3NlQXJ0aWZhY3QgPSBwcm9ncmFtTWFuYWdlci5idWlsZCh0aGlzLnRyYW5zcG9zZVByb2dyYW1JbmZvKTtcbiAgICB9XG4gICAgY29uc3QgcnVuRGF0YVRyYW5zcG9zZSA9XG4gICAgICAgIHRyYW5zcG9zZS5jcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXIsIHRoaXMudHJhbnNwb3NlUHJvZ3JhbUluZm8sIFtmaXJzdFJlc2hhcGVkVGVuc29yXSk7XG4gICAgaW5mZXJlbmNlSGFuZGxlci5jaGVja0FuZFVwZGF0ZVRleHR1cmVGb3JtKHRoaXMudHJhbnNwb3NlQXJ0aWZhY3QsIHJ1bkRhdGFUcmFuc3Bvc2UpO1xuICAgIHByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLnRyYW5zcG9zZUFydGlmYWN0LCBydW5EYXRhVHJhbnNwb3NlKTtcbiAgICBjb25zdCB0cmFuc3Bvc2VPdXRwdXQgPSBydW5EYXRhVHJhbnNwb3NlLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvcjtcblxuICAgIC8vIFNlY29uZCByZXNoYXBlXG4gICAgY29uc3QgcmVzdWx0ID0gcmVzaGFwZShpbmZlcmVuY2VIYW5kbGVyLCB0cmFuc3Bvc2VPdXRwdXQsIFtcbiAgICAgIGlucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSAvIHRoaXMuYmxvY2tzaXplU3FyLCBpbnB1dHNbMF0uZGltc1syXSAqIHRoaXMuYmxvY2tzaXplLFxuICAgICAgaW5wdXRzWzBdLmRpbXNbM10gKiB0aGlzLmJsb2Nrc2l6ZVxuICAgIF0pO1xuICAgIHJldHVybiBbcmVzdWx0XTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRPdXRTaGFwZShpbnB1dDogVGVuc29yKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0LmRpbXNbMF07XG4gICAgY29uc3QgaW5wdXREZXB0aCA9IGlucHV0LmRpbXNbMV07XG4gICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dC5kaW1zWzJdO1xuICAgIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dC5kaW1zWzNdO1xuICAgIGlmIChpbnB1dERlcHRoICUgKHRoaXMuYmxvY2tzaXplU3FyKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkZXB0aCBtdXN0IGJlIGRpdmlzaWJsZSBieSBzcXVhcmVkIGJsb2Nrc2l6ZS4nKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0RGVwdGggPSBpbnB1dERlcHRoIC8gdGhpcy5ibG9ja3NpemVTcXI7XG4gICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gaW5wdXRIZWlnaHQgKiB0aGlzLmJsb2Nrc2l6ZTtcbiAgICBjb25zdCBvdXRwdXRXaWR0aCA9IGlucHV0V2lkdGggKiB0aGlzLmJsb2Nrc2l6ZTtcbiAgICByZXR1cm4gW2JhdGNoU2l6ZSwgb3V0cHV0RGVwdGgsIG91dHB1dEhlaWdodCwgb3V0cHV0V2lkdGhdO1xuICB9XG5cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59IiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RHJvcG91dH0gZnJvbSAnLi4vLi4vLi4vb3BzL2Ryb3BvdXQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xEcm9wb3V0IGV4dGVuZHMgRHJvcG91dCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGlmICh0aGlzLnRlc3RNb2RlKSB7XG4gICAgICByZXR1cm4gW2lucHV0c1swXV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIHRlc3QgbW9kZSBEcm9wb3V0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBfaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiB0ZXN0IG1vZGUgRHJvcG91dCBpcyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBfcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBfaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9uIHRlc3QgbW9kZSBEcm9wb3V0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RWx1fSBmcm9tICcuLi8uLi8uLi9vcHMvZWx1JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xFbHUgZXh0ZW5kcyBFbHUgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHYgPSAke2dsc2wudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpLnI7XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCh2ID49IDAuMCA/IHY6IChleHAodikgLSAxLjApICogJHt0aGlzLmFscGhhLnRvRXhwb25lbnRpYWwoKX0pOyAvKiBmbG9hdCBudW1iZXIgZm9ybWF0ICovXG4gICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0pXSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0ZsYXR0ZW59IGZyb20gJy4uLy4uLy4uL29wcy9mbGF0dGVuJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL3Jlc2hhcGUnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xGbGF0dGVuIGV4dGVuZHMgRmxhdHRlbiB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFNoYXBlVXRpbC5mbGF0dGVuU2hhcGUoaW5wdXRzWzBdLmRpbXMsIHRoaXMuYXhpcyk7XG5cbiAgICByZXR1cm4gW3Jlc2hhcGUoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBvdXRwdXREaW1zKV07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2dsc2xSZWx1LCBnbHNsU2lnbW9pZH0gZnJvbSAnLi91bmFyeS1vcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpY2F0aW9uU25pcHBldChhY3RpdmF0aW9uOiBzdHJpbmcpIHtcbiAgbGV0IGFjdGl2YXRpb25GdW5jdGlvbiA9ICcnO1xuICBsZXQgYWN0aXZhdGlvbk5hbWUgPSAnJztcbiAgc3dpdGNoIChhY3RpdmF0aW9uKSB7XG4gICAgY2FzZSAnUmVsdSc6XG4gICAgICBhY3RpdmF0aW9uTmFtZSA9IGdsc2xSZWx1KCkubmFtZTtcbiAgICAgIGFjdGl2YXRpb25GdW5jdGlvbiA9IGdsc2xSZWx1KCkuYm9keTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgYWN0aXZhdGlvbk5hbWUgPSBnbHNsU2lnbW9pZCgpLm5hbWU7XG4gICAgICBhY3RpdmF0aW9uRnVuY3Rpb24gPSBnbHNsU2lnbW9pZCgpLmJvZHk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgICAgYWN0aXZhdGlvbk5hbWUgPSAnJztcbiAgICAgIGFjdGl2YXRpb25GdW5jdGlvbiA9ICcnO1xuICB9XG4gIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGFjdGl2YXRpb24gPyBgXG4gIHZhbHVlID0gJHthY3RpdmF0aW9uTmFtZX0odmFsdWUpO2AgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XG4gIHJldHVybiB7YWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb259O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2F0aGVyfSBmcm9tICcuLi8uLi8uLi9vcHMvZ2F0aGVyJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMR2F0aGVyIGV4dGVuZHMgR2F0aGVyIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cblxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgaW5kZXhEYXRhU2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGlucHV0U2hhcGUubGVuZ3RoICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIC0gMSk7XG5cbiAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXModGhpcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kZXhDb3B5T3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIG91dHB1dFNoYXBlIGlzIGRpdmlkZWQgaW50byB0aHJlZSBwYXJ0czogQSwgQiwgQ1xuICAgICAgLy8gfDAgICAgICAgIGF4aXN8ICBheGlzICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIHwgICAgICAgICAgZW5kfFxuICAgICAgLy8gfCAgICAgQSAgICAgICB8ICAgICAgICAgICAgIEIgICAgICAgICAgICAgICAgIHwgICAgICBDICAgICAgfFxuICAgICAgLy9cbiAgICAgIC8vIGlucHV0SWR4OiBbQSwgaW5wdXRzWzFdW0JdLCBDXVxuICAgICAgaWYgKGkgPCBheGlzKSB7ICAvLyBBXG4gICAgICAgIG91dHB1dFNoYXBlW2ldID0gaW5wdXRTaGFwZVtpXTtcbiAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGkgPCBheGlzICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoKSB7ICAvLyBCXG4gICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbmRleERhdGFTaGFwZVtpIC0gYXhpc107XG4gICAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGluZGV4RGF0YUlkeFske2kgLSBheGlzfV0gPSBvdXRwdXRJZHhbJHtpfV07YCk7XG4gICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENcbiAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaSAtIGluZGV4RGF0YVNoYXBlLmxlbmd0aCArIDFdOyAgLy8gc2tpcCAxIGZvciBheGlzXG4gICAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGlucHV0SWR4WyR7aSAtIGluZGV4RGF0YVNoYXBlLmxlbmd0aCArIDF9XSA9IG91dHB1dElkeFske2l9XTtgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoIHx8IDE7XG4gICAgY29uc3QgaXJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpRHJhbmsgPSBpbmRleERhdGFTaGFwZS5sZW5ndGggfHwgMTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtvcmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske2lyYW5rfV07XG4gICAgICAgIGludCBpbmRleERhdGFJZHhbJHtpRHJhbmt9XTtcbiAgICAgICAgaW5kZXhEYXRhSWR4WzBdID0gMDtcbiAgICAgICAgJHtpbmRleENvcHlPcHMuam9pbignXFxuICAgICAgICAnKX1cbiAgICAgICAgaW50IGlkeCA9IGludChfQihpbmRleERhdGFJZHgpKTtcbiAgICAgICAgaW5wdXRJZHhbJHtheGlzfV0gPSBpZHggPCAwID8gaWR4ICsgJHtpbnB1dFNoYXBlW2F4aXNdfSA6IGlkeDtcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcbiAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSksXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJywgJ0InXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2VtbX0gZnJvbSAnLi4vLi4vLi4vb3BzL2dlbW0nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0dlbW1VdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEdlbW0gZXh0ZW5kcyBHZW1tIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBbTSwgTl0gPSBHZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICAgICAgYVNoYXBlLCB0aGlzLnRyYW5zQSwgYlNoYXBlLCB0aGlzLnRyYW5zQiwgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkKTtcbiAgICBjb25zdCBvU2hhcGUgPSBbTSwgTl07XG4gICAgaWYgKCFvU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgIH1cbiAgICBsZXQgc2hhcmVkRGltID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICBsZXQgbGluZSA9ICcnO1xuICAgIGlmICh0aGlzLnRyYW5zQSkge1xuICAgICAgc2hhcmVkRGltID0gYVNoYXBlWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFuc0EgJiYgdGhpcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gX0FfVChhKSAqIF9CX1QoYik7JztcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNBICYmICF0aGlzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBfQV9UKGEpICogX0IoYik7JztcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnRyYW5zQSAmJiB0aGlzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7JztcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnRyYW5zQSAmJiAhdGhpcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gX0EoYSkgKiBfQihiKTsnO1xuICAgIH1cbiAgICBjb25zdCByYW5rID0gb1NoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBkZWNsYXJlQyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyBgaW50IGNbJHtpbnB1dHNbMl0uZGltcy5sZW5ndGh9XTtgIDogJyc7XG4gICAgY29uc3QgYnJvYWRjYXN0QyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyAnYmNhc3RJbmRpY2VzX0MoaW5kaWNlcywgYyk7JyA6ICcnO1xuICAgIGNvbnN0IGNhbGN1bGF0ZUMgPSBpbnB1dHMubGVuZ3RoID09PSAzID8gJ3ZhbHVlICs9IGJldGEgKiBfQyhjKTsnIDogJyc7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgIGludCBhWyR7cmFua31dO1xuICAgICAgICAgIGludCBiWyR7cmFua31dO1xuICAgICAgICAgICR7ZGVjbGFyZUN9XG5cbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGEpO1xuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XG4gICAgICAgICAgJHticm9hZGNhc3RDfVxuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7c2hhcmVkRGltfTsgKytrKSB7XG4gICAgICAgICAgICAgIGFbJHtyYW5rIC0gMX1dID0gaztcbiAgICAgICAgICAgICAgYlske3JhbmsgLSAyfV0gPSBrO1xuICAgICAgICAgICAgICAke2xpbmV9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGFscGhhO1xuICAgICAgICAgICR7Y2FsY3VsYXRlQ31cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcbiAgICBjb25zdCBpbnB1dExheW91dHMgPSBpbnB1dHMubWFwKHQgPT4gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHMsXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvU2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IGlucHV0cy5sZW5ndGggPT09IDMgPyBbJ0EnLCAnQicsICdDJ10gOiBbJ0EnLCAnQiddLFxuICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdhbHBoYScsIHR5cGU6ICdmbG9hdCd9LCB7bmFtZTogJ2JldGEnLCB0eXBlOiAnZmxvYXQnfV0sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOlxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHsnYWxwaGEnOiB0aGlzLmFscGhhLCAnYmV0YSc6IHRoaXMuYmV0YX1cbiAgICB9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge3VucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xJbTJDb2xQYWNrZWQgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcHJvdGVjdGVkIGNvbnZPdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHByb3RlY3RlZCBrZXJuZWxTaGFwZTogbnVtYmVyW107XG4gIHByb3RlY3RlZCBkaWxhdGlvbnM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgcGFkczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBzdHJpZGVzOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGNvbnZPdXRwdXRTaGFwZTogbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdKSB7XG4gICAgdGhpcy5jb252T3V0cHV0U2hhcGUgPSBjb252T3V0cHV0U2hhcGU7XG4gICAgdGhpcy5rZXJuZWxTaGFwZSA9IGtlcm5lbFNoYXBlO1xuICAgIHRoaXMuZGlsYXRpb25zID0gZGlsYXRpb25zO1xuICAgIHRoaXMucGFkcyA9IHBhZHM7XG4gICAgdGhpcy5zdHJpZGVzID0gc3RyaWRlcztcbiAgfVxuXG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltMkNvbCBrZXJuZWwgc2hvdWxkIGhhdmUgdHdvIGlucHV0IHRlbnNvcnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IHdzaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3Qgcm93RGltID0gMjtcbiAgICBjb25zdCBjb2xEaW0gPSAzO1xuICAgIGNvbnN0IHJhbmsgPSB0aGlzLmNvbnZPdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgaW0yY29sU2hhcGUgPSBbd3NoYXBlWzFdICogd3NoYXBlWzJdICogd3NoYXBlWzNdLCB0aGlzLmNvbnZPdXRwdXRTaGFwZVsyXSAqIHRoaXMuY29udk91dHB1dFNoYXBlWzNdXTtcbiAgICBjb25zdCBrZXJuZWxTaXplID0gd3NoYXBlWzJdICogd3NoYXBlWzNdO1xuICAgIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBsZXQgdW5yb2xsZWQgPSAnJztcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8PSAxOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDw9IDE7IGNvbCsrKSB7XG4gICAgICAgIHVucm9sbGVkICs9IGBcbiAgICAgICAgICBibG9ja0luZGV4ID0gcmMueCArICR7Y29sfTtcbiAgICAgICAgICBwb3MgPSByYy55ICsgJHtyb3d9O1xuXG4gICAgICAgICAgaWYoYmxvY2tJbmRleCA8ICR7aW0yY29sU2hhcGVbMV19ICYmIHBvcyA8ICR7aW0yY29sU2hhcGVbMF19KSB7XG4gICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoJHt0aGlzLmNvbnZPdXRwdXRTaGFwZVtyYW5rIC0gMV19KSkgKiAke3RoaXMuc3RyaWRlc1swXX0gLSAke3RoaXMucGFkc1swXX07XG4gICAgICAgICAgICBkMCA9IG9mZnNldFkgKyAke3RoaXMuZGlsYXRpb25zWzBdfSAqIChpbW9kKHBvcywgJHtrZXJuZWxTaXplfSkgLyAke3dzaGFwZVsyXX0pO1xuXG4gICAgICAgICAgICBpZihkMCA8ICR7eHNoYXBlW3Jvd0RpbV19ICYmIGQwID49IDApIHtcbiAgICAgICAgICAgICAgb2Zmc2V0WCA9IGltb2QoYmxvY2tJbmRleCwgJHt0aGlzLmNvbnZPdXRwdXRTaGFwZVtyYW5rIC0gMV19KSAqICR7dGhpcy5zdHJpZGVzWzFdfSAtICR7dGhpcy5wYWRzWzFdfTtcbiAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgJHt0aGlzLmRpbGF0aW9uc1sxXX0gKiBpbW9kKGltb2QocG9zLCAke2tlcm5lbFNpemV9KSwgJHt3c2hhcGVbMl19KTtcblxuICAgICAgICAgICAgICBpZihkMSA8ICR7eHNoYXBlW2NvbERpbV19ICYmIGQxID49IDApIHtcblxuICAgICAgICAgICAgICAgIGNoID0gaW50KGZsb2F0KHBvcykvICR7a2VybmVsU2l6ZX0uKTtcbiAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFske3JvdyAqIDIgKyBjb2x9XSA9IGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgICAgIGdldEEoMCwgY2gsIGludChpbm5lckRpbXMueCksXG4gICAgICAgICAgICAgICAgICAgIGludChpbm5lckRpbXMueSkpLCBpbm5lckRpbXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dW5wYWNrQ2hhbm5lbH1cblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLjApO1xuICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xuICAgICAgICB2ZWMyIGlubmVyRGltcztcbiAgICAgICAgJHt1bnJvbGxlZH1cbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgfVxuICAgICAgICAgIGA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdXZWJHTEltMkNvbFBhY2tlZCcsXG4gICAgICBpbnB1dExheW91dHM6IFtpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDQsIHRydWUsIHhzaGFwZSwgdHJ1ZSldLFxuICAgICAgb3V0cHV0TGF5b3V0OlxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShpbTJjb2xTaGFwZSwgNCwgaW0yY29sU2hhcGUsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkSW5wdXRzOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkT3V0cHV0czogdHJ1ZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9XG4gICAgICAgIGlucHV0cy5tYXAoKHQpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0LCAxLCBmYWxzZSwgW10sIHRydWUpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0ltYWdlU2NhbGVyfSBmcm9tICcuLi8uLi8uLi9vcHMvaW1hZ2Utc2NhbGVyJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMSW1hZ2VTY2FsZXIgZXh0ZW5kcyBJbWFnZVNjYWxlciBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBnZXRCaWFzTWV0aG9kID0gdGhpcy5jcmVhdGVHZXRCaWFzTWV0aG9kKHRoaXMuYmlhcy5sZW5ndGgpO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7Z2V0Qmlhc01ldGhvZH1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgcmV0dXJuIF9YKGluZGljZXMpICogc2NhbGUgKyBnZXRCaWFzKGJpYXMsIGluZGljZXNbMV0pO1xuICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSldLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnWCddLFxuICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdiaWFzJywgdHlwZTogJ2Zsb2F0JywgYXJyYXlMZW5ndGg6IHRoaXMuYmlhcy5sZW5ndGh9LCB7bmFtZTogJ3NjYWxlJywgdHlwZTogJ2Zsb2F0J31dLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1swXSldO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YTogeydiaWFzJzogdGhpcy5iaWFzLCAnc2NhbGUnOiB0aGlzLnNjYWxlfVxuICAgIH07XG4gIH1cbiAgcHJpdmF0ZSBjcmVhdGVHZXRCaWFzTWV0aG9kKG51bUNoYW5uZWxzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbYGZsb2F0IGdldEJpYXMoZmxvYXQgYmlhc1ske251bUNoYW5uZWxzfV0sIGludCBjaGFubmVsKSB7YF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGFubmVsczsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBpZiAoY2hhbm5lbCA9PSAke2l9KSB7IHJldHVybiBiaWFzWyR7aX1dOyB9YCk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IG51bUNoYW5uZWxzIC0gMSkge1xuICAgICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICAgIGBlbHNlIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgICAgYGVsc2UgaWYgKGNoYW5uZWwgPT0gJHtpfSkgeyByZXR1cm4gYmlhc1ske2l9XTsgfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgJ1xcdCcgK1xuICAgICAgICAnfScpO1xuICAgIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luc3RhbmNlTm9ybWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUnVuRGF0YSwgVGV4dHVyZUxheW91dH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xJbnN0YW5jZU5vcm1hbGl6YXRpb24gZXh0ZW5kcyBJbnN0YW5jZU5vcm1hbGl6YXRpb24ge1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGlmICghdGhpcy5hcnRpZmFjdHMpIHtcbiAgICAgIHRoaXMuYXJ0aWZhY3RzID0gW107XG4gICAgICBjb25zdCBwcm9ncmFtSW5mb3MgPSB0aGlzLmNyZWF0ZVByb2dyYW1JbmZvcyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICAgICAgcHJvZ3JhbUluZm9zLmZvckVhY2goKHByb2dyYW1JbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IGFydGlmYWN0ID0gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW1JbmZvKTtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMucHVzaChhcnRpZmFjdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBydW5EYXRhcyA9IHRoaXMuY3JlYXRlUnVuRGF0YXMoaW5mZXJlbmNlSGFuZGxlciwgdGhpcy5hcnRpZmFjdHMubWFwKGEgPT4gYS5wcm9ncmFtSW5mbyksIGlucHV0cyk7XG4gICAgcnVuRGF0YXMuZm9yRWFjaCgodiwgaSkgPT4gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bih0aGlzLmFydGlmYWN0c1tpXSwgdikpO1xuICAgIHJldHVybiBbcnVuRGF0YXNbMV0ub3V0cHV0VGV4dHVyZURhdGEudGVuc29yXTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFzdXBlci5jaGVja0lucHV0VHlwZXMoaW5wdXRzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIC8vIGN1cnJlbnRseSB3ZWJnbCBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnQgNC1EIGlucHV0LlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCB4TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IHhEaW1zID0geExheW91dC5zaGFwZTtcbiAgICBjb25zdCBjaGFubmVsID0geERpbXNbMV07XG4gICAgY29uc3QgY2hhbm5lbFNpemUgPSB4RGltc1syXSAqIHhEaW1zWzNdO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gW3hEaW1zWzBdLCBjaGFubmVsXTtcbiAgICBjb25zdCBvdXRwdXRVbnBhY2tlZFNoYXBlID0gW3hEaW1zWzBdLCBjaGFubmVsICogNF07XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XG4gICAgICB2ZWM0IHYgPSB2ZWM0KDAuMCk7XG4gICAgICBpbnQgYVs0XTtcbiAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xuICAgICAgYVsxXSA9IGluZGljZXNbMV07XG4gICAgICBmbG9hdCB0ZW1wID0gMC4wO1xuICAgICAgZm9yKGludCBhMj0wOyBhMjwke3hEaW1zWzJdfTsgYTIrKykge1xuICAgICAgICBhWzJdID0gYTI7XG4gICAgICAgIGZvcihpbnQgYTM9MDsgYTM8JHt4RGltc1szXX07IGEzKyspIHtcbiAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xuICAgICAgICAgIHRlbXAgKz0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmxvYXQgbWVhbiA9IHRlbXAgLyBmbG9hdCgke2NoYW5uZWxTaXplfSk7XG4gICAgICB0ZW1wID0gMC4wO1xuICAgICAgZm9yKGludCBhMj0wOyBhMjwke3hEaW1zWzJdfTsgYTIrKykge1xuICAgICAgICBhWzJdID0gYTI7XG4gICAgICAgIGZvcihpbnQgYTM9MDsgYTM8JHt4RGltc1szXX07IGEzKyspIHtcbiAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xuICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHYuciA9IG1lYW47XG4gICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtjaGFubmVsU2l6ZX0pO1xuXG4gICAgICByZXR1cm4gdjtcbiAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbeExheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSwgNCwgb3V0cHV0VW5wYWNrZWRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydYJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBuYW1lOiAnTWVhbkFuZFZhcmlhbmNlJyxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlQ29tcHV0T3V0cHV0UHJvZ3JhbUluZm8oXG4gICAgICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHhMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIHNjYWxlTGF5b3V0OiBUZXh0dXJlTGF5b3V0LFxuICAgICAgYkxheW91dDogVGV4dHVyZUxheW91dCwgbWVhbkFuZFZhcmlhbmNlTGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xuICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xuICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7bWVhbkFuZFZhcmlhbmNlTGF5b3V0LndpZHRofSwgJHttZWFuQW5kVmFyaWFuY2VMYXlvdXQuaGVpZ2h0fSk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oTWVhbkFuZFZhcmlhbmNlLCBjb29yZHMpO1xuICAgIH1cblxuICAgIGZsb2F0IHByb2Nlc3MoaW50WzRdIGluZGljZXMpIHtcblxuICAgICAgICAgIGludCBtdlsyXTtcbiAgICAgICAgICBtdlswXSA9IGluZGljZXNbMF07XG4gICAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xuICAgICAgICAgIHZlYzQgbWVhbl9hbmRfdmFyaWFuY2UgPSBnZXRfTWVhbkFuZFZhcmlhbmNlKG12KTtcbiAgICAgICAgICBmbG9hdCBtZWFuID0gbWVhbl9hbmRfdmFyaWFuY2UucjtcbiAgICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XG5cbiAgICAgICAgICBpbnQgc2JbMV07XG4gICAgICAgICAgc2JbMF0gPSBpbmRpY2VzWzFdO1xuICAgICAgICAgIGZsb2F0IHNjYWxlID0gX1NjYWxlKHNiKTtcbiAgICAgICAgICBmbG9hdCBiID0gX0Ioc2IpO1xuXG4gICAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xuICAgICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbeExheW91dCwgbWVhbkFuZFZhcmlhbmNlTGF5b3V0LCBzY2FsZUxheW91dCwgYkxheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh4TGF5b3V0LnNoYXBlKSxcbiAgICAgIHNhbXBsZXJzOiBbJ1gnLCAnTWVhbkFuZFZhcmlhbmNlJywgJ1NjYWxlJywgJ0InXSxcbiAgICAgIHZhcmlhYmxlczogW3tuYW1lOiAnZXBzaWxvbicsIHR5cGU6ICdmbG9hdCd9XSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIG5hbWU6ICdDb21wdXRPdXRwdXQnLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm9zKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvW10ge1xuICAgIGNvbnN0IHhMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0pO1xuICAgIGNvbnN0IHNjYWxlTGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzFdKTtcbiAgICBjb25zdCBiTGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzJdKTtcbiAgICBjb25zdCBtZWFuQW5kVmFyaWFuY2VQcm9ncmFtSW5mbyA9IHRoaXMuY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgeExheW91dCk7XG4gICAgY29uc3QgY29tcHV0ZU91dHB1dFByb2dyYW1JbmZvID0gdGhpcy5jcmVhdGVDb21wdXRPdXRwdXRQcm9ncmFtSW5mbyhcbiAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgeExheW91dCwgc2NhbGVMYXlvdXQsIGJMYXlvdXQsIG1lYW5BbmRWYXJpYW5jZVByb2dyYW1JbmZvLm91dHB1dExheW91dCk7XG5cbiAgICBjb25zdCBwcm9ncmFtSW5mb3M6IFByb2dyYW1JbmZvW10gPSBbbWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8sIGNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mb107XG4gICAgcmV0dXJuIHByb2dyYW1JbmZvcztcbiAgfVxuICBjcmVhdGVSdW5EYXRhcyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvczogUHJvZ3JhbUluZm9bXSwgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGFbXSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZTtcbiAgICBjb25zdCBpbnB1dFREID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm9zWzBdLmlucHV0TGF5b3V0c1swXSk7XG4gICAgY29uc3Qgc2NhbGVURCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMV0sIHByb2dyYW1JbmZvc1sxXS5pbnB1dExheW91dHNbMl0pO1xuICAgIGNvbnN0IGJURCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMl0sIHByb2dyYW1JbmZvc1sxXS5pbnB1dExheW91dHNbM10pO1xuICAgIGNvbnN0IHJ1bkRhdGFzOiBSdW5EYXRhW10gPSBbXTtcbiAgICBydW5EYXRhcy5wdXNoKHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBbaW5wdXRURF0sXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm9zWzBdLm91dHB1dExheW91dCwgZGF0YVR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfSk7XG4gICAgcnVuRGF0YXMucHVzaCh7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogW2lucHV0VEQsIHJ1bkRhdGFzWzBdLm91dHB1dFRleHR1cmVEYXRhLCBzY2FsZVRELCBiVERdLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvc1sxXS5vdXRwdXRMYXlvdXQsIGRhdGFUeXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7J2Vwc2lsb24nOiB0aGlzLmVwc2lsb259XG4gICAgfSk7XG4gICAgcmV0dXJuIHJ1bkRhdGFzO1xuICB9XG4gIHByb3RlY3RlZCBhcnRpZmFjdHM6IEFydGlmYWN0W107XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtMZWFreVJlbHV9IGZyb20gJy4uLy4uLy4uL29wcy9sZWFreS1yZWx1JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xMZWFreVJlbHUgZXh0ZW5kcyBMZWFreVJlbHUgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHYgPSAke2dsc2wudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpLnI7XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCh2IDwgMC4wID8gdiAqIGZsb2F0KCR7dGhpcy5hbHBoYX0pIDogdik7XG4gICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgaW5wdXRMYXlvdXRzOiBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKV0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge01hdE11bH0gZnJvbSAnLi4vLi4vLi4vb3BzL21hdG11bCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7Z2V0QWN0aWNhdGlvblNuaXBwZXR9IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTE1hdE11bFBhY2tlZCBleHRlbmRzIE1hdE11bCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3Jlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTsnIDogJyc7XG4gICAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhU2hhcGUsIGJTaGFwZSwgdHJ1ZSk7XG5cbiAgICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgIH1cbiAgICBjb25zdCBzaGFyZWREaW0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNoYXJlZERpbUluZGV4ID0gTWF0aC5jZWlsKHNoYXJlZERpbSAvIDIpO1xuICAgIGNvbnN0IGFSYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgYWxsR2xDaGFubmVscyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXTtcblxuICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpY2F0aW9uU25pcHBldCh0aGlzLmFjdGl2YXRpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgbGFzdERpbSA9IHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMV19O1xuICAgICAgICByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfSA9IHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19O1xuICAgICAgICByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDJdfSA9IGxhc3REaW07XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c2hhcmVkRGltSW5kZXh9OyBpKyspIHtcbiAgICAgICAgICB2ZWM0IGEgPSBnZXRBKCR7Z2V0QShhbGxHbENoYW5uZWxzLCBhUmFuayl9KTtcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRCKCR7Z2V0QihhbGxHbENoYW5uZWxzLCBiUmFuayl9KTtcbiAgICAgICAgICByZXN1bHQgKz0gKGEucnJiYiAqIGIucmdyZyk7XG4gICAgICAgICAgcmVzdWx0ICs9IChhLmdnYWEgKiBiLmJhYmEpO1xuICAgICAgICB9XG4gICAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1gO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnV2ViR0xNYXRNdWxQYWNrZWQnLFxuICAgICAgaW5wdXRMYXlvdXRzOiBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0LCA0LCB0cnVlLCBpbnB1dHNbaV0uZGltcywgdHJ1ZSkpLFxuICAgICAgb3V0cHV0TGF5b3V0OlxuICAgICAgICAgIGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSwgNCwgb3V0cHV0U2hhcGUsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSksXG4gICAgICBzYW1wbGVyczogaGFzQmlhcyA/IFsnQScsICdCJywgJ0JpYXMnXSA6IFsnQScsICdCJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkSW5wdXRzOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkT3V0cHV0czogdHJ1ZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9XG4gICAgICAgIGlucHV0cy5tYXAoKHQpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0LCAxLCBmYWxzZSwgW10sIHRydWUpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QShhbGxHbENoYW5uZWxzOiBzdHJpbmdbXSwgcmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAyOyBpKyspIHtcbiAgICByZXMgKz0gYHJjLiR7YWxsR2xDaGFubmVsc1tpXX0sIGA7XG4gIH1cbiAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDJdfSwgYCArXG4gICAgICAnaSoyJztcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gZ2V0QihhbGxHbENoYW5uZWxzOiBzdHJpbmdbXSwgcmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAyOyBpKyspIHtcbiAgICByZXMgKz0gYHJjLiR7YWxsR2xDaGFubmVsc1tpXX0sIGA7XG4gIH1cbiAgcmVzICs9ICdpKjIsICcgK1xuICAgICAgYHJjLiR7YWxsR2xDaGFubmVsc1tyYW5rIC0gMV19YDtcbiAgcmV0dXJuIHJlcztcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge01hdE11bH0gZnJvbSAnLi4vLi4vLi4vb3BzL21hdG11bCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1dlYkdMTWF0TXVsUGFja2VkfSBmcm9tICcuL21hdG11bC1wYWNrJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMTWF0TXVsIGV4dGVuZHMgTWF0TXVsIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHByaXZhdGUgdXNlUGFja2VkVGV4dHVyZT86IGJvb2xlYW47XG5cbiAgcGFja2VkSW1wbDogV2ViR0xNYXRNdWxQYWNrZWQ7XG4gIHVucGFja2VkSW1wbDogV2ViR0xVbnBhY2tlZE1hdE11bDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhY2tlZEltcGwgPSBuZXcgV2ViR0xNYXRNdWxQYWNrZWQoKTtcbiAgICB0aGlzLnVucGFja2VkSW1wbCA9IG5ldyBXZWJHTFVucGFja2VkTWF0TXVsKCk7XG4gIH1cblxuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGlmICh0aGlzLnVzZVBhY2tlZFRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcyk7XG4gICAgICB0aGlzLnVzZVBhY2tlZFRleHR1cmUgPSAhaXNCcm9hZGNhc3QgJiYgaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2s7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudXNlUGFja2VkVGV4dHVyZSkge1xuICAgICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMucGFja2VkSW1wbCwgaW5wdXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMudW5wYWNrZWRJbXBsLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBpZiAodGhpcy51c2VQYWNrZWRUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpO1xuICAgICAgdGhpcy51c2VQYWNrZWRUZXh0dXJlID0gIWlzQnJvYWRjYXN0ICYmIGhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZVBhY2tlZFRleHR1cmUgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFja2VkSW1wbC5jcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhY2tlZEltcGwuY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXRzKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgaWYgKHRoaXMudXNlUGFja2VkVGV4dHVyZSAmJiBpbnB1dHNbMF0uZGltcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRJbXBsLmNyZWF0ZVJ1bkRhdGEoaGFuZGxlciwgcHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja2VkSW1wbC5jcmVhdGVSdW5EYXRhKGhhbmRsZXIsIHByb2dyYW1JbmZvLCBpbnB1dHMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xVbnBhY2tlZE1hdE11bCBleHRlbmRzIE1hdE11bCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFTaGFwZSwgYlNoYXBlLCB0cnVlKTtcbiAgICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgIH1cbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGFyYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgc2hhcmVkRGltID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IGFbJHthcmFua31dO1xuICAgICAgICAgIGludCBiWyR7YnJhbmt9XTtcbiAgICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQShpbmRpY2VzLCBhKTtcbiAgICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQihpbmRpY2VzLCBiKTtcblxuICAgICAgICAgIGZsb2F0IHZhbHVlO1xuICAgICAgICAgIGZvciAoaW50IGs9MDsgazwke3NoYXJlZERpbX07ICsraykge1xuICAgICAgICAgICAgICBhWyR7YXJhbmsgLSAxfV0gPSBrO1xuICAgICAgICAgICAgICBiWyR7YnJhbmsgLSAyfV0gPSBrO1xuICAgICAgICAgICAgICB2YWx1ZSArPSBfQShhKSAqIF9CKGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnQScsICdCJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRDaGFubmVsc30gZnJvbSAnLi9wYWNraW5nLXV0aWxzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMUGFjayBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrIGtlcm5lbCBzaG91bGQgaGF2ZSBpbnB1dCB0ZW5zb3IgY291bnQgdG8gMS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPVxuICAgICAgICBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoaW5wdXRTaGFwZSwgNCwgaW5wdXRTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IG91dHB1dExheW91dC5zaGFwZTtcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRSYW5rKTtcbiAgICBjb25zdCBjaGFubmVscyA9IGdldENoYW5uZWxzKCdyYycsIG91dHB1dFJhbmspO1xuICAgIGNvbnN0IHNldHVwID0gZ2V0U2V0dXAob3V0cHV0UmFuaywgY2hhbm5lbHMsIGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAyXSwgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdKTtcblxuICAgIGxldCByZXZlcnNlZElucHV0V0g7XG4gICAgaWYgKGlucHV0UmFuayA9PT0gMCkge1xuICAgICAgcmV2ZXJzZWRJbnB1dFdIID0gWzEsIDFdO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRSYW5rID09PSAxKSB7XG4gICAgICByZXZlcnNlZElucHV0V0ggPSBbaW5wdXRTaGFwZVswXSwgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldmVyc2VkSW5wdXRXSCA9IFtpbnB1dFNoYXBlW291dHB1dFJhbmsgLSAxXSwgaW5wdXRTaGFwZVtvdXRwdXRSYW5rIC0gMl1dO1xuICAgIH1cbiAgICBjb25zdCBvdXRPZkJvdW5kc0NvbmRpdGlvbiA9IGdldE91dE9mQm91bmRzQ29uZGl0aW9uKG91dHB1dFJhbmssIHJldmVyc2VkSW5wdXRXSCwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IGdldE91dHB1dChpbnB1dFNoYXBlLCBjaGFubmVscyk7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgJHtjb29yZHNEYXRhVHlwZX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICAgIGlmKCR7b3V0T2ZCb3VuZHNDb25kaXRpb259KSB7XG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQoMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7c2V0dXB9XG5cbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNCgke291dHB1dH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYDtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnV2ViR0xQYWNrJyxcbiAgICAgIGlucHV0TGF5b3V0czogW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgMSwgZmFsc2UsIFtdLCB0cnVlKV0sXG4gICAgICBvdXRwdXRMYXlvdXQsXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgZXhwZWN0UGFja2VkSW5wdXRzOiBmYWxzZSxcbiAgICAgIGV4cGVjdFBhY2tlZE91dHB1dHM6IHRydWUsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBjaGVjayBvdXRwdXQgY29vcmRpbmF0ZSBsb2NhdGlvbiBhbmQgcmV0dXJuIGZhbHNlIGlmIGl0IGlzIG91dHNpZGUgaW5wdXQncyB3aWR0aC9oZWlnaHQgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0T2ZCb3VuZHNDb25kaXRpb24ocmFuazogbnVtYmVyLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gYHJjID4gJHtzaGFwZVswXX1gO1xuICB9XG5cbiAgbGV0IGNvbmQgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAyOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29uZCArPSBgJHtkaW1zW2ldfSA+PSAke3NoYXBlW2kgLSByYW5rICsgMl19YDtcbiAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICBjb25kICs9ICd8fCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmQ7XG59XG5cbi8qKlxuICogY29kZSBzbmlwcGV0IHRvIHNhbXBsZSBpbnB1dCB0ZXh0dXJlIHdpdGggb3V0cHV0IGNvb3JkaWFudGVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dHB1dChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICBpZiAocmFuayA9PT0gMCkge1xuICAgIHJldHVybiAnZ2V0QSgpLCAwLCAwLCAwJztcbiAgfVxuXG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGBnZXRBKHJjKSxcbiAgICAgICAgICAgIHJjICsgMSA+PSAke3NoYXBlWzBdfSA/IDAuIDogZ2V0QShyYyArIDEpLFxuICAgICAgICAgICAgMCwgMGA7XG4gIH1cblxuICBjb25zdCBjb29yZDAwID0gJ3IsIGMnO1xuICBjb25zdCBjb29yZDAxID0gJ3IsIGNwMSc7XG4gIGNvbnN0IGNvb3JkMTAgPSAncnAxLCBjJztcbiAgY29uc3QgY29vcmQxMSA9ICdycDEsIGNwMSc7XG4gIGxldCBEID0gJyc7XG4gIGlmIChyYW5rID4gMikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7ICsraSkge1xuICAgICAgRCA9IEQgKyBgJHtkaW1zW2ldfSxgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYGdldEEoJHtEfSR7Y29vcmQwMH0pLFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7RH0ke2Nvb3JkMTB9KSxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke0R9JHtjb29yZDAxfSksXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtEfSR7Y29vcmQxMX0pYDtcbn1cblxuLyoqXG4gKiBjb2RlIHNuaXBwZXQgdG8gc2V0dXAgNCBjb29yZGluYXRlcyBhbmQgZWRnZSBjb25kaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFNldHVwKHJhbms6IG51bWJlciwgZGltczogc3RyaW5nW10sIHJvd3M6IG51bWJlciwgY29sczogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDAgfHwgcmFuayA9PT0gMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICAvLyByYW5rID49IDIgZm9yIHdpZHRoK2hlaWdodCBwYWNrLlxuICBlbHNlIHtcbiAgICBjb25zdCBzZXR1cCA9IGBcbiAgICBpbnQgciA9ICR7ZGltc1tyYW5rIC0gMl19O1xuICAgIGludCBjID0gJHtkaW1zW3JhbmsgLSAxXX07XG4gICAgaW50IHJwMSA9ICR7ZGltc1tyYW5rIC0gMl19ICsgMTtcbiAgICBpbnQgY3AxID0gJHtkaW1zW3JhbmsgLSAxXX0gKyAxO1xuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gJHtjb2xzfTtcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7cm93c307XG4gICAgYDtcbiAgICByZXR1cm4gc2V0dXA7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVjQ2hhbm5lbHMobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIHJldHVybiBbJ3gnLCAneScsICd6JywgJ3cnLCAndScsICd2J10uc2xpY2UoMCwgcmFuaykubWFwKGQgPT4gYCR7bmFtZX0uJHtkfWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbm5lbHMobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIFtuYW1lXTtcbiAgfVxuICByZXR1cm4gZ2V0VmVjQ2hhbm5lbHMobmFtZSwgcmFuayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tGcm9tQ2hhbm5lbCgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XG4gICAgICBpbnQgbW9kQ29vcmQgPSBpbW9kKGRpbSwgMik7XG4gICAgICByZXR1cm4gbW9kQ29vcmQgPT0gMCA/IGZyYWcuciA6IGZyYWcuZztcbiAgICB9XG5cbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XG4gICAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcbiAgICB9XG4gIGA7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtQYWR9IGZyb20gJy4uLy4uLy4uL29wcy9wYWQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2wsIEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlTGF5b3V0LCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFBhZCBleHRlbmRzIFBhZCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5wYWRTaGFwZShpbnB1dHNbMF0uZGltcy5zbGljZSgpLCB0aGlzLnBhZHMpO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgYWxheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSk7XG4gICAgY29uc3QgcGFkRnVuY3Rpb24gPSBnZXRQYWRGdW5jdGlvbihcbiAgICAgICAgZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksICdBJywgYWxheW91dCwgdGhpcy5tb2RlLCB0aGlzLnBhZHMsIHRoaXMudmFsdWUpO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7cGFkRnVuY3Rpb259XG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XG4gICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbYWxheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOlxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZEZ1bmN0aW9uKFxuICAgIGdsc2w6IEdsc2wsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG1vZGU6IHN0cmluZywgcGFkczogbnVtYmVyW10sIHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdjb25zdGFudCc6XG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQoXG4gICAgICAgICAgZ2xzbCwgbmFtZSwgaW5wdXRMYXlvdXQuc2hhcGUsIGlucHV0TGF5b3V0LnN0cmlkZXMsIGlucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHQsIHBhZHMsIHZhbHVlKTtcbiAgICBjYXNlICdyZWZsZWN0JzpcbiAgICAgIHJldHVybiBnZXRQYWRSZWZsZWN0KFxuICAgICAgICAgIGdsc2wsIG5hbWUsIGlucHV0TGF5b3V0LnNoYXBlLCBpbnB1dExheW91dC5zdHJpZGVzLCBpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0LCBwYWRzKTtcbiAgICBjYXNlICdlZGdlJzpcbiAgICAgIHJldHVybiBnZXRQYWRFZGdlKFxuICAgICAgICAgIGdsc2wsIG5hbWUsIGlucHV0TGF5b3V0LnNoYXBlLCBpbnB1dExheW91dC5zdHJpZGVzLCBpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0LCBwYWRzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGUnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFkQ29uc3RhbnQoXG4gICAgZ2xzbDogR2xzbCwgbmFtZTogc3RyaW5nLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcixcbiAgICBwYWRzOiBudW1iZXJbXSwgdmFsdWU6IG51bWJlcikge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICBrID0gbVske2l9XSAtICR7cGFkc1tpXX07XG4gICAgICAgICAgaWYgKGsgPCAwKSAgcmV0dXJuIGNvbnN0YW50O1xuICAgICAgICAgIGlmIChrID49ICR7c2hhcGVbaV19KSByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgICAgb2Zmc2V0ICs9IGsgKiAke3N0cmlkZXNbaV19O1xuICAgICAgICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgICAgZmxvYXQgcGFkJHtuYW1lfShpbnQgbVske3Jhbmt9XSkge1xuICAgICAgICAgIGNvbnN0IGZsb2F0IGNvbnN0YW50ID0gZmxvYXQoJHt2YWx1ZX0pO1xuICAgICAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgICAgIGludCBrID0gMDtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3dpZHRofSwgJHtoZWlnaHR9KTtcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBjb29yZHMpKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbn1cbmZ1bmN0aW9uIGdldFBhZFJlZmxlY3QoXG4gICAgZ2xzbDogR2xzbCwgbmFtZTogc3RyaW5nLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcixcbiAgICBwYWRzOiBudW1iZXJbXSkge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICBrID0gbVske2l9XSAtICR7cGFkc1tpXX07XG4gICAgICAgIGlmIChrIDwgMCkgeyBrID0gLWs7IH1cbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGludCBfMm5fMSA9ICR7MiAqIChzaGFwZVtpXSAtIDEpfTtcbiAgICAgICAgICBrID0gaW50KCBtb2QoIGZsb2F0KGspLCBmbG9hdChfMm5fMSkgKSApIDtcbiAgICAgICAgICBpZihrID49ICR7c2hhcGVbaV19KSB7IGsgPSBfMm5fMSAtIGs7IH1cbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gayAqICR7c3RyaWRlc1tpXX07XG4gICAgICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IHBhZCR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbn1cbmZ1bmN0aW9uIGdldFBhZEVkZ2UoXG4gICAgZ2xzbDogR2xzbCwgbmFtZTogc3RyaW5nLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcixcbiAgICBwYWRzOiBudW1iZXJbXSkge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgaWYgKGsgPCAwKSAgayA9IDA7XG4gICAgICBpZiAoayA+PSAke3NoYXBlW2ldfSkgayA9ICR7c2hhcGVbaV0gLSAxfTtcbiAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBmbG9hdCBwYWQke25hbWV9KGludCBtWyR7cmFua31dKSB7XG4gICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgIGludCBrID0gMDtcbiAgICAgICR7YmxvY2t9XG4gICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBjb29yZHMpKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgYDtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F2ZXJhZ2VQb29sLCBHbG9iYWxBdmVyYWdlUG9vbCwgR2xvYmFsTWF4UG9vbCwgTWF4UG9vbH0gZnJvbSAnLi4vLi4vLi4vb3BzL3Bvb2wnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1Bvb2xDb252VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlTGF5b3V0LCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEdsb2JhbEF2ZXJhZ2VQb29sIGV4dGVuZHMgR2xvYmFsQXZlcmFnZVBvb2wgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgcmV0dXJuIGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oXG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgdHJ1ZSwgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5hdXRvUGFkLCB0aGlzLnN0cmlkZXMsIHRoaXMucGFkcywgdGhpcy5jb3VudEluY2x1ZGVQYWQpO1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEF2ZXJhZ2VQb29sIGV4dGVuZHMgQXZlcmFnZVBvb2wgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgcmV0dXJuIGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oXG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgZmFsc2UsIHRoaXMua2VybmVsU2hhcGUsIHRoaXMuYXV0b1BhZCwgdGhpcy5zdHJpZGVzLCB0aGlzLnBhZHMsIHRoaXMuY291bnRJbmNsdWRlUGFkKTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOlxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyhcbiAgICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSA9IFtdLFxuICAgIGF1dG9QYWQgPSAnJywgc3RyaWRlczogbnVtYmVyW10gPSBbXSwgcGFkczogbnVtYmVyW10gPSBbXSwgY291bnRJbmNsdWRlUGFkOiBib29sZWFuKTogUHJvZ3JhbUluZm8ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGUsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZSwgc3RyaWRlcywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICBjb25zdCBrZXJuZWxTaXplID0gU2hhcGVVdGlsLnNpemUoa2VybmVsU2hhcGUpO1xuICBjb25zdCBvcDEgPSAndmFsdWUgKz0gX1goeCk7JztcbiAgbGV0IG9wMiA9ICcnO1xuICBpZiAoY291bnRJbmNsdWRlUGFkKSB7XG4gICAgb3AyICs9IGB2YWx1ZSAvPSBmbG9hdCgke2tlcm5lbFNpemV9KTtgO1xuICB9IGVsc2Uge1xuICAgIG9wMiArPSBgdmFsdWUgLz0gZmxvYXQoJHtrZXJuZWxTaXplfSAtIHBhZCk7YDtcbiAgfVxuICBjb25zdCBpbnB1dExheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSk7XG4gIGNvbnN0IHBvb2xpbmdDb2RlID0gZ2VuZXJhdGVQb29saW5nQ29kZShpbnB1dExheW91dCwga2VybmVsU2hhcGUsIHBhZHMsIHN0cmlkZXMsIG9wMSwgb3AyLCAnMC4wJyk7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7cG9vbGluZ0NvZGV9XG4gICAgYDtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dF0sXG4gICAgb3V0cHV0TGF5b3V0OiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgIHNhbXBsZXJzOiBbJ1gnXSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEdsb2JhbE1heFBvb2wgZXh0ZW5kcyBHbG9iYWxNYXhQb29sIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIHJldHVybiBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oXG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgdHJ1ZSwgdGhpcy5rZXJuZWxTaGFwZSwgdGhpcy5hdXRvUGFkLCB0aGlzLnN0cmlkZXMsIHRoaXMucGFkcyk7XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gW2luZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0pXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTE1heFBvb2wgZXh0ZW5kcyBNYXhQb29sIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIHJldHVybiBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oXG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgZmFsc2UsIHRoaXMua2VybmVsU2hhcGUsIHRoaXMuYXV0b1BhZCwgdGhpcy5zdHJpZGVzLCB0aGlzLnBhZHMpO1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtpbmZlcmVuY2VIYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOlxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKFxuICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwga2VybmVsU2hhcGU6IG51bWJlcltdID0gW10sXG4gICAgYXV0b1BhZCA9ICcnLCBzdHJpZGVzOiBudW1iZXJbXSA9IFtdLCBwYWRzOiBudW1iZXJbXSA9IFtdKTogUHJvZ3JhbUluZm8ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgUG9vbENvbnZVdGlsLmFkanVzdFBvb2xBdHRyaWJ1dGVzKGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGUsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZSwgc3RyaWRlcywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICBjb25zdCBvcDEgPSBgXG4gICAgICAgICAgICAgIHZhbHVlID0gbWF4KF9YKHgpLCB2YWx1ZSk7XG4gICAgICBgO1xuICBjb25zdCBvcDIgPSAnJztcbiAgY29uc3QgaW5wdXRMYXlvdXQgPSBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IHBvb2xpbmdDb2RlID0gZ2VuZXJhdGVQb29saW5nQ29kZShpbnB1dExheW91dCwga2VybmVsU2hhcGUsIHBhZHMsIHN0cmlkZXMsIG9wMSwgb3AyLCAnLTFlNScpO1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgJHtwb29saW5nQ29kZX1cbiAgYDtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dF0sXG4gICAgb3V0cHV0TGF5b3V0OiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgIHNhbXBsZXJzOiBbJ1gnXSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxuICAgIHg6IFRleHR1cmVMYXlvdXQsIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBvcDE6IHN0cmluZywgb3AyOiBzdHJpbmcsXG4gICAgc3RhcnRWYWw6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGlucHV0RGltcyA9IHguc2hhcGU7XG4gIGNvbnN0IHJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XG4gICAgY29uc3Qga3cgPSBrZXJuZWxTaGFwZVtrZXJuZWxTaGFwZS5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBzdyA9IHN0cmlkZXNbc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwd1N0YXJ0ID0gcGFkc1twYWRzLmxlbmd0aCAvIDIgLSAxXTtcbiAgICBjb25zdCBwd0VuZCA9IHBhZHNbcGFkcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBkaW1XID0gaW5wdXREaW1zW3JhbmsgLSAxXTtcbiAgICBsZXQgY29kZVcgPSAnJztcbiAgICBsZXQgY29kZUggPSAnJztcbiAgICBsZXQgY29kZUhFbmQgPSAnJztcbiAgICBpZiAocHdTdGFydCArIHB3RW5kICE9PSAwKSB7XG4gICAgICBjb2RlVyA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7a3d9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDFdID0gaW5kaWNlc1ske3Jhbmt9IC0gMV0gKiAke3N3fSAtICR7cHdTdGFydH0gKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhbJHtyYW5rfSAtIDFdIDwgMCB8fCB4WyR7cmFua30gLSAxXSA+PSAke2RpbVd9KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlVyA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7a3d9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDFdID0gaW5kaWNlc1ske3Jhbmt9IC0gMV0gKiAke3N3fSAtICR7cHdTdGFydH0gKyBpO1xuICAgICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgfVxuXG4gICAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qga2ggPSBrZXJuZWxTaGFwZVtrZXJuZWxTaGFwZS5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IHNoID0gc3RyaWRlc1tzdHJpZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgcGhTdGFydCA9IHBhZHNbcGFkcy5sZW5ndGggLyAyIC0gMl07XG4gICAgICBjb25zdCBwaEVuZCA9IHBhZHNbcGFkcy5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IGRpbUggPSBpbnB1dERpbXNbcmFuayAtIDJdO1xuICAgICAgaWYgKHBoU3RhcnQgKyBwaEVuZCAhPT0gMCkge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke2tofTsgaisrKSB7XG4gICAgICAgICAgICAgICAgeFske3Jhbmt9IC0gMl0gPSBpbmRpY2VzWyR7cmFua30gLSAyXSAqICR7c2h9IC0gJHtwaFN0YXJ0fSArIGo7XG4gICAgICAgICAgICAgICAgaWYgKHhbJHtyYW5rfSAtIDJdIDwgMCB8fCB4WyR7cmFua30gLSAyXSA+PSAke2RpbUh9KSB7XG4gICAgICAgICAgICAgICAgICBwYWQrPSAke2t3fTtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7a2h9OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDJdID0gaW5kaWNlc1ske3Jhbmt9IC0gMl0gKiAke3NofSAtICR7cGhTdGFydH0gKyBqO1xuICAgICAgICAgICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb2RlSEVuZCA9IGBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICB9XG5cbiAgICBjb25zdCBwb29saW5nQ29kZSA9IGBcbiAgICAgICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAgICAgaW50IHhbJHtyYW5rfV07XG4gICAgICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XG5cbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSAke3N0YXJ0VmFsfTtcbiAgICAgICAgICAgICAgaW50IHBhZCA9IDA7XG4gICAgICAgICAgICAgICR7Y29kZUh9XG4gICAgICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgICAgICR7Y29kZUhFbmR9XG4gICAgICAgICAgICAgICR7b3AyfVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGtlcm5lbFNoYXBlKTtcbiAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGtlcm5lbFNoYXBlKTtcbiAgICBjb25zdCBzdHJpZGVzUmFuayA9IGtlcm5lbFN0cmlkZXMubGVuZ3RoO1xuICAgIGNvbnN0IHBhZHNSYW5rID0gcGFkcy5sZW5ndGg7XG4gICAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzRnVuY3Rpb24gPSBvZmZzZXRUb0luZGljZXMoc3RyaWRlc1JhbmspO1xuICAgIGNvbnN0IGNvcHlJbnB1dERpbXMgPSBjb3B5QXJyYXkoaW5wdXREaW1zLCAnaW5wdXREaW1zJyk7XG4gICAgY29uc3QgY29weVBhZHMgPSBjb3B5QXJyYXkocGFkcywgJ3BhZHMnKTtcbiAgICBjb25zdCBjb3B5S2VybmVsU3RyaWRlcyA9IGNvcHlBcnJheShrZXJuZWxTdHJpZGVzLCAna2VybmVsU3RyaWRlcycpO1xuICAgIGNvbnN0IGNvcHlTdHJpZGVzID0gY29weUFycmF5KHN0cmlkZXMsICdzdHJpZGVzJyk7XG4gICAgY29uc3QgaGFzUGFkcyA9IHBhZHMucmVkdWNlKChzdW0sIGN1cikgPT4gc3VtICsgY3VyKTtcbiAgICBsZXQgcGFkQ29kZSA9ICcnO1xuICAgIGlmIChoYXNQYWRzKSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xuICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICBpc1BhZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICR7b3AxfWA7XG4gICAgfVxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtvZmZzZXRUb0luZGljZXNGdW5jdGlvbn1cbiAgICAgICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAgICAgICBpbnQgeFske3Jhbmt9XTtcbiAgICAgICAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xuICAgICAgICAgICAgICAgIGludCBvZmZzZXRbJHtzdHJpZGVzUmFua31dO1xuICAgICAgICAgICAgICAgIGludCBwYWRzWyR7cGFkc1Jhbmt9XTtcbiAgICAgICAgICAgICAgICBpbnQgaW5wdXREaW1zWyR7cmFua31dO1xuICAgICAgICAgICAgICAgIGludCBrZXJuZWxTdHJpZGVzWyR7c3RyaWRlc1Jhbmt9XTtcbiAgICAgICAgICAgICAgICBpbnQgc3RyaWRlc1ske3N0cmlkZXNSYW5rfV07XG4gICAgICAgICAgICAgICAgJHtjb3B5UGFkc31cbiAgICAgICAgICAgICAgICAke2NvcHlJbnB1dERpbXN9XG4gICAgICAgICAgICAgICAgJHtjb3B5U3RyaWRlc31cbiAgICAgICAgICAgICAgICAke2NvcHlLZXJuZWxTdHJpZGVzfVxuXG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSAke3N0YXJ0VmFsfTtcbiAgICAgICAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAgICAgICBib29sIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2tlcm5lbFNpemV9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9JbmRpY2VzKGksIGtlcm5lbFN0cmlkZXMsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAke3Jhbmt9IC0gJHtzdHJpZGVzUmFua307IGogPCAke3Jhbmt9OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICB4W2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7cmFua30gKyAke3N0cmlkZXNSYW5rfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0W2ogLSAke3Jhbmt9ICsgJHtzdHJpZGVzUmFua31dIC0gcGFkc1tqIC0gMl07XG4gICAgICAgICAgICAgICAgICAgICAgJHtwYWRDb2RlfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAke29wMn1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1gO1xuICAgIHJldHVybiBwb29saW5nQ29kZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weUFycmF5KGFycmF5OiByZWFkb25seSBudW1iZXJbXSwgYXJyYXlOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICR7YXJyYXlOYW1lfVske2l9XSA9ICR7YXJyYXlbaV19O1xuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGJsb2NrO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0VG9JbmRpY2VzKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7cmFua31dIHN0cmlkZXMsIG91dCBpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgICAgaWYgKCR7cmFua30gPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7cmFua30gLSAxOyArK2kpIHtcbiAgICAgICAgaW5kaWNlc1tpXSA9IG9mZnNldCAvIHN0cmlkZXNbaV07XG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICAgIH1cbiAgICAgIGluZGljZXNbJHtyYW5rfSAtIDFdID0gb2Zmc2V0O1xuICAgIH1gO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7UmVkdWNlQmFzZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3JlZHVjZS1vcCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmFic3RyYWN0IGNsYXNzIFdlYkdMR2VuZXJpY1JlZHVjZSBleHRlbmRzIFJlZHVjZUJhc2UgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgZ2V0T3BzKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW107XG5cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gICAgY29uc3QgaVJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggfHwgMTtcblxuICAgIGNvbnN0IGlkeENvcHkgPSBbXTsgIC8vIGNvcHkgb3V0cHV0IGluZGV4ZXMgdG8gaW5wdXQgaW5kZXhlc1xuXG4gICAgY29uc3QgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHRoaXMuYXhlcywgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBvcHMgPSB0aGlzLmdldE9wcyhpbnB1dHMsIGF4ZXMpOyAgLy8gW2luaXQgb3BzLCByZWR1Y2Ugb3BzLCBmaW5hbCBvcHNdXG4gICAgbGV0IHJlZHVjZU9wcyA9IG9wc1sxXTtcblxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyByZWR1Y2VkXG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMua2VlcERpbXMpIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xuICAgICAgICB9ICAvLyBlbHNlIHsgcmVtb3ZlIHRoZSBheGlzIGZyb20gb3V0cHV0U2hhcGU7IH1cblxuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGQtdGggYXhpc1xuICAgICAgICByZWR1Y2VPcHMgPSBgXG4gICAgICAgIGZvcihpbnQgaiR7a30gPSAwOyBqJHtrfSA8ICR7aW5wdXRzWzBdLmRpbXNba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgaW5wdXRJZHhbJHtrfV0gPSBqJHtrfTtcbiAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4Q29weS5wdXNoKGBpbnB1dElkeFske2t9XSA9IG91dHB1dElkeFske291dHB1dFNoYXBlLmxlbmd0aH1dO2ApO1xuXG4gICAgICAgIG91dHB1dFNoYXBlLnB1c2goaW5wdXRzWzBdLmRpbXNba10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9SYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoIHx8IDE7XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtvUmFua31dKSB7XG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XG4gICAgICAgIGludCBpbnB1dElkeFske2lSYW5rfV07ICAgICAgLy8gYWRkcmVzc2luZyBpbnB1dCBkYXRhXG4gICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cbiAgICAgICAgJHtvcHNbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgJHtvcHNbMl19ICAgICAgIC8vIGZpbmFsIGNvbXB1dGF0aW9uIGZvciByZWR1Y2UgbWVhblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcblxuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IGlucHV0cy5tYXAodCA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dCh0KSksXG4gICAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVkdWNlU3VtIGV4dGVuZHMgV2ViR0xHZW5lcmljUmVkdWNlIHtcbiAgZ2V0T3BzKF9pbnB1dHM6IFRlbnNvcltdKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbJ3ZhbHVlID0gMC4wOycsICd2YWx1ZSArPSBfQShpbnB1dElkeCk7JywgJyddO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFJlZHVjZU1lYW4gZXh0ZW5kcyBXZWJHTEdlbmVyaWNSZWR1Y2Uge1xuICBnZXRPcHMoaW5wdXRzOiBUZW5zb3JbXSwgYXhlczogbnVtYmVyW10pOiBzdHJpbmdbXSB7XG4gICAgbGV0IHNpemUgPSAxLjA7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dHNbMF0uZGltcy5sZW5ndGg7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNpemUgKj0gaW5wdXRzWzBdLmRpbXNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCBgdmFsdWUgLz0gJHtzaXplfS47YF07ICAvLyBlbnN1cmUgcmVhbCBudW1iZXIgd2l0aCBgLmBcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xSZWR1Y2VNYXggZXh0ZW5kcyBXZWJHTEdlbmVyaWNSZWR1Y2Uge1xuICBnZXRPcHMoaW5wdXRzOiBUZW5zb3JbXSwgYXhlczogbnVtYmVyW10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0SWR4WyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2Ake2lkeFplcm8uam9pbignXFxuJyl9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCwgJ3ZhbHVlID0gbWF4KHZhbHVlLCBfQShpbnB1dElkeCkpOycsICcnXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xSZWR1Y2VNaW4gZXh0ZW5kcyBXZWJHTEdlbmVyaWNSZWR1Y2Uge1xuICBnZXRPcHMoaW5wdXRzOiBUZW5zb3JbXSwgYXhlczogbnVtYmVyW10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0SWR4WyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2Ake2lkeFplcm8uam9pbignXFxuJyl9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCwgJ3ZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpOycsICcnXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgV2ViR0xSZWR1Y2VQcm9kIGV4dGVuZHMgV2ViR0xHZW5lcmljUmVkdWNlIHtcbiAgZ2V0T3BzKF9pbnB1dHM6IFRlbnNvcltdKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbJ3ZhbHVlID0gMS4wOycsICd2YWx1ZSAqPSBfQShpbnB1dElkeCk7JywgJyddO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFJlZHVjZUxvZ1N1bSBleHRlbmRzIFdlYkdMR2VuZXJpY1JlZHVjZSB7XG4gIGdldE9wcyhfaW5wdXRzOiBUZW5zb3JbXSk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWyd2YWx1ZSA9IDAuMDsnLCAndmFsdWUgKz0gX0EoaW5wdXRJZHgpOycsICd2YWx1ZSA9IGxvZyh2YWx1ZSk7J107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVkdWNlU3VtU3F1YXJlIGV4dGVuZHMgV2ViR0xHZW5lcmljUmVkdWNlIHtcbiAgZ2V0T3BzKF9pbnB1dHM6IFRlbnNvcltdKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbJ2Zsb2F0IHQ7IHZhbHVlID0gMC4wOycsICd0ID0gX0EoaW5wdXRJZHgpOyB2YWx1ZSArPSB0ICogdDsnLCAnJ107XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Jlc2hhcGV9IGZyb20gJy4uLy4uLy4uL29wcy9yZXNoYXBlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgVGV4dHVyZURhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7VGV4dHVyZUxheW91dH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHt1bnBhY2tGcm9tQ2hhbm5lbH0gZnJvbSAnLi9wYWNraW5nLXV0aWxzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVzaGFwZVBhY2tlZCBleHRlbmRzIFJlc2hhcGUgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVzaXplIGtlcm5lbCBzaG91bGQgaGF2ZSBpbnB1dCB0ZW5zb3IgY291bnQgdG8gMi4nKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgcGFja2VkIHJlc2hhcGUsIHdlIG5lZWQgdG8gcmUtYXJyYW5nZSB0ZXhlbCBkYXRhIGZvciBvdXRwdXQgc2hhcGUuXG4gICAgLy8gT3VyIHBhY2sgaXMgZGVzaWduZWQgdG8gcGFjayBhIDJ4MiB0aWxlIGluIGxhc3QgaCBhbmQgdyBkaW1lbnNpb24sIHNvXG4gICAgLy8gZm9yIHRoZSByZXNoYXBlZCBuZXcgdGVuc29yLCB3ZSBqdXN0IG5lZWQgdG8gcmUtYXJyYW5nZSB0aGUgbGFzdCBoIGFuZFxuICAgIC8vIHcgZGltZW5zaW9uLiBGb3IgYW55IHNoYXBlIHRoYXQgaXMgbm90IGluIDNELCBpLmUuIFtiYXRjaCwgVywgSF0sIHdlXG4gICAgLy8gZmlyc3QgY29udmVydCBpdCB0byAzRCBieSBjb2xsYXBzaW5nIG90aGVyIGRpbWVuc2lvbiB0byBiYXRjaCBkaW0sIHRoZW5cbiAgICAvLyBwcm9jZXNzIHdpdGggdGhlIGxhc3QgdHdvIGRpbWVuc2lvbnMuXG4gICAgLy8gTm90ZTogd2Ugb25seSBuZWVkIHRoZSBzaGFwZSB0ZW5zb3IgdG8gY2FsY3VsYXRlIG91dHB1dCBzaGFwZSwgc28gdGhlXG4gICAgLy8gY29udGVudCBpbiBzaGFwZSB0ZW5zb3IgaXMgbmV2ZXIgdXBsb2FkZWQgdG8gR1BVLiBJdCBpcyBhbHdheXMga2VwdCBpbiBDUFUuXG4gICAgLy8gVE9ETzogb3B0aW1pemUgdGhlIGFsZ29yaXRobSAtLSBpbiBzb21lIGNhc2VzLCBpZiB0aGUgbGFzdCB0d28gZGltcyBhcmVcbiAgICAvLyB0aGUgc2FtZSBiZXR3ZWVuIGlucHV0IHNoYXBlIGFuZCBvdXRwdXQgc2hhcGUsIHRoZSBwYWNrZWQgcmVzaGFwZSBjYW4gYmVcbiAgICAvLyB0cmVhdGVkIGFzIG5vLW9wLlxuICAgIC8vIFRPRE86IHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBhIGJpdCBjb21wbGljYXRlZCBkdWUgdG8gdGhlIGZhY3QgdGVuc29yIHNoYXBlIGlzXG4gICAgLy8gaW1tdXRhYmxlIG9uY2UgdGhlIHRlbnNvciBpcyBjcmVhdGVkLCBwbHVzIHRoZSB0ZW5zb3Igc2hhcGUgaGFzIGEgMS10by0xXG4gICAgLy8gbWFwcGluZyB3aXRoIHRleHR1cmUgbGF5b3V0LiBJbiB0aGUgZnV0dXJlLCB3ZSBtYXkgY29uc2lkZXIgcmVsYXhpbmcgdGhpc1xuICAgIC8vIGFzc3VtcHRpb24uXG5cbiAgICBjb25zdCBvcmlnaW5JbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgdGhpcy5pbnB1dFNoYXBlM0QgPSBwcm9jZXNzRGltczNEKGlucHV0c1swXS5kaW1zKTtcbiAgICBsZXQgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQ7XG4gICAgaW5wdXRMYXlvdXQgPSBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDQsIHRydWUsIG9yaWdpbklucHV0U2hhcGUsIHRydWUpO1xuICAgIGlmIChvcmlnaW5JbnB1dFNoYXBlLmxlbmd0aCAhPT0gMykge1xuICAgICAgY29uc3Qgb3JpZ2luYWxJbnB1dExheW91dCA9IGlucHV0TGF5b3V0O1xuICAgICAgLy8gaWYgb3JpZ2luU2hhcGUgaXMgbm90IGEgM0Qgc2hhcGUsIGNyZWF0ZSB0ZXh0dXJlIGxheW91dCBmcm9tIHRoZSBwcm9jZXNzZWQgc2hhcGUuXG4gICAgICBpbnB1dExheW91dCA9IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShcbiAgICAgICAgICB0aGlzLmlucHV0U2hhcGUzRCwgNCwgdGhpcy5pbnB1dFNoYXBlM0QsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSk7XG4gICAgICAvLyBpZiB0aGUgcHJvY2Vzc2VkIGlucHV0IHNoYXBlIHByb2R1Y2VzIHRleHR1cmUgbGF5b3V0IGRpZmZlcm50IGZyb20gdGhlIG9yaWdpbmFsXG4gICAgICAvLyBvbmUsIHRoZSBydW4gZGF0YSBoYXMgdG8gdXNlIHRoZSBwcm9jZXNzZWQgKDNEKSBpbnB1dCBzaGFwZSBsYXRlci5cbiAgICAgIHRoaXMubmVlZFNxdWVlemVJbnB1dERhdGEgPVxuICAgICAgICAgIChpbnB1dExheW91dC5oZWlnaHQgIT09IG9yaWdpbmFsSW5wdXRMYXlvdXQuaGVpZ2h0KSB8fCAoaW5wdXRMYXlvdXQud2lkdGggIT09IG9yaWdpbmFsSW5wdXRMYXlvdXQud2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBTaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKG9yaWdpbklucHV0U2hhcGUsIGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRPdXRwdXRTaGFwZSA9IHByb2Nlc3NEaW1zM0QodGhpcy5vdXRwdXRTaGFwZSk7XG5cbiAgICB0aGlzLm91dHB1dExheW91dCA9IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShcbiAgICAgICAgc3F1ZWV6ZWRPdXRwdXRTaGFwZSwgNCwgc3F1ZWV6ZWRPdXRwdXRTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KTtcblxuICAgIGxldCBtYWluTG9vcCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBsZXQgb3V0cHV0Q29vcmRzID0gJyc7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSByYzsnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueik7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55LCByYy56KzEpOyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSsxLCByYy56KzEpOyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgJHtvdXRwdXRDb29yZHN9XG4gICAgICAgICR7aSA+IDAgPyAnaWYob3V0cHV0Q29vcmRzLnkgPCByb3dzICYmIG91dHB1dENvb3Jkcy56IDwgY29scyl7JyA6ICcnfVxuICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IGdldEZsYXR0ZW5lZEluZGV4KG91dHB1dENvb3Jkcyk7XG5cbiAgICAgICAgICBpdmVjMyBpbnB1dFJDID0gaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoZmxhdHRlbmVkSW5kZXgpO1xuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xuXG4gICAgICAgICAgcmVzdWx0WyR7aX1dID0gZ2V0Q2hhbm5lbChnZXRBKGlucHV0UkMueCwgaW5wdXRSQy55LCBpbnB1dFJDLnopLCBpbm5lckRpbXMpO1xuXG4gICAgICAgICR7aSA+IDAgPyAnfScgOiAnJ31cbiAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7Z2V0UmVzaGFwZWRJbnB1dENvb3Jkcyh0aGlzLmlucHV0U2hhcGUzRCl9XG4gICAgICAke2dldEZsYXR0ZW5lZEluZGV4RnJvbTNEKHNxdWVlemVkT3V0cHV0U2hhcGUpfVxuICAgICAgJHt1bnBhY2tGcm9tQ2hhbm5lbCgpfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMzIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XG5cbiAgICAgICAgaXZlYzMgb3V0cHV0Q29vcmRzO1xuICAgICAgICBpbnQgcm93cyA9ICR7c3F1ZWV6ZWRPdXRwdXRTaGFwZVsyXX07XG4gICAgICAgIGludCBjb2xzID0gJHtzcXVlZXplZE91dHB1dFNoYXBlWzFdfTtcblxuICAgICAgICAke21haW5Mb29wfVxuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdXZWJHTFJlc2hhcGVQYWNrZWQnLFxuICAgICAgaW5wdXRMYXlvdXRzOiBbaW5wdXRMYXlvdXRdLFxuICAgICAgb3V0cHV0TGF5b3V0OiB0aGlzLm91dHB1dExheW91dCxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGxldCBpbnB1dFREczogW1RleHR1cmVEYXRhXTtcbiAgICBjb25zdCBvcmlnaW5hbElucHV0TGF5b3V0ID0gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdLCAxLCBmYWxzZSwgW10sIGZhbHNlKTtcbiAgICBjb25zdCBvcmlnaW5hbElucHV0VEQgPSBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBvcmlnaW5hbElucHV0TGF5b3V0LCBmYWxzZSk7XG5cbiAgICBpZiAodGhpcy5uZWVkU3F1ZWV6ZUlucHV0RGF0YSkge1xuICAgICAgY29uc3Qgc3F1ZWV6ZWRJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IHtcbiAgICAgICAgY2hhbm5lbHM6IDEsXG4gICAgICAgIGhlaWdodDogb3JpZ2luYWxJbnB1dExheW91dC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBvcmlnaW5hbElucHV0TGF5b3V0LndpZHRoLFxuICAgICAgICBzaGFwZTogdGhpcy5pbnB1dFNoYXBlM0QsXG4gICAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0aGlzLmlucHV0U2hhcGUzRCksXG4gICAgICAgIHVucGFja2VkU2hhcGU6IHRoaXMuaW5wdXRTaGFwZTNELFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNxdWVlemVkSW5wdXRURCA9XG4gICAgICAgICAgaGFuZGxlci5jcmVhdGVTaGFyZWRUZXh0dXJlRGF0YShzcXVlZXplZElucHV0TGF5b3V0LCBpbnB1dHNbMF0udHlwZSwgb3JpZ2luYWxJbnB1dFRELnRleHR1cmUpO1xuICAgICAgaW5wdXRURHMgPSBbc3F1ZWV6ZWRJbnB1dFREXTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dFREcyA9IFtvcmlnaW5hbElucHV0VERdO1xuICAgIH1cbiAgICBsZXQgb3V0cHV0TGF5b3V0ID0gdGhpcy5vdXRwdXRMYXlvdXQ7XG4gICAgLy8gVXNlIG9yaWdpbmFsIG91dHB1dCBzaGFwZSBmb3IgcnVuRGF0YSBvdXRwdXQgbGF5b3V0LlxuICAgIG91dHB1dExheW91dC5zaGFwZSA9IHRoaXMub3V0cHV0U2hhcGU7XG4gICAgb3V0cHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSB0aGlzLm91dHB1dFNoYXBlO1xuICAgIGlmIChvdXRwdXRMYXlvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0cHV0TGF5b3V0ID0gaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKFxuICAgICAgICAgIHRoaXMub3V0cHV0U2hhcGUsIDQsIHRoaXMub3V0cHV0U2hhcGUsIHtpc1BhY2tlZDogdHJ1ZSwgcmV2ZXJzZVdIOiB0cnVlfSk7XG4gICAgfVxuICAgIC8vIHJldHVybiBydW4gZGF0YSBmb3IgcmVzaGFwZS4gSGVyZSwgd2UgdXNlIHRoZSBvcmlnaW5hbCBjYWxjdWxhdGUgb3V0cHV0TGF5b3V0IHRvIGNyZWF0ZSB0aGUgcmVhbCBvdXRwdXQgbGF5b3V0LlxuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQob3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHByaXZhdGUgaW5wdXRTaGFwZTNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHByaXZhdGUgbmVlZFNxdWVlemVJbnB1dERhdGEgPSBmYWxzZTtcbiAgcHJpdmF0ZSBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQ7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NEaW1zM0Qoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IG51bWJlcltdfFRlbnNvci5JbnRlZ2VyVHlwZSk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gWzEsIDEsIDFdO1xuICB9XG4gIC8vIFRPRE86IHNxdWVlemUgb3RoZXIgc2hhcGVzIHRvIDJEIGNhc2VcbiAgY29uc3QgYmF0Y2hEaW1zID0gc2hhcGUubGVuZ3RoID49IDMgPyBzaGFwZS5zbGljZSgwLCBzaGFwZS5sZW5ndGggLSAyKSA6IFsxXTtcbiAgbGV0IGJhdGNoID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaERpbXMubGVuZ3RoOyArK2kpIHtcbiAgICBiYXRjaCAqPSBiYXRjaERpbXNbaV07XG4gIH1cbiAgcmV0dXJuIFtiYXRjaCwgc2hhcGUubGVuZ3RoID4gMSA/IHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdIDogMSwgc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV1dO1xufVxuZnVuY3Rpb24gZ2V0UmVzaGFwZWRJbnB1dENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG4gIGNvbnN0IGNvb3JkcyA9IFsnYicsICdyJywgJ2MnXTtcbiAgY29uc3QgaW5kZXggPSAnaW5kZXgnO1xuICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID0gc3RyaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzW2ldfSA9ICR7aW5kZXh9IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUyID0gaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgaW50ICR7Y29vcmRzW2kgKyAxXX0gPSAke2luZGV4fSAtICR7Y29vcmRzW2ldfSAqICR7c3RyaWRlfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1tpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICByZXR1cm4gYFxuICAgIGl2ZWMzIGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGludCBpbmRleCkge1xuICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoc2hhcGUpO1xuXG4gIHJldHVybiBgXG4gIGludCBnZXRGbGF0dGVuZWRJbmRleChpdmVjMyBjb29yZHMpIHtcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcbiAgICByZXR1cm4gY29vcmRzLnggKiAke3N0cmlkZXNbMF19ICsgY29vcmRzLnogKiAke3N0cmlkZXNbMV19ICsgY29vcmRzLnk7XG4gIH1cbmA7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtSZXNoYXBlfSBmcm9tICcuLi8uLi8uLi9vcHMvcmVzaGFwZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1RleHR1cmVMYXlvdXR9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0UGFja2VkU2hhcGV9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7V2ViR0xSZXNoYXBlUGFja2VkfSBmcm9tICcuL3Jlc2hhcGUtcGFja2VkJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMUmVzaGFwZSBleHRlbmRzIFJlc2hhcGUge1xuICBwYWNrZWRJbXBsOiBXZWJHTFJlc2hhcGVQYWNrZWQ7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYWNrZWRJbXBsID0gbmV3IFdlYkdMUmVzaGFwZVBhY2tlZCgpO1xuICB9XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrKSB7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcy5wYWNrZWRJbXBsLCBpbnB1dHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNoYXBlZERpbXMgPSBTaGFwZVV0aWwuY2FsY3VsYXRlUmVzaGFwZWREaW1zKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uaW50ZWdlckRhdGEpO1xuICAgICAgY29uc3QgcmVzaGFwZWRUZW5zb3IgPSByZXNoYXBlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgcmVzaGFwZWREaW1zKTtcbiAgICAgIHJldHVybiBbcmVzaGFwZWRUZW5zb3JdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzaGFwZShcbiAgICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIHJlc2hhcGVkRGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3Ige1xuICBjb25zdCBpbnB1dFREID0gaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0KTtcbiAgbGV0IHBhY2tlZFNoYXBlID0gcmVzaGFwZWREaW1zO1xuICBpZiAoaW5wdXRURC5jaGFubmVscyA9PT0gNCkge1xuICAgIHBhY2tlZFNoYXBlID0gZ2V0UGFja2VkU2hhcGUocmVzaGFwZWREaW1zKTtcbiAgfVxuICBjb25zdCBuZXdUZXh0dXJlTGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0ge1xuICAgIGNoYW5uZWxzOiBpbnB1dFRELmNoYW5uZWxzLFxuICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgd2lkdGg6IGlucHV0VEQud2lkdGgsXG4gICAgLy8gaGFuZGxlIHJlc2hhcGluZyBpbnRvIHNjYWxhciBUZW5zb3JzXG4gICAgc2hhcGU6IHBhY2tlZFNoYXBlLmxlbmd0aCAhPT0gMCA/IHBhY2tlZFNoYXBlIDogWzFdLFxuICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhwYWNrZWRTaGFwZSksXG4gICAgdW5wYWNrZWRTaGFwZTogcmVzaGFwZWREaW1zLFxuICB9O1xuXG4gIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVTaGFyZWRUZXh0dXJlRGF0YShuZXdUZXh0dXJlTGF5b3V0LCBpbnB1dC50eXBlLCBpbnB1dFRELnRleHR1cmUpO1xuICByZXR1cm4gbmV3VGV4dHVyZURhdGEudGVuc29yO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VXBzYW1wbGV9IGZyb20gJy4uLy4uLy4uL29wcy91cHNhbXBsZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbCwgR2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBSdW5EYXRhLCBUZXh0dXJlTGF5b3V0LCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7dW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFJlc2l6ZVBhY2tlZCBleHRlbmRzIFVwc2FtcGxlIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlucHV0TGF5b3V0ID0gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdLCA0LCB0cnVlLCBpbnB1dHNbMF0uZGltcywgdHJ1ZSk7XG5cbiAgICBjb25zdCBbcm9pLCBzY2FsZXMsIG91dHB1dFNoYXBlXSA9IHRoaXMucHJlcGFyZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID1cbiAgICAgICAgaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlLCA0LCBvdXRwdXRTaGFwZSwge2lzUGFja2VkOiB0cnVlLCByZXZlcnNlV0g6IHRydWV9KTtcblxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gY3JlYXRlUmVzaXplUHJvZ3JhbUluZm8oXG4gICAgICAgIGdsc2wsIHRoaXMubW9kZSwgaW5wdXRMYXlvdXQsIG91dHB1dExheW91dCwgc2NhbGVzLCByb2ksIHRoaXMudXNlRXh0cmFwb2xhdGlvbiwgdGhpcy5leHRyYXBvbGF0aW9uVmFsdWUsXG4gICAgICAgIHRoaXMuY3ViaWNDb2VmZmljaWVudEEsIHRoaXMuZXhjbHVkZU91dHNpZGUsIHRoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpO1xuICB9XG5cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VEQgPVxuICAgICAgICBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDEsIGZhbHNlLCBbXSwgdHJ1ZSkpO1xuICAgIGNvbnN0IG91dHB1dFREID0gaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFRELnRlbnNvci50eXBlKTtcbiAgICByZXR1cm4ge2lucHV0VGV4dHVyZURhdGFzOiBbaW5wdXRURF0sIG91dHB1dFRleHR1cmVEYXRhOiBvdXRwdXRURCwgdW5pZm9ybURhdGE6IHt9fTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcnRpZmFjdHM6IEFydGlmYWN0W107XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvKFxuICAgIGdsc2w6IEdsc2wsIG1vZGU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG91dHB1dExheW91dDogVGV4dHVyZUxheW91dCwgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICByb2k6IHJlYWRvbmx5IG51bWJlcltdLCBleHRyYXBvbGF0aW9uRW5hYmxlZDogYm9vbGVhbiwgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsIGN1YmljQ29lZmZpY2llbnRBOiBudW1iZXIsXG4gICAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW4sIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBzdHJpbmcpOiBQcm9ncmFtSW5mbyB7XG4gIGNvbnN0IGlzU2FtZSA9IHNjYWxlcy5ldmVyeShzID0+IHMgPT09IDEpICYmIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlICE9PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgaWYgKGlzU2FtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dF0sXG4gICAgICBvdXRwdXRMYXlvdXQsXG4gICAgICBzYW1wbGVyczogWydYJ10sXG4gICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgc2hhZGVyU291cmNlOiBgdm9pZCBtYWluKCkge1xuICAgICAgdmVjNCB2ID0gJHtnbHNsLnRleHR1cmUyRH0oWCwgVGV4Q29vcmRzKTtcbiAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdjtcbiAgICB9YFxuICAgIH07XG4gIH1cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgY29uc3QgZGltID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICBpZiAoZGltIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2RpbX1gKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dEhlaWdodCA9IG91dHB1dFNoYXBlW2RpbSAtIDJdO1xuICBjb25zdCBvdXRwdXRXaWR0aCA9IG91dHB1dFNoYXBlW2RpbSAtIDFdO1xuXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICBpZiAoZGltICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgbWF0Y2ggaW5wdXQgJHtpbnB1dFNoYXBlLmxlbmd0aH0sIGJ1dCBnb3QgJHtkaW19YCk7XG4gIH1cbiAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dFNoYXBlW2RpbSAtIDJdO1xuICBjb25zdCBpbnB1dFdpZHRoID0gaW5wdXRTaGFwZVtkaW0gLSAxXTtcblxuICBjb25zdCBzY2FsZXNIZWlnaHQgPSBzY2FsZXNbZGltIC0gMl07XG4gIGNvbnN0IHNjYWxlc1dpZHRoID0gc2NhbGVzW2RpbSAtIDFdO1xuXG4gIGxldCBnZXRTb3VyY2VGcmFjSW5kZXggPSAnJztcblxuICBpZiAobW9kZSAhPT0gJ2xpbmVhcicpIHtcbiAgICAvLyBUT0RPOiBzdXBwb3J0IG90aGVyIG1vZGVzXG4gICAgdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBtb2RlOiAnJHttb2RlfSdgKTtcbiAgfVxuICBzd2l0Y2ggKGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKSB7XG4gICAgY2FzZSAnYXN5bW1ldHJpYyc6XG4gICAgICBnZXRTb3VyY2VGcmFjSW5kZXggPSBgXG4gICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcyl7XG4gICAgICAgICAgcmV0dXJuIHZlYzQoY29vcmRzKSAvIHNjYWxlV0hXSDtcbiAgICAgICAgfVxuICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdoYWxmX3BpeGVsJzpcbiAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKXtcbiAgICAgICAgICByZXR1cm4gKHZlYzQoY29vcmRzKSArIDAuNSkgLyBzY2FsZVdIV0ggLSAwLjU7XG4gICAgICAgIH1cbiAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWxpZ25fY29ybmVycyc6XG4gICAgICBnZXRTb3VyY2VGcmFjSW5kZXggPSBgXG4gICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcyl7XG4gICAgICAgICAgdmVjNCByZXNpemVkID0gdmVjNCgke291dHB1dFdpZHRofS4wIC0gMS4wLCAke291dHB1dEhlaWdodH0uMCAtIDEuMCwgJHtvdXRwdXRXaWR0aH0uMCAtIDEuMCwgJHtcbiAgICAgICAgICBvdXRwdXRIZWlnaHR9LjAgLSAxLjApO1xuICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7aW5wdXRXaWR0aH0uMCAtIDEuMCwgJHtpbnB1dEhlaWdodH0uMCAtIDEuMCwgJHtpbnB1dFdpZHRofS4wIC0gMS4wLCAke1xuICAgICAgICAgIGlucHV0SGVpZ2h0fS4wIC0gMS4wKTtcbiAgICAgICAgICB2ZWM0IG5ld19zY2FsZSA9IG9yaWdpbmFsIC8gcmVzaXplZDtcbiAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFRPRE86c3VwcG9ydGluZyBvdGhlciBjb29yZGluYXRlVHJhbnNmb3JtTW9kZXNcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVzaXplIChwYWNrZWQpIGRvZXMgbm90IHN1cHBvcnQgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6ICcke2Nvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKTtcbiAgfVxuXG4gIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoZGltKTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IHNoYWRlciA9IGBcbiAgICAgICAgY29uc3QgdmVjMiBpbnB1dFdIID0gdmVjMigke2lucHV0SGVpZ2h0fS4wLCAke2lucHV0V2lkdGh9LjApO1xuICAgICAgICBjb25zdCB2ZWM0IHNjYWxlV0hXSCA9IHZlYzQoJHtzY2FsZXNIZWlnaHR9LjAsICR7c2NhbGVzV2lkdGh9LjAsICR7c2NhbGVzSGVpZ2h0fS4wLCAke3NjYWxlc1dpZHRofS4wKTtcbiAgICAgICAgJHt1bnBhY2tDaGFubmVsfVxuICAgICAgICAke2dldFNvdXJjZUZyYWNJbmRleH1cbiAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xuICAgICAgICB9XG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XG4gICAgICAgICAgaW50IGRlcHRoID0gcmNbMV07XG5cbiAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gaXZlYzQocmMud3osIHJjLncgKyAxLCByYy56ICsgMSk7XG5cbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxuICAgICAgICAgIHZlYzQgc291cmNlRnJhYyA9IGdldFNvdXJjZUZyYWNJbmRleChjb29yZHMpO1xuXG4gICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXG4gICAgICAgICAgaXZlYzQgeDAwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHkpKSk7XG4gICAgICAgICAgaXZlYzQgeDAxID0gaXZlYzQobWF4KHNvdXJjZUZyYWMueHcsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMueHcpKSk7XG4gICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XG4gICAgICAgICAgaXZlYzQgeDExID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuencsIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuencpKSk7XG5cbiAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtvdXRwdXRIZWlnaHQgLSAxfTtcbiAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtvdXRwdXRXaWR0aCAtIDF9O1xuXG4gICAgICAgICAgLy8gcGFjayB4MDAsIHgwMSwgeDEwLCB4MTEncyB0b3AtbGVmdCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC55KSxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC55KVxuICAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLnkpIDogMC4wKTtcblxuICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgdG9wLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC53KSxcbiAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLncpXG4gICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXG4gICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC53KVxuICAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xuICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLncpIDogMC4wKTtcblxuICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLWxlZnQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXG4gICAgICAgICAgdmVjNCBib3R0b21MZWZ0ID0gdmVjNChcbiAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAueSksXG4gICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS55KVxuICAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAueSlcbiAgICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XG5cbiAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcbiAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcbiAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAudyksXG4gICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KVxuICAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxuICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAudylcbiAgICAgICAgICAgICAgICAgICAgICA6IDAuMCxcbiAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cbiAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS53KSA6IDAuMCk7XG5cbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGludGVycG9sYXRpb24gZnJhY3Rpb24gb24gdSBhbmQgdiBkaXJlY3Rpb25cbiAgICAgICAgICB2ZWM0IGZyYWMgPSB2ZWM0KHNvdXJjZUZyYWMpIC0gZmxvb3Ioc291cmNlRnJhYyk7XG4gICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XG5cbiAgICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xuICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XG4gICAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgY2xhbXBGcmFjLnh4enopO1xuXG4gICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dExheW91dHM6IFtpbnB1dExheW91dF0sXG4gICAgb3V0cHV0TGF5b3V0LFxuICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICBzaGFkZXJTb3VyY2U6IHNoYWRlcixcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIGV4cGVjdFBhY2tlZElucHV0czogdHJ1ZSxcbiAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlLFxuICB9O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2hhcGV9IGZyb20gJy4uLy4uLy4uL29wcy9zaGFwZSc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cblxuZXhwb3J0IGNsYXNzIFdlYkdMU2hhcGUgZXh0ZW5kcyBTaGFwZSB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIFtuZXcgVGVuc29yKFtpbnB1dHNbMF0uZGltcy5sZW5ndGhdLCAnaW50MzInLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbmV3IEludDMyQXJyYXkoaW5wdXRzWzBdLmRpbXMpKV07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1NsaWNlLCBTbGljZVYxMH0gZnJvbSAnLi4vLi4vLi4vb3BzL3NsaWNlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMU2xpY2UgZXh0ZW5kcyBTbGljZSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG5cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIHJldHVybiBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHNbMF0sIHRoaXMuc3RhcnRzLCB0aGlzLmVuZHMsIHRoaXMuYXhlcyk7XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIHJldHVybiBjcmVhdGVSdW5EYXRhKGhhbmRsZXIsIHByb2dyYW1JbmZvLCBpbnB1dHMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFNsaWNlVjEwIGV4dGVuZHMgU2xpY2VWMTAgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuXG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBpZiAoIWhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1sxXS5kYXRhSWQpIHx8ICFoYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMl0uZGF0YUlkKSB8fFxuICAgICAgICAoaW5wdXRzLmxlbmd0aCA+PSA0ICYmICFoYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbM10uZGF0YUlkKSkgfHxcbiAgICAgICAgKGlucHV0cy5sZW5ndGggPj0gNSAmJiAhaGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzRdLmRhdGFJZCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPj0gNSAmJiBpbnB1dHNbNF0uaW50ZWdlckRhdGEuc29tZSgoaTogbnVtYmVyKSA9PiBpICE9PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2UnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRzID0gQXJyYXkuZnJvbShpbnB1dHNbMV0uaW50ZWdlckRhdGEpO1xuICAgIGNvbnN0IGVuZHMgPSBBcnJheS5mcm9tKGlucHV0c1syXS5pbnRlZ2VyRGF0YSk7XG4gICAgY29uc3QgYXhlcyA9IGlucHV0cy5sZW5ndGggPj0gNCA/IEFycmF5LmZyb20oaW5wdXRzWzNdLmludGVnZXJEYXRhKSA6IFtdO1xuXG4gICAgcmV0dXJuIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0c1swXSwgc3RhcnRzLCBlbmRzLCBheGVzKTtcbiAgfVxuXG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICByZXR1cm4gY3JlYXRlUnVuRGF0YShoYW5kbGVyLCBwcm9ncmFtSW5mbywgaW5wdXRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtSW5mbyhcbiAgICBoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHg6IFRlbnNvciwgc3RhcnRzOiByZWFkb25seSBudW1iZXJbXSwgZW5kczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtSW5mbyB7XG4gIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGF4ZXMgPSB4LmRpbXMuc2xpY2UoMCkubWFwKCh2YWwsIGluZCkgPT4gaW5kKTtcbiAgfVxuICBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXhlcywgeC5kaW1zLmxlbmd0aCk7XG4gIHN0YXJ0cyA9IHN0YXJ0cy5tYXAoKHN0YXJ0LCBpbmQpID0+IHtcbiAgICBpZiAoc3RhcnQgPiB4LmRpbXNbYXhlc1tpbmRdXSAtIDEpIHtcbiAgICAgIHJldHVybiB4LmRpbXNbYXhlc1tpbmRdXTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHN0YXJ0LCB4LmRpbXNbYXhlc1tpbmRdXSk7XG4gIH0pO1xuICBlbmRzID0gZW5kcy5tYXAoKGVuZCwgaW5kKSA9PiB7XG4gICAgaWYgKGVuZCA+IHguZGltc1theGVzW2luZF1dIC0gMSkge1xuICAgICAgcmV0dXJuIHguZGltc1theGVzW2luZF1dO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoZW5kLCB4LmRpbXNbYXhlc1tpbmRdXSk7XG4gIH0pO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0geC5kaW1zLnNsaWNlKCk7XG5cbiAgY29uc3Qgc2xpY2VPcHM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFNoYXBlW2F4ZXNbaV1dID0gZW5kc1tpXSAtIHN0YXJ0c1tpXTtcbiAgICBpZiAoc3RhcnRzW2ldID4gMCkge1xuICAgICAgc2xpY2VPcHMucHVzaChgb3V0cHV0SWR4WyR7YXhlc1tpXX1dICs9ICR7c3RhcnRzW2ldfTtgKTtcbiAgICB9ICAvLyBlbHNlIHsgc2xpY2VPcHMucHVzaChgb3V0cHV0SWR4WyR7YXhlc1tpXX1dICs9IDA7YCk7IH1cbiAgfVxuXG4gIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3Jhbmt9XSkge1xuICAgICAgICAke3NsaWNlT3BzLmpvaW4oJ1xcbiAgICAgICcpfVxuICAgICAgICByZXR1cm4gX0Eob3V0cHV0SWR4KTtcbiAgICAgIH1gO1xuICByZXR1cm4ge1xuICAgIGlucHV0TGF5b3V0czogW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHgpXSxcbiAgICBvdXRwdXRMYXlvdXQ6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgc2FtcGxlcnM6IFsnQSddLFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0pXTtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgIHVuaWZvcm1EYXRhOiB7fVxuICB9O1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U29mdG1heH0gZnJvbSAnLi4vLi4vLi4vb3BzL3NvZnRtYXgnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUnVuRGF0YSwgVGV4dHVyZUxheW91dH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTb2Z0bWF4IGV4dGVuZHMgU29mdG1heCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBpZiAoIXRoaXMuYXJ0aWZhY3RzKSB7XG4gICAgICB0aGlzLmFydGlmYWN0cyA9IFtdO1xuICAgICAgY29uc3QgcHJvZ3JhbUluZm9zID0gdGhpcy5jcmVhdGVQcm9ncmFtSW5mb3MoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzKTtcbiAgICAgIHByb2dyYW1JbmZvcy5mb3JFYWNoKChwaSkgPT4ge1xuICAgICAgICBjb25zdCBhcnRpZmFjdCA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChwaSk7XG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzLnB1c2goYXJ0aWZhY3QpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcnVuRGF0YXMgPSB0aGlzLmNyZWF0ZVJ1bkRhdGFzKGluZmVyZW5jZUhhbmRsZXIsIHRoaXMuYXJ0aWZhY3RzLm1hcChhID0+IGEucHJvZ3JhbUluZm8pLCBpbnB1dHMpO1xuICAgIHJ1bkRhdGFzLmZvckVhY2goKHYsIGkpID0+IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5ydW4odGhpcy5hcnRpZmFjdHNbaV0sIHYpKTtcbiAgICAvLyByZXR1cm4gb25seSB0aGUgbGFzdCBvdXRwdXRcbiAgICByZXR1cm4gW3J1bkRhdGFzW3J1bkRhdGFzLmxlbmd0aCAtIDFdLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvcl07XG4gIH1cbiAgY3JlYXRlU29mdE1heFByb2dyYW1JbmZvKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBOOiBudW1iZXIsIEQ6IG51bWJlcixcbiAgICAgIG1heEVsZW1lbnRQZXJMb2dpY2FsUm93OiBUZXh0dXJlTGF5b3V0LCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvdzogVGV4dHVyZUxheW91dCk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGlucHV0TGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKGlucHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHRleHR1cmVXaWR0aCA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleHR1cmVIZWlnaHQgPSBpbnB1dExheW91dC5oZWlnaHQ7XG5cbiAgICBpZiAoTiA8IDEgfHwgRCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICB9XG5cbiAgICBpZiAobWF4RWxlbWVudFBlckxvZ2ljYWxSb3cuc2hhcGUubGVuZ3RoICE9PSAxIHx8IG5vcm1hbGl6YXRpb25QZXJMb2dpY2FsUm93LnNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgICB9XG5cbiAgICBpZiAobWF4RWxlbWVudFBlckxvZ2ljYWxSb3cuc2hhcGVbMF0gIT09IE4gfHwgbm9ybWFsaXphdGlvblBlckxvZ2ljYWxSb3cuc2hhcGVbMF0gIT09IE4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhcGUgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG5cbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxuICAgICAgaW50IG9mZnNldCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHt0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KTtcblxuICAgICAgLy9kZXRlcm1pbmUgdGhlIGxvZ2ljYWwgcm93IGZvciB0aGlzIGluZGV4XG4gICAgICBpbnQgbG9naWNhbF9yb3dfaW5kZXhbMV07XG4gICAgICBsb2dpY2FsX3Jvd19pbmRleFswXSA9IG9mZnNldCAvICR7RH07XG5cbiAgICAgIGZsb2F0IG5vcm1fZmFjdG9yID0gX05vcm0obG9naWNhbF9yb3dfaW5kZXgpO1xuXG4gICAgICAvLyBhdm9pZCBwb3NzaWJsZSBkaXZpc2lvbiBieSAwXG4gICAgICAvLyBpZiBub3JtX2ZhY29yIGlzIDAsIGFsbCBlbGVtZW50cyBhcmUgemVyb1xuICAgICAgLy8gaWYgc28sIHJldHVybiAwXG4gICAgICBpZihub3JtX2ZhY3RvciA9PSAwLjApXG4gICAgICAgIHJldHVybiAwLjA7XG5cbiAgICAgIHJldHVybiBleHAoX0EoaW5kaWNlcykgLSBfTWF4KGxvZ2ljYWxfcm93X2luZGV4KSkgLyBub3JtX2ZhY3RvcjtcbiAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbaW5wdXRMYXlvdXQsIG1heEVsZW1lbnRQZXJMb2dpY2FsUm93LCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvd10sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJywgJ01heCcsICdOb3JtJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICBuYW1lOiAnU29mdE1heCcsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIG5vcm1hbGl6YXRpb24gZmFjdG9yIGZvciBlYWNoIG9mIHRoZSAnTicgcm93c1xuICAgKi9cbiAgY3JlYXRlQ29tcHV0U2NhbGVQcm9ncmFtSW5mbyhcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICAgIGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgeDogVGVuc29yLCBOOiBudW1iZXIsIEQ6IG51bWJlciwgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3c6IFRleHR1cmVMYXlvdXQsXG4gICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgY29uc3QgeGxheW91dCA9IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh4LmRpbXMuc2xpY2UoKSk7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCB0ZXh0dXJlV2lkdGggPSB4bGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleHR1cmVIZWlnaHQgPSB4bGF5b3V0LmhlaWdodDtcblxuICAgIGlmIChOIDwgMSB8fCBEIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICAgIH1cblxuICAgIGlmIChvdXRwdXRTaGFwZVswXSAhPT0gTikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudCcpO1xuICAgIH1cblxuICAgIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5zaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93LnNoYXBlWzBdICE9PSBOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcblxuICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke0R9O1xuXG4gICAgICBmbG9hdCBub3JtX2ZhY3RvciA9IDAuMDtcbiAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XG4gICAgICBmb3IoaW50IGk9MDsgaTwke0R9OyArK2kpXG4gICAgICB7XG4gICAgICAgIG5vcm1fZmFjdG9yICs9IGV4cChnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ICsgaSwgJHtcbiAgICAgICAgdGV4dHVyZVdpZHRofSwgJHt0ZXh0dXJlSGVpZ2h0fSkpKSAtIG1heCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub3JtX2ZhY3RvcjtcbiAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbeGxheW91dCwgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3ddLFxuICAgICAgb3V0cHV0TGF5b3V0OiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnQScsICdNYXgnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIG5hbWU6ICdDb21wdXRTY2FsZScsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdGV4dHVyZSB0aGF0IGNvbnRhaW5zIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGVhY2ggb2YgdGhlICdOJyByb3dzXG4gICAqL1xuICBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8oXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICBpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHg6IFRlbnNvciwgTjogbnVtYmVyLCBEOiBudW1iZXIsIG91dHB1dFNoYXBlOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCB4bGF5b3V0ID0gaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHguZGltcy5zbGljZSgpKTtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHRleHR1cmVXaWR0aCA9IHhsYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IHhsYXlvdXQuaGVpZ2h0O1xuXG4gICAgaWYgKE4gPCAxIHx8IEQgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dFNoYXBlWzBdICE9PSBOKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuXG4gICAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke0R9O1xuXG4gICAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHt0ZXh0dXJlV2lkdGh9LCAke1xuICAgICAgICB0ZXh0dXJlSGVpZ2h0fSApKSk7XG4gICAgICAgICAgZm9yKGludCBpPTE7IGk8JHtEfTsgKytpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZsb2F0IGN1cnJlbnQgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQSwgb2Zmc2V0VG9Db29yZHMobG9naWNhbF9yb3dfc3RhcnRfb2Zmc2V0ICsgaSwgJHtcbiAgICAgICAgdGV4dHVyZVdpZHRofSwgJHt0ZXh0dXJlSGVpZ2h0fSkpKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnQgPiBtYXgpXG4gICAgICAgICAgICAgIG1heCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogW3hsYXlvdXRdLFxuICAgICAgb3V0cHV0TGF5b3V0OiBpbmZlcmVuY2VIYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnQSddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgbmFtZTogJ0NvbXB1dGVNYXgnLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm9zKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvW10ge1xuICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyh0aGlzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCBOID0gU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihpbnB1dFNoYXBlLCBheGlzKTtcbiAgICBjb25zdCBEID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuICAgIGNvbnN0IGNvbXB1dGVNYXhQcm9ncmFtSW5mbyA9IHRoaXMuY3JlYXRlQ29tcHV0ZU1heFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgTiwgRCwgW05dKTtcbiAgICBjb25zdCBjb21wdXRlU2NhbGVQcm9ncmFtSW5mbyA9XG4gICAgICAgIHRoaXMuY3JlYXRlQ29tcHV0U2NhbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIE4sIEQsIGNvbXB1dGVNYXhQcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIFtOXSk7XG4gICAgY29uc3Qgc29mdE1heFByb2dyYW1JbmZvID0gdGhpcy5jcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8oXG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgTiwgRCwgY29tcHV0ZU1heFByb2dyYW1JbmZvLm91dHB1dExheW91dCwgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0KTtcblxuICAgIGNvbnN0IHByb2dyYW1JbmZvczogUHJvZ3JhbUluZm9bXSA9IFtjb21wdXRlTWF4UHJvZ3JhbUluZm8sIGNvbXB1dGVTY2FsZVByb2dyYW1JbmZvLCBzb2Z0TWF4UHJvZ3JhbUluZm9dO1xuICAgIHJldHVybiBwcm9ncmFtSW5mb3M7XG4gIH1cbiAgY3JlYXRlUnVuRGF0YXMoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mb3M6IFByb2dyYW1JbmZvW10sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhW10ge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLnR5cGU7XG4gICAgY29uc3QgaW5wdXRURCA9IGluZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbMF0sIHByb2dyYW1JbmZvc1swXS5pbnB1dExheW91dHNbMF0pO1xuICAgIGNvbnN0IHJ1bkRhdGFzOiBSdW5EYXRhW10gPSBbXTtcbiAgICBydW5EYXRhcy5wdXNoKHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBbaW5wdXRURF0sXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaW5mZXJlbmNlSGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm9zWzBdLm91dHB1dExheW91dCwgZGF0YVR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwcm9ncmFtSW5mb3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJ1bkRhdGFzLnB1c2goe1xuICAgICAgICBpbnB1dFRleHR1cmVEYXRhczogWy4uLnJ1bkRhdGFzW2kgLSAxXS5pbnB1dFRleHR1cmVEYXRhcywgcnVuRGF0YXNbaSAtIDFdLm91dHB1dFRleHR1cmVEYXRhXSxcbiAgICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvc1tpXS5vdXRwdXRMYXlvdXQsIGRhdGFUeXBlKSxcbiAgICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bkRhdGFzO1xuICB9XG4gIHByb3RlY3RlZCBhcnRpZmFjdHM6IEFydGlmYWN0W107XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTcGxpdH0gZnJvbSAnLi4vLi4vLi4vb3BzL3NwbGl0JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWwsIFNwbGl0VXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtBcnRpZmFjdCwgUHJvZ3JhbUluZm8sIFJ1bkRhdGF9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMU3BsaXQgZXh0ZW5kcyBTcGxpdCB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgaWYgKCF0aGlzLmFydGlmYWN0cykge1xuICAgICAgdGhpcy5hcnRpZmFjdHMgPSBbXTtcbiAgICAgIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyh0aGlzLmF4aXMsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gICAgICBjb25zdCBjb3VudCA9IHRoaXMuZ2V0UHJvZ3JhbUNvdW50KGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXhpcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgcHJvZ3JhbUluZm8gPSB0aGlzLmNyZWF0ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgYXhpcywgaSk7XG4gICAgICAgIGNvbnN0IGFydGlmYWN0ID0gaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW1JbmZvKTtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMucHVzaChhcnRpZmFjdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHM6IFRlbnNvcltdID0gW107XG5cbiAgICB0aGlzLmFydGlmYWN0cy5mb3JFYWNoKGFydGlmYWN0ID0+IHtcbiAgICAgIGNvbnN0IHJ1bmRhdGEgPSB0aGlzLmNyZWF0ZVJ1bkRhdGEoaW5mZXJlbmNlSGFuZGxlciwgYXJ0aWZhY3QucHJvZ3JhbUluZm8sIGlucHV0cyk7XG4gICAgICBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBydW5kYXRhKTtcbiAgICAgIHJlc3VsdHMucHVzaChydW5kYXRhLm91dHB1dFRleHR1cmVEYXRhLnRlbnNvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgZ2V0UHJvZ3JhbUNvdW50KGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXhpczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBbLCBvZmZzZXRzXSA9IFNwbGl0VXRpbC5zcGxpdFNoYXBlKGlucHV0c1swXS5kaW1zLCBheGlzLCB0aGlzLnNwbGl0LCB0aGlzLm51bU91dHB1dHMpO1xuICAgIHJldHVybiBvZmZzZXRzLmxlbmd0aDtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF4aXM6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBbc2hhcGVzLCBvZmZzZXRzXSA9IFNwbGl0VXRpbC5zcGxpdFNoYXBlKGlucHV0LmRpbXMsIGF4aXMsIHRoaXMuc3BsaXQsIHRoaXMubnVtT3V0cHV0cyk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0c1tpbmRleF07XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBzaGFwZXNbaW5kZXhdO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbmRpY2VzWyR7YXhpc31dICs9ICR7b2Zmc2V0fTtcbiAgICAgICAgcmV0dXJuIF9BKGluZGljZXMpO1xuICAgICAgfWA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdXZWJHTFNwbGl0JyxcbiAgICAgIGlucHV0TGF5b3V0czogW2luZmVyZW5jZUhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0KV0sXG4gICAgICBvdXRwdXRMYXlvdXQ6IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZShvdXRwdXRTaGFwZSksXG4gICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICBzaGFkZXJTb3VyY2UsXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaW5mZXJlbmNlSGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOlxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxuICBwcm90ZWN0ZWQgYXJ0aWZhY3RzOiBBcnRpZmFjdFtdO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U3F1ZWV6ZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3NxdWVlemUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL3Jlc2hhcGUnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTcXVlZXplIGV4dGVuZHMgU3F1ZWV6ZSB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFNoYXBlVXRpbC5zcXVlZXplU2hhcGUoaW5wdXRzWzBdLmRpbXMsIHRoaXMuYXhlcyk7XG4gICAgcmV0dXJuIFtyZXNoYXBlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgb3V0cHV0RGltcyldO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTdW19IGZyb20gJy4uLy4uLy4uL29wcy9zdW0nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBSdW5EYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFN1bSBleHRlbmRzIFN1bSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IHN1bUxpbmUgPSBpbnB1dHMubWFwKCh2LCBpKSA9PiBgJHtnbHNsLnRleHR1cmUyRH0oWCR7aX0sVGV4Q29vcmRzKWApLmpvaW4oJyArICcpO1xuICAgIGNvbnN0IHNhbXBsZXJzID0gaW5wdXRzLm1hcCgodiwgaSkgPT4gYFgke2l9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0TGF5b3V0czogaW5wdXRzLm1hcCh0ID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KHQpKSxcbiAgICAgIG91dHB1dExheW91dDogaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKSxcbiAgICAgIHNhbXBsZXJzLFxuICAgICAgc2hhZGVyU291cmNlOiBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gJHtzdW1MaW5lfTtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICB9YCxcbiAgICAgIGhhc01haW46IHRydWVcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IGlucHV0cy5tYXAoKHQsIGkpID0+IGhhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YSh0LCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbaV0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGlsZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3RpbGUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xUaWxlIGV4dGVuZHMgVGlsZSBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJ1bih0aGlzLCBpbnB1dHMpO1xuICB9XG5cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGlucHV0U2hhcGUubGVuZ3RoKTsgIC8vIGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG5cbiAgICBjb25zdCB0aWxlT3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbnB1dFNoYXBlW2ldICogaW5wdXRzWzFdLm51bWJlckRhdGFbaV07XG4gICAgICB0aWxlT3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHtpfV0pLCAke2lucHV0U2hhcGVbaV19LikpO2ApO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgIGZsb2F0IHByb2Nlc3MoaW50IG91dHB1dElkeFske3Jhbmt9XSkge1xuICAgICAgaW50IGlucHV0SWR4WyR7cmFua31dO1xuICAgICAgJHt0aWxlT3BzLmpvaW4oJ1xcbicpfVxuICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcbiAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBpbnB1dHMubWFwKHQgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQodCkpLFxuICAgICAgb3V0cHV0TGF5b3V0OiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUpLFxuICAgICAgc2FtcGxlcnM6IFsnQSddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgIH07XG4gIH1cbiAgY3JlYXRlUnVuRGF0YShoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbywgaW5wdXRzOiBUZW5zb3JbXSk6IFJ1bkRhdGEge1xuICAgIGNvbnN0IGlucHV0VERzID0gaW5wdXRzLm1hcCgodCwgaSkgPT4gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKHQsIHByb2dyYW1JbmZvLmlucHV0TGF5b3V0c1tpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhczogaW5wdXRURHMsXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFREc1swXS50ZW5zb3IudHlwZSksXG4gICAgICB1bmlmb3JtRGF0YToge31cbiAgICB9O1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUcmFuc3Bvc2V9IGZyb20gJy4uLy4uLy4uL29wcy90cmFuc3Bvc2UnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge0Z1bmN0aW9uVHlwZSwgR2xzbFBvc2l0aW9uYWxGdW5jdGlvbn0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xUcmFuc3Bvc2UgZXh0ZW5kcyBUcmFuc3Bvc2UgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+KTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHBlcm0gPSB0aGlzLmdldEFkanVzdGVkUGVybShpbnB1dFNoYXBlc1swXSk7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5zb3J0QmFzZWRPblBlcm0oaW5wdXRTaGFwZXNbMF0sIHBlcm0pO1xuICB9XG4gIGNyZWF0ZVByb2dyYW1JbmZvKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFByb2dyYW1JbmZvIHtcbiAgICBjb25zdCBpbnB1dFNoYXBlcyA9IGlucHV0cy5tYXAodCA9PiB0LmRpbXMuc2xpY2UoKSk7XG4gICAgY29uc3QgcGVybSA9IHRoaXMuZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGVzWzBdKTtcbiAgICBjb25zdCB1bnBhY2tlZE91dHB1dFNoYXBlID0gdGhpcy5nZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlcyk7XG4gICAgY29uc3QgcmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICAvLyBBIGRpbXM9WyR7aW5wdXRzWzBdLmRpbXMudG9TdHJpbmcoKX1dXG4gICAgLy8gb3V0IERpbXM9WyR7dW5wYWNrZWRPdXRwdXRTaGFwZS50b1N0cmluZygpfV1cbiAgICAvLyBiYXNlZCBvbiBwZXJtPVske3Blcm0udG9TdHJpbmcoKX1dXG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHt0aGlzLmdldFBlcm1GdW5jdGlvbkJvZHkoJ3Blcm0nLCBwZXJtLCByYW5rKX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IGFbJHtyYW5rfV07XG4gICAgICAgIHBlcm0oYSwgaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBfQShhKTtcbiAgICAgIH1gO1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IGhhbmRsZXIuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSh1bnBhY2tlZE91dHB1dFNoYXBlLCAxLCB1bnBhY2tlZE91dHB1dFNoYXBlKTtcbiAgICByZXR1cm4ge2lucHV0TGF5b3V0czogW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSldLCBvdXRwdXRMYXlvdXQsIHNhbXBsZXJzOiBbJ0EnXSwgc2hhZGVyU291cmNlfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBbaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzWzBdKV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbiAgZ2V0UG9zaXRpb25hbEZ1bmN0aW9uKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRTaGFwZTogbnVtYmVyW10sIG5hbWU/OiBzdHJpbmcpOiBHbHNsUG9zaXRpb25hbEZ1bmN0aW9uIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHRoaXMuZ2V0T3V0cHV0U2hhcGUoW2lucHV0U2hhcGVdKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIG5hbWUgPSAncGVybSc7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgYm9keTogdGhpcy5nZXRQZXJtRnVuY3Rpb25Cb2R5KG5hbWUsIHRoaXMuZ2V0QWRqdXN0ZWRQZXJtKGlucHV0U2hhcGUpLCBvdXRwdXRTaGFwZS5sZW5ndGgpLFxuICAgICAgdHlwZTogRnVuY3Rpb25UeXBlLlBvc2l0aW9uYWwsXG4gICAgICBpbnB1dFNoYXBlLFxuICAgICAgb3V0cHV0U2hhcGVcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gICAgbGV0IHBlcm0gPSB0aGlzLnBlcm07XG4gICAgaWYgKHBlcm0gJiYgcGVybS5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgICBwZXJtID0gWy4uLihpbnB1dFNoYXBlLmtleXMoKSldLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBlcm07XG4gIH1cbiAgcHJvdGVjdGVkIGdldFBlcm1GdW5jdGlvbkJvZHkobmFtZTogc3RyaW5nLCBwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICAgIHJldmVyc2VGdW5jLnB1c2goYHZvaWQgJHtuYW1lfShvdXQgaW50IGFbJHtyYW5rfV0sIGludCBzcmNbJHtyYW5rfV0pIHtgKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgcmV2ZXJzZUZ1bmMucHVzaChgXFx0YVske3Blcm1baV19XT1zcmNbJHtpfV07YCk7XG4gICAgfVxuICAgIHJldmVyc2VGdW5jLnB1c2goJ1xcdH0nKTtcbiAgICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1RleHR1cmVEYXRhLCBUZXh0dXJlTGF5b3V0fSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBXZWJHTFVpbnQ4RW5jb2RlIHtcbiAgcnVuSW50ZXJuYWwoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3kuY29tcHV0ZVRleHR1cmVXSChpbnB1dC5zaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBjaGFubmVsczogNCxcbiAgICAgIHNoYXBlOiBvdXRwdXRTaGFwZSxcbiAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhvdXRwdXRTaGFwZSksXG4gICAgICB1bnBhY2tlZFNoYXBlOiBvdXRwdXRTaGFwZVxuICAgIH07XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHNwZWNpYWwgc2NyaXB0LiBVc2UgZ3JhcGggdHJhbnNmb3JtZXIgaW5zdGVhZC5cbiAgICAvKipcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzLWNvcmUvYmxvYi9tYXN0ZXIvc3JjL2tlcm5lbHMvd2ViZ2wvZW5jb2RlX2Zsb2F0X2dwdS50c1xuICAgICAqL1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XG4gICAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcblxuICAgICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcbiAgICAgICAgcmV0dXJuICh2YWwgPCAxLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjApID8gZmFsc2UgOiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBoaWdocCB2ZWM0IGVuY29kZUFzVWludDgoaGlnaHAgZmxvYXQgdikge1xuICAgICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGlnaHAgZmxvYXQgYXYgPSBhYnModik7XG5cbiAgICAgICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcbiAgICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICB9IGVsc2UgaWYodiA+IEZMT0FUX01BWCkge1xuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XG4gICAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xuICAgICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAgMTI4LjAsIDI1NS4wKSAvIDI1NS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcblxuICAgICAgICBoaWdocCBmbG9hdCBlID0gZmxvb3IobG9nMihhdikpO1xuICAgICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xuXG4gICAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xuICAgICAgICBtIC09IGNbMl0gLyAxMjguMDtcbiAgICAgICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcbiAgICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcbiAgICAgICAgY1swXSA9IGZsb29yKDgzODg2MDguMCAqIG0pO1xuXG4gICAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xuICAgICAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xuICAgICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xuICAgICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xuXG4gICAgICAgIGNbM10gKz0gMTI4LjAgKiBzdGVwKDAuMCwgLXYpO1xuXG4gICAgICAgIHJldHVybiBjIC8gMjU1LjA7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZmxvYXQgdmFsdWUgPSAke2dsc2wudGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSBlbmNvZGVBc1VpbnQ4KHZhbHVlKTtcbiAgICAgIH1gO1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID1cbiAgICAgICAge25hbWU6ICdVaW50OEVuY29kZScsIGlucHV0TGF5b3V0czogW2lucHV0XSwgb3V0cHV0TGF5b3V0LCBzYW1wbGVyczogWydYJ10sIHNoYWRlclNvdXJjZSwgaGFzTWFpbjogdHJ1ZX07XG4gICAgY29uc3QgYXJ0aWZhY3QgPSBpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8pO1xuXG4gICAgY29uc3QgZW5jb2RlciA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5nZXRFbmNvZGVyKCdieXRlJywgNCk7XG4gICAgY29uc3QgdGV4dHVyZSA9XG4gICAgICAgIGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5hbGxvY2F0ZVRleHR1cmUob3V0cHV0TGF5b3V0LndpZHRoLCBvdXRwdXRMYXlvdXQuaGVpZ2h0LCBlbmNvZGVyKTtcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlRGF0YSA9IGluZmVyZW5jZUhhbmRsZXIuY3JlYXRlU2hhcmVkVGV4dHVyZURhdGEob3V0cHV0TGF5b3V0LCAndWludDgnLCB0ZXh0dXJlKTtcbiAgICBjb25zdCBydW5EYXRhID0ge2lucHV0VGV4dHVyZURhdGFzOiBbaW5wdXRdLCBvdXRwdXRUZXh0dXJlRGF0YSwgdW5pZm9ybURhdGE6IHt9fTtcblxuICAgIGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5ydW4oYXJ0aWZhY3QsIHJ1bkRhdGEpO1xuICAgIHJldHVybiBydW5EYXRhLm91dHB1dFRleHR1cmVEYXRhO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtVbmFyeU9wfSBmcm9tICcuLi8uLi8uLi9vcHMvdW5hcnktb3AnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0Z1bmN0aW9uVHlwZSwgR2xzbFZhbHVlRnVuY3Rpb259IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xVbmFyeU9wIGV4dGVuZHMgVW5hcnlPcCBpbXBsZW1lbnRzIFdlYkdMT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgdHlwZUNvbnN0cmFpbnQ6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdLCBwcm90ZWN0ZWQgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uKSB7XG4gICAgc3VwZXIodHlwZUNvbnN0cmFpbnQpO1xuICB9XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICBjb25zdCBpbnB1dExheW91dCA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID9cbiAgICAgICAgaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdLCA0LCB0cnVlLCBpbnB1dHNbMF0uZGltcywgdHJ1ZSkgOlxuICAgICAgICBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0pO1xuXG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgP1xuICAgICAgICBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUob3V0cHV0U2hhcGUsIDQsIG91dHB1dFNoYXBlLCB7aXNQYWNrZWQ6IHRydWUsIHJldmVyc2VXSDogdHJ1ZX0pIDpcbiAgICAgICAgaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHt0aGlzLmdsc2xGdW5jLmJvZHl9XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzQgdiA9ICR7Z2xzbC50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XG4gICAgICAgIHYgPSAke3RoaXMuZ2xzbEZ1bmMubmFtZX0odik7XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdjtcbiAgICAgIH1cbiAgICAgIGA7XG5cbiAgICBpZiAoaGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0TGF5b3V0czogW2lucHV0TGF5b3V0XSxcbiAgICAgICAgb3V0cHV0TGF5b3V0LFxuICAgICAgICBzYW1wbGVyczogWydBJ10sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgICAgZXhwZWN0UGFja2VkSW5wdXRzOiB0cnVlLFxuICAgICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge2lucHV0TGF5b3V0czogW2lucHV0TGF5b3V0XSwgb3V0cHV0TGF5b3V0LCBzYW1wbGVyczogWydBJ10sIHNoYWRlclNvdXJjZSwgaGFzTWFpbjogdHJ1ZX07XG4gICAgfVxuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgP1xuICAgICAgICBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDEsIGZhbHNlLCBbXSwgdHJ1ZSkpIDpcbiAgICAgICAgaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0c1swXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBbaW5wdXRURF0sXG4gICAgICBvdXRwdXRUZXh0dXJlRGF0YTogaGFuZGxlci5jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXQocHJvZ3JhbUluZm8ub3V0cHV0TGF5b3V0LCBpbnB1dFRELnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7fVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBYnMoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYWJzJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFjb3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYWNvcycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBc2luKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2FzaW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQXRhbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhdGFuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbENlaWwoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnY2VpbCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDb3MoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnY29zJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEV4cCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdleHAnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRmxvb3IoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnZmxvb3InKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsSWRlbnRpdHkoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2luZGVudGl0eV8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbExvZygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdsb2cnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTmVnKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICduZWdfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhKSB7XG4gICAgcmV0dXJuIC1hO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYpIHtcbiAgICByZXR1cm4gLXY7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE5vdCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbm90Xyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSkge1xuICAgIHJldHVybiBmbG9hdCggISBib29sKGEpICk7XG4gIH1cbiAgYm9vbCAke25hbWV9KGJvb2wgYSkge1xuICAgIHJldHVybiAhYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2KSB7XG4gICAgcmV0dXJuIHZlYzQoIWJvb2wodi54KSwgIWJvb2wodi55KSwgIWJvb2wodi56KSwgIWJvb2wodi53KSk7XG4gIH1cbiAgYnZlYzQgJHtuYW1lfShidmVjNCB2KSB7XG4gICAgcmV0dXJuIGJ2ZWM0KCF2LngsICF2LnksICF2LnosICF2LncpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnc2luJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFJlbHUoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3JlbHVfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhKSB7XG4gICAgcmV0dXJuIG1heCggYSwgMC4wICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdikge1xuICAgIHJldHVybiBtYXgoIHYsIDAuMCApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaWdtb2lkKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdzaWdtb2lkXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSkge1xuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1hKSk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdikge1xuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC12KSk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNxcnQoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnc3FydCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xUYW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgndGFuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFRhbmgoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ3RhbmhfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhKSB7XG4gICAgYSA9IGNsYW1wKGEsIC0xMC4sIDEwLik7XG4gICAgYSA9IGV4cCgyLiphKTtcbiAgICByZXR1cm4gKGEgLSAxLikgLyAoYSArIDEuKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2KSB7XG4gICAgdiA9IGNsYW1wKHYsIC0xMC4sIDEwLik7XG4gICAgdiA9IGV4cCgyLip2KTtcbiAgICByZXR1cm4gKHYgLSAxLikgLyAodiArIDEuKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmZ1bmN0aW9uIGdsc2xCdWlsdGluVW5hcnkoZm5hbWU6IHN0cmluZyk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9IGAke2ZuYW1lfV9gO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEpIHtcbiAgICByZXR1cm4gJHtmbmFtZX0oYSk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdikge1xuICAgIHJldHVybiAke2ZuYW1lfSh2KTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFJ1bkRhdGEsIFdlYkdMT3BlcmF0b3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7Z2V0Q2hhbm5lbHMsIHVucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xVbnBhY2sgaW1wbGVtZW50cyBXZWJHTE9wZXJhdG9yIHtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5ydW4odGhpcywgaW5wdXRzKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtSW5mbyhoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBQcm9ncmFtSW5mbyB7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFjayBrZXJuZWwgc2hvdWxkIGhhdmUgaW5wdXQgdGVuc29yIGNvdW50IHRvIDEuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRUZXh0dXJlID0gaGFuZGxlci5nZXRUZXh0dXJlRGF0YShpbnB1dHNbMF0uZGF0YUlkLCB0cnVlKTtcbiAgICBpZiAoIWlucHV0VGV4dHVyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWNrZWQgaW5wdXQgdGV4dHVyZSBtdXN0IGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRMYXlvdXQgPSBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZUxheW91dChpbnB1dHNbMF0sIDQsIHRydWUpO1xuICAgIGNvbnN0IGlzU2NhbGFyID0gKGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoID09PSAwKTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSBoYW5kbGVyLmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoaW5wdXRUZXh0dXJlLnVucGFja2VkU2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gb3V0cHV0TGF5b3V0LnNoYXBlO1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBjaGFubmVscyA9IGdldENoYW5uZWxzKCdyYycsIHJhbmspO1xuICAgIGNvbnN0IGlubmVyRGltcyA9IGNoYW5uZWxzLnNsaWNlKC0yKTtcbiAgICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuICAgIGNvbnN0IHNvdXJjZUNvb3JkcyA9IGlzU2NhbGFyID8gJycgOiBnZXRTb3VyY2VDb29yZHMocmFuaywgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHJhbmsgPD0gMSA/ICdyYycgOiBgdmVjMigke2lubmVyRGltcy5qb2luKCcsJyl9KWA7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAke3VucGFja0NoYW5uZWx9XG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgJHtjb29yZHNEYXRhVHlwZX0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgLy8gU2FtcGxlIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGNvb3JkcyB0byBnZXQgdGhlIHJnYmEgY2hhbm5lbCB2YWx1ZS5cbiAgICAgIHZlYzQgcGFja2VkSW5wdXQgPSBnZXRBKCR7c291cmNlQ29vcmRzfSk7XG5cbiAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmVjNChnZXRDaGFubmVsKHBhY2tlZElucHV0LCAke2Nvb3Jkc30pLCAwLCAwLCAwKTtcbiAgICB9XG4gIGA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ1dlYkdMVW5wYWNrJyxcbiAgICAgIGlucHV0TGF5b3V0czogW2hhbmRsZXIuZ2V0T3JDcmVhdGVUZXh0dXJlTGF5b3V0KGlucHV0c1swXSwgNCwgdHJ1ZSwgaW5wdXRzWzBdLmRpbXMsIHRydWUpXSxcbiAgICAgIG91dHB1dExheW91dCxcbiAgICAgIHNhbXBsZXJzOiBbJ0EnXSxcbiAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIGhhc01haW46IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRJbnB1dHM6IHRydWUsXG4gICAgICBleHBlY3RQYWNrZWRPdXRwdXRzOiBmYWxzZSxcbiAgICB9O1xuICB9XG4gIGNyZWF0ZVJ1bkRhdGEoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0czogVGVuc29yW10pOiBSdW5EYXRhIHtcbiAgICBjb25zdCBpbnB1dFREcyA9IFtoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEoaW5wdXRzWzBdLCBwcm9ncmFtSW5mby5pbnB1dExheW91dHNbMF0sIHRydWUpXTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRUZXh0dXJlRGF0YXM6IGlucHV0VERzLFxuICAgICAgb3V0cHV0VGV4dHVyZURhdGE6IGhhbmRsZXIuY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0KHByb2dyYW1JbmZvLm91dHB1dExheW91dCwgaW5wdXRURHNbMF0udGVuc29yLnR5cGUpLFxuICAgICAgdW5pZm9ybURhdGE6IHt9XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzKHJhbms6IG51bWJlciwgZGltczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiAncmMnO1xuICB9XG5cbiAgbGV0IGNvb3JkcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7IGkrKykge1xuICAgIGNvb3JkcyArPSBkaW1zW2ldO1xuICAgIGlmIChpIDwgcmFuayAtIDEpIHtcbiAgICAgIGNvb3JkcyArPSAnLCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtVbnNxdWVlemV9IGZyb20gJy4uLy4uLy4uL29wcy91bnNxdWVlemUnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL3Jlc2hhcGUnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xVbnNxdWVlemUgZXh0ZW5kcyBVbnNxdWVlemUge1xuICBydW4oaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBTaGFwZVV0aWwudW5zcXVlZXplU2hhcGUoaW5wdXRzWzBdLmRpbXMsIHRoaXMuYXhlcyk7XG4gICAgcmV0dXJuIFtyZXNoYXBlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgb3V0cHV0RGltcyldO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtVcHNhbXBsZX0gZnJvbSAnLi4vLi4vLi4vb3BzL3Vwc2FtcGxlJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUnVuRGF0YSwgV2ViR0xPcGVyYXRvcn0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xVcHNhbXBsZSBleHRlbmRzIFVwc2FtcGxlIGltcGxlbWVudHMgV2ViR0xPcGVyYXRvciB7XG4gIHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZmVyZW5jZUhhbmRsZXIucnVuKHRoaXMsIGlucHV0cyk7XG4gIH1cbiAgY3JlYXRlUHJvZ3JhbUluZm8oaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogUHJvZ3JhbUluZm8ge1xuICAgIGNvbnN0IGlucHV0TGF5b3V0ID0gaGFuZGxlci5nZXRPckNyZWF0ZVRleHR1cmVMYXlvdXQoaW5wdXRzWzBdKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLm1hcCgoZGltLCBpKSA9PiBNYXRoLmZsb29yKGRpbSAqIHRoaXMuc2NhbGVzW2ldKSk7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gaGFuZGxlci5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBkaW0gPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBjb25zdCBvdXRwdXRQaXRjaGVzID0gbmV3IEFycmF5PG51bWJlcj4oZGltKTtcbiAgICBjb25zdCBpbnB1dFBpdGNoZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW0pO1xuICAgIGxldCBwcmVjYWxjdWxhdGVkUGl0Y2hlcyA9IGBcbiAgICAgIGludCBvdXRwdXRfcGl0Y2hlc1ske2RpbX1dO1xuICAgICAgaW50IGlucHV0X3BpdGNoZXNbJHtkaW19XTtcbiAgICAgIGA7XG4gICAgZm9yIChsZXQgZCA9IGRpbSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICBvdXRwdXRQaXRjaGVzW2RdID0gKGQgPT09IGRpbSAtIDEpID8gMSA6IG91dHB1dFBpdGNoZXNbZCArIDFdICogb3V0cHV0U2hhcGVbZCArIDFdO1xuICAgICAgaW5wdXRQaXRjaGVzW2RdID0gKGQgPT09IGRpbSAtIDEpID8gMSA6IGlucHV0UGl0Y2hlc1tkICsgMV0gKiBpbnB1dHNbMF0uZGltc1tkICsgMV07XG5cbiAgICAgIHByZWNhbGN1bGF0ZWRQaXRjaGVzICs9IGBcbiAgICAgIG91dHB1dF9waXRjaGVzWyR7ZH1dID0gJHtvdXRwdXRQaXRjaGVzW2RdfTtcbiAgICAgIGlucHV0X3BpdGNoZXNbJHtkfV0gPSAke2lucHV0UGl0Y2hlc1tkXX07XG4gICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBnZXRJbnB1dEZsb2F0RnVuY3Rpb24gPSBgXG4gICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcbiAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7aW5wdXRMYXlvdXQud2lkdGh9LCAke2lucHV0TGF5b3V0LmhlaWdodH0pO1xuICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGA7XG5cbiAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSB0aGlzLm1vZGUgPT09ICduZWFyZXN0JyA/XG4gICAgICAgIC8vIG5lYXJlc3RcbiAgICAgICAgYFxuICAgICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7ZGltfV0pIHtcbiAgICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcbiAgICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRMYXlvdXQud2lkdGh9LCAke291dHB1dExheW91dC5oZWlnaHR9KTtcblxuICAgICAgICAke3ByZWNhbGN1bGF0ZWRQaXRjaGVzfVxuXG4gICAgICAgIGludCBkLCBtO1xuICAgICAgICBmb3IgKGludCBkaW0gPSAwOyBkaW0gPCAke2RpbX07ICsrZGltKSB7XG4gICAgICAgICAgZCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzW2RpbV07XG4gICAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGQgKiBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xuICAgICAgICAgIG91dHB1dF9pbmRleCA9IG07XG5cbiAgICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xuICAgICAgICAgICAgaW50IGQyID0gZCAvIHNjYWxlc1tkaW1dO1xuICAgICAgICAgICAgbSA9IGQgLSBkMiAqIHNjYWxlc1tkaW1dO1xuICAgICAgICAgICAgZCA9IGQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dF9pbmRleCArPSBpbnB1dF9waXRjaGVzW2RpbV0gKiBkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgICAgfWAgOlxuICAgICAgICBkaW0gPT09IDQgP1xuICAgICAgICAvLyBiaWxpbmVhciA0RFxuICAgICAgICAgICAgYFxuICAgICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzRdKSB7XG4gICAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7b3V0cHV0TGF5b3V0LndpZHRofSwgJHtvdXRwdXRMYXlvdXQuaGVpZ2h0fSk7XG5cbiAgICAgICAgJHtwcmVjYWxjdWxhdGVkUGl0Y2hlc31cblxuICAgICAgICBpbnQgbTtcbiAgICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTEsIGluZGV4X29mX2RpbTIsIGluZGV4X29mX2RpbTM7XG4gICAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgICAgaW5kZXhfb2ZfZGltMSA9IG0gLyBvdXRwdXRfcGl0Y2hlc1sxXTtcbiAgICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XG4gICAgICAgIGluZGV4X29mX2RpbTIgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMl07XG4gICAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMiAqIG91dHB1dF9waXRjaGVzWzJdO1xuICAgICAgICBpbmRleF9vZl9kaW0zID0gbTtcblxuICAgICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xuICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0yID0gaW5kZXhfb2ZfZGltMiAvIHNjYWxlc1syXTtcbiAgICAgICAgeV9vZmZzZXQgPSBpbmRleF9vZl9kaW0yIC0gaW5kZXhfb2ZfaW5wdXRfZGltMiAqIHNjYWxlc1syXTtcbiAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XG4gICAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMyAtIGluZGV4X29mX2lucHV0X2RpbTMgKiBzY2FsZXNbM107XG5cbiAgICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXhfb2ZfZGltMSAqIGlucHV0X3BpdGNoZXNbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgKiBpbnB1dF9waXRjaGVzWzJdICtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleF9vZl9pbnB1dF9kaW0zO1xuXG4gICAgICAgIGZsb2F0IHgwMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xuXG4gICAgICAgIGJvb2wgZW5kX29mX2RpbTIgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7aW5wdXRzWzBdLmRpbXNbMl19IC0gMSkpIHtcbiAgICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcbiAgICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgICAgZW5kX29mX2RpbTIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0zID09IChpbnB1dF9waXRjaGVzWzJdIC0gMSkpIHtcbiAgICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcbiAgICAgICAgICB4MTAgPSB4MDA7XG4gICAgICAgICAgeDExID0geDAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzJdKTtcbiAgICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1syXSk7XG4gICAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XG4gICAgICB9YCA6XG4gICAgICAgICAgICAvLyBiaWxpbmVhciAyRFxuICAgICAgICAgICAgYFxuICAgICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XG4gICAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgIGludCBvdXRwdXRfaW5kZXggPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7b3V0cHV0TGF5b3V0LndpZHRofSwgJHtvdXRwdXRMYXlvdXQuaGVpZ2h0fSk7XG5cbiAgICAgICAgJHtwcmVjYWxjdWxhdGVkUGl0Y2hlc31cblxuICAgICAgICBpbnQgbTtcbiAgICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XG4gICAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGluZGV4X29mX2RpbTAgKiBvdXRwdXRfcGl0Y2hlc1swXTtcbiAgICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XG5cbiAgICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcbiAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMCA9IGluZGV4X29mX2RpbTAgLyBzY2FsZXNbMF07XG4gICAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMCAtIGluZGV4X29mX2lucHV0X2RpbTAgKiBzY2FsZXNbMF07XG4gICAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xuICAgICAgICB4X29mZnNldCA9IGluZGV4X29mX2RpbTEgLSBpbmRleF9vZl9pbnB1dF9kaW0xICogc2NhbGVzWzFdO1xuXG4gICAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gKyBpbmRleF9vZl9pbnB1dF9kaW0xO1xuXG4gICAgICAgIGZsb2F0IHgwMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xuXG4gICAgICAgIGJvb2wgZW5kX29mX2RpbTAgPSBmYWxzZTtcbiAgICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7aW5wdXRzWzBdLmRpbXNbMF19IC0gMSkpIHtcbiAgICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcbiAgICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgICAgZW5kX29mX2RpbTAgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0xID09IChpbnB1dF9waXRjaGVzWzBdIC0gMSkpIHtcbiAgICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcbiAgICAgICAgICB4MTAgPSB4MDA7XG4gICAgICAgICAgeDExID0geDAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzBdKTtcbiAgICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1swXSk7XG4gICAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XG4gICAgICB9YDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRMYXlvdXRzOiBbaW5wdXRMYXlvdXRdLFxuICAgICAgb3V0cHV0TGF5b3V0LFxuICAgICAgc2FtcGxlcnM6IFsnWCddLFxuICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdzY2FsZXMnLCB0eXBlOiAnaW50JywgYXJyYXlMZW5ndGg6IHRoaXMuc2NhbGVzLmxlbmd0aH1dXG4gICAgfTtcbiAgfVxuICBjcmVhdGVSdW5EYXRhKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dHM6IFRlbnNvcltdKTogUnVuRGF0YSB7XG4gICAgY29uc3QgaW5wdXRURHMgPSBpbnB1dHMubWFwKCh0LCBpKSA9PiBoYW5kbGVyLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodCwgcHJvZ3JhbUluZm8uaW5wdXRMYXlvdXRzW2ldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VGV4dHVyZURhdGFzOiBpbnB1dFREcyxcbiAgICAgIG91dHB1dFRleHR1cmVEYXRhOiBoYW5kbGVyLmNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dChwcm9ncmFtSW5mby5vdXRwdXRMYXlvdXQsIGlucHV0VERzWzBdLnRlbnNvci50eXBlKSxcbiAgICAgIHVuaWZvcm1EYXRhOiB7c2NhbGVzOiB0aGlzLnNjYWxlcy5tYXAoeCA9PiBNYXRoLmNlaWwoeCkpfVxuICAgIH07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7TG9nZ2VyLCBQcm9maWxlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7R2xzbFByZXByb2Nlc3Nvcn0gZnJvbSAnLi9nbHNsLXByZXByb2Nlc3Nvcic7XG5pbXBvcnQge2dldFZlcnRleFNoYWRlclNvdXJjZX0gZnJvbSAnLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1RleHR1cmVMYXlvdXRTdHJhdGVneX0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUnVuRGF0YSwgVGV4dHVyZURhdGEsIFVuaWZvcm1EYXRhLCBWYXJpYWJsZUluZm99IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbi8qKlxuICogUHJvZ3JhbU1hbmFnZXIgaXMgdGhlIG1haW4gY2xhc3MgYmVoaW5kIHJ1bm5pbmcgY29tcHV0YXRpb25zXG4gKiBJdCBidWlsZHMgUHJvZ3JhbUluZm8ncyBpbnRvIEFydGlmYWN0c1xuICogSXQgY29tcGlsZXMgZ2l2ZW4gUHJvZ3JhbUluZm8ncyBpbnRvIFdlYkdMIFByb3JhbXMgKGNhY2hlZCBhcyBBcnRpZmFjdHMpXG4gKiBVc2VzIHRoZSBhcnRpZmFjdCB0byBydW4gdGhlIGNvbXB1dGF0aW9uIGJ5IGNhbGxpbmcgRHJhdyBvblxuICogdGhlIFdlYkdMIGRyYXdpbmcgYnVmZmVyXG4gKiBQcm9ncmFtTWFuYWdlciBhdXRvbWF0aWNhbGx5IG1hcHMgKGJpbmRzKSBpbnB1dCB2YXJpYWJsZXMgdG8gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgTG9jYXRpb24ncyBpbiB0aGUgYmluYXJ5IHByb2dyYW1cbiAqL1xuZXhwb3J0IGNsYXNzIFByb2dyYW1NYW5hZ2VyIHtcbiAgcmVwbzogTWFwPHVua25vd24sIEFydGlmYWN0PjsgIC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxuICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyO1xuICBhdHRyaWJ1dGVzQm91bmQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPiwgcHVibGljIGdsQ29udGV4dDogV2ViR0xDb250ZXh0LFxuICAgICAgcHVibGljIHRleHR1cmVMYXlvdXRTdHJhdGVneTogVGV4dHVyZUxheW91dFN0cmF0ZWd5KSB7XG4gICAgdGhpcy5yZXBvID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XG4gIH1cbiAgZ2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duKTogQXJ0aWZhY3R8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5yZXBvLmdldChrZXkpO1xuICB9XG4gIHNldEFydGlmYWN0KGtleTogdW5rbm93biwgYXJ0aWZhY3Q6IEFydGlmYWN0KTogdm9pZCB7XG4gICAgdGhpcy5yZXBvLnNldChrZXksIGFydGlmYWN0KTtcbiAgfVxuICBydW4oYnVpbGRBcnRpZmFjdDogQXJ0aWZhY3QsIHJ1bkRhdGE6IFJ1bkRhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdvcCcsIGBQcm9ncmFtTWFuYWdlci5ydW4gJHtidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUgPz8gJ3Vua25vd24ga2VybmVsJ31gLCAoKSA9PiB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgICAgY29uc3QgcHJvZ3JhbSA9IGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJpbmRPdXRwdXQocnVuRGF0YS5vdXRwdXRUZXh0dXJlRGF0YSk7XG4gICAgICAgIGlmICghdGhpcy5hdHRyaWJ1dGVzQm91bmQpIHtcbiAgICAgICAgICB0aGlzLmJpbmRBdHRyaWJ1dGVzKGJ1aWxkQXJ0aWZhY3QuYXR0cmliTG9jYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpbmRVbmlmb3JtcyhidWlsZEFydGlmYWN0LnVuaWZvcm1Mb2NhdGlvbnMsIHJ1bkRhdGEudW5pZm9ybURhdGEsIHJ1bkRhdGEuaW5wdXRUZXh0dXJlRGF0YXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci5lcnJvcignUHJvZ3JhbU1hbmFnZXInLCBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnR2xDb250ZXh0LmRyYXcoKScsICgpID0+IHtcbiAgICAgICAgdGhpcy5kb0RyYXcoYnVpbGRBcnRpZmFjdCwgcnVuRGF0YSk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLmdsQ29udGV4dCk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy52ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcbiAgfVxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8pOiBBcnRpZmFjdCB7XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnUHJvZ3JhbU1hbmFnZXIuYnVpbGQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVwcm9jZXNzb3IgPSBuZXcgR2xzbFByZXByb2Nlc3Nvcih0aGlzLmdsQ29udGV4dCwgcHJvZ3JhbUluZm8pO1xuICAgICAgY29uc3QgZnJhZ1NjcmlwdCA9IHByZXByb2Nlc3Nvci5wcmVwcm9jZXNzKCk7XG4gICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5jb21waWxlKGZyYWdTY3JpcHQpO1xuICAgICAgY29uc3QgYXJ0aWZhY3QgPSB7XG4gICAgICAgIHByb2dyYW1JbmZvLFxuICAgICAgICBwcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoXG4gICAgICAgICAgICBwcm9ncmFtLCBwcmVwcm9jZXNzb3IuY29udGV4dC5wcm9ncmFtSW5mby5zYW1wbGVycywgcHJlcHJvY2Vzc29yLmNvbnRleHQucHJvZ3JhbUluZm8udmFyaWFibGVzKSxcbiAgICAgICAgYXR0cmliTG9jYXRpb25zOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBhcnRpZmFjdDtcbiAgICB9KTtcbiAgfVxuICBwcm90ZWN0ZWQgZG9EcmF3KGFydGlmYWN0OiBBcnRpZmFjdCwgcnVuRGF0YTogUnVuRGF0YSk6IHZvaWQge1xuICAgIGlmIChydW5EYXRhLmRyYXcpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdQcm9ncmFtTWFuYWdlcicsICdDdXN0b20gZHJhdyBmdW5jdGlvbicpO1xuICAgICAgcnVuRGF0YS5kcmF3KHRoaXMuZ2xDb250ZXh0LCBhcnRpZmFjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRyYXcoKTtcbiAgICB9XG4gIH1cbiAgcHJvdGVjdGVkIGNvbXBpbGUoZnJhZ1NoYWRlclNjcmlwdDogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICBpZiAoIXRoaXMudmVydGV4U2hhZGVyKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnUHJvcmdyYW1NYW5hZ2VyJywgJ0NvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZScpO1xuICAgICAgY29uc3QgdmVydGV4U2hhZGVyU2NyaXB0ID0gZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgfVxuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdQcm9yZ3JhbU1hbmFnZXInLCBgRnJhZ1NoYWRlcjpcbiR7ZnJhZ1NoYWRlclNjcmlwdH1cbmApO1xuICAgIH1cbiAgICBjb25zdCBmcmFnU2hhZGVyID0gdGhpcy5nbENvbnRleHQuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyU2NyaXB0LCB0aGlzLmdsQ29udGV4dC5nbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsQ29udGV4dC5jcmVhdGVQcm9ncmFtKHRoaXMudmVydGV4U2hhZGVyLCBmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmdsQ29udGV4dC5kZWxldGVTaGFkZXIoZnJhZ1NoYWRlcik7XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgYmluZE91dHB1dCh0ZDogVGV4dHVyZURhdGEpOiB2b2lkIHtcbiAgICBjb25zdCB3aWR0aCA9IHRkLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRkLmhlaWdodDtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgJ1Byb3JncmFtTWFuYWdlcicsXG4gICAgICAgIGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHt3aWR0aH0vJHtoZWlnaHR9LCBzaGFwZT0ke3RkLnNoYXBlfSwgdHlwZT0ke3RkLnRlbnNvci50eXBlfWApO1xuICAgIHRoaXMuZ2xDb250ZXh0LmF0dGFjaEZyYW1lYnVmZmVyKHRkLnRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGJpbmRBdHRyaWJ1dGVzKGF0dHJpYkxvY2F0aW9uczogQXJ0aWZhY3QuQXR0cmliTG9jYXRpb25zKTogdm9pZCB7XG4gICAgY29uc3QgcG9zaXRpb25IYW5kbGUgPSBhdHRyaWJMb2NhdGlvbnMucG9zaXRpb247XG4gICAgY29uc3QgdGV4dHVyZUNvb3JkSGFuZGxlID0gYXR0cmliTG9jYXRpb25zLnRleHR1cmVDb29yZDtcbiAgICB0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHBvc2l0aW9uSGFuZGxlLCB0ZXh0dXJlQ29vcmRIYW5kbGUpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gdHJ1ZTtcbiAgfVxuICBiaW5kVW5pZm9ybXModW5pZm9ybUxvY2F0aW9uczogQXJ0aWZhY3QuVW5pZm9ybUxvY2F0aW9ucywgdW5pZm9ybURhdGE6IFVuaWZvcm1EYXRhLCB0ZXh0dXJlczogVGV4dHVyZURhdGFbXSk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgbGV0IHRleHR1cmVQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChjb25zdCB7bmFtZSwgdHlwZSwgbG9jYXRpb24sIGFycmF5TGVuZ3RofSBvZiB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmVzW3RleHR1cmVQb3NpdGlvbl0sIGxvY2F0aW9uLCB0ZXh0dXJlUG9zaXRpb24pO1xuICAgICAgICAgIHRleHR1cmVQb3NpdGlvbisrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB1bmlmb3JtRGF0YVtuYW1lXSBhcyBudW1iZXJbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdW5pZm9ybURhdGFbbmFtZV0gYXMgbnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ludCc6XG4gICAgICAgICAgaWYgKGFycmF5TGVuZ3RoKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB1bmlmb3JtRGF0YVtuYW1lXSBhcyBudW1iZXJbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdW5pZm9ybURhdGFbbmFtZV0gYXMgbnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIG5vdCBpbXBsZW1lbnRlZDogJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBiaW5kVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIHVuaWZvcm1IYW5kbGU6IFdlYkdMVW5pZm9ybUxvY2F0aW9uLCBwb3NpdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuYmluZFRleHR1cmVUb1VuaWZvcm0odGQudGV4dHVyZSwgcG9zaXRpb24sIHVuaWZvcm1IYW5kbGUpO1xuICB9XG4gIGdldEF0dHJpYkxvY2F0aW9ucyhwcm9ncmFtOiBXZWJHTFByb2dyYW0pOiBBcnRpZmFjdC5BdHRyaWJMb2NhdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAncG9zaXRpb24nKSxcbiAgICAgIHRleHR1cmVDb29yZDogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAndGV4dHVyZUNvb3JkJylcbiAgICB9O1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbnMocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBzYW1wbGVycz86IHN0cmluZ1tdLCB2YXJpYWJsZXM/OiBWYXJpYWJsZUluZm9bXSk6XG4gICAgICBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zIHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zOiBBcnRpZmFjdC5Vbmlmb3JtTG9jYXRpb25zID0gW107XG4gICAgaWYgKHNhbXBsZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHNhbXBsZXIgb2Ygc2FtcGxlcnMpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucy5wdXNoKHtuYW1lOiBzYW1wbGVyLCB0eXBlOiAnc2FtcGxlcjJEJywgbG9jYXRpb246IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHNhbXBsZXIpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YXJpYWJsZXMpIHtcbiAgICAgIGZvciAoY29uc3QgdmFyaWFibGUgb2YgdmFyaWFibGVzKSB7XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMucHVzaCh7Li4udmFyaWFibGUsIGxvY2F0aW9uOiB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB2YXJpYWJsZS5uYW1lKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pZm9ybUxvY2F0aW9ucztcbiAgfVxuICBnZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBuYW1lOiBzdHJpbmcpOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbiB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICBjb25zdCByZWZlcmVuY2UgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG4gICAgaWYgKHJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtICR7bmFtZX0gbm90IGZvdW5kLmApO1xuICAgIH1cbiAgICByZXR1cm4gcmVmZXJlbmNlO1xuICB9XG4gIGdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgbmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgIGNvbnN0IGF0dHJpYnV0ZUxvY2F0aW9uOiBudW1iZXIgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICByZXR1cm4gYXR0cmlidXRlTG9jYXRpb247XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Nlc3Npb25IYW5kbGVyfSBmcm9tICcuLi8uLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uL2dyYXBoJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge09wU2V0LCByZXNvbHZlT3BlcmF0b3J9IGZyb20gJy4uLy4uL29wc2V0JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi4vLi4vc2Vzc2lvbic7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xCYWNrZW5kfSBmcm9tICcuLi9iYWNrZW5kLXdlYmdsJztcblxuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtXRUJHTF9PUF9SRVNPTFZFX1JVTEVTfSBmcm9tICcuL29wLXJlc29sdmUtcnVsZXMnO1xuaW1wb3J0IHtQcm9ncmFtTWFuYWdlcn0gZnJvbSAnLi9wcm9ncmFtLW1hbmFnZXInO1xuaW1wb3J0IHtQcmVmZXJMb2dpY2FsU3RyYXRlZ3ksIFRleHR1cmVMYXlvdXRTdHJhdGVneX0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQge1RleHR1cmVNYW5hZ2VyfSBmcm9tICcuL3RleHR1cmUtbWFuYWdlcic7XG5pbXBvcnQge1RleHR1cmVEYXRhLCBXZWJHTE9wZXJhdG9yfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFdlYkdMU2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBTZXNzaW9uSGFuZGxlciB7XG4gIHByb2dyYW1NYW5hZ2VyOiBQcm9ncmFtTWFuYWdlcjtcbiAgdGV4dHVyZU1hbmFnZXI6IFRleHR1cmVNYW5hZ2VyO1xuICBsYXlvdXRTdHJhdGVneTogVGV4dHVyZUxheW91dFN0cmF0ZWd5O1xuICBwYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHVucGFja2VkVGV4dHVyZURhdGFDYWNoZTogTWFwPFRlbnNvci5JZCwgVGV4dHVyZURhdGE+O1xuICBwYWNrMnVucGFja01hcDogTWFwPFRlbnNvci5JZCwgVGVuc29yLklkPjtcbiAgdW5wYWNrMnBhY2tNYXA6IE1hcDxUZW5zb3IuSWQsIFRlbnNvci5JZD47XG4gIGluaXRpYWxpemVyczogU2V0PFRlbnNvci5JZD47XG4gIHBhY2tPcENhY2hlOiBNYXA8c3RyaW5nLCBXZWJHTE9wZXJhdG9yPjtcbiAgdW5wYWNrT3BDYWNoZTogTWFwPHN0cmluZywgV2ViR0xPcGVyYXRvcj47XG4gIHBhY2s/OiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBiYWNrZW5kOiBXZWJHTEJhY2tlbmQsIHB1YmxpYyByZWFkb25seSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpIHtcbiAgICB0aGlzLmxheW91dFN0cmF0ZWd5ID0gbmV3IFByZWZlckxvZ2ljYWxTdHJhdGVneShiYWNrZW5kLmdsQ29udGV4dC5tYXhUZXh0dXJlU2l6ZSk7XG4gICAgdGhpcy5wcm9ncmFtTWFuYWdlciA9IG5ldyBQcm9ncmFtTWFuYWdlcih0aGlzLmNvbnRleHQucHJvZmlsZXIsIGJhY2tlbmQuZ2xDb250ZXh0LCB0aGlzLmxheW91dFN0cmF0ZWd5KTtcbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IFRleHR1cmVNYW5hZ2VyKFxuICAgICAgICBiYWNrZW5kLmdsQ29udGV4dCwgdGhpcy5sYXlvdXRTdHJhdGVneSwgdGhpcy5jb250ZXh0LnByb2ZpbGVyLFxuICAgICAgICB7cmV1c2VUZXh0dXJlczogYmFja2VuZC50ZXh0dXJlQ2FjaGVNb2RlID09PSAnZnVsbCd9KTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYWNrT3BDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFja09wQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYWNrID0gYmFja2VuZC5wYWNrO1xuICAgIHRoaXMucGFjazJ1bnBhY2tNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2sycGFja01hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBXZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyk7XG4gIH1cbiAgb25HcmFwaEluaXRpYWxpemVkKGdyYXBoOiBHcmFwaCk6IHZvaWQge1xuICAgIGNvbnN0IGluaXRpYWxpemVycyA9IGdyYXBoLmdldFZhbHVlcygpLmZpbHRlcih2ID0+IHYuZnJvbSA9PT0gLTEgJiYgdi50ZW5zb3IpLm1hcCh2ID0+IHYudGVuc29yIS5kYXRhSWQpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZXJzID0gbmV3IFNldChpbml0aWFsaXplcnMpO1xuICB9XG4gIGlzSW5pdGlhbGl6ZXIodGVuc29ySWQ6IFRlbnNvci5JZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVycyA/IHRoaXMuaW5pdGlhbGl6ZXJzLmhhcyh0ZW5zb3JJZCkgOiBmYWxzZTtcbiAgfVxuICBhZGRJbml0aWFsaXplcih0ZW5zb3JJZDogVGVuc29yLklkKTogdm9pZCB7XG4gICAgdGhpcy5pbml0aWFsaXplcnMuYWRkKHRlbnNvcklkKTtcbiAgfVxuICBnZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZDogVGVuc29yLklkLCBpc1BhY2tlZDogYm9vbGVhbik6IFRleHR1cmVEYXRhfHVuZGVmaW5lZCB7XG4gICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpO1xuICAgIH1cbiAgfVxuICBzZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZDogVGVuc29yLklkLCB0ZXh0dXJlRGF0YTogVGV4dHVyZURhdGEsIGlzUGFja2VkID0gZmFsc2UpOiB2b2lkIHtcbiAgICBMb2dnZXIudmVyYm9zZSgnV2ViR0xTZXNzaW9uSGFuZGxlcicsICdTdG9yaW5nIFRleHR1cmUgZGF0YSBpbiBjYWNoZScpO1xuICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0ZW5zb3JJZCwgdGV4dHVyZURhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5zZXQodGVuc29ySWQsIHRleHR1cmVEYXRhKTtcbiAgICB9XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2godGQgPT4gdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0ZCwgdHJ1ZSkpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG4gIHJlc29sdmUobm9kZTogR3JhcGguTm9kZSwgb3BzZXRzOiByZWFkb25seSBPcFNldFtdLCBncmFwaDogR3JhcGgpOiBPcGVyYXRvciB7XG4gICAgY29uc3Qgb3AgPSByZXNvbHZlT3BlcmF0b3Iobm9kZSwgb3BzZXRzLCBXRUJHTF9PUF9SRVNPTFZFX1JVTEVTKTtcbiAgICBvcC5pbml0aWFsaXplKG5vZGUuYXR0cmlidXRlcywgbm9kZSwgZ3JhcGgpO1xuICAgIHJldHVybiBvcDtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEVuY29kZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDogRmxvYXQzMkFycmF5O1xuICAgIGJ5dGU6IFVpbnQ4QXJyYXk7XG4gICAgaW50OiBVaW50MzJBcnJheTtcbiAgfVxuICBleHBvcnQgdHlwZSBEYXRhVHlwZSA9IGtleW9mIERhdGFUeXBlTWFwO1xuICB0eXBlIERhdGFBcnJheVR5cGUgPSBEYXRhVHlwZU1hcFtEYXRhVHlwZV07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4gIGV4cG9ydCBjb25zdCBlbnVtIFVzYWdlIHtcbiAgICBEZWZhdWx0ID0gMCxcbiAgICBVcGxvYWRPbmx5LFxuICAgIERvd25sb2FkNEJ5dGVzQXNGbG9hdDMyLFxuICB9XG59XG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIG1hcHBpbmcgZGF0YSB0eXBlcyB0byB0ZXh0dXJlIHRleGxldHNcbiAqIEVuY29kaW5nIG1lYW5zIGhvdyBhIEZsb2F0MzIgaXMgbWFwcGVkIHRvIDEgb3IgNCBjaGFubmVscyBmb3IgZWFjaCB0ZXhsZXRcbiAqIERlY29kaW5nIG1lYW5zIGhvdyBhIHRleGxldCdzIGNoYW5uZWxzIGFyZSBtYXBwZWQgdG8gYSByZXN1bHRpbmcgRmxvYXQzMlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGVuY29kZShzcmM6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZTtcbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlO1xuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGU7XG59XG4vKipcbiAqIFdlYkdMMiBkYXRhIGVuY29kZXJcbiAqIFVzZXMgUjMyRiBhcyB0aGUgZm9ybWF0IGZvciB0ZXhsZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZEZsb2F0MzJEYXRhRW5jb2RlciBpbXBsZW1lbnRzIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LCBjaGFubmVscyA9IDEpIHtcbiAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SMzJGO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5SRUQ7XG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuRkxPQVQ7XG4gICAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgfSBlbHNlIGlmIChjaGFubmVscyA9PT0gNCkge1xuICAgICAgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IGdsLlJHQkEzMkY7XG4gICAgICB0aGlzLmZvcm1hdCA9IGdsLlJHQkE7XG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuRkxPQVQ7XG4gICAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICB9XG4gIGVuY29kZShzcmM6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgbGV0IHJlc3VsdDogRmxvYXQzMkFycmF5O1xuICAgIGxldCBzb3VyY2U6IEZsb2F0MzJBcnJheTtcbiAgICBpZiAoc3JjLmNvbnN0cnVjdG9yICE9PSBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIExvZ2dlci53YXJuaW5nKCdFbmNvZGVyJywgJ2RhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXknKTtcbiAgICAgIHNvdXJjZSA9IG5ldyBGbG9hdDMyQXJyYXkoc3JjKTtcbiAgICB9XG4gICAgaWYgKHRleHR1cmVTaXplICogdGhpcy5jaGFubmVsU2l6ZSA+IHNyYy5sZW5ndGgpIHtcbiAgICAgIExvZ2dlci53YXJuaW5nKCdFbmNvZGVyJywgJ1NvdXJjZSBkYXRhIHRvbyBzbWFsbC4gQWxsb2NhdGluZyBsYXJnZXIgYXJyYXknKTtcbiAgICAgIHNvdXJjZSA9IHNyYyBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICByZXN1bHQgPSB0aGlzLmFsbG9jYXRlKHRleHR1cmVTaXplICogdGhpcy5jaGFubmVsU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgc291cmNlLmZvckVhY2goKHYsIGkpID0+IHJlc3VsdFtpXSA9IHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSBzcmMgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgcmVzdWx0ID0gc291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDQpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IChidWZmZXIgYXMgRmxvYXQzMkFycmF5KS5maWx0ZXIoKHZhbHVlLCBpbmRleCkgPT4gaW5kZXggJSA0ID09PSAwKS5zdWJhcnJheSgwLCBkYXRhU2l6ZSk7XG4gICAgICByZXR1cm4gZmlsdGVyZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKSBhcyBGbG9hdDMyQXJyYXk7XG4gIH1cbn1cbi8qKlxuICogRGF0YSBlbmNvZGVyIGZvciBXZWJHTCAxIHdpdGggc3VwcG9ydCBmb3IgZmxvYXRpbmcgcG9pbnQgdGV4dHVyZVxuICovXG5leHBvcnQgY2xhc3MgUkdCQUZsb2F0RGF0YUVuY29kZXIgaW1wbGVtZW50cyBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZTogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBjaGFubmVscyA9IDEsIHRleHR1cmVUeXBlPzogbnVtYmVyKSB7XG4gICAgaWYgKGNoYW5uZWxzICE9PSAxICYmIGNoYW5uZWxzICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke2NoYW5uZWxzfWApO1xuICAgIH1cbiAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB0aGlzLmZvcm1hdCA9IGdsLlJHQkE7XG4gICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIHRoaXMudGV4dHVyZVR5cGUgPSB0ZXh0dXJlVHlwZSB8fCBnbC5GTE9BVDtcbiAgfVxuICBlbmNvZGUoc3JjOiBGbG9hdDMyQXJyYXksIHRleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIGxldCBkZXN0ID0gc3JjO1xuICAgIGlmICh0aGlzLmNoYW5uZWxTaXplID09PSAxKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnRW5jb2RlcicsICdFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheScpO1xuICAgICAgZGVzdCA9IHRoaXMuYWxsb2NhdGUodGV4dHVyZVNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHNyYy5mb3JFYWNoKCh2LCBpKSA9PiBkZXN0W2kgKiA0XSA9IHYpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0KTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmNoYW5uZWxTaXplID09PSAxKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSAoYnVmZmVyIGFzIEZsb2F0MzJBcnJheSkuZmlsdGVyKCh2YWx1ZSwgaW5kZXgpID0+IGluZGV4ICUgNCA9PT0gMCkuc3ViYXJyYXkoMCwgZGF0YVNpemUpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheSgwLCBkYXRhU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50OERhdGFFbmNvZGVyIGltcGxlbWVudHMgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemUgPSA0O1xuICBjb25zdHJ1Y3RvcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBjaGFubmVscyA9IDEpIHtcbiAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5BTFBIQTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuQUxQSEE7ICAvLyBub3QgdGVzdGVkXG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxzID09PSA0KSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke2NoYW5uZWxzfWApO1xuICAgIH1cbiAgfVxuICBlbmNvZGUoc3JjOiBVaW50OEFycmF5LCBfdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IHR5cGU6ICR7YnVmZmVyLmNvbnN0cnVjdG9yfWApO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uLy4uL3V0aWwnO1xuLyoqIExheW91dCBwcmVmZXJlbmNlcyAqL1xuZXhwb3J0IGludGVyZmFjZSBXaWR0aEhlaWdodFByZWZzIHtcbiAgYnJlYWtBeGlzPzogbnVtYmVyO1xuICBpc1BhY2tlZD86IGJvb2xlYW47XG4gIHJldmVyc2VXSD86IGJvb2xlYW47XG59XG4vKipcbiAqIFRleHR1cmVMYXlvdXRTdHJhdGVneSBpcyBhbiBhYnN0cmFjdGlvbiBmb3IgZGlmZmVyZW50IHBsYW5zXG4gKiBmb3IgbWFwcGluZyBuLWRpbWVuc2lvbmFsIGFycmF5cyB0byAyRCB0ZXh0dXJlcyAoYW5kIGJhY2spXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl07XG59XG5cbi8qKlxuICogVGhpcyBzdHJhdGVneSB0cnkgdG8gZmluZCB0aGUgbWluaW1hbCBtYXgoVyxIKSB0aGF0IGZ1bGZpbGxzIChXICogSCA9PSB0b3RhbFNpemUpXG4gKi9cbmV4cG9ydCBjbGFzcyBBbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3kgaW1wbGVtZW50cyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF4VGV4dHVyZVNpemU6IG51bWJlcikge31cbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIC8vIHNjYWxhciB0ZW5zb3JcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWzEsIDFdO1xuICAgIH1cbiAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemU7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmJyZWFrQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGltcyBmaXRcbiAgICAgIGNvbnN0IHdzaXplID0gcHJlZnMuYnJlYWtBeGlzID49IHNoYXBlLmxlbmd0aCA/IDEgOiBzaGFwZS5zbGljZShwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgaHNpemUgPSBwcmVmcy5icmVha0F4aXMgPD0gMCA/IDEgOiBzaGFwZS5zbGljZSgwLCBwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgaWYgKHdzaXplID4gbWF4VGV4dHVyZVNpemUgfHwgaHNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAvLyBpZ25vcmUgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gY29udGludWUgd2l0aCBkZWZhdWx0IGxheW91dFxuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICdUZXh0dXJlTGF5b3V0JyxcbiAgICAgICAgICAgIGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7c2hhcGV9LCBicmVha0F4aXM6JHtwcmVmcy5icmVha0F4aXN9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3dzaXplLCBoc2l6ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuXG4gICAgbGV0IHdpZHRoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQodG90YWxTaXplKSk7XG5cbiAgICBmb3IgKDsgd2lkdGggPCBtYXhUZXh0dXJlU2l6ZSAmJiB3aWR0aCA8IHRvdGFsU2l6ZTsgd2lkdGgrKykge1xuICAgICAgaWYgKHRvdGFsU2l6ZSAlIHdpZHRoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWR0aCA+PSBtYXhUZXh0dXJlU2l6ZSB8fCB0b3RhbFNpemUgJSB3aWR0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gZGltZW5zaW9ucyBhcmUgb3V0c2lkZSB0aGlzIEdQVSdzIGJvdW5kYXJpZXM6ICR7c2hhcGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBbd2lkdGgsIHRvdGFsU2l6ZSAvIHdpZHRoXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJlZmVyTG9naWNhbFN0cmF0ZWd5IGltcGxlbWVudHMgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29uc3RydWN0b3IocHVibGljIG1heFRleHR1cmVTaXplOiBudW1iZXIpIHt9XG4gIGNvbXB1dGVUZXh0dXJlV0goc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCB3aCA9IHRoaXMuY29tcHV0ZVRleHR1cmUoc2hhcGUsIHByZWZzKTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQpIHtcbiAgICAgIHdoWzBdIC89IDI7XG4gICAgICB3aFsxXSAvPSAyO1xuICAgIH1cblxuICAgIHJldHVybiB3aDtcbiAgfVxuXG4gIGNvbXB1dGVUZXh0dXJlKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgaXNQYWNrZWQgPSBwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZDtcbiAgICAvLyBzY2FsYXIgdGVuc29yXG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGlzUGFja2VkID8gWzIsIDJdIDogWzEsIDFdO1xuICAgIH1cbiAgICBsZXQgbWF4VGV4dHVyZVNpemUgPSB0aGlzLm1heFRleHR1cmVTaXplO1xuICAgIGlmIChwcmVmcyAmJiBwcmVmcy5icmVha0F4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGRpbXMgZml0XG4gICAgICBjb25zdCB3c2l6ZSA9IHByZWZzLmJyZWFrQXhpcyA+PSBzaGFwZS5sZW5ndGggPyAxIDogc2hhcGUuc2xpY2UocHJlZnMuYnJlYWtBeGlzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgIGNvbnN0IGhzaXplID0gcHJlZnMuYnJlYWtBeGlzIDw9IDAgPyAxIDogc2hhcGUuc2xpY2UoMCwgcHJlZnMuYnJlYWtBeGlzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgIGlmICh3c2l6ZSA+IG1heFRleHR1cmVTaXplIHx8IGhzaXplID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgICAgLy8gaWdub3JlIHByZWZlcmVuY2VzXG4gICAgICAgIC8vIGNvbnRpbnVlIHdpdGggZGVmYXVsdCBsYXlvdXRcbiAgICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAnVGV4dHVyZUxheW91dCcsXG4gICAgICAgICAgICBgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3NoYXBlfSwgYnJlYWtBeGlzOiR7cHJlZnMuYnJlYWtBeGlzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt3c2l6ZSwgaHNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbG9nU2hhcGUgPSBzaGFwZS5zbGljZSgwKTtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIG1heFRleHR1cmVTaXplID0gbWF4VGV4dHVyZVNpemUgKiAyO1xuXG4gICAgICAvLyBUaGlzIGxvZ2ljIGVuc3VyZXMgd2UgYWNjdXJhdGVseSBjb3VudCB0aGUgbnVtYmVyIG9mIHBhY2tlZCB0ZXhlbHMgbmVlZGVkXG4gICAgICAvLyB0byBhY2NvbW1vZGF0ZSB0aGUgdGVuc29yLiBXZSBjYW4gb25seSBwYWNrIHZhbHVlcyBpbiB0aGUgc2FtZSB0ZXhlbCBpZlxuICAgICAgLy8gdGhleSBhcmUgZnJvbSBhZGphY2VudCBwYWlycyBvZiByb3dzL2NvbHMgd2l0aGluIHRoZSBzYW1lIGJhdGNoLiBTbyBpZiBhXG4gICAgICAvLyB0ZW5zb3IgaGFzIDMgcm93cywgd2UgcHJldGVuZCBpdCBoYXMgNCByb3dzIGluIG9yZGVyIHRvIGFjY291bnQgZm9yIHRoZVxuICAgICAgLy8gZmFjdCB0aGF0IHRoZSB0ZXhlbHMgY29udGFpbmluZyB0aGUgdGhpcmQgcm93IGFyZSBoYWxmIGVtcHR5LlxuICAgICAgbG9nU2hhcGUgPSBsb2dTaGFwZS5tYXAoXG4gICAgICAgICAgKGQsIGkpID0+IGkgPj0gbG9nU2hhcGUubGVuZ3RoIC0gMiA/IChsb2dTaGFwZVtpXSAlIDIgPT09IDAgPyBsb2dTaGFwZVtpXSA6IGxvZ1NoYXBlW2ldICsgMSkgOiBsb2dTaGFwZVtpXSk7XG5cbiAgICAgIC8vIFBhY2tlZCB0ZXh0dXJlIGhlaWdodCBpcyBhdCBsZWFzdCAyICh0aGUgY2hhbm5lbCBoZWlnaHQgb2YgYSBzaW5nbGVcbiAgICAgIC8vIHRleGVsKS5cbiAgICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbG9nU2hhcGUgPSBbMiwgbG9nU2hhcGVbMF1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGxvZ2ljYWwgc2hhcGUgaXMgMiwgd2UgZG9uJ3Qgc3F1ZWV6ZSwgc2luY2Ugd2Ugd2FudCB0byBtYXRjaCBwaHlzaWNhbC5cbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICBjb25zdCBzcXVlZXplUmVzdWx0ID0gc3F1ZWV6ZVNoYXBlKGxvZ1NoYXBlKTtcbiAgICAgIGxvZ1NoYXBlID0gc3F1ZWV6ZVJlc3VsdC5uZXdTaGFwZTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gc2l6ZUZyb21TaGFwZShsb2dTaGFwZSk7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCA8PSAxICYmIHNpemUgPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbMSwgc2l6ZV07XG4gICAgfSBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDIgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMV0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBsb2dTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gPD0gbWF4VGV4dHVyZVNpemUgJiYgbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSwgbG9nU2hhcGVbMl1dO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl1dO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSAqIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gPD0gbWF4VGV4dHVyZVNpemUgJiZcbiAgICAgICAgbG9nU2hhcGVbM10gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdLCBsb2dTaGFwZVszXV07XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgbG9nU2hhcGUubGVuZ3RoID09PSA0ICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleHR1cmVTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSAqIGxvZ1NoYXBlWzNdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIC8vIEZvciBwYWNrZWQgdGV4dHVyZXMgc2l6ZSBlcXVhbHMgdGhlIG51bWJlciBvZiBjaGFubmVscyByZXF1aXJlZCB0b1xuICAgICAgICAvLyBhY2NvbW1vZGF0ZSB0aGUgdGV4dHVyZSBkYXRhLiBIb3dldmVyIGluIG9yZGVyIHRvIHNxdWFyaWZ5IHN1Y2ggdGhhdFxuICAgICAgICAvLyBpbm5lciBkaW1lbnNpb25zIHN0YXkgZXZlbiwgd2UgcmV3cml0ZSBzaXplIHRvIGVxdWFsIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gdGV4ZWxzLiBUaGVuIGluIHRoZSByZXR1cm4gc3RhdGVtZW50IHdlIHJlaHlkcmF0ZSB0aGUgc3F1YXJpZmllZFxuICAgICAgICAvLyBkaW1lbnNpb25zIHRvIGNoYW5uZWwgdW5pdHMuXG4gICAgICAgIHJldHVybiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUgLyA0KS5tYXAoZCA9PiBkICogMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3F1ZWV6ZVNoYXBlKHNoYXBlOiBudW1iZXJbXSwgYXhpcz86IG51bWJlcltdKToge25ld1NoYXBlOiBudW1iZXJbXTsga2VwdERpbXM6IG51bWJlcltdfSB7XG4gIGNvbnN0IG5ld1NoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBrZXB0RGltczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaXNFbXB0eUFycmF5ID0gYXhpcyAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkoYXhpcykgJiYgYXhpcy5sZW5ndGggPT09IDA7XG4gIGNvbnN0IGF4ZXMgPSAoYXhpcyA9PSBudWxsIHx8IGlzRW1wdHlBcnJheSkgPyBudWxsIDogcGFyc2VBeGlzUGFyYW0oYXhpcywgc2hhcGUpLnNvcnQoKTtcbiAgbGV0IGogPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGF4ZXMgIT0gbnVsbCkge1xuICAgICAgaWYgKGF4ZXNbal0gPT09IGkgJiYgc2hhcGVbaV0gIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHtpfSBzaW5jZSBpdHMgZGltICcke3NoYXBlW2ldfScgaXMgbm90IDFgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoYXhlc1tqXSA9PSBudWxsIHx8IGF4ZXNbal0gPiBpKSAmJiBzaGFwZVtpXSA9PT0gMSkge1xuICAgICAgICBuZXdTaGFwZS5wdXNoKHNoYXBlW2ldKTtcbiAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgIH1cbiAgICAgIGlmIChheGVzW2pdIDw9IGkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hhcGVbaV0gIT09IDEpIHtcbiAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtuZXdTaGFwZSwga2VwdERpbXN9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBeGlzUGFyYW0oYXhpczogbnVtYmVyfG51bWJlcltdLCBzaGFwZTogbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgLy8gTm9ybWFsaXplIGlucHV0XG4gIGF4aXMgPSBheGlzID09IG51bGwgPyBzaGFwZS5tYXAoKHMsIGkpID0+IGkpIDogKFtdIGFzIG51bWJlcltdKS5jb25jYXQoYXhpcyk7XG5cbiAgLy8gQ2hlY2sgZm9yIHZhbGlkIHJhbmdlXG4gIGFzc2VydChcbiAgICAgIGF4aXMuZXZlcnkoYXggPT4gYXggPj0gLXJhbmsgJiYgYXggPCByYW5rKSxcbiAgICAgICgpID0+IGBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLSR7cmFua30sICR7cmFua30pIGJ1dCBgICtcbiAgICAgICAgICBgZ290IGF4aXMgJHtheGlzfWApO1xuXG4gIC8vIENoZWNrIGZvciBvbmx5IGludGVnZXJzXG4gIGFzc2VydChcbiAgICAgIGF4aXMuZXZlcnkoaXNJbnQpLFxuICAgICAgKCkgPT4gJ0FsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGludGVnZXJzIGJ1dCAnICtcbiAgICAgICAgICBgZ290IGF4aXMgJHtheGlzfWApO1xuXG4gIC8vIEhhbmRsZSBuZWdhdGl2ZSBheGlzLlxuICByZXR1cm4gYXhpcy5tYXAoYSA9PiBhIDwgMCA/IHJhbmsgKyBhIDogYSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNJbnQoYTogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBhICUgMSA9PT0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplRnJvbVNoYXBlKHNoYXBlOiBudW1iZXJbXSk6IG51bWJlciB7XG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBTY2FsYXIuXG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgbGV0IHNpemUgPSBzaGFwZVswXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzaGFwZS5sZW5ndGg7IGkrKykge1xuICAgIHNpemUgKj0gc2hhcGVbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Um93c0NvbHMoc2hhcGU6IG51bWJlcltdKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBFcnJvcignQ2Fubm90IGdldCByb3dzIGFuZCBjb2x1bW5zIG9mIGFuIGVtcHR5IHNoYXBlIGFycmF5LicpO1xuICB9XG5cbiAgcmV0dXJuIFtzaGFwZS5sZW5ndGggPiAxID8gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gOiAxLCBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXV07XG59XG5leHBvcnQgZnVuY3Rpb24gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KHNpemUpKTtcbiAgcmV0dXJuIFt3aWR0aCwgTWF0aC5jZWlsKHNpemUgLyB3aWR0aCldO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhdGNoRGltKHNoYXBlOiBudW1iZXJbXSwgZGltc1RvU2tpcCA9IDIpOiBudW1iZXIge1xuICByZXR1cm4gc2l6ZUZyb21TaGFwZShzaGFwZS5zbGljZSgwLCBzaGFwZS5sZW5ndGggLSBkaW1zVG9Ta2lwKSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtMb2dnZXIsIFByb2ZpbGVyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG5pbXBvcnQge0VuY29kZXJ9IGZyb20gJy4vdGV4dHVyZS1kYXRhLWVuY29kZXInO1xuaW1wb3J0IHtUZXh0dXJlTGF5b3V0U3RyYXRlZ3l9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHtUZXh0dXJlRGF0YSwgVGV4dHVyZUxheW91dH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1dlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC1jb250ZXh0JztcblxuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlTWFuYWdlckNvbmZpZyB7XG4gIHJldXNlVGV4dHVyZXM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRleHR1cmVNYW5hZ2VyIGlzIHRoZSBtYWlubHkgcmVzcG9uc2libGUgZm9yIGNhY2hpbmcgVGV4dHVyZXNcbiAqIFRleHR1cmVzIGFyZSBjYWNoZWQgaW4gMiBsZXZlbHM6XG4gKiAgIDEuIHRoZSB0ZXh1cmVzIHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggYSBkYXRhSWQgKGZyb20gVGVuc29yKVxuICogICAgQ2FjaGluZyB0aGVzZSBpcyBjcnVjaWFsIHRvIHBlcmZvcm1hbmNlLiBUaGVzZSBhcmUgSW4tdXNlIFRleHR1cmVzXG4gKiAgIDIuIHRleHR1cmVzIHdoaWNoIGFyZSBub3QgaW4gdXNlIGJ5IGFueSBjdXJyZW50IFByb2dyYW1JbmZvL1RlbnNvclxuICogICAgIFRoZXNlIGFyZSBjYWxsZWQgRnJlZSBUZXh0dXJlc1xuICogVGV4dHVyZU1hbmFnZXIgaXMgYWxzbyB1c2VkIHRvIGhlbHAgY3JlYXRpbmcgdGV4dHVyZXMuIEZvciB0aGlzIGl0XG4gKiB1c2VzIFdlYkdMQ29udGV4dCBhbmQgVGV4dHVyZUxheW91dFN0cmF0ZWd5XG4gKi9cbmV4cG9ydCBjbGFzcyBUZXh0dXJlTWFuYWdlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW5Vc2VUZXh0dXJlczogTWFwPHN0cmluZywgV2ViR0xUZXh0dXJlW10+O1xuICBwcml2YXRlIHJlYWRvbmx5IGlkbGVUZXh0dXJlczogTWFwPHN0cmluZywgV2ViR0xUZXh0dXJlW10+O1xuICBwcml2YXRlIHJlYWRvbmx5IHRleHR1cmVMb29rdXA6IE1hcDxXZWJHTFRleHR1cmUsIHN0cmluZz47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsIHB1YmxpYyBsYXlvdXRTdHJhdGVneTogVGV4dHVyZUxheW91dFN0cmF0ZWd5LCBwdWJsaWMgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPixcbiAgICAgIHByaXZhdGUgY29uZmlnOiBUZXh0dXJlTWFuYWdlckNvbmZpZykge1xuICAgIGlmIChjb25maWcucmV1c2VUZXh0dXJlcykge1xuICAgICAgdGhpcy5pblVzZVRleHR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5pZGxlVGV4dHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KFxuICAgICAgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgbGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBkYXRhPzogVGVuc29yLk51bWJlclR5cGUsIHVzYWdlPzogRW5jb2Rlci5Vc2FnZSkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhVHlwZSA9IHRoaXMudG9FbmNvZGVyVHlwZShkYXRhVHlwZSk7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5nbENvbnRleHQuZ2V0RW5jb2Rlcih0ZXh0dXJlRGF0YVR5cGUsIGxheW91dC5jaGFubmVscyB8fCAxLCB1c2FnZSk7XG4gICAgaWYgKGxheW91dC5pc1BhY2tlZCAmJiB1c2FnZSA9PT0gRW5jb2Rlci5Vc2FnZS5VcGxvYWRPbmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGxheW91dC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBsYXlvdXQuaGVpZ2h0O1xuXG4gICAgbGV0IGtleTogc3RyaW5nfHVuZGVmaW5lZDtcbiAgICBsZXQgaW5Vc2VUZXh0dXJlczogV2ViR0xUZXh0dXJlW118dW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKSB7XG4gICAgICBrZXkgPSBgJHt3aWR0aH14JHtoZWlnaHR9XyR7ZW5jb2Rlci5mb3JtYXR9XyR7ZW5jb2Rlci5pbnRlcm5hbEZvcm1hdH1fJHtlbmNvZGVyLnRleHR1cmVUeXBlfWA7XG4gICAgICBpblVzZVRleHR1cmVzID0gdGhpcy5pblVzZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgaWYgKCFpblVzZVRleHR1cmVzKSB7XG4gICAgICAgIGluVXNlVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pblVzZVRleHR1cmVzLnNldChrZXksIGluVXNlVGV4dHVyZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpZGxlVGV4dHVyZXMgPSB0aGlzLmlkbGVUZXh0dXJlcy5nZXQoa2V5KTtcbiAgICAgIGlmIChpZGxlVGV4dHVyZXMgJiYgaWRsZVRleHR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGlkbGVUZXh0dXJlcy5wb3AoKSE7XG4gICAgICAgIGluVXNlVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgaWYgKHVzYWdlID09PSBFbmNvZGVyLlVzYWdlLlVwbG9hZE9ubHkpIHtcbiAgICAgICAgICB0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGVuY29kZXIsIHRoaXMudG9UZXh0dXJlRGF0YShkYXRhVHlwZSwgZGF0YSkhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBMb2dnZXIudmVyYm9zZSgnVGV4dHVyZU1hbmFnZXInLCBgQ3JlYXRpbmcgbmV3IHRleHR1cmUgb2Ygc2l6ZSAke2xheW91dC53aWR0aH14JHtsYXlvdXQuaGVpZ2h0fWApO1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsQ29udGV4dC5hbGxvY2F0ZVRleHR1cmUod2lkdGgsIGhlaWdodCwgZW5jb2RlciwgdGhpcy50b1RleHR1cmVEYXRhKGRhdGFUeXBlLCBkYXRhKSk7XG5cbiAgICBpZiAodGhpcy5jb25maWcucmV1c2VUZXh0dXJlcykge1xuICAgICAgaW5Vc2VUZXh0dXJlcyEucHVzaCh0ZXh0dXJlKTtcbiAgICAgIHRoaXMudGV4dHVyZUxvb2t1cC5zZXQodGV4dHVyZSwga2V5ISk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG4gIHJlYWRUZXh0dXJlKHRkOiBUZXh0dXJlRGF0YSwgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgY2hhbm5lbHM/OiBudW1iZXIpOiBUZW5zb3IuTnVtYmVyVHlwZSB7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gdGQuc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYikgKiBjaGFubmVscyE7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUoXG4gICAgICAgICAgdGQudGV4dHVyZSwgdGQud2lkdGgsIHRkLmhlaWdodCwgZGF0YVNpemUsIHRoaXMudG9FbmNvZGVyVHlwZShkYXRhVHlwZSksIGNoYW5uZWxzISk7XG4gICAgICByZXR1cm4gdGhpcy50b1RlbnNvckRhdGEoZGF0YVR5cGUsIGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIHJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KHRkOiBUZXh0dXJlRGF0YSk6IEZsb2F0MzJBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnVGV4dHVyZU1hbmFnZXIucmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKHRkLnRleHR1cmUsIHRkLndpZHRoLCB0ZC5oZWlnaHQsIGRhdGFTaXplICogNCwgJ2J5dGUnLCA0KTtcbiAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFTaXplKTtcbiAgICB9KTtcbiAgfVxuICByZWxlYXNlVGV4dHVyZSh0ZXh0dXJlRGF0YTogVGV4dHVyZURhdGEsIGRlbGV0ZVRleHR1cmU/OiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IGtleTogc3RyaW5nfHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5jb25maWcucmV1c2VUZXh0dXJlcykge1xuICAgICAga2V5ID0gdGhpcy50ZXh0dXJlTG9va3VwLmdldCh0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKGRlbGV0ZVRleHR1cmUpIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmVMb29rdXAuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5Vc2VUZXh0dXJlcyA9IHRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGluVXNlVGV4dHVyZXMpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IGluVXNlVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlRGF0YS50ZXh0dXJlKTtcbiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBpblVzZVRleHR1cmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBsZXQgaWRsZVRleHR1cmVzID0gdGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoIWlkbGVUZXh0dXJlcykge1xuICAgICAgICAgICAgICBpZGxlVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgdGhpcy5pZGxlVGV4dHVyZXMuc2V0KGtleSwgaWRsZVRleHR1cmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkbGVUZXh0dXJlcy5wdXNoKHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgha2V5IHx8IGRlbGV0ZVRleHR1cmUpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdUZXh0dXJlTWFuYWdlcicsIGBEZWxldGluZyB0ZXh0dXJlIG9mIHNpemUgJHt0ZXh0dXJlRGF0YS53aWR0aH14JHt0ZXh0dXJlRGF0YS5oZWlnaHR9YCk7XG4gICAgICB0aGlzLmdsQ29udGV4dC5kZWxldGVUZXh0dXJlKHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgIH1cbiAgfVxuICB0b1RlbnNvckRhdGEoZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgZGF0YTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlKTogVGVuc29yLk51bWJlclR5cGUge1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBJbnQxNkFycmF5ID8gZGF0YSA6IEludDE2QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBJbnQzMkFycmF5ID8gZGF0YSA6IEludDMyQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDhBcnJheSA/IGRhdGEgOiBJbnQ4QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgVWludDE2QXJyYXkgPyBkYXRhIDogVWludDE2QXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgVWludDMyQXJyYXkgPyBkYXRhIDogVWludDMyQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBkYXRhIDogVWludDhBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gZGF0YSA6IEZsb2F0MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ID8gZGF0YSA6IEZsb2F0NjRBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHtkYXRhVHlwZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxuICB0b1RleHR1cmVEYXRhKGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IFRlbnNvci5OdW1iZXJUeXBlfHVuZGVmaW5lZCk6IEVuY29kZXIuRGF0YUFycmF5VHlwZXx1bmRlZmluZWQge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSA/IGRhdGEgOiBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIC8qXG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDMyQXJyYXkpID8gZGF0YSBhcyBVaW50MzJBcnJheSA6IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkgPyBkYXRhIGFzIFVpbnQ4QXJyYXkgOiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gRmxvYXQzMkFycmF5KSA/IGRhdGEgYXMgRmxvYXQzMkFycmF5IDogbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZGF0YVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgKi9cbiAgfVxuICB0b0VuY29kZXJUeXBlKF9kYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlKTogRW5jb2Rlci5EYXRhVHlwZSB7XG4gICAgcmV0dXJuICdmbG9hdCc7XG4gICAgLy8gc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIC8vICAgY2FzZSAnaW50MTYnOlxuICAgIC8vICAgY2FzZSAnaW50MzInOlxuICAgIC8vICAgY2FzZSAndWludDE2JzpcbiAgICAvLyAgIGNhc2UgJ3VpbnQzMic6XG4gICAgLy8gICAgIHJldHVybiAnaW50JztcbiAgICAvLyAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAvLyAgIGNhc2UgJ2Jvb2wnOlxuICAgIC8vICAgICByZXR1cm4gJ2J5dGUnO1xuICAgIC8vICAgY2FzZSAnZmxvYXQzMic6XG4gICAgLy8gICBjYXNlICdmbG9hdDY0JzpcbiAgICAvLyAgICAgcmV0dXJuICdmbG9hdCc7XG4gICAgLy8gICBkZWZhdWx0OlxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgLy8gfVxuICB9XG4gIGNsZWFyQWN0aXZlVGV4dHVyZXMoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uLy4uL3V0aWwnO1xuLyoqXG4gKiBHaXZlbiBhIG5vbiBSR0JBIHNoYXBlIGNhbGN1bGF0ZSB0aGUgUiB2ZXJzaW9uXG4gKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIGRpbWVuc2lvbnMgYXJlIG11bHRpcGxlcyBvZiBnaXZlbiBjaGFubmVsc1xuICogTk9URTogaXQgaXMgYWx3YXlzIHRoZSBsYXN0IGRpbSB0aGF0IGdldHMgcGFja2VkLlxuICogQHBhcmFtIHVucGFja2VkU2hhcGUgb3JpZ2luYWwgc2hhcGUgdG8gY3JlYXRlIGEgcGFja2VkIHZlcnNpb24gZnJvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFja2VkU2hhcGUodW5wYWNrZWRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gIGNvbnN0IGxlbiA9IHVucGFja2VkU2hhcGUubGVuZ3RoO1xuICByZXR1cm4gdW5wYWNrZWRTaGFwZS5zbGljZSgwLCBsZW4gLSAxKS5jb25jYXQodW5wYWNrZWRTaGFwZVtsZW4gLSAxXSAvIDQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVwZWF0ZWRUcnkoXG4gICAgY2hlY2tGbjogKCkgPT4gYm9vbGVhbiwgZGVsYXlGbiA9IChfY291bnRlcjogbnVtYmVyKSA9PiAwLCBtYXhDb3VudGVyPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHRyeUNvdW50ID0gMDtcblxuICAgIGNvbnN0IHRyeUZuID0gKCkgPT4ge1xuICAgICAgaWYgKGNoZWNrRm4oKSkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5Q291bnQrKztcblxuICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBkZWxheUZuKHRyeUNvdW50KTtcblxuICAgICAgaWYgKG1heENvdW50ZXIgIT0gbnVsbCAmJiB0cnlDb3VudCA+PSBtYXhDb3VudGVyKSB7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KHRyeUZuLCBuZXh0QmFja29mZik7XG4gICAgfTtcblxuICAgIHRyeUZuKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGFuIGlucHV0IHNhbXBsZXIgbmFtZS5cbiAqIEBwYXJhbSBzYW1wbGVyTmFtZSBOYW1lIG9mIHRoZSBzYW1wbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQodHlwZW9mIHNhbXBsZXJOYW1lICE9PSAndW5kZWZpbmVkJyAmJiBzYW1wbGVyTmFtZS5sZW5ndGggIT09IDAsICgpID0+ICdlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZScpO1xuICByZXR1cm4gJ2dldCcgKyBzYW1wbGVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNhbXBsZXJOYW1lLnNsaWNlKDEpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgZnVuY3Rpb24gbmFtZSBmcm9tIGFuIGlucHV0IHNhbXBsZXIgbmFtZSBhdCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0gc2FtcGxlck5hbWUgTmFtZSBvZiB0aGUgc2FtcGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzKHNhbXBsZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQodHlwZW9mIHNhbXBsZXJOYW1lICE9PSAndW5kZWZpbmVkJyAmJiBzYW1wbGVyTmFtZS5sZW5ndGggIT09IDAsICgpID0+ICdlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZScpO1xuICByZXR1cm4gJ2dldCcgKyBzYW1wbGVyTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNhbXBsZXJOYW1lLnNsaWNlKDEpICsgJ0F0T3V0Q29vcmRzJztcbn1cblxuLyoqIFJldHVybnMgYSBuZXcgaW5wdXQgc2hhcGUgKGEgY29weSkgdGhhdCBoYXMgYSBzcXVlZXplZCBsb2dpY2FsIHNoYXBlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWVlemVJbnB1dFNoYXBlKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzcXVlZXplZFNoYXBlOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgLy8gRGVlcCBjb3B5LlxuICBsZXQgbmV3SW5wdXRTaGFwZTogbnVtYmVyW10gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpKTtcbiAgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVkU2hhcGU7XG4gIHJldHVybiBuZXdJbnB1dFNoYXBlO1xufVxuXG4vKiogUmV0dXJucyBhIGxpc3Qgb2Ygc3F1ZWV6ZWQgcGFyYW1ldGVycyBmb3Igc2hhZGVyIGZ1bmN0aW9ucyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWVlemVkUGFyYW1zKHBhcmFtczogc3RyaW5nW10sIGtlcHREaW1zOiBudW1iZXJbXSk6IHN0cmluZyB7XG4gIHJldHVybiBrZXB0RGltcy5tYXAoZCA9PiBwYXJhbXNbZF0pLmpvaW4oJywgJyk7XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBkYXRhIHR5cGUgZm9yIGRpZmZlcmVudCByYW5rcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb29yZHNEYXRhVHlwZShyYW5rOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAocmFuayA8PSAxKSB7XG4gICAgcmV0dXJuICdpbnQnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICByZXR1cm4gJ2l2ZWMyJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgcmV0dXJuICdpdmVjMyc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgIHJldHVybiAnaXZlYzQnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDUpIHtcbiAgICByZXR1cm4gJ2l2ZWM1JztcbiAgfSBlbHNlIGlmIChyYW5rID09PSA2KSB7XG4gICAgcmV0dXJuICdpdmVjNic7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYEdQVSBmb3IgcmFuayAke3Jhbmt9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG5jb25zdCBjYWNoZToge1tjb250ZXh0SWQ6IHN0cmluZ106IFdlYkdMQ29udGV4dH0gPSB7fTtcblxuLyoqXG4gKiBUaGlzIGZhY3RvcnkgZnVuY3Rpb24gY3JlYXRlcyBwcm9wZXIgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGJhc2VkIG9uXG4gKiB0aGUgY3VycmVudCBicm93c2VycyBjYXBhYmlsaXRpZXNcbiAqIFRoZSBvcmRlciBpcyBmcm9tIGhpZ2hlci9tb3N0IHJlY2VudCB2ZXJzaW9ucyB0byBtb3N0IGJhc2ljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoY29udGV4dElkPzogJ3dlYmdsJ3wnd2ViZ2wyJyk6IFdlYkdMQ29udGV4dCB7XG4gIGxldCBjb250ZXh0OiBXZWJHTENvbnRleHR8dW5kZWZpbmVkO1xuICBpZiAoKCFjb250ZXh0SWQgfHwgY29udGV4dElkID09PSAnd2ViZ2wyJykgJiYgJ3dlYmdsMicgaW4gY2FjaGUpIHtcbiAgICBjb250ZXh0ID0gY2FjaGUud2ViZ2wyO1xuICB9IGVsc2UgaWYgKCghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsJykgJiYgJ3dlYmdsJyBpbiBjYWNoZSkge1xuICAgIGNvbnRleHQgPSBjYWNoZS53ZWJnbDtcbiAgfVxuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IGNyZWF0ZU5ld1dlYkdMQ29udGV4dChjb250ZXh0SWQpO1xuICBjb250ZXh0SWQgPSBjb250ZXh0SWQgfHwgY29udGV4dC52ZXJzaW9uID09PSAxID8gJ3dlYmdsJyA6ICd3ZWJnbDInO1xuICBjb25zdCBnbCA9IGNvbnRleHQuZ2w7XG5cbiAgY2FjaGVbY29udGV4dElkXSA9IGNvbnRleHQ7XG5cbiAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgIGRlbGV0ZSBjYWNoZVtjb250ZXh0SWRdO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTENvbnRleHQoY29udGV4dElkKTtcbiAgfVxuXG4gIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gIGdsLmRpc2FibGUoZ2wuRElUSEVSKTtcbiAgZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgZ2wuZGlzYWJsZShnbC5TQU1QTEVfQ09WRVJBR0UpO1xuICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmV3V2ViR0xDb250ZXh0KGNvbnRleHRJZD86ICd3ZWJnbCd8J3dlYmdsMicpOiBXZWJHTENvbnRleHQge1xuICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgY29uc3QgY29udGV4dEF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgYWxwaGE6IGZhbHNlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZVxuICB9O1xuICBsZXQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dHxudWxsO1xuICBjb25zdCBjYSA9IGNvbnRleHRBdHRyaWJ1dGVzO1xuICBpZiAoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbDInKSB7XG4gICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgY2EpO1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKCdHbENvbnRleHRGYWN0b3J5JywgYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRleHRJZCB8fCBjb250ZXh0SWQgPT09ICd3ZWJnbCcpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGNhKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgY2EpIGFzIFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICBpZiAoZ2wpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xDb250ZXh0KGdsLCAxKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBMb2dnZXIud2FybmluZyhcbiAgICAgICAgICAgICdHbENvbnRleHRGYWN0b3J5JyxcbiAgICAgICAgICAgIGBmYWlsZWQgdG8gY3JlYXRlIFdlYkdMQ29udGV4dCB1c2luZyBjb250ZXh0SWQgJ3dlYmdsJyBvciAnZXhwZXJpbWVudGFsLXdlYmdsJy4gRXJyb3I6ICR7ZXJyfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV2ViR0wgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICByZXR1cm4gY2FudmFzO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgKiBhcyBEYXRhRW5jb2RlcnMgZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQge0RhdGFFbmNvZGVyLCBFbmNvZGVyfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7cmVwZWF0ZWRUcnl9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGFuZCB3cmFwcGVyIGFyb3VuZCBXZWJHTFJlbmRlcmluZ0NvbnRleHQgYW5kIGl0cyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTENvbnRleHQge1xuICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICB2ZXJzaW9uOiAxfDI7XG5cbiAgcHJpdmF0ZSB2ZXJ0ZXhidWZmZXI6IFdlYkdMQnVmZmVyO1xuICBwcml2YXRlIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuXG4gIC8vIFdlYkdMIGZsYWdzIGFuZCB2aXRhbCBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjogYm9vbGVhbjtcbiAgaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ6IGJvb2xlYW47XG4gIGlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZDogYm9vbGVhbjtcbiAgaXNCbGVuZFN1cHBvcnRlZDogYm9vbGVhbjtcbiAgbWF4VGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4VGV4dHVyZUltYWdlVW5pdHM6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDdWJlTWFwVGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uOiBzdHJpbmc7XG4gIC8vIHByaXZhdGUgd2ViZ2xWZW5kb3I6IHN0cmluZztcbiAgLy8gcHJpdmF0ZSB3ZWJnbFZlcnNpb246IHN0cmluZztcblxuICAvLyBXZWJHTDIgZmxhZ3MgYW5kIHZpdGFsIHBhcmFtZXRlcnNcbiAgLy8gcHJpdmF0ZSBtYXgzRFRleHR1cmVTaXplOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4QXJyYXlUZXh0dXJlTGF5ZXJzOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4Q29sb3JBdHRhY2htZW50czogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heERyYXdCdWZmZXJzOiBudW1iZXI7XG5cbiAgLy8gV2ViR0wgZXh0ZW5zaW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVGbG9hdEV4dGVuc2lvbjogT0VTX3RleHR1cmVfZmxvYXR8bnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICB0ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uOiBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0fG51bGw7XG5cbiAgLy8gV2ViR0wyIGV4dGVuc2lvbnNcbiAgY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbjogdW5rbm93bnxudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIGRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjoge1RJTUVfRUxBUFNFRF9FWFQ6IEdMZW51bTsgR1BVX0RJU0pPSU5UX0VYVDogR0xlbnVtfXxudWxsO1xuXG4gIHByaXZhdGUgZGlzcG9zZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgZnJhbWVCdWZmZXJCb3VuZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHZlcnNpb246IDF8Mikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgdGhpcy52ZXJ0ZXhidWZmZXIgPSB0aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSB0aGlzLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5xdWVyeVZpdGFsUGFyYW1ldGVycygpO1xuICB9XG5cbiAgYWxsb2NhdGVUZXh0dXJlKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBlbmNvZGVyOiBEYXRhRW5jb2RlciwgZGF0YT86IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIGNyZWF0ZSB0aGUgdGV4dHVyZVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgLy8gYmluZCB0aGUgdGV4dHVyZSBzbyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgZWZmZWN0IHRoaXMgdGV4dHVyZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGRhdGEgPyBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCkgOiBudWxsO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsICAvLyBMZXZlbCBvZiBkZXRhaWwuXG4gICAgICAgIGVuY29kZXIuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDAsICAvLyBBbHdheXMgMCBpbiBPcGVuR0wgRVMuXG4gICAgICAgIGVuY29kZXIuZm9ybWF0LCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIHJldHVybiB0ZXh0dXJlIGFzIFdlYkdMVGV4dHVyZTtcbiAgfVxuICB1cGRhdGVUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZW5jb2RlcjogRGF0YUVuY29kZXIsIGRhdGE6IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBidWZmZXIgPSBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCk7XG4gICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCwgIC8vIGxldmVsXG4gICAgICAgIDAsICAvLyB4b2Zmc2V0XG4gICAgICAgIDAsICAvLyB5b2Zmc2V0XG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGVuY29kZXIuZm9ybWF0LCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGF0dGFjaEZyYW1lYnVmZmVyKHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgLy8gTWFrZSBpdCB0aGUgdGFyZ2V0IGZvciBmcmFtZWJ1ZmZlciBvcGVyYXRpb25zIC0gaW5jbHVkaW5nIHJlbmRlcmluZy5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsXG4gICAgICAgIDApOyAgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHJlYWRUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZGF0YVNpemU6IG51bWJlciwgZGF0YVR5cGU6IEVuY29kZXIuRGF0YVR5cGUsXG4gICAgICBjaGFubmVsczogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZnJhbWVCdWZmZXJCb3VuZCkge1xuICAgICAgdGhpcy5hdHRhY2hGcmFtZWJ1ZmZlcih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihkYXRhVHlwZSwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuYWxsb2NhdGUod2lkdGggKiBoZWlnaHQpO1xuICAgIC8vIGJpbmQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsXG4gICAgICAgIDApOyAgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmcmFtZWJ1ZmZlciBpcyByZWFkeVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZW5jb2Rlci50ZXh0dXJlVHlwZSwgYnVmZmVyKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICAvLyB1bmJpbmQgRkJcbiAgICByZXR1cm4gZW5jb2Rlci5kZWNvZGUoYnVmZmVyLCBkYXRhU2l6ZSk7XG4gIH1cbiAgaXNGcmFtZWJ1ZmZlclJlYWR5KCk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IEltcGxlbWVudCBsb2dpYyB0byBjaGVjayBpZiB0aGUgZnJhbWVidWZmZXIgaXMgcmVhZHlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRBY3RpdmVUZXh0dXJlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IG4gPSBnbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5BQ1RJVkVfVEVYVFVSRSk7XG4gICAgcmV0dXJuIGBURVhUVVJFJHsobiAtIGdsLlRFWFRVUkUwKX1gO1xuICB9XG4gIGdldFRleHR1cmVCaW5kaW5nKCk6IFdlYkdMVGV4dHVyZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKTtcbiAgfVxuICBnZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG4gICAgcmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuRlJBTUVCVUZGRVJfQklORElORyk7XG4gIH1cbiAgc2V0VmVydGV4QXR0cmlidXRlcyhwb3NpdGlvbkhhbmRsZTogbnVtYmVyLCB0ZXh0dXJlQ29vcmRIYW5kbGU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uSGFuZGxlLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAwKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkhhbmRsZSk7XG4gICAgaWYgKHRleHR1cmVDb29yZEhhbmRsZSAhPT0gLTEpIHtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4dHVyZUNvb3JkSGFuZGxlLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAxMik7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXh0dXJlQ29vcmRIYW5kbGUpO1xuICAgIH1cbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBjcmVhdGVQcm9ncmFtKFxuICAgICAgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcixcbiAgICAgIGZyYWdTaGFkZXI6IFdlYkdMU2hhZGVyLFxuICAgICAgKTogV2ViR0xQcm9ncmFtIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKSE7XG5cbiAgICAvLyB0aGUgcHJvZ3JhbSBjb25zaXN0cyBvZiBvdXIgc2hhZGVyc1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnU2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuICBjb21waWxlU2hhZGVyKHNoYWRlclNvdXJjZTogc3RyaW5nLCBzaGFkZXJUeXBlOiBudW1iZXIpOiBXZWJHTFNoYWRlciB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcbiAgICBpZiAoIXNoYWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVTaGFkZXIoKSByZXR1cm5lZCBudWxsIHdpdGggdHlwZSAke3NoYWRlclR5cGV9YCk7XG4gICAgfVxuXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOiAke2dsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKX1cblNoYWRlciBzb3VyY2U6XG4ke3NoYWRlclNvdXJjZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfVxuICBkZWxldGVTaGFkZXIoc2hhZGVyOiBXZWJHTFNoYWRlcik6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gIH1cbiAgYmluZFRleHR1cmVUb1VuaWZvcm0odGV4dHVyZTogV2ViR0xUZXh0dXJlLCBwb3NpdGlvbjogbnVtYmVyLCB1bmlmb3JtSGFuZGxlOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgcG9zaXRpb24pO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtSGFuZGxlLCBwb3NpdGlvbik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgZHJhdygpOiB2b2lkIHtcbiAgICB0aGlzLmdsLmRyYXdBcnJheXModGhpcy5nbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gIH1cbiAgY2hlY2tFcnJvcigpOiB2b2lkIHtcbiAgICBpZiAoZW52LmRlYnVnKSB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICBjb25zdCBlcnJvciA9IGdsLmdldEVycm9yKCk7XG4gICAgICBsZXQgbGFiZWwgPSAnJztcbiAgICAgIHN3aXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FzZSAoZ2wuTk9fRVJST1IpOlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAoZ2wuSU5WQUxJRF9FTlVNKTpcbiAgICAgICAgICBsYWJlbCA9ICdJTlZBTElEX0VOVU0nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX1ZBTFVFKTpcbiAgICAgICAgICBsYWJlbCA9ICdJTlZBTElEX1ZBTFVFJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAoZ2wuSU5WQUxJRF9PUEVSQVRJT04pOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfT1BFUkFUSU9OJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAoZ2wuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04pOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAoZ2wuT1VUX09GX01FTU9SWSk6XG4gICAgICAgICAgbGFiZWwgPSAnT1VUX09GX01FTU9SWSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgKGdsLkNPTlRFWFRfTE9TVF9XRUJHTCk6XG4gICAgICAgICAgbGFiZWwgPSAnQ09OVEVYVF9MT1NUX1dFQkdMJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsYWJlbCA9IGBVbmtub3duIFdlYkdMIEVycm9yOiAke2Vycm9yLnRvU3RyaW5nKDE2KX1gO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGxhYmVsKTtcbiAgICB9XG4gIH1cbiAgZGVsZXRlVGV4dHVyZSh0ZXh0dXJlOiBXZWJHTFRleHR1cmUpOiB2b2lkIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gIH1cbiAgZGVsZXRlUHJvZ3JhbShwcm9ncmFtOiBXZWJHTFByb2dyYW0pOiB2b2lkIHtcbiAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gIH1cbiAgZ2V0RW5jb2RlcihkYXRhVHlwZTogRW5jb2Rlci5EYXRhVHlwZSwgY2hhbm5lbHM6IG51bWJlciwgdXNhZ2U6IEVuY29kZXIuVXNhZ2UgPSBFbmNvZGVyLlVzYWdlLkRlZmF1bHQpOiBEYXRhRW5jb2RlciB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhRW5jb2RlcnMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgaWYgKHVzYWdlID09PSBFbmNvZGVyLlVzYWdlLlVwbG9hZE9ubHkgfHwgdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLCBjaGFubmVscyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRhRW5jb2RlcnMuUkdCQUZsb2F0RGF0YUVuY29kZXIoXG4gICAgICAgICAgICAgIHRoaXMuZ2wsIGNoYW5uZWxzLCB0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24hLkhBTEZfRkxPQVRfT0VTKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgIGNhc2UgJ2J5dGUnOlxuICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5VaW50OERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgY2xlYXJBY3RpdmVUZXh0dXJlcygpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCB0aGlzLm1heFRleHR1cmVJbWFnZVVuaXRzOyArK3VuaXQpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy52ZXJ0ZXhidWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmZpbmlzaCgpO1xuICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTogRmxvYXQzMkFycmF5IHtcbiAgICAvLyBTZXRzIG9mIHgseSx6KD0wKSxzLHQgY29vcmRpbmF0ZXMuXG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgLTEuMCwgMS4wLCAgMC4wLCAwLjAsIDEuMCwgIC8vIHVwcGVyIGxlZnRcbiAgICAgIC0xLjAsIC0xLjAsIDAuMCwgMC4wLCAwLjAsICAvLyBsb3dlciBsZWZ0XG4gICAgICAxLjAsICAxLjAsICAwLjAsIDEuMCwgMS4wLCAgLy8gdXBwZXIgcmlnaHRcbiAgICAgIDEuMCwgIC0xLjAsIDAuMCwgMS4wLCAwLjAgICAvLyBsb3dlciByaWdodFxuICAgIF0pO1xuICB9XG4gIHByaXZhdGUgY3JlYXRlVmVydGV4YnVmZmVyKCk6IFdlYkdMQnVmZmVyIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlQnVmZmVyKCkgcmV0dXJuZWQgbnVsbCcpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuY3JlYXRlRGVmYXVsdEdlb21ldHJ5KCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5LCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuICBwcml2YXRlIGNyZWF0ZUZyYW1lYnVmZmVyKCk6IFdlYkdMRnJhbWVidWZmZXIge1xuICAgIGNvbnN0IGZiID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgIGlmICghZmIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlRnJhbWVidWZmZXIgcmV0dXJuZWQgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gZmI7XG4gIH1cblxuICBwcml2YXRlIHF1ZXJ5Vml0YWxQYXJhbWV0ZXJzKCk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcblxuICAgIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlciA9IHRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpO1xuICAgIHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkID0gdGhpcy5jaGVja1JlbmRlckZsb2F0MzIoKTtcbiAgICB0aGlzLmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkID0gdGhpcy5jaGVja0Zsb2F0MzJEb3dubG9hZCgpO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSAmJiAhdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uICYmICF0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIGZsb2F0MzIgYW5kIGZsb2F0MTYgVGV4dHVyZVR5cGUgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQmxlbmRTdXBwb3J0ZWQgPSAhdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQgfHwgdGhpcy5jaGVja0Zsb2F0MzJCbGVuZCgpO1xuXG4gICAgLy8gdGhpcy5tYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICB0aGlzLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgIHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIC8vIHRoaXMubWF4Q3ViZU1hcFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpO1xuICAgIC8vIHRoaXMuc2hhZGluZ0xhbmd1YWdlVmVyc2lvbiA9IGdsLmdldFBhcmFtZXRlcihnbC5TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04pO1xuICAgIC8vIHRoaXMud2ViZ2xWZW5kb3IgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVkVORE9SKTtcbiAgICAvLyB0aGlzLndlYmdsVmVyc2lvbiA9IGdsLmdldFBhcmFtZXRlcihnbC5WRVJTSU9OKTtcblxuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIC8vIHRoaXMubWF4M0RUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF8zRF9URVhUVVJFX1NJWkUpO1xuICAgICAgLy8gdGhpcy5tYXhBcnJheVRleHR1cmVMYXllcnMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfQVJSQVlfVEVYVFVSRV9MQVlFUlMpO1xuICAgICAgLy8gdGhpcy5tYXhDb2xvckF0dGFjaG1lbnRzID0gZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUFYX0NPTE9SX0FUVEFDSE1FTlRTKTtcbiAgICAgIC8vIHRoaXMubWF4RHJhd0J1ZmZlcnMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfRFJBV19CVUZGRVJTKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBnZXRFeHRlbnNpb25zKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIHRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgICB0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gPSB0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpOiBib29sZWFuIHtcbiAgICAvLyB0ZXN0IHdoZXRoZXIgRmxvYXQzMiB0ZXh0dXJlIGlzIHN1cHBvcnRlZDpcbiAgICAvLyBTVEVQLjEgY3JlYXRlIGEgZmxvYXQgdGV4dHVyZVxuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMudmVyc2lvbiA9PT0gMiA/IChnbCBhcyB1bmtub3duIGFzIHtSR0JBMzJGOiBudW1iZXJ9KS5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG4gICAgLy8gU1RFUC4yIGJpbmQgYSBmcmFtZSBidWZmZXJcbiAgICBjb25zdCBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgLy8gU1RFUC4zIGF0dGFjaCB0ZXh0dXJlIHRvIGZyYW1lYnVmZmVyXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICAvLyBTVEVQLjQgdGVzdCB3aGV0aGVyIGZyYW1lYnVmZmVyIGlzIGNvbXBsZXRlXG4gICAgY29uc3QgaXNDb21wbGV0ZSA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgIHJldHVybiBpc0NvbXBsZXRlO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja1JlbmRlckZsb2F0MzIoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgaWYgKCF0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGbG9hdDMyRG93bmxvYWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgaWYgKCF0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIEdMX0JMRU5EIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0MzJCbGVuZCgpOiBib29sZWFuIHtcbiAgICAvLyBpdCBsb29rcyBsaWtlIGN1cnJlbnRseSAoMjAxOS0wNS0wOCkgdGhlcmUgaXMgbm8gZWFzeSB3YXkgdG8gZGV0ZWN0IHdoZXRoZXIgQkxFTkQgaXMgc3VwcG9ydGVkXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54anMvaXNzdWVzLzE0NVxuXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgbGV0IHRleHR1cmU6IFdlYkdMVGV4dHVyZXxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgZnJhbWVCdWZmZXI6IFdlYkdMRnJhbWVidWZmZXJ8bnVsbHx1bmRlZmluZWQ7XG4gICAgbGV0IHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXJ8bnVsbHx1bmRlZmluZWQ7XG4gICAgbGV0IGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgcHJvZ3JhbTogV2ViR0xQcm9ncmFtfG51bGx8dW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBmcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgICAgY29uc3QgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLnZlcnNpb24gPT09IDIgPyAoZ2wgYXMgdW5rbm93biBhcyB7UkdCQTMyRjogbnVtYmVyfSkuUkdCQTMyRiA6IGdsLlJHQkE7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG5cbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcblxuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcblxuICAgICAgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgaWYgKCF2ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgJ3ZvaWQgbWFpbigpe30nKTtcbiAgICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgIGlmICghZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj12ZWM0KDAuNSk7fScpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG5cbiAgICAgIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgMSk7XG4gICAgICByZXR1cm4gZ2wuZ2V0RXJyb3IoKSA9PT0gZ2wuTk9fRVJST1I7XG5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgIGlmIChwcm9ncmFtKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICBpZiAodmVydGV4U2hhZGVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWdtZW50U2hhZGVyKSB7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhbWVCdWZmZXIpIHtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVCdWZmZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmVnaW5UaW1lcigpOiBXZWJHTFF1ZXJ5IHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcblxuICAgICAgY29uc3QgcXVlcnkgPSBnbDIuY3JlYXRlUXVlcnkoKSBhcyBXZWJHTFF1ZXJ5O1xuICAgICAgZ2wyLmJlZ2luUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgZW5kVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMiAmJiB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgY29uc3QgZXh0ID0gdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247XG4gICAgICBnbDIuZW5kUXVlcnkoZXh0LlRJTUVfRUxBUFNFRF9FWFQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGlzVGltZXJSZXN1bHRBdmFpbGFibGUocXVlcnk6IFdlYkdMUXVlcnkpOiBib29sZWFuIHtcbiAgICBsZXQgYXZhaWxhYmxlID0gZmFsc2UsIGRpc2pvaW50ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMiAmJiB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgY29uc3QgZXh0ID0gdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247XG5cbiAgICAgIGF2YWlsYWJsZSA9IGdsMi5nZXRRdWVyeVBhcmFtZXRlcihxdWVyeSwgZ2wyLlFVRVJZX1JFU1VMVF9BVkFJTEFCTEUpO1xuICAgICAgZGlzam9pbnQgPSBnbDIuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXZhaWxhYmxlICYmICFkaXNqb2ludDtcbiAgfVxuXG4gIGdldFRpbWVyUmVzdWx0KHF1ZXJ5OiBXZWJHTFF1ZXJ5KTogbnVtYmVyIHtcbiAgICBsZXQgdGltZUVsYXBzZWQgPSAwO1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIpIHtcbiAgICAgIGNvbnN0IGdsMiA9IHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIHRpbWVFbGFwc2VkID0gZ2wyLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBnbDIuUVVFUllfUkVTVUxUKTtcbiAgICAgIGdsMi5kZWxldGVRdWVyeShxdWVyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkZCB3ZWJnbCAxIGhhbmRsaW5nLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIC8vIHJldHVybiBtaWxpc2Vjb25kc1xuICAgIHJldHVybiB0aW1lRWxhcHNlZCAvIDEwMDAwMDA7XG4gIH1cblxuICBhc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHF1ZXJ5OiBXZWJHTFF1ZXJ5KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBhd2FpdCByZXBlYXRlZFRyeSgoKSA9PiB0aGlzLmlzVGltZXJSZXN1bHRBdmFpbGFibGUocXVlcnkpKTtcbiAgICByZXR1cm4gdGhpcy5nZXRUaW1lclJlc3VsdChxdWVyeSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Nlc3Npb25IYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge0xvZ2dlciwgUHJvZmlsZXJ9IGZyb20gJy4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuXG5jbGFzcyBLZXJuZWxPcCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcDogT3BlcmF0b3IsIHB1YmxpYyBub2RlOiBHcmFwaC5Ob2RlKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRXhlY3V0aW9uUGxhbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZ3JhcGg6IEdyYXBoLCBvcHM6IE9wZXJhdG9yW10sIHByaXZhdGUgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZShvcHMpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZShvcHM6IE9wZXJhdG9yW10pIHtcbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ0V4ZWN1dGlvblBsYW4uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG4gICAgICBpZiAoZ3JhcGhOb2Rlcy5sZW5ndGggIT09IG9wcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3BzID0gb3BzLm1hcCgob3AsIGkpID0+IG5ldyBLZXJuZWxPcChvcCwgZ3JhcGhOb2Rlc1tpXSkpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAvLyBsb29rIGZvciBzdGFydGVyIG5vZGUocylcbiAgICAgIHRoaXMuX3N0YXJ0ZXIgPSBbXTtcbiAgICAgIHRoaXMuX29wcy5mb3JFYWNoKChvcCwgaSkgPT4ge1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG9wLm5vZGUuaW5wdXRzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhdGhpcy5fdmFsdWVzW2lucHV0XSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGFuIGluaXRpYWxpemVkIGlucHV0XG4gICAgICAgICAgICAgICYmIHRoaXMuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCkuaW5kZXhPZihpbnB1dCkgPT09IC0xICAvLyBub3QgbW9kZWwgaW5wdXRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKGkgPT4gaS50ZW5zb3IpO1xuICB9XG5cbiAgYXN5bmMgZXhlY3V0ZShzZXNzaW9uSGFuZGxlcjogU2Vzc2lvbkhhbmRsZXIsIG1vZGVsSW5wdXRzOiBUZW5zb3JbXSk6IFByb21pc2U8VGVuc29yW10+IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdFeGVjdXRpb25QbGFuLmV4ZWN1dGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyByZXNldCBtZWRpZW0gcmVzdWx0XG4gICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgIC8vIGNyZWF0ZSBpbmZlcmVuY2UgaGFuZGxlclxuICAgICAgY29uc3QgaW5mZXJlbmNlSGFuZGxlciA9IHNlc3Npb25IYW5kbGVyLmNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKTtcblxuICAgICAgLy8gcG9wdWxhdGUgaW5wdXRzIHZhbHVlXG4gICAgICBjb25zdCBncmFwaElucHV0cyA9IHRoaXMuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCk7XG4gICAgICBpZiAobW9kZWxJbnB1dHMubGVuZ3RoICE9PSBncmFwaElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHtcbiAgICAgICAgICAgIG1vZGVsSW5wdXRzLmxlbmd0aH0gZXhwZWN0ZWQ6ICR7Z3JhcGhJbnB1dHMubGVuZ3RofWApO1xuICAgICAgfVxuXG4gICAgICBtb2RlbElucHV0cy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGdyYXBoSW5wdXRzW2ldO1xuICAgICAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5wdXQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gcHJlcGFyZSBydW5uaW5nIHNlcXVlbmNlXG4gICAgICBjb25zdCBzZXF1ZW5jZTogbnVtYmVyW10gPSB0aGlzLl9zdGFydGVyLnNsaWNlKDApO1xuXG4gICAgICAvLyBleGVjdXRpb24gaXRlcmF0aW9uc1xuICAgICAgY29uc3QgZ3JhcGhWYWx1ZXMgPSB0aGlzLmdyYXBoLmdldFZhbHVlcygpO1xuICAgICAgY29uc3QgZ3JhcGhOb2RlcyA9IHRoaXMuZ3JhcGguZ2V0Tm9kZXMoKTtcblxuICAgICAgbGV0IHJlYXIgPSAwO1xuICAgICAgd2hpbGUgKHJlYXIgPCBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdGhpc09wSW5kZXggPSBzZXF1ZW5jZVtyZWFyKytdO1xuICAgICAgICBjb25zdCB0aGlzT3AgPSB0aGlzLl9vcHNbdGhpc09wSW5kZXhdO1xuXG4gICAgICAgIC8vIGNoZWNrIGlucHV0XG4gICAgICAgIGNvbnN0IGlucHV0TGlzdCA9IHRoaXNPcC5ub2RlLmlucHV0cy5tYXAoaSA9PiB0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICBpZiAoaW5wdXRMaXN0LmluZGV4T2YodW5kZWZpbmVkKSAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke3RoaXNPcC5ub2RlfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuXG4gICAgICAgIGNvbnN0IGlucHV0VGVuc29ycyA9IGlucHV0TGlzdCBhcyBUZW5zb3JbXTtcbiAgICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAnRXhlY1BsYW4nLFxuICAgICAgICAgICAgYFJ1bmluZyBvcDoke3RoaXNPcC5ub2RlLm5hbWV9ICgke1xuICAgICAgICAgICAgICAgIGlucHV0VGVuc29ycy5tYXAoKHQsIGkpID0+IGAnJHt0aGlzT3Aubm9kZS5pbnB1dHNbaV19JzogJHt0LnR5cGV9WyR7dC5kaW1zLmpvaW4oJywnKX1dYCkuam9pbignLCAnKX0pYCk7XG5cbiAgICAgICAgY29uc3QgZXhlY05vZGVGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBvcCA9IHRoaXNPcC5vcDtcbiAgICAgICAgICBpZiAoIW9wLmNoZWNrSW5wdXRzKGlucHV0VGVuc29ycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dHMgZGV0ZWN0ZWQ7IG9wOiAke3RoaXNPcC5ub2RlLm5hbWV9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3AucnVuKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0VGVuc29ycyk7XG5cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG91dHB1dExpc3QgPSBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KCdub2RlJywgdGhpc09wLm5vZGUubmFtZSwgZXhlY05vZGVGbik7XG5cbiAgICAgICAgLy8gY2hlY2sgb3V0cHV0XG4gICAgICAgIGlmIChvdXRwdXRMaXN0Lmxlbmd0aCAhPT0gdGhpc09wLm5vZGUub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBzaXplIG9mIG91dHB1dCBkb2VzIG5vdCBtYXRjaCBtb2RlbCBkZWZpbml0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCB2YWx1ZVxuICAgICAgICBvdXRwdXRMaXN0LmZvckVhY2goKG91dHB1dCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGogPSB0aGlzT3Aubm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbal0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske2p9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHt0aGlzT3Aubm9kZS5uYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl92YWx1ZXNbal0gPSBvdXRwdXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlc29sdmUgZG93bnN0cmVhbSBub2Rlc1xuICAgICAgICBjb25zdCBkb3duc3RyZWFtTm9kZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgb3V0cHV0TGlzdC5mb3JFYWNoKChvdXRwdXQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCBqID0gdGhpc09wLm5vZGUub3V0cHV0c1tpXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnREb3duc3RyZWFtTm9kZUluZGV4IG9mIGdyYXBoVmFsdWVzW2pdLnRvKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RG93bnN0cmVhbU5vZGUgPSBncmFwaE5vZGVzW2N1cnJlbnREb3duc3RyZWFtTm9kZUluZGV4XTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgY3VycmVudERvd25zdHJlYW1Ob2RlLmlucHV0cykge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlc1trXSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgICBkb3duc3RyZWFtTm9kZXMuYWRkKGN1cnJlbnREb3duc3RyZWFtTm9kZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXF1ZW5jZS5wdXNoKC4uLmRvd25zdHJlYW1Ob2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG91dHB1dDogVGVuc29yW10gPSBbXTtcbiAgICAgIHRoaXMuZ3JhcGguZ2V0T3V0cHV0SW5kaWNlcygpLmZvckVhY2goKG91dHB1dEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRoaXNWYWx1ZSA9IHRoaXMuX3ZhbHVlc1tvdXRwdXRJbmRleF07XG4gICAgICAgIGlmICh0aGlzVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske291dHB1dEluZGV4fV0gZG9lcyBub3QgaGF2ZSB2YWx1ZWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgICAgdGhpc1ZhbHVlLmRhdGE7XG4gICAgICAgIG91dHB1dC5wdXNoKHRoaXNWYWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdFeGVjUGxhbicsICdkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlcicpO1xuICAgICAgaW5mZXJlbmNlSGFuZGxlci5kaXNwb3NlKCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICB9XG5cbiAgX3ZhbHVlczogQXJyYXk8VGVuc29yfHVuZGVmaW5lZD47XG4gIF9vcHM6IEtlcm5lbE9wW107XG4gIF9zdGFydGVyOiBudW1iZXJbXTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge29ubnh9IGZyb20gJ29ubngtcHJvdG8nO1xuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtvbm54cnVudGltZX0gZnJvbSAnLi9vcnQtc2NoZW1hL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IHtMb25nVXRpbCwgUHJvdG9VdGlsfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgR3JhcGgge1xuICBleHBvcnQgaW50ZXJmYWNlIFNoYXBlIHtcbiAgICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlVHlwZSB7XG4gICAgcmVhZG9ubHkgdGVuc29yVHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICAgIHJlYWRvbmx5IHNoYXBlOiBTaGFwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlIHtcbiAgICAvLyB0aGUgdGVuc29yIGRhdGEuIGVtcHR5IGZvciBub24taW5pdGlhbGl6ZWQgaW5wdXRzXG4gICAgcmVhZG9ubHkgdGVuc29yPzogVGVuc29yO1xuXG4gICAgLy8gaW5kZXggdG8gdGhlIE5vZGUgd2hlcmUgdGhlIHZhbHVlIGNvbWVzIGZyb20uIC0xIGZvciBpbml0aWFsaXplci5cbiAgICByZWFkb25seSBmcm9tOiBudW1iZXI7XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBOb2RlcyB3aGVyZSB0aGUgdmFsdWVzIGdvIHRvLlxuICAgIHJlYWRvbmx5IHRvOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHZhbHVlIHR5cGUgc3BlY2lmaWNhdGlvbi4gZW1wdHkgZm9yIG5vbi1pbnB1dCB2YWx1ZXMuXG4gICAgcmVhZG9ubHkgdHlwZT86IFZhbHVlVHlwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAgIC8vIG5hbWUgb2YgdGhlIG5vZGVcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvLyB0aGUgb3BlcmF0b3IgdHlwZVxuICAgIHJlYWRvbmx5IG9wVHlwZTogc3RyaW5nO1xuXG4gICAgLy8gaW5kaWNlcyB0byB0aGUgVmFsdWVzIHdoZXJlIHRoZSBpbnB1dHMgY29tZSBmcm9tLlxuICAgIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBWYWx1ZXMgd2hlcmUgdGhlIG91dHB1cyBnbyB0by5cbiAgICByZWFkb25seSBvdXRwdXRzOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHRoYXQgdXNlZCBieSB0aGUgb3BlcmF0b3JcbiAgICByZWFkb25seSBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIH1cblxuICAvKipcbiAgICogYSBUcmFuc2Zvcm1lciBpcyBhbiBpbnN0YW5jZSB0aGF0IGFsbG93cyBhbGwgcG9zc2libGUgdHJhbnNmb3JtYXRpb24gb3BlcmF0aW9ucyB0aGF0IGFwcGxpZWQgdG8gYSBncmFwaFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lciB7XG4gICAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpOiB2b2lkO1xuICAgIHJlbW92ZUFsbERyb3BvdXROb2RlcygpOiB2b2lkO1xuICAgIC8vIFRPRE86IGFkZCBnZW5lcmljIGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHRoZSBncmFwaFxuICB9XG5cbiAgLy8gYW4gaW5pdGlhbGl6ZXIgY2FuIHVzZSB0cmFuc2Zvcm1lciB0byB0cmFuc2Zvcm0gdGhlIGdyYXBoXG4gIGV4cG9ydCBpbnRlcmZhY2UgSW5pdGlhbGl6ZXIge1xuICAgIHRyYW5zZm9ybUdyYXBoKHRyYW5zZm9ybWVyOiBUcmFuc2Zvcm1lcik6IHZvaWQ7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGgge1xuICBnZXRJbnB1dEluZGljZXMoKTogcmVhZG9ubHkgbnVtYmVyW107XG4gIGdldElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW107XG4gIGdldE91dHB1dEluZGljZXMoKTogcmVhZG9ubHkgbnVtYmVyW107XG4gIGdldE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBnZXRWYWx1ZXMoKTogcmVhZG9ubHkgR3JhcGguVmFsdWVbXTtcbiAgZ2V0Tm9kZXMoKTogcmVhZG9ubHkgR3JhcGguTm9kZVtdO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlXG5leHBvcnQgY29uc3QgR3JhcGggPSB7XG4gIC8qKlxuICAgKiBjb25zdHJ1Y3QgYSBncmFwaCBmcm9tIGEgZ3JhcGggcHJvdG9idWYgdHlwZVxuICAgKi9cbiAgZnJvbTogKGdyYXBoUHJvdG86IG9ubnguSUdyYXBoUHJvdG98b3J0RmJzLkdyYXBoLCBpbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKSA9PlxuICAgICAgbmV3IEdyYXBoSW1wbChncmFwaFByb3RvLCBpbml0aWFsaXplciksXG59O1xuXG5jbGFzcyBWYWx1ZSBpbXBsZW1lbnRzIEdyYXBoLlZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWVJbmZvPzogb25ueC5JVmFsdWVJbmZvUHJvdG8pIHtcbiAgICB0aGlzLl9mcm9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RvID0gW107XG4gICAgdGhpcy50ZW5zb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50eXBlID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHZhbHVlSW5mbykge1xuICAgICAgdGhpcy50eXBlID0gUHJvdG9VdGlsLnRlbnNvclZhbHVlVHlwZUZyb21Qcm90byh2YWx1ZUluZm8udHlwZSEudGVuc29yVHlwZSEpO1xuICAgIH1cbiAgfVxuXG4gIF9mcm9tPzogbnVtYmVyOyAgLy8gLTEgcmVwcmVzZW50IGZyb20gaW5pdGlhbGl6ZXJcbiAgZ2V0IGZyb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zyb20hO1xuICB9XG4gIF90bzogbnVtYmVyW107XG4gIGdldCB0bygpIHtcbiAgICByZXR1cm4gdGhpcy5fdG87XG4gIH1cbiAgdHlwZT86IEdyYXBoLlZhbHVlVHlwZTtcbiAgdGVuc29yPzogVGVuc29yO1xufVxuXG5jbGFzcyBOb2RlIGltcGxlbWVudHMgR3JhcGguTm9kZSB7XG4gIGNvbnN0cnVjdG9yKF9ub2RlUHJvdG86IG9ubnguSU5vZGVQcm90b3xvcnRGYnMuTm9kZSwgbmFtZT86IHN0cmluZykge1xuICAgIGlmIChfbm9kZVByb3RvIGluc3RhbmNlb2Ygb25ueC5Ob2RlUHJvdG8pIHtcbiAgICAgIHRoaXMubmFtZSA9IF9ub2RlUHJvdG8ubmFtZTtcbiAgICAgIHRoaXMub3BUeXBlID0gX25vZGVQcm90by5vcFR5cGU7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKF9ub2RlUHJvdG8uYXR0cmlidXRlKTtcbiAgICB9IGVsc2UgaWYgKF9ub2RlUHJvdG8gaW5zdGFuY2VvZiBvcnRGYnMuTm9kZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZSA/PyBfbm9kZVByb3RvLm5hbWUoKSE7XG4gICAgICB0aGlzLm9wVHlwZSA9IF9ub2RlUHJvdG8ub3BUeXBlKCkhO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbmV3IEF0dHJpYnV0ZShQcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQoX25vZGVQcm90bykpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgdGhpcy5leGVjdXRlTm9kZSA9IHRydWU7XG4gIH1cblxuICBuYW1lOiBzdHJpbmc7XG4gIG9wVHlwZTogc3RyaW5nO1xuICBpbnB1dHM6IG51bWJlcltdO1xuICBvdXRwdXRzOiBudW1iZXJbXTtcbiAgYXR0cmlidXRlczogQXR0cmlidXRlO1xuICBleGVjdXRlTm9kZTogYm9vbGVhbjtcbn1cblxuY2xhc3MgR3JhcGhJbXBsIGltcGxlbWVudHMgR3JhcGgsIEdyYXBoLlRyYW5zZm9ybWVyIHtcbiAgcHJpdmF0ZSBfYWxsRGF0YTogVmFsdWVbXTtcblxuICBwcml2YXRlIF9hbGxJbnB1dEluZGljZXM6IG51bWJlcltdO1xuICBwcml2YXRlIF9hbGxJbnB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBwcml2YXRlIF9hbGxPdXRwdXRJbmRpY2VzOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBfYWxsT3V0cHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgX25vZGVzOiBOb2RlW107XG5cbiAgY29uc3RydWN0b3IoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG98b3J0RmJzLkdyYXBoLCBncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpIHtcbiAgICBpZiAoIWdyYXBoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdncmFwaCBpcyBlbXB0eScpO1xuICAgIH1cblxuICAgIC8vIGJ1aWxkIHRoZSBncmFwaCAtIHdpbGwgdGhyb3cgZXhjZXB0aW9ucyBpZiBzb21ldGhpbmcgZmF0YWwgaXMgZGV0ZWN0ZWRcbiAgICB0aGlzLmJ1aWxkR3JhcGgoZ3JhcGgpO1xuXG4gICAgLy8gZXhlY3V0ZSBhbnkgdHJhbnNmb3JtYXRpb24gbG9naWMgZm9yIHRoZSBncmFwaCAoaWYgYXBwbGljYWJsZSlcbiAgICB0aGlzLnRyYW5zZm9ybUdyYXBoKGdyYXBoSW5pdGlhbGl6ZXIpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGN5Y2xlcyBhbmQgb3RoZXIgaW5jb25zaXN0ZW5jaWVzIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIHRoaXMuY2hlY2tJc0FjeWNsaWMoKTtcbiAgfVxuXG4gIGdldElucHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlcztcbiAgfVxuXG4gIGdldElucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9hbGxJbnB1dE5hbWVzO1xuICB9XG5cbiAgZ2V0T3V0cHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbE91dHB1dEluZGljZXM7XG4gIH1cblxuICBnZXRPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzO1xuICB9XG5cbiAgZ2V0VmFsdWVzKCk6IHJlYWRvbmx5IEdyYXBoLlZhbHVlW10ge1xuICAgIHJldHVybiB0aGlzLl9hbGxEYXRhO1xuICB9XG5cbiAgZ2V0Tm9kZXMoKTogcmVhZG9ubHkgR3JhcGguTm9kZVtdIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXM7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkR3JhcGgoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG98b3J0RmJzLkdyYXBoKSB7XG4gICAgLy8gYnVpbGQgdGhlIGdyYXBoIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIGlmIChncmFwaCBpbnN0YW5jZW9mIG9ubnguR3JhcGhQcm90bykge1xuICAgICAgdGhpcy5idWlsZEdyYXBoRnJvbU9ubnhGb3JtYXQoZ3JhcGgpO1xuICAgIH0gZWxzZSBpZiAoZ3JhcGggaW5zdGFuY2VvZiBvcnRGYnMuR3JhcGgpIHtcbiAgICAgIHRoaXMuYnVpbGRHcmFwaEZyb21PcnRGb3JtYXQoZ3JhcGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHcmFwaCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICB9XG4gIHByaXZhdGUgYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGdyYXBoOiBvbm54LklHcmFwaFByb3RvKSB7XG4gICAgY29uc3QgZGF0YUluZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIHRoaXMuX2FsbERhdGEgPSBbXTtcblxuICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbElucHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxPdXRwdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcblxuICAgIGNvbnN0IG5vZGVzSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgICAvLyBzY2FuIGFsbCBpbnB1dHNcbiAgICBpZiAoIWdyYXBoLmlucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0VmFsdWVOYW1lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBvZiBncmFwaC5pbnB1dCkge1xuICAgICAgaWYgKGRhdGFJbmRpY2VzLmhhcyhpLm5hbWUhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtpLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKGkpKSAtIDE7XG4gICAgICBkYXRhSW5kaWNlcy5zZXQoaS5uYW1lISwgY3VycmVudEluZGV4KTtcbiAgICAgIGlucHV0VmFsdWVOYW1lcy5wdXNoKGkubmFtZSEpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIGluaXRpYWxpemVyc1xuICAgIGlmICghZ3JhcGguaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5pdGlhbGl6ZXInKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpIG9mIGdyYXBoLmluaXRpYWxpemVyKSB7XG4gICAgICBsZXQgaW5kZXggPSBkYXRhSW5kaWNlcy5nZXQoaS5uYW1lISk7XG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBWYWx1ZSgpO1xuICAgICAgICB2YWx1ZS50eXBlID0ge1xuICAgICAgICAgIHNoYXBlOiB7ZGltczogUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8oaS5kaW1zISl9LFxuICAgICAgICAgIHRlbnNvclR5cGU6IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhpLmRhdGFUeXBlISlcbiAgICAgICAgfTtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2godmFsdWUpIC0gMTtcbiAgICAgICAgZGF0YUluZGljZXMuc2V0KGkubmFtZSEsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICB0aGlzLl9hbGxEYXRhW2luZGV4XS50ZW5zb3IgPSBUZW5zb3IuZnJvbVByb3RvKGkpO1xuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgaW5wdXQgaW5kaWNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWxsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLl9hbGxEYXRhW2ldLnRlbnNvcikge1xuICAgICAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaChpKTtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXROYW1lcy5wdXNoKGlucHV0VmFsdWVOYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgb3V0cHV0c1xuICAgIGlmICghZ3JhcGgub3V0cHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG91dHB1dCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgZ3JhcGgub3V0cHV0KSB7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGkubmFtZSEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBvdXRwdXQgbmFtZTogJHtpLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKGkpKSAtIDE7XG4gICAgICBkYXRhSW5kaWNlcy5zZXQoaS5uYW1lISwgY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXMucHVzaChjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0TmFtZXMucHVzaChpLm5hbWUhKTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBub2Rlc1xuICAgIGlmICghZ3JhcGgubm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBub2RlJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZVByb3RvIG9mIGdyYXBoLm5vZGUpIHtcbiAgICAgIGlmICghbm9kZVByb3RvLm5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIGEgbmFtZSB0byB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgIGZvciAobGV0IHBpY2sgPSAwOzsgcGljaysrKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGB1bm5hbWVkXyR7bm9kZVByb3RvLm9wVHlwZX1fJHtwaWNrfWA7XG4gICAgICAgICAgaWYgKCFub2Rlc0luZGljZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBub2RlUHJvdG8ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzSW5kaWNlcy5oYXMobm9kZVByb3RvLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9ub2Rlcy5wdXNoKG5ldyBOb2RlKG5vZGVQcm90bykpIC0gMTtcbiAgICAgIG5vZGVzSW5kaWNlcy5zZXQobm9kZVByb3RvLm5hbWUsIGN1cnJlbnRJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBub2RlJ3Mgb3V0cHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVbaV07XG4gICAgICBpZiAoIW5vZGVQcm90by5vdXRwdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG5vZGVQcm90by5vdXRwdXQpIHtcbiAgICAgICAgbGV0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChvdXRwdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkYXRhSW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgICAgICBkYXRhSW5kaWNlcy5zZXQob3V0cHV0LCBkYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUub3V0cHV0cy5wdXNoKGRhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7ZGF0YUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSA9IGk7XG5cbiAgICAgICAgLy8gZm9yIHRoZSAnQ29uc3RhbnQnIG9wZXJhdG9yLCBqdXN0IGNyZWF0ZSBhIG5ldyBlZGdlIGluIHRoZSBncmFwaCBjb3JyZXNwb25kaW5nIHRvIHRoZSAnb3V0cHV0JyBvZiB0aGVcbiAgICAgICAgLy8gb3BlcmF0b3IgYW5kIGlnbm9yZSB0aGUgbm9kZSBmcm9tIHRoZSBncmFwaFxuICAgICAgICBpZiAobm9kZVByb3RvLm9wVHlwZSA9PT0gJ0NvbnN0YW50Jykge1xuICAgICAgICAgIGlmICghbm9kZVByb3RvLmF0dHJpYnV0ZSB8fCBub2RlUHJvdG8uYXR0cmlidXRlLmxlbmd0aCAhPT0gMSB8fCAhbm9kZVByb3RvLmF0dHJpYnV0ZVswXS50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbm9kZVByb3RvLm91dHB1dCB8fCBub2RlUHJvdG8ub3V0cHV0Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5vdXRwdXRzLnBvcCgpO1xuICAgICAgICAgIG5vZGUuZXhlY3V0ZU5vZGUgPSBmYWxzZTtcblxuICAgICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSA9IC0xO1xuICAgICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS50ZW5zb3IgPSBUZW5zb3IuZnJvbVByb3RvKG5vZGVQcm90by5hdHRyaWJ1dGVbMF0udCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBpbnB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlW2ldO1xuXG4gICAgICBpZiAoIW5vZGVQcm90by5pbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIG5vZGVQcm90by5pbnB1dCkge1xuICAgICAgICBjb25zdCBkYXRhSW5kZXggPSBkYXRhSW5kaWNlcy5nZXQoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBpbnB1dCAnJHtpbnB1dH0nIGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuaW5wdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX3RvLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KGdyYXBoOiBvcnRGYnMuR3JhcGgpIHtcbiAgICBjb25zdCBkYXRhSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgdGhpcy5fYWxsRGF0YSA9IFtdO1xuXG4gICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsSW5wdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuXG4gICAgY29uc3Qgbm9kZXNJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAgIC8vIHNjYW4gYWxsIGlucHV0c1xuICAgIGNvbnN0IGlucHV0VmFsdWVOYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGguaW5wdXRzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3QgaW5wdXROYW1lID0gZ3JhcGguaW5wdXRzKGkpO1xuICAgICAgaWYgKGRhdGFJbmRpY2VzLmhhcyhpbnB1dE5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBpbnB1dCBuYW1lOiAke2lucHV0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIEZpbmQgdGhlIGlucHV0IHR5cGVJbmZvIGZyb20gbm9kZWFyZ3NcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ3JhcGgubm9kZUFyZ3NMZW5ndGgoKTsgaisrKSB7XG4gICAgICAgIGlmIChncmFwaC5ub2RlQXJncyhqKT8ubmFtZSgpID09PSBpbnB1dE5hbWUpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBWYWx1ZSgpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGdyYXBoLm5vZGVBcmdzKGopPy50eXBlKCk/LnZhbHVlVHlwZSgpO1xuICAgICAgICAgIGlmICh2YWx1ZVR5cGUgIT09IG9ydEZicy5UeXBlSW5mb1ZhbHVlLnRlbnNvcl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdmFsdWUgdHlwZSBmb3IgdGhlIG5vZGVBcmcuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZhbHVlSW5mbyA9IGdyYXBoLm5vZGVBcmdzKGopIS50eXBlKCkhLnZhbHVlKG5ldyBvcnRGYnMuVGVuc29yVHlwZUFuZFNoYXBlKCkpITtcbiAgICAgICAgICBjb25zdCB0eXBlID0gUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHZhbHVlSW5mby5lbGVtVHlwZSgpKTtcbiAgICAgICAgICBjb25zdCBzaGFwZSA9IHZhbHVlSW5mby5zaGFwZSgpITtcbiAgICAgICAgICBjb25zdCBkaW1zID0gW107XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaGFwZS5kaW1MZW5ndGgoKSE7IGsrKykge1xuICAgICAgICAgICAgZGltcy5wdXNoKExvbmdVdGlsLmxvbmdUb051bWJlcihzaGFwZS5kaW0oaykhLnZhbHVlKCkhLmRpbVZhbHVlKCkhKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlLnR5cGUgPSB7c2hhcGU6IHtkaW1zfSwgdGVuc29yVHlwZTogdHlwZX07XG4gICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgICAgZGF0YUluZGljZXMuc2V0KGlucHV0TmFtZSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICBpbnB1dFZhbHVlTmFtZXMucHVzaChpbnB1dE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGluaXRpYWxpemVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGguaW5pdGlhbGl6ZXJzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZXIgPSBncmFwaC5pbml0aWFsaXplcnMoaSkhO1xuICAgICAgbGV0IGluZGV4ID0gZGF0YUluZGljZXMuZ2V0KGluaXRpYWxpemVyLm5hbWUoKSEpO1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgY29uc3QgZGltcyA9IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChpbml0aWFsaXplcik7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oaW5pdGlhbGl6ZXIuZGF0YVR5cGUoKSk7XG4gICAgICAgIHZhbHVlLnR5cGUgPSB7c2hhcGU6IHtkaW1zfSwgdGVuc29yVHlwZTogdHlwZX07XG4gICAgICAgIGluZGV4ID0gdGhpcy5fYWxsRGF0YS5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICAgIGRhdGFJbmRpY2VzLnNldChpbml0aWFsaXplci5uYW1lKCkhLCBpbmRleCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbGxEYXRhW2luZGV4XS5fZnJvbSA9IC0xO1xuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0udGVuc29yID0gVGVuc29yLmZyb21PcnRUZW5zb3IoaW5pdGlhbGl6ZXIpO1xuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgaW5wdXQgaW5kaWNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYWxsRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLl9hbGxEYXRhW2ldLnRlbnNvcikge1xuICAgICAgICB0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaChpKTtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXROYW1lcy5wdXNoKGlucHV0VmFsdWVOYW1lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgb3V0cHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGgub3V0cHV0c0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IG91dHB1dE5hbWUgPSBncmFwaC5vdXRwdXRzKGkpO1xuICAgICAgaWYgKGRhdGFJbmRpY2VzLmhhcyhvdXRwdXROYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgb3V0cHV0IG5hbWU6ICR7b3V0cHV0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgZGF0YUluZGljZXMuc2V0KG91dHB1dE5hbWUsIGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLnB1c2goY3VycmVudEluZGV4KTtcbiAgICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gob3V0cHV0TmFtZSk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgbm9kZXNcbiAgICBpZiAoIWdyYXBoLm5vZGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGUnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaC5ub2Rlc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVzKGkpO1xuICAgICAgbGV0IG5hbWUgPSBub2RlUHJvdG8hLm5hbWUoKTtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAvLyBhc3NpZ24gYSBuYW1lIHRvIHRoZSBub2RlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgZm9yIChsZXQgcGljayA9IDA7OyBwaWNrKyspIHtcbiAgICAgICAgICBuYW1lID0gYHVubmFtZWRfJHtub2RlUHJvdG8hLm9wVHlwZSgpfV8ke3BpY2t9YDtcbiAgICAgICAgICBpZiAoIW5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGFuIHVuaXF1ZSBuYW1lIGlzIGZvdW5kLiBicmVhay5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNJbmRpY2VzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke25hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9ub2Rlcy5wdXNoKG5ldyBOb2RlKG5vZGVQcm90byEsIG5hbWUpKSAtIDE7XG4gICAgICBub2Rlc0luZGljZXMuc2V0KG5hbWUsIGN1cnJlbnRJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBub2RlJ3Mgb3V0cHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVzKGkpO1xuICAgICAgaWYgKG5vZGVQcm90byA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbm9kZSBleGlzdHMgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVQcm90bz8ub3V0cHV0c0xlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBvdXRwdXQgZm9yIG5vZGU6ICR7bm9kZVByb3RvLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVQcm90bz8ub3V0cHV0c0xlbmd0aCgpOyBqKyspIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbm9kZVByb3RvPy5vdXRwdXRzKGopO1xuICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXQsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5vdXRwdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHtkYXRhSW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gaTtcblxuICAgICAgICAvLyBmb3IgdGhlICdDb25zdGFudCcgb3BlcmF0b3IsIGp1c3QgY3JlYXRlIGEgbmV3IGVkZ2UgaW4gdGhlIGdyYXBoIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdvdXRwdXQnIG9mIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgaWdub3JlIHRoZSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICAgIGlmIChub2RlUHJvdG8ub3BUeXBlKCkgPT09ICdDb25zdGFudCcpIHtcbiAgICAgICAgICBpZiAobm9kZVByb3RvLmF0dHJpYnV0ZXNMZW5ndGgoKSAhPT0gMSB8fCAhbm9kZVByb3RvLmF0dHJpYnV0ZXMoMCkhLnQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGF0dHJpYnV0ZXMgb3IgbWlzc2luZyB0ZW5zb3IgdmFsdWUgaW4gYXR0cmlidXRlcyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZVByb3RvLm91dHB1dHNMZW5ndGgoKSAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5vdXRwdXRzLnBvcCgpO1xuICAgICAgICAgIG5vZGUuZXhlY3V0ZU5vZGUgPSBmYWxzZTtcblxuICAgICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSA9IC0xO1xuICAgICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS50ZW5zb3IgPSBUZW5zb3IuZnJvbU9ydFRlbnNvcihub2RlUHJvdG8uYXR0cmlidXRlcygwKSEudCgpISk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBpbnB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKSE7XG5cbiAgICAgIGlmIChub2RlUHJvdG8uaW5wdXRzTGVuZ3RoKCkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlUHJvdG8uaW5wdXRzTGVuZ3RoKCkhOyBqKyspIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBub2RlUHJvdG8uaW5wdXRzKGopITtcbiAgICAgICAgY29uc3QgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7aW5wdXR9JyBmb3Igbm9kZTogJHtub2RlUHJvdG8hLm5hbWUoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlucHV0cy5wdXNoKGRhdGFJbmRleCk7XG5cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl90by5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tJc0FjeWNsaWMoKSB7XG4gICAgLy8gZ28gdGhyb3VnaCB0aGUgZ3JhcGggYW5kIGNoZWNrIGZvciBjeWNsZXMgb3Igb3RoZXIgZmF0YWwgaW5jb25zaXN0ZW5jaWVzXG4gICAgY29uc3Qgc3RhcnRlcnM6IFNldDxudW1iZXI+ID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLmZvckVhY2goaSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5fYWxsRGF0YVtpXTtcbiAgICAgIGRhdGEuX3RvLmZvckVhY2goaiA9PiB7XG4gICAgICAgIHN0YXJ0ZXJzLmFkZChqKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSXRlcmF0aXZlIERGUyB0byBjaGVjayBmb3IgY3ljbGVzXG4gICAgY29uc3Qgbm9kZXNTdGFjayA9IEFycmF5LmZyb20oc3RhcnRlcnMpO1xuICAgIGNvbnN0IG5vZGVzU3RhdGUgPSBuZXcgQXJyYXk8c3RyaW5nPih0aGlzLl9ub2Rlcy5sZW5ndGgpLmZpbGwoJ3doaXRlJyk7XG5cbiAgICB3aGlsZSAobm9kZXNTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBub2Rlc1N0YWNrLnBvcCgpITtcbiAgICAgIC8vIHRoaXMgbm9kZSBoYXMgbm93IGJlZW4gcHJvY2Vzc2VkIGNvbXBsZXRlbHkuIE1hcmsgdGhpcyBub2RlICdibGFjaycgdG8gZGVub3RlIHRoaXMuXG4gICAgICBpZiAobm9kZXNTdGF0ZVtub2RlSW5kZXhdID09PSAnZ3JheScpIHtcbiAgICAgICAgbm9kZXNTdGF0ZVtub2RlSW5kZXhdID0gJ2JsYWNrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgbm9kZSBpcyB1bmRlciBwcm9jZXNzaW5nIHN0YWdlLiBtYXJrIHRoaXMgbm9kZSAnZ3JheScgdG8gZGVub3RlIHRoaXMuXG4gICAgICAgIG5vZGVzU3RhY2sucHVzaChub2RlSW5kZXgpO1xuICAgICAgICBub2Rlc1N0YXRlW25vZGVJbmRleF0gPSAnZ3JheSc7XG5cbiAgICAgICAgdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5vdXRwdXRzLmZvckVhY2goKG91dGdvaW5nRWRnZUluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbb3V0Z29pbmdFZGdlSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS50ZW5zb3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgb3V0cHV0cyBzaG91bGQgbm90IGJlIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLl9mcm9tICE9PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbSBwcm9wZXJ0eSBvZiB0aGUgVmFsdWUgb2JqZWN0IGRvZXNuXFwndCBtYXRjaCBpbmRleCBvZiBOb2RlIGJlaW5nIHByb2Nlc3NlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLl90by5mb3JFYWNoKChkb3duc3RyZWFtTm9kZUluZGV4KSA9PiB7XG4gICAgICAgICAgICAvLyBiYWNrIGVkZ2UgZm91bmQgLSBjeWNsaWNcbiAgICAgICAgICAgIGlmIChub2Rlc1N0YXRlW2Rvd25zdHJlYW1Ob2RlSW5kZXhdID09PSAnZ3JheScpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBncmFwaCBpcyBjeWNsaWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyZWUgZWRnZSBmb3VuZCAtIGNvbnRpbnVlIHByb2Nlc3NpbmcgYnkgYWRkaW5nIGl0IHRvIHN0YWNrXG4gICAgICAgICAgICBlbHNlIGlmIChub2Rlc1N0YXRlW2Rvd25zdHJlYW1Ob2RlSW5kZXhdID09PSAnd2hpdGUnKSB7XG4gICAgICAgICAgICAgIG5vZGVzU3RhY2sucHVzaChkb3duc3RyZWFtTm9kZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1HcmFwaChncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpOiB2b2lkIHtcbiAgICAvLyBhcHBseSBjb21tb24gdHJhbnNmb3JtXG4gICAgdGhpcy5yZW1vdmVBbGxJZGVudGl0eU5vZGVzKCk7XG4gICAgdGhpcy5yZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKTtcblxuICAgIC8vIGFwcGx5IGluaXRpYWxpemVyIHNwZWNpZmljIHRyYW5zZm9ybVxuICAgIGlmIChncmFwaEluaXRpYWxpemVyKSB7XG4gICAgICBncmFwaEluaXRpYWxpemVyLnRyYW5zZm9ybUdyYXBoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGZpbmFsaXplIGdyYXBoXG4gICAgdGhpcy5maW5hbGl6ZUdyYXBoKCk7XG4gIH1cblxuICAvKipcbiAgICogZmluYWxpemUgdGhlIGdyYXBoLlxuICAgKlxuICAgKiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHRoZSB0cmFuc2Zvcm1hdGlvbiBjb21wbGV0ZWQuXG4gICAqIHRoaXMgZnVuY3Rpb24gcmVtb3ZlcyBhbGwgdW5uZWNlc3Nhcnkgbm9kZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBncmFwaFxuICAgKi9cbiAgZmluYWxpemVHcmFwaCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAvLyBkZWxldGUgYWxsIG5vZGVzIHRoYXQgYXJlIG5vdCBiZWluZyBleGVjdXRlZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fbm9kZXNbaV0uZXhlY3V0ZU5vZGUpIHtcbiAgICAgICAgLy8gZGVsZXRlIHRoaXMgbm9kZSBhbmQgc2hpZnQgYWxsIHN1YnNlcXVlbnQgbm9kZXMgdXBcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgb3V0cHV0IHZhbHVlc1xuICAgICAgICB0aGlzLl9ub2Rlc1tpXS5vdXRwdXRzLmZvckVhY2goaW5kID0+IHtcbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2luZF0uX2Zyb20gPSAtMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX25vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgdGFibGVcbiAgICAgICAgdGhpcy5fbm9kZXNbaV0uaW5wdXRzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGluZCA9IHRoaXMuX2FsbERhdGFbdmFsdWVdLl90by5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxEYXRhW3ZhbHVlXS5fdG9baW5kXSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXNbaV0ub3V0cHV0cy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVt2YWx1ZV0uX2Zyb20gJiYgdGhpcy5fYWxsRGF0YVt2YWx1ZV0uX2Zyb20hID09PSBpICsgb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxEYXRhW3ZhbHVlXS5fZnJvbSEgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9mZnNldCA9IDA7XG4gICAgLy8gZGVsZXRlIGFsbCB2YWx1ZXMgdGhhdCBhcmUgbm90IGJlaW5nIHJlZmVyZW5jZWRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgbmVpdGhlciBsaW5rZWQgdG8gbmV4dCBub2RlLCBub3IgYW4gb3V0cHV0IHZhbHVlLCByZW1vdmUgaXQuXG4gICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS5mcm9tID09PSAtMiAmJiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2YoaSArIG9mZnNldCkgPT09IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICB0aGlzLl9hbGxEYXRhLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIGxldCBpbmQgPSAtMTtcbiAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBuZWl0aGVyIGFuIGlucHV0IHZhbHVlIG5vciBhbiBpbml0aWFsaXplciwgZmluZCB0aGUgbm9kZSBpdCdzXG4gICAgICAgIC8vIGNvbWluZyBmcm9tIGFuZCB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBvdXRwdXRcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbaV0uZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2FsbERhdGFbaV0uZnJvbSAhPT0gLTEpIHtcbiAgICAgICAgICBpbmQgPSB0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2ldLmZyb21dLm91dHB1dHMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtpXS5mcm9tXS5vdXRwdXRzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIGFuIGlucHV0IHZhbHVlLCB1cGRhdGUgaXRzIHJlZmVyZW5jZSBpbiBpbnB1dEluZGljZXNcbiAgICAgICAgICBpbmQgPSB0aGlzLl9hbGxJbnB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG5vZGUgdGhhdCB0aGUgY3VycmVudCB2YWx1ZSBpcyBsaW5raW5nIHRvIGFuZCB1cGRhdGUgaXRzIGlucHV0IHJlZmVyZW5jZVxuICAgICAgICB0aGlzLl9hbGxEYXRhW2ldLnRvLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaW5kID0gdGhpcy5fbm9kZXNbbm9kZV0uaW5wdXRzLmluZGV4T2YoaSArIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW25vZGVdLmlucHV0c1tpbmRdID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS50by5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIGEgZ3JhcGggb3V0cHV0LCB1cGRhdGUgaXRzIHJlZmVyZW5jZSBpbiBvdXRwdXRJbmRpY2VzXG4gICAgICAgICAgaW5kID0gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHNwZWNpZmVkIG5vZGUuIEFzc3VtZSB0aGUgbm9kZSBoYXMgb25seSBvbmUgaW5wdXQgYW5kIHRoZSBmaXJzdCBvdXRwdXQgY29ubmVjdGVkIHRvIG90aGVyIG5vZGVzXG4gICAqIEBwYXJhbSBub2RlSW5kZXggVGhlIGluZGV4IG9mIG5vZGUgdG8gYmUgZGVsZXRlZFxuICAgKi9cbiAgcHJpdmF0ZSBkZWxldGVOb2RlKG5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKG5vZGUuaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBkZWxldGlvbiB3aXRoIG11bHRpcGxlIGlucHV0cyBpcyBub3Qgc3VwcG9ydGVkLiAnKTtcbiAgICB9XG4gICAgaWYgKG5vZGUub3V0cHV0cy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5vZGUub3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtub2RlLm91dHB1dHNbaV1dLnRvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgZGVsZXRpb24gd2l0aCBtb3JlIHRoYW4gb25lIG91dHB1dCBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMgaXMgbm90IHN1cHBvcnRlZC4gJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aGlzIG5vZGUgd2lsIG5vdCBiZSBleGVjdXRlZFxuICAgIG5vZGUuZXhlY3V0ZU5vZGUgPSBmYWxzZTtcbiAgICBjb25zdCBpbnB1dFZhbHVlSW5kZXggPSBub2RlLmlucHV0c1swXTtcbiAgICBjb25zdCBvdXRwdXRWYWx1ZUluZGV4ID0gbm9kZS5vdXRwdXRzWzBdO1xuICAgIGNvbnN0IG5vZGVzQ29uc3VtaW5nT3V0cHV0ID0gdGhpcy5fYWxsRGF0YVtvdXRwdXRWYWx1ZUluZGV4XS50bztcblxuICAgIC8vIHJlbW92ZSB0aGlzIG5vZGUgZnJvbSB0aGUgdG8gcHJvcGVydHkgb2YgdGhlIGlucHV0IFZhbHVlXG4gICAgY29uc3QgZGVsSW5kZXggPSB0aGlzLl9hbGxEYXRhW2lucHV0VmFsdWVJbmRleF0udG8uaW5kZXhPZihub2RlSW5kZXgpO1xuICAgIC8vIHNob3VsZCBub3QgaGFwcGVuXG4gICAgaWYgKGRlbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgVmFsdWUgb2JqZWN0IGRvZXNuXFwndCBoYXZlIHRoZSBjdXJyZW50IE5vZGUgaW4gaXRcXCdzIFxcJ3RvXFwnIHByb3BlcnR5ICcpO1xuICAgIH1cbiAgICB0aGlzLl9hbGxEYXRhW2lucHV0VmFsdWVJbmRleF0udG8uc3BsaWNlKGRlbEluZGV4LCAxKTtcblxuICAgIC8vIGNsZWFyIG5vZGUgaW5kaWNlcyBjb25zdW1pbmcgdGhpcyBvdXRwdXQgVmFsdWVcbiAgICB0aGlzLl9hbGxEYXRhW291dHB1dFZhbHVlSW5kZXhdLl90byA9IFtdO1xuXG4gICAgLy8gaWYgdGhlIG91dHB1dCBvZiB0aGlzIG5vZGUgaXMgYSBncmFwaCBvdXRwdXQsIGFkanVzdCB0aGUgaW5kZXggYXBwcm9wcmlhdGVseVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKG91dHB1dFZhbHVlSW5kZXgpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXNbaW5kZXhdID0gaW5wdXRWYWx1ZUluZGV4O1xuICAgIH1cblxuICAgIC8vIG92ZXJyaWRlIHRoZSBpbnB1dHMgZm9yIG5vZGVzIGNvbnN1bWluZyB0aGlzIG5vZGUncyBvdXRwdXQgd2l0aCB0aGUgaW5wdXQgdG8gdGhpcyBub2RlXG4gICAgaWYgKG5vZGVzQ29uc3VtaW5nT3V0cHV0ICYmIG5vZGVzQ29uc3VtaW5nT3V0cHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZUluZGV4IG9mIG5vZGVzQ29uc3VtaW5nT3V0cHV0KSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VJbmRleCA9IHRoaXMuX25vZGVzW25vZGVJbmRleF0uaW5wdXRzLmluZGV4T2Yob3V0cHV0VmFsdWVJbmRleCk7XG4gICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICAgIGlmIChyZXBsYWNlSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgTm9kZSBvYmplY3QgZG9lc25cXCd0IGhhdmUgdGhlIG91dHB1dCBWYWx1ZSBpbiBpdFxcJ3MgXFwnaW5wdXRzXFwnIHByb3BlcnR5ICcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25vZGVzW25vZGVJbmRleF0uaW5wdXRzW3JlcGxhY2VJbmRleF0gPSBpbnB1dFZhbHVlSW5kZXg7XG4gICAgICAgIHRoaXMuX2FsbERhdGFbaW5wdXRWYWx1ZUluZGV4XS50by5wdXNoKG5vZGVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlQWxsRHJvcG91dE5vZGVzKCkge1xuICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLl9ub2Rlcykge1xuICAgICAgLy8gd2VlZCBvdXQgJ0Ryb3BvdXQnIG5vZGVzIHNvIHRoYXQgbm8gdGltZSBpcyB3YXN0ZWQgaW4gZXhlY3V0aW9uXG4gICAgICBpZiAobm9kZS5vcFR5cGUgPT09ICdEcm9wb3V0Jykge1xuICAgICAgICAvLyB0aGUgbm9kZSBzaG91bGQgaGF2ZSBleGFjdGx5IDEgaW5wdXQgYW5kIDEgb3IgMiBvdXRwdXRzXG4gICAgICAgIGlmIChub2RlLmlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ryb3BvdXQgbm9kZXMgc2hvdWxkIG9ubHkgY29udGFpbiBvbmUgaW5wdXQuICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLm91dHB1dHMubGVuZ3RoICE9PSAxICYmIG5vZGUub3V0cHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ryb3BvdXQgbm9kZXMgc2hvdWxkIGNvbnRhaW4gZWl0aGVyIDEgb3IgMiBvdXRwdXQocyknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc2Vjb25kIG91dHB1dCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZWQgYnkgYW55IG90aGVyIG5vZGVcbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cy5sZW5ndGggPT09IDIgJiYgdGhpcy5fYWxsRGF0YVtub2RlLm91dHB1dHNbMV1dLl90by5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Ryb3BvdXQgbm9kZXNcXCdzIHNlY29uZCBvdXRwdXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2VkIGJ5IG90aGVyIG5vZGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGVJbmRleCk7XG4gICAgICB9XG4gICAgICBub2RlSW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZW1vdmVBbGxJZGVudGl0eU5vZGVzKCkge1xuICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLl9ub2Rlcykge1xuICAgICAgLy8gd2VlZCBvdXQgJ0lkZW50aXR5JyBub2RlcyBzbyB0aGF0IG5vIHRpbWUgaXMgd2FzdGVkIGluIGV4ZWN1dGlvblxuICAgICAgaWYgKG5vZGUub3BUeXBlID09PSAnSWRlbnRpdHknKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlTm9kZShub2RlSW5kZXgpO1xuICAgICAgfVxuICAgICAgbm9kZUluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgaXNBY3RpdmF0aW9uKG46IE5vZGUpOiBib29sZWFuIHtcbiAgICBzd2l0Y2ggKG4ub3BUeXBlKSB7XG4gICAgICAvLyBUT0RPOiBhZGQgb3RoZXIgYWN0aXZhdGlvbiBtZXRob2RzXG4gICAgICBjYXNlICdSZWx1JzpcbiAgICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdXNlQ29udkFjdGl2YXRpb25Ob2RlcygpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0NvbnYnKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1swXV0uX3RvO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPT09IDEgJiYgdGhpcy5pc0FjdGl2YXRpb24odGhpcy5fbm9kZXNbbmV4dFswXV0pKSB7XG4gICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnX19pbnRlcm5hbF9hY3RpdmF0aW9uJywgJ3N0cmluZycsICh0aGlzLl9ub2Rlc1tuZXh0WzBdXS5vcFR5cGUpKTtcbiAgICAgICAgICB0aGlzLmRlbGV0ZU5vZGUobmV4dFswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgTG9nZ2VyIHtcbiAgZXhwb3J0IGludGVyZmFjZSBTZXZlcml0eVR5cGVNYXAge1xuICAgIHZlcmJvc2U6ICd2JztcbiAgICBpbmZvOiAnaSc7XG4gICAgd2FybmluZzogJ3cnO1xuICAgIGVycm9yOiAnZSc7XG4gICAgZmF0YWw6ICdmJztcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFNldmVyaXR5ID0ga2V5b2YgU2V2ZXJpdHlUeXBlTWFwO1xuXG4gIGV4cG9ydCB0eXBlIFByb3ZpZGVyID0gJ25vbmUnfCdjb25zb2xlJztcblxuICAvKipcbiAgICogTG9nZ2luZyBjb25maWcgdGhhdCB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIGxvZ2dlclxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIGxvZ2dpbmcgcHJvdmlkZXIuICdjb25zb2xlJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgcHJvdmlkZXI/OiBQcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBtaW5pbWFsIGxvZ2dlciBzZXJ2ZXJpdHkuICd3YXJuaW5nJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbWluaW1hbFNldmVyaXR5PzogTG9nZ2VyLlNldmVyaXR5O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3V0cHV0IGRhdGUgdGltZSBpbiBsb2cuIHRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ0RhdGVUaW1lPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG91dHB1dCBzb3VyY2UgaW5mb3JtYXRpb24gKE5vdCB5ZXQgc3VwcG9ydGVkKS4gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ1NvdXJjZUxvY2F0aW9uPzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcml6ZWRMb2dnZXIge1xuICAgIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICAgIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICAoY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlcjtcblxuICB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHZlcmJvc2UoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgaW5mbyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHdhcm5pbmcoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgd2FybmluZyhjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgbG9nZ2VyIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBjb25maWcgc3BlY2lmeSBhbiBvcHRpb25hbCBkZWZhdWx0IGNvbmZpZ1xuICAgKi9cbiAgcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvZ2dlcidzIGJlaGF2aW9yIG9uIHRoZSBnaXZlbiBjYXRlZ29yeVxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgc3BlY2lmeSBhIGNhdGVnb3J5IHN0cmluZy4gSWYgJyonIGlzIHNwZWNpZmllZCwgYWxsIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBvdmVyd3JpdHRlbi4gSWZcbiAgICogJycgaXMgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBjb25maWcgdGhlIGNvbmZpZyBvYmplY3QgdG8gaW5kaWNhdGUgdGhlIGxvZ2dlcidzIGJlaGF2aW9yXG4gICAqL1xuICBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZDtcblxuICAvKipcbiAgICogU2V0IHRoZSBsb2dnZXIncyBiZWhhdmlvciBmcm9tIG9ydC1jb21tb24gZW52XG4gICAqIEBwYXJhbSBlbnYgdGhlIGVudiB1c2VkIHRvIHNldCBsb2dnZXIuIEN1cnJlbnRseSBvbmx5IHNldHRpbmcgbG9nbGV2ZWwgaXMgc3VwcG9ydGVkIHRocm91Z2ggRW52LlxuICAgKi9cbiAgc2V0V2l0aEVudihlbnY6IEVudik6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBMb2dnZXJQcm92aWRlciB7XG4gIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjb250ZW50OiBzdHJpbmcsIGNhdGVnb3J5Pzogc3RyaW5nKTogdm9pZDtcbn1cbmNsYXNzIE5vT3BMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKF9zZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBfY29udGVudDogc3RyaW5nLCBfY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cbn1cbmNsYXNzIENvbnNvbGVMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY29sb3Ioc2V2ZXJpdHkpfSAke2NhdGVnb3J5ID8gJ1xceDFiWzM1bScgKyBjYXRlZ29yeSArICdcXHgxYlswbSAnIDogJyd9JHtjb250ZW50fWApO1xuICB9XG5cbiAgcHJpdmF0ZSBjb2xvcihzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5KSB7XG4gICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzQ7NDBtdlxceDFiWzBtJztcbiAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMybWlcXHgxYlswbSc7XG4gICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlszMDs0M213XFx4MWJbMG0nO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMxOzQwbWVcXHgxYlswbSc7XG4gICAgICBjYXNlICdmYXRhbCc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMTAxbWZcXHgxYlswbSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNldmVyaXR5OiAke3NldmVyaXR5fWApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRVZFUklUWV9WQUxVRSA9IHtcbiAgdmVyYm9zZTogMTAwMCxcbiAgaW5mbzogMjAwMCxcbiAgd2FybmluZzogNDAwMCxcbiAgZXJyb3I6IDUwMDAsXG4gIGZhdGFsOiA2MDAwXG59O1xuXG5jb25zdCBMT0dHRVJfUFJPVklERVJfTUFQOiB7cmVhZG9ubHkgW3Byb3ZpZGVyOiBzdHJpbmddOiBSZWFkb25seTxMb2dnZXJQcm92aWRlcj59ID0ge1xuICBbJ25vbmUnXTogbmV3IE5vT3BMb2dnZXJQcm92aWRlcigpLFxuICBbJ2NvbnNvbGUnXTogbmV3IENvbnNvbGVMb2dnZXJQcm92aWRlcigpXG59O1xuY29uc3QgTE9HR0VSX0RFRkFVTFRfQ09ORklHID0ge1xuICBwcm92aWRlcjogJ2NvbnNvbGUnLFxuICBtaW5pbWFsU2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgbG9nRGF0ZVRpbWU6IHRydWUsXG4gIGxvZ1NvdXJjZUxvY2F0aW9uOiBmYWxzZVxufTtcbmxldCBMT0dHRVJfQ09ORklHX01BUDpcbiAgICB7W2NhdGVnb3J5OiBzdHJpbmddOiBSZWFkb25seTxSZXF1aXJlZDxMb2dnZXIuQ29uZmlnPj59ID0ge1snJ106IExPR0dFUl9ERUZBVUxUX0NPTkZJRyBhcyBSZXF1aXJlZDxMb2dnZXIuQ29uZmlnPn07XG5cbmZ1bmN0aW9uIGxvZyhjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuZnVuY3Rpb24gbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG5mdW5jdGlvbiBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbmZ1bmN0aW9uIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBhcmcxOiBzdHJpbmcsIGFyZzI/OiBzdHJpbmcpOiB2b2lkO1xuZnVuY3Rpb24gbG9nKFxuICAgIGFyZzA6IHN0cmluZ3xMb2dnZXIuU2V2ZXJpdHksIGFyZzE/OiBzdHJpbmcsIGFyZzI/OiBzdHJpbmd8bnVtYmVyLCBhcmczPzogbnVtYmVyKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyfHZvaWQge1xuICBpZiAoYXJnMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKGNhdGVnb3J5OiBzdHJpbmcpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXI7XG4gICAgcmV0dXJuIGNyZWF0ZUNhdGVnb3JpemVkTG9nZ2VyKGFyZzApO1xuICB9IGVsc2UgaWYgKGFyZzIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY29udGVudCk7XG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzEsIDEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJyAmJiBhcmczID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNvbnRlbnQsIHN0YWNrKVxuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcxLCBhcmcyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZycgJiYgYXJnMyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjYXRlZ29yeSwgY29udGVudClcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMiwgMSwgYXJnMSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY2F0ZWdvcnksIGNvbnRlbnQsIHN0YWNrKVxuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcyLCBhcmczLCBhcmcxKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBpcyB2YWxpZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhdGVnb3JpemVkTG9nZ2VyKGNhdGVnb3J5OiBzdHJpbmcpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXIge1xuICByZXR1cm4ge1xuICAgIHZlcmJvc2U6IGxvZy52ZXJib3NlLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIGluZm86IGxvZy5pbmZvLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIHdhcm5pbmc6IGxvZy53YXJuaW5nLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIGVycm9yOiBsb2cuZXJyb3IuYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgZmF0YWw6IGxvZy5mYXRhbC5iaW5kKG51bGwsIGNhdGVnb3J5KVxuICB9O1xufVxuXG4vLyBOT1RFOiBhcmd1bWVudCAnY2F0ZWdvcnknIGlzIHB1dCB0aGUgbGFzdCBwYXJhbWV0ZXIgYmVhY2F1c2UgdHlwZXNjcmlwdFxuLy8gZG9lc24ndCBhbGxvdyBvcHRpb25hbCBhcmd1bWVudCBwdXQgaW4gZnJvbnQgb2YgcmVxdWlyZWQgYXJndW1lbnQuIFRoaXNcbi8vIG9yZGVyIGlzIGRpZmZlcmVudCBmcm9tIGEgdXN1YWwgbG9nZ2luZyBBUEkuXG5mdW5jdGlvbiBsb2dJbnRlcm5hbChzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjb250ZW50OiBzdHJpbmcsIHN0YWNrOiBudW1iZXIsIGNhdGVnb3J5Pzogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbmZpZyA9IExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5IHx8ICcnXSB8fCBMT0dHRVJfQ09ORklHX01BUFsnJ107XG4gIGlmIChTRVZFUklUWV9WQUxVRVtzZXZlcml0eV0gPCBTRVZFUklUWV9WQUxVRVtjb25maWcubWluaW1hbFNldmVyaXR5XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nRGF0ZVRpbWUpIHtcbiAgICBjb250ZW50ID0gYCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfXwke2NvbnRlbnR9YDtcbiAgfVxuXG4gIGlmIChjb25maWcubG9nU291cmNlTG9jYXRpb24pIHtcbiAgICAvLyBUT0RPOiBjYWxjdWxhdGUgc291cmNlIGxvY2F0aW9uIGZyb20gJ3N0YWNrJ1xuICB9XG5cbiAgTE9HR0VSX1BST1ZJREVSX01BUFtjb25maWcucHJvdmlkZXJdLmxvZyhzZXZlcml0eSwgY29udGVudCwgY2F0ZWdvcnkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxubmFtZXNwYWNlIGxvZyB7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB2ZXJib3NlKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygndmVyYm9zZScsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBpbmZvKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnaW5mbycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnd2FybmluZycsIGFyZzAsIGFyZzEpO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZXJyb3IoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGFyZzA6IHN0cmluZywgYXJnMT86IHN0cmluZykge1xuICAgIGxvZygnZXJyb3InLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGZhdGFsKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBmYXRhbChhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ2ZhdGFsJywgYXJnMCwgYXJnMSk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQge1xuICAgIExPR0dFUl9DT05GSUdfTUFQID0ge307XG4gICAgc2V0KCcnLCBjb25maWcgfHwge30pO1xuICB9XG4gIGV4cG9ydCBmdW5jdGlvbiBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZCB7XG4gICAgaWYgKGNhdGVnb3J5ID09PSAnKicpIHtcbiAgICAgIHJlc2V0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ29uZmlnID0gTE9HR0VSX0NPTkZJR19NQVBbY2F0ZWdvcnldIHx8IExPR0dFUl9ERUZBVUxUX0NPTkZJRztcbiAgICAgIExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5XSA9IHtcbiAgICAgICAgcHJvdmlkZXI6IGNvbmZpZy5wcm92aWRlciB8fCBwcmV2aW91c0NvbmZpZy5wcm92aWRlcixcbiAgICAgICAgbWluaW1hbFNldmVyaXR5OiBjb25maWcubWluaW1hbFNldmVyaXR5IHx8IHByZXZpb3VzQ29uZmlnLm1pbmltYWxTZXZlcml0eSxcbiAgICAgICAgbG9nRGF0ZVRpbWU6IChjb25maWcubG9nRGF0ZVRpbWUgPT09IHVuZGVmaW5lZCkgPyBwcmV2aW91c0NvbmZpZy5sb2dEYXRlVGltZSA6IGNvbmZpZy5sb2dEYXRlVGltZSxcbiAgICAgICAgbG9nU291cmNlTG9jYXRpb246IChjb25maWcubG9nU291cmNlTG9jYXRpb24gPT09IHVuZGVmaW5lZCkgPyBwcmV2aW91c0NvbmZpZy5sb2dTb3VyY2VMb2NhdGlvbiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmxvZ1NvdXJjZUxvY2F0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdlIHdhbnQgdG8gc3VwcG9ydCB3aWxkY2FyZCBvciByZWdleD9cbiAgfVxuXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXRXaXRoRW52KGVudjogRW52KTogdm9pZCB7XG4gICAgY29uc3QgY29uZmlnOiBMb2dnZXIuQ29uZmlnID0ge307XG4gICAgaWYgKGVudi5sb2dMZXZlbCkge1xuICAgICAgY29uZmlnLm1pbmltYWxTZXZlcml0eSA9IGVudi5sb2dMZXZlbCBhcyBMb2dnZXIuU2V2ZXJpdHk7XG4gICAgfVxuICAgIHNldCgnJywgY29uZmlnKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZSwgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgTG9nZ2VyOiBMb2dnZXIgPSBsb2c7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBQcm9maWxlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgICBtYXhOdW1iZXJFdmVudHM/OiBudW1iZXI7XG4gICAgZmx1c2hCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzPzogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRXZlbnRDYXRlZ29yeSA9ICdzZXNzaW9uJ3wnbm9kZSd8J29wJ3wnYmFja2VuZCc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG4gICAgZW5kKCk6IHZvaWR8UHJvbWlzZTx2b2lkPjtcbiAgfVxufVxuLy8gVE9ET1xuLy8gY2xhc3MgV2ViR0xFdmVudCBpbXBsZW1lbnRzIFByb2ZpbGVyLkV2ZW50IHt9XG5cbmNsYXNzIEV2ZW50IGltcGxlbWVudHMgUHJvZmlsZXIuRXZlbnQge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgcHVibGljIG5hbWU6IHN0cmluZywgcHVibGljIHN0YXJ0VGltZTogbnVtYmVyLFxuICAgICAgcHJpdmF0ZSBlbmRDYWxsYmFjazogKGU6IEV2ZW50KSA9PiB2b2lkfFByb21pc2U8dm9pZD4sIHB1YmxpYyB0aW1lcj86IFdlYkdMUXVlcnksIHB1YmxpYyBjdHg/OiBXZWJHTENvbnRleHQpIHt9XG5cbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmVuZENhbGxiYWNrKHRoaXMpO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tUaW1lcigpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICh0aGlzLmN0eCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3ZWJnbCB0aW1lciBmb3VuZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5lbmRUaW1lcigpO1xuICAgICAgcmV0dXJuIHRoaXMuY3R4LndhaXRGb3JRdWVyeUFuZEdldFRpbWUodGhpcy50aW1lcik7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEV2ZW50UmVjb3JkIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIHB1YmxpYyBuYW1lOiBzdHJpbmcsIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlciwgcHVibGljIGVuZFRpbWU6IG51bWJlcikge31cbn1cblxuZXhwb3J0IGNsYXNzIFByb2ZpbGVyIHtcbiAgc3RhdGljIGNyZWF0ZShjb25maWc/OiBQcm9maWxlci5Db25maWcpOiBQcm9maWxlciB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKGNvbmZpZy5tYXhOdW1iZXJFdmVudHMsIGNvbmZpZy5mbHVzaEJhdGNoU2l6ZSwgY29uZmlnLmZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKG1heE51bWJlckV2ZW50cz86IG51bWJlciwgZmx1c2hCYXRjaFNpemU/OiBudW1iZXIsIGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz86IG51bWJlcikge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9tYXhOdW1iZXJFdmVudHMgPSBtYXhOdW1iZXJFdmVudHMgPT09IHVuZGVmaW5lZCA/IDEwMDAwIDogbWF4TnVtYmVyRXZlbnRzO1xuICAgIHRoaXMuX2ZsdXNoQmF0Y2hTaXplID0gZmx1c2hCYXRjaFNpemUgPT09IHVuZGVmaW5lZCA/IDEwIDogZmx1c2hCYXRjaFNpemU7XG4gICAgdGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzID0gZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzID09PSB1bmRlZmluZWQgPyA1MDAwIDogZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzO1xuICB9XG5cbiAgLy8gc3RhcnQgcHJvZmlsaW5nXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RpbWluZ0V2ZW50cyA9IFtdO1xuICAgIHRoaXMuX2ZsdXNoVGltZSA9IG5vdygpO1xuICAgIHRoaXMuX2ZsdXNoUG9pbnRlciA9IDA7XG4gIH1cblxuICAvLyBzdG9wIHByb2ZpbGluZ1xuICBzdG9wKCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKDsgdGhpcy5fZmx1c2hQb2ludGVyIDwgdGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDsgdGhpcy5fZmx1c2hQb2ludGVyKyspIHtcbiAgICAgIHRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSBhbiBldmVudCBzY29wZSBmb3IgdGhlIHNwZWNpZmljIGZ1bmN0aW9uXG4gIGV2ZW50PFQ+KGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBuYW1lOiBzdHJpbmcsIGZ1bmM6ICgpID0+IFQsIGN0eD86IFdlYkdMQ29udGV4dCk6IFQ7XG4gIGV2ZW50PFQ+KGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBuYW1lOiBzdHJpbmcsIGZ1bmM6ICgpID0+IFByb21pc2U8VD4sIGN0eD86IFdlYkdMQ29udGV4dCk6IFByb21pc2U8VD47XG5cbiAgZXZlbnQ8VD4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgZnVuYzogKCkgPT4gVCB8IFByb21pc2U8VD4sIGN0eD86IFdlYkdMQ29udGV4dCk6IFRcbiAgICAgIHxQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX3N0YXJ0ZWQgPyB0aGlzLmJlZ2luKGNhdGVnb3J5LCBuYW1lLCBjdHgpIDogdW5kZWZpbmVkO1xuICAgIGxldCBpc1Byb21pc2UgPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlcyA9IGZ1bmMoKTtcblxuICAgIC8vIHdlIGNvbnNpZGVyIGEgdGhlbi1hYmxlIG9iamVjdCBpcyBhIHByb21pc2VcbiAgICBpZiAocmVzICYmIHR5cGVvZiAocmVzIGFzIFByb21pc2U8VD4pLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlzUHJvbWlzZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAocmVzIGFzIFByb21pc2U8VD4pXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICBhc3luYyB2YWx1ZSA9PiB7ICAvLyBmdWxmaWxsZWRcbiAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBldmVudC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXN5bmMgcmVhc29uID0+IHsgIC8vIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXZlbnQuZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWlzUHJvbWlzZSAmJiBldmVudCkge1xuICAgICAgY29uc3QgZXZlbnRSZXMgPSBldmVudC5lbmQoKTtcbiAgICAgIGlmIChldmVudFJlcyAmJiB0eXBlb2YgZXZlbnRSZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIChldmVudFJlcykudGhlbihcbiAgICAgICAgICAgICAgKCkgPT4geyAgLy8gZnVsZmlsbGVkXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVhc29uKSA9PiB7ICAvLyByZWplY3RlZFxuICAgICAgICAgICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBiZWdpbiBhbiBldmVudFxuICBiZWdpbihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBjdHg/OiBXZWJHTENvbnRleHQpOiBFdmVudCB7XG4gICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2ZpbGVyIGlzIG5vdCBzdGFydGVkIHlldCcpO1xuICAgIH1cbiAgICBpZiAoY3R4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgdGhpcy5mbHVzaChzdGFydFRpbWUpO1xuICAgICAgcmV0dXJuIG5ldyBFdmVudChjYXRlZ29yeSwgbmFtZSwgc3RhcnRUaW1lLCBlID0+IHRoaXMuZW5kU3luYyhlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpbWVyOiBXZWJHTFF1ZXJ5ID0gY3R4LmJlZ2luVGltZXIoKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIDAsIGFzeW5jIGUgPT4gdGhpcy5lbmQoZSksIHRpbWVyLCBjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuZCB0aGUgc3BlY2lmaWMgZXZlbnRcbiAgcHJpdmF0ZSBhc3luYyBlbmQoZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZW5kVGltZTogbnVtYmVyID0gYXdhaXQgZXZlbnQuY2hlY2tUaW1lcigpO1xuICAgIGlmICh0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoIDwgdGhpcy5fbWF4TnVtYmVyRXZlbnRzKSB7XG4gICAgICB0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgRXZlbnRSZWNvcmQoZXZlbnQuY2F0ZWdvcnksIGV2ZW50Lm5hbWUsIGV2ZW50LnN0YXJ0VGltZSwgZW5kVGltZSkpO1xuICAgICAgdGhpcy5mbHVzaChlbmRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVuZFN5bmMoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgZW5kVGltZTogbnVtYmVyID0gbm93KCk7XG4gICAgaWYgKHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGggPCB0aGlzLl9tYXhOdW1iZXJFdmVudHMpIHtcbiAgICAgIHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBFdmVudFJlY29yZChldmVudC5jYXRlZ29yeSwgZXZlbnQubmFtZSwgZXZlbnQuc3RhcnRUaW1lLCBlbmRUaW1lKSk7XG4gICAgICB0aGlzLmZsdXNoKGVuZFRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbG9nT25lRXZlbnQoZXZlbnQ6IEV2ZW50UmVjb3JkKSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgIGBQcm9maWxlci4ke2V2ZW50LmNhdGVnb3J5fWAsXG4gICAgICAgIGAkeyhldmVudC5lbmRUaW1lIC0gZXZlbnQuc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zIG9uIGV2ZW50ICcke2V2ZW50Lm5hbWV9JyBhdCAke2V2ZW50LmVuZFRpbWUudG9GaXhlZCgyKX1gKTtcbiAgfVxuXG4gIHByaXZhdGUgZmx1c2goY3VycmVudFRpbWU6IG51bWJlcikge1xuICAgIGlmICh0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoIC0gdGhpcy5fZmx1c2hQb2ludGVyID49IHRoaXMuX2ZsdXNoQmF0Y2hTaXplIHx8XG4gICAgICAgIGN1cnJlbnRUaW1lIC0gdGhpcy5fZmx1c2hUaW1lID49IHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcykge1xuICAgICAgLy8gc2hvdWxkIGZsdXNoIHdoZW4gZWl0aGVyIGJhdGNoIHNpemUgYWNjdW1sYXRlZCBvciBpbnRlcnZhbCBlbGVwc2VkXG5cbiAgICAgIGZvciAoY29uc3QgcHJldmlvdXNQb2ludGVyID0gdGhpcy5fZmx1c2hQb2ludGVyOyB0aGlzLl9mbHVzaFBvaW50ZXIgPCBwcmV2aW91c1BvaW50ZXIgKyB0aGlzLl9mbHVzaEJhdGNoU2l6ZSAmJlxuICAgICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPCB0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO1xuICAgICAgICAgICB0aGlzLl9mbHVzaFBvaW50ZXIrKykge1xuICAgICAgICB0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmx1c2hUaW1lID0gbm93KCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XG4gIH1cbiAgcHJpdmF0ZSBfc3RhcnRlZCA9IGZhbHNlO1xuICBwcml2YXRlIF90aW1pbmdFdmVudHM6IEV2ZW50UmVjb3JkW107XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfbWF4TnVtYmVyRXZlbnRzOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfZmx1c2hCYXRjaFNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBfZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfZmx1c2hUaW1lOiBudW1iZXI7XG4gIHByaXZhdGUgX2ZsdXNoUG9pbnRlciA9IDA7XG59XG5cbi8qKlxuICogcmV0dXJucyBhIG51bWJlciB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIGEgcmVzb2x1dGlvbiBhcyBoaWdoIGFzIHBvc3NpYmxlLlxuICovXG5leHBvcnQgY29uc3Qgbm93ID0gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KSA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogRGF0ZS5ub3c7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtmbGF0YnVmZmVyc30gZnJvbSAnZmxhdGJ1ZmZlcnMnO1xuaW1wb3J0IHtvbm54fSBmcm9tICdvbm54LXByb3RvJztcblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wU2V0fSBmcm9tICcuL29wc2V0JztcbmltcG9ydCB7b25ueHJ1bnRpbWV9IGZyb20gJy4vb3J0LXNjaGVtYS9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuaW1wb3J0IHtMb25nVXRpbH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGNsYXNzIE1vZGVsIHtcbiAgLy8gZW1wdHkgbW9kZWxcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIGxvYWQoYnVmOiBVaW50OEFycmF5LCBncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIsIGlzT3J0Rm9ybWF0PzogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghaXNPcnRGb3JtYXQpIHtcbiAgICAgIC8vIGlzT3J0Rm9ybWF0ID09PSBmYWxzZSB8fCBpc09ydEZvcm1hdCA9PT0gdW5kZWZpbmVkXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxvYWRGcm9tT25ueEZvcm1hdChidWYsIGdyYXBoSW5pdGlhbGl6ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc09ydEZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9hZEZyb21PcnRGb3JtYXQoYnVmLCBncmFwaEluaXRpYWxpemVyKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZEZyb21Pbm54Rm9ybWF0KGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgY29uc3QgbW9kZWxQcm90byA9IG9ubnguTW9kZWxQcm90by5kZWNvZGUoYnVmKTtcbiAgICBjb25zdCBpclZlcnNpb24gPSBMb25nVXRpbC5sb25nVG9OdW1iZXIobW9kZWxQcm90by5pclZlcnNpb24pO1xuICAgIGlmIChpclZlcnNpb24gPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49MycpO1xuICAgIH1cblxuICAgIHRoaXMuX29wc2V0cyA9XG4gICAgICAgIG1vZGVsUHJvdG8ub3BzZXRJbXBvcnQubWFwKGkgPT4gKHtkb21haW46IGkuZG9tYWluIGFzIHN0cmluZywgdmVyc2lvbjogTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKGkudmVyc2lvbiEpfSkpO1xuXG4gICAgdGhpcy5fZ3JhcGggPSBHcmFwaC5mcm9tKG1vZGVsUHJvdG8uZ3JhcGghLCBncmFwaEluaXRpYWxpemVyKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZEZyb21PcnRGb3JtYXQoYnVmOiBVaW50OEFycmF5LCBncmFwaEluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpOiB2b2lkIHtcbiAgICBjb25zdCBmYiA9IG5ldyBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKGJ1Zik7XG4gICAgY29uc3Qgb3J0TW9kZWwgPSBvcnRGYnMuSW5mZXJlbmNlU2Vzc2lvbi5nZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uKGZiKS5tb2RlbCgpITtcbiAgICBjb25zdCBpclZlcnNpb24gPSBMb25nVXRpbC5sb25nVG9OdW1iZXIob3J0TW9kZWwuaXJWZXJzaW9uKCkpO1xuICAgIGlmIChpclZlcnNpb24gPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49MycpO1xuICAgIH1cbiAgICB0aGlzLl9vcHNldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ydE1vZGVsLm9wc2V0SW1wb3J0TGVuZ3RoKCk7IGkrKykge1xuICAgICAgY29uc3Qgb3BzZXRJZCA9IG9ydE1vZGVsLm9wc2V0SW1wb3J0KGkpITtcbiAgICAgIHRoaXMuX29wc2V0cy5wdXNoKHtkb21haW46IG9wc2V0SWQ/LmRvbWFpbigpIGFzIHN0cmluZywgdmVyc2lvbjogTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG9wc2V0SWQudmVyc2lvbigpISl9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9ncmFwaCA9IEdyYXBoLmZyb20ob3J0TW9kZWwuZ3JhcGgoKSEsIGdyYXBoSW5pdGlhbGl6ZXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ3JhcGg6IEdyYXBoO1xuICBnZXQgZ3JhcGgoKTogR3JhcGgge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaDtcbiAgfVxuXG4gIHByaXZhdGUgX29wc2V0czogT3BTZXRbXTtcbiAgZ2V0IG9wc2V0cygpOiByZWFkb25seSBPcFNldFtdIHtcbiAgICByZXR1cm4gdGhpcy5fb3BzZXRzO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGludGVyZmFjZSBPcGVyYXRvciB7XG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlLCBub2RlOiBHcmFwaC5Ob2RlLCBncmFwaDogR3JhcGgpOiB2b2lkO1xuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbjtcbiAgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcbn1cblxuZXhwb3J0IGNvbnN0IE5VTUJFUl9UWVBFUzogcmVhZG9ubHkgVGVuc29yLkRhdGFUeXBlW10gPVxuICAgIFsnZmxvYXQzMicsICdmbG9hdDY0JywgJ2ludDMyJywgJ2ludDE2JywgJ2ludDgnLCAndWludDE2JywgJ3VpbnQzMicsICd1aW50OCddO1xuZXhwb3J0IGNvbnN0IElOVF9UWVBFUzogcmVhZG9ubHkgVGVuc29yLkRhdGFUeXBlW10gPSBbJ2ludDMyJywgJ2ludDE2JywgJ2ludDgnLCAndWludDE2JywgJ3VpbnQzMicsICd1aW50OCddO1xuZXhwb3J0IGNvbnN0IEZMT0FUX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9IFsnZmxvYXQzMicsICdmbG9hdDY0J107XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG4vLyBjdXJyZW50bHkgdGhpcyBvcGVyYXRvciBzdXBwb3J0cyBPTkxZICd0ZXN0JyBtb2RlXG4vLyBpbnB1dHMvb3V0cHV0cyBhbmQgcGFyYW1ldGVycyB3aWxsIHJlZmxlY3QgdGhhdFxuLy8gdGhlIG9wZXJhdG9yIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgdGVzdCBtb2RlXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmF0Y2hOb3JtYWxpemF0aW9uIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5lcHNpbG9uID0gYXR0cmlidXRlcy5nZXRGbG9hdCgnZXBzaWxvbicsIDFlLTUpO1xuICAgIHRoaXMubW9tZW50dW0gPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdtb21lbnR1bScsIDAuOSk7XG4gICAgdGhpcy5zcGF0aWFsID0gYXR0cmlidXRlcy5nZXRJbnQoJ3NwYXRpYWwnLCAxKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSA1KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBYID0gaW5wdXRzWzBdO1xuICAgIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICAgIGNvbnN0IEIgPSBpbnB1dHNbMl07XG4gICAgY29uc3QgbWVhbiA9IGlucHV0c1szXTtcbiAgICBjb25zdCB2YXJfID0gaW5wdXRzWzRdO1xuXG4gICAgLy8gaW5wdXQgc2hvdWxkIGF0bGVhc3QgaGF2ZSB0aHJlZSBkaW1lbnNpb25zIC0gTixDLGRpbTEsLi4uLGRpbW5cbiAgICAvLyBvdGhlciBpbnB1dHMgY2FuIGhhdmUgb25seSBvbmUgZGltZW5zaW9uc1xuICAgIGlmIChYLmRpbXMubGVuZ3RoIDwgMyB8fCBzY2FsZS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBCLmRpbXMubGVuZ3RoICE9PSAxIHx8IG1lYW4uZGltcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgdmFyXy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2NhbGUuZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8IEIuZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8IG1lYW4uZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8XG4gICAgICAgIHZhcl8uZGltc1swXSAhPT0gWC5kaW1zWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoWC50eXBlICE9PSAnZmxvYXQzMicgJiYgWC50eXBlICE9PSAnZmxvYXQ2NCcpIHx8IChzY2FsZS50eXBlICE9PSAnZmxvYXQzMicgJiYgc2NhbGUudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgICAoQi50eXBlICE9PSAnZmxvYXQzMicgJiYgQi50eXBlICE9PSAnZmxvYXQ2NCcpIHx8IChtZWFuLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBtZWFuLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgICAgKHZhcl8udHlwZSAhPT0gJ2Zsb2F0MzInICYmIHZhcl8udHlwZSAhPT0gJ2Zsb2F0NjQnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBlcHNpbG9uOiBudW1iZXI7XG4gIHByb3RlY3RlZCBtb21lbnR1bTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgc3BhdGlhbDogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJpbmFyeU9wIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByb3RlY3RlZCB0eXBlQ29uc3RyYWludDogcmVhZG9ubHkgVGVuc29yLkRhdGFUeXBlW10sIHByb3RlY3RlZCBvcFR5cGU/OiBzdHJpbmcsXG4gICAgICBwcm90ZWN0ZWQgcmVzdWx0VHlwZT86IFRlbnNvci5EYXRhVHlwZSkge31cblxuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudHlwZUNvbnN0cmFpbnQuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzWzFdLnR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDbGlwIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5taW4gPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdtaW4nLCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gICAgdGhpcy5tYXggPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdtYXgnLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWluOiBudW1iZXI7XG4gIHByb3RlY3RlZCBtYXg6IG51bWJlcjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb25jYXQgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4aXMgPSBhdHRyaWJ1dGVzLmdldEludCgnYXhpcycpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dHNbMF0udHlwZTtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbmFsaXR5ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuXG4gICAgLy8gVE9ETzogU3VwcG9ydCBzdHJpbmcgY29uY2F0XG4gICAgaWYgKGlucHV0VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgLy8gbWFrZSBzdXJlIHR5cGVzIG9mIGFsbCBpbnB1dHMgbWF0Y2hcbiAgICAgIGlmIChpbnB1dC50eXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggIT09IGlucHV0RGltZW5zaW9uYWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF4aXM6IG51bWJlcjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb252IGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICAgIHRoaXMuYXV0b1BhZCA9IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdhdXRvX3BhZCcsICdOT1RTRVQnKTtcbiAgICB0aGlzLmRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnZGlsYXRpb25zJywgWzEsIDFdKTtcbiAgICB0aGlzLmdyb3VwID0gYXR0cmlidXRlcy5nZXRJbnQoJ2dyb3VwJywgMSk7XG4gICAgdGhpcy5rZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMuZ2V0SW50cygna2VybmVsX3NoYXBlJywgW10pO1xuICAgIHRoaXMucGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gICAgdGhpcy5zdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgWzEsIDFdKTtcbiAgICB0aGlzLmFjdGl2YXRpb24gPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnX19pbnRlcm5hbF9hY3RpdmF0aW9uJywgJycpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gICAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICAgIC8vIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XG4gICAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gICAgY29uc3QgZGF0YUNoYW5uZWwgPSBpbnB1dHNbMF0uZGltc1sxXTtcbiAgICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1sxXSAqIHRoaXMuZ3JvdXA7XG4gICAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZiBiaWFzIGlzIHByb3ZpZGVkIGl0IHNob3VsZCBiZSAxRCBhbmQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBmZWF0dXJlIG1hcHNcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gICAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICAgIGlmICh0aGlzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgICBpZiAodGhpcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBXcm9uZyBwYWRzIGRpbWVuc2lvblxuICAgIGlmICh0aGlzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gICAgaWYgKHRoaXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIHRoaXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInIHx8IGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXV0b1BhZDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgZGlsYXRpb25zOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIGdyb3VwOiBudW1iZXI7XG4gIHByb3RlY3RlZCBrZXJuZWxTaGFwZTogbnVtYmVyW107XG4gIHByb3RlY3RlZCBwYWRzOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIHN0cmlkZXM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgYWN0aXZhdGlvbjogc3RyaW5nO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERlcHRoVG9TcGFjZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICAvLyBwcm9jZXNzaW5nIG5vZGUgYXR0cmlidXRlc1xuICAgIHRoaXMuYmxvY2tzaXplID0gYXR0cmlidXRlcy5nZXRJbnQoJ2Jsb2Nrc2l6ZScpO1xuICAgIGlmICh0aGlzLmJsb2Nrc2l6ZSA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmxvY2tzaXplIG11c3QgYmUgPj0gMSwgYnV0IGdvdCA6ICR7dGhpcy5ibG9ja3NpemV9IGZvciBEZXB0aFRvU3BhY2VgKTtcbiAgICB9XG4gICAgdGhpcy5ibG9ja3NpemVTcXIgPSB0aGlzLmJsb2Nrc2l6ZSAqIHRoaXMuYmxvY2tzaXplO1xuICAgIHRoaXMubW9kZSA9IGF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ0RDUicpO1xuICAgIGlmIChEZXB0aFRvU3BhY2Uuc3VwcG9ydGVkTW9kZXMuaW5kZXhPZih0aGlzLm1vZGUpIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHt0aGlzLm1vZGV9IGZvciBEZXB0aFRvU3BhY2VgKTtcbiAgICB9XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaW5wdXRUeXBlID0gaW5wdXRzWzBdLnR5cGU7XG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25hbGl0eSA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcblxuICAgIC8vIElucHV0IGhhcyB0byBiZSBhIDQtRCB0ZW5zb3JcbiAgICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyBkZXB0aC10by1zcGFjZS5cbiAgICBpZiAoaW5wdXRUeXBlID09PSAnc3RyaW5nJyB8fCBpbnB1dERpbWVuc2lvbmFsaXR5ICE9PSA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgbW9kZTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgYmxvY2tzaXplOiBudW1iZXI7XG4gIHByb3RlY3RlZCBibG9ja3NpemVTcXI6IG51bWJlcjtcblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBzdXBwb3J0ZWRNb2RlcyA9IFsnRENSJywgJ0NSRCddO1xufSIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEcm9wb3V0IGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5yYXRpbyA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ3JhdGlvJywgMC41KTtcbiAgICB0aGlzLnRlc3RNb2RlID0gdHJ1ZTsgIC8vIHRoaXMgaXMgYSBoYWNrIHRvIHJlZmxlY3QgdGhhdCB0ZXN0IG1vZGUgaXMgaGFyZGNvZGVkXG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJhdGlvOiBudW1iZXI7XG4gIHByb3RlY3RlZCB0ZXN0TW9kZTogYm9vbGVhbjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFbHUgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmFscGhhID0gYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAxLjApO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhbHBoYTogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZsYXR0ZW4gaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4aXMgPSBhdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDEpOyAgLy8gZGVmYXVsdCBheGlzIGlzIDFcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgciA9IGlucHV0c1swXS5kaW1zLmxlbmd0aDtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAgLy8gc2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXhpcyA8IC1yIHx8IHRoaXMuYXhpcyA+IHIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIHR5cGVcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXhpczogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2F0aGVyIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5heGlzID0gYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAwKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRlbnNvclJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gICAgaWYgKHRlbnNvclJhbmsgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXMgPCAtdGVuc29yUmFuayB8fCB0aGlzLmF4aXMgPiB0ZW5zb3JSYW5rIC0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnaW50MTYnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF4aXM6IG51bWJlcjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHZW1tIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihpc09wdGlvbmFsQzogYm9vbGVhbikge1xuICAgIHRoaXMuaXNPcHRpb25hbEMgPSBpc09wdGlvbmFsQztcbiAgfVxuXG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zQSA9IGF0dHJpYnV0ZXMuZ2V0SW50KCd0cmFuc0EnLCAwKSAhPT0gMDtcbiAgICB0aGlzLnRyYW5zQiA9IGF0dHJpYnV0ZXMuZ2V0SW50KCd0cmFuc0InLCAwKSAhPT0gMDtcbiAgICB0aGlzLmFscGhhID0gYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAxKTtcbiAgICB0aGlzLmJldGEgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdiZXRhJywgMSk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNPcHRpb25hbEMgJiYgKGlucHV0cy5sZW5ndGggPCAyIHx8IGlucHV0cy5sZW5ndGggPiAzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNPcHRpb25hbEMgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vICdDJyBjYW4gYmUgb2YgZGltZW5zaW9uYWxpdHkgMSBvciAyIG9ubHlcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgJiYgaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgICAgKGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgICAgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0NjQnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgoaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1sxXS50eXBlKSB8fCAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gaW5wdXRzWzJdLnR5cGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgdHJhbnNBOiBib29sZWFuO1xuICBwcm90ZWN0ZWQgdHJhbnNCOiBib29sZWFuO1xuICBwcm90ZWN0ZWQgYWxwaGE6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGJldGE6IG51bWJlcjtcblxuICBwcm90ZWN0ZWQgaXNPcHRpb25hbEM6IGJvb2xlYW47ICAvLyBpbiBvcHNldCAxMSwgQyBiZWNvbWVzIG9wdGlvbmFsXG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW1hZ2VTY2FsZXIgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLnNjYWxlID0gYXR0cmlidXRlcy5nZXRGbG9hdCgnc2NhbGUnKTtcbiAgICB0aGlzLmJpYXMgPSBhdHRyaWJ1dGVzLmdldEZsb2F0cygnYmlhcycpO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2NhbGU6IG51bWJlcjtcbiAgcHJvdGVjdGVkIGJpYXM6IG51bWJlcltdO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEluc3RhbmNlTm9ybWFsaXphdGlvbiBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuZXBzaWxvbiA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2Vwc2lsb24nLCAxZS01KTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBYID0gaW5wdXRzWzBdO1xuICAgIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICAgIGNvbnN0IEIgPSBpbnB1dHNbMl07XG5cbiAgICAvLyBpbnB1dCBzaG91bGQgYXRsZWFzdCBoYXZlIHRocmVlIGRpbWVuc2lvbnMgLSBOLEMsZGltMSwuLi4sZGltblxuICAgIC8vIG90aGVyIGlucHV0cyBjYW4gaGF2ZSBvbmx5IG9uZSBkaW1lbnNpb25zXG4gICAgaWYgKFguZGltcy5sZW5ndGggPCAzIHx8IHNjYWxlLmRpbXMubGVuZ3RoICE9PSAxIHx8IEIuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNjYWxlLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fCBCLmRpbXNbMF0gIT09IFguZGltc1sxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKFgudHlwZSAhPT0gJ2Zsb2F0MzInICYmIFgudHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fCAoc2NhbGUudHlwZSAhPT0gJ2Zsb2F0MzInICYmIHNjYWxlLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgICAgKEIudHlwZSAhPT0gJ2Zsb2F0MzInICYmIEIudHlwZSAhPT0gJ2Zsb2F0NjQnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBlcHNpbG9uOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTGVha3lSZWx1IGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5hbHBoYSA9IGF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMC4wMSk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFscGhhOiBudW1iZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWF0TXVsIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmF0aW9uID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ19faW50ZXJuYWxfYWN0aXZhdGlvbicsICcnKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1sxXS50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcHJvdGVjdGVkIGFjdGl2YXRpb246IHN0cmluZztcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYWQgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLm1vZGUgPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnbW9kZScsICdjb25zdGFudCcpO1xuICAgIHRoaXMudmFsdWUgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCd2YWx1ZScsIDAuMCk7XG4gICAgdGhpcy5wYWRzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJyk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1vZGU6IHN0cmluZztcbiAgcHJvdGVjdGVkIHBhZHM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgdmFsdWU6IG51bWJlcjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmNsYXNzIFBvb2xCYXNlIHtcbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhdXRvUGFkOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBjZWlsTW9kZTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgY291bnRJbmNsdWRlUGFkOiBib29sZWFuO1xuICBwcm90ZWN0ZWQga2VybmVsU2hhcGU6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgc3RyaWRlczogbnVtYmVyW107XG4gIHByb3RlY3RlZCBwYWRzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEF2ZXJhZ2VQb29sIGV4dGVuZHMgUG9vbEJhc2UgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF1dG9QYWQgPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYXV0b19wYWQnLCAnTk9UU0VUJyk7XG4gICAgdGhpcy5rZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMuZ2V0SW50cygna2VybmVsX3NoYXBlJyk7XG4gICAgdGhpcy5zdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgW10pO1xuICAgIHRoaXMucGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFtdKTtcbiAgICB0aGlzLmNvdW50SW5jbHVkZVBhZCA9IChhdHRyaWJ1dGVzLmdldEludCgnY291bnRfaW5jbHVkZV9wYWQnLCAwKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgdGhpcy5jZWlsTW9kZSA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdjZWlsX21vZGUnLCAwKTtcblxuICAgIC8vIFRPRE86IHN1cHBvcnQgYXR0cmlidXRlICdjZWlsX21vZGUnXG4gICAgaWYgKHRoaXMuY2VpbE1vZGUgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbCcpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2xvYmFsQXZlcmFnZVBvb2wgZXh0ZW5kcyBQb29sQmFzZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMuY291bnRJbmNsdWRlUGFkID0gKGF0dHJpYnV0ZXMuZ2V0SW50KCdjb3VudF9pbmNsdWRlX3BhZCcsIDApID09PSAwID8gZmFsc2UgOiB0cnVlKTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWF4UG9vbCBleHRlbmRzIFBvb2xCYXNlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5hdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICAgIHRoaXMua2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScpO1xuICAgIHRoaXMuc3RyaWRlcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnc3RyaWRlcycsIFtdKTtcbiAgICB0aGlzLnBhZHMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3BhZHMnLCBbXSk7XG4gICAgdGhpcy5jZWlsTW9kZSA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdjZWlsX21vZGUnLCAwKTtcbiAgICB0aGlzLnN0b3JhZ2VPcmRlciA9IGF0dHJpYnV0ZXMuZ2V0SW50KCdzdG9yYWdlX29yZGVyJywgMCk7XG5cbiAgICAvLyBUT0RPOiBzdXBwb3J0IGF0dHJpYnV0ZSAnY2VpbF9tb2RlJyBhbmQgJ3N0b3JhZ2Vfb3JkZXInXG4gICAgaWYgKHRoaXMuc3RvcmFnZU9yZGVyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNlaWxNb2RlICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBzdG9yYWdlT3JkZXI6IG51bWJlcjtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEdsb2JhbE1heFBvb2wgZXh0ZW5kcyBQb29sQmFzZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKF9hdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHt9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtOVU1CRVJfVFlQRVMsIE9wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWR1Y2VCYXNlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5heGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdheGVzJywgW10pO1xuICAgIHRoaXMua2VlcERpbXMgPSBhdHRyaWJ1dGVzLmdldEludCgna2VlcGRpbXMnLCAxKSA9PT0gMTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF4ZXM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQga2VlcERpbXM6IGJvb2xlYW47XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtOVU1CRVJfVFlQRVMsIE9wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZXNoYXBlIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMiB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFwZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKF9hdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHt9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2xpY2UgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXJ0cyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnc3RhcnRzJyk7XG4gICAgdGhpcy5lbmRzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdlbmRzJyk7XG4gICAgdGhpcy5heGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdheGVzJywgW10pO1xuICB9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBheGVzOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIGVuZHM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgc3RhcnRzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNsaWNlVjEwIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoX2F0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge31cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDMgfHwgaW5wdXRzLmxlbmd0aCA+IDUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgfHwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dHNbMl0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPj0gNCAmJiAoaW5wdXRzWzNdLnR5cGUgIT09ICdpbnQzMicgfHwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoICE9PSAxKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmIChpbnB1dHNbNF0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbNF0uZGltcy5sZW5ndGggIT09IDEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTb2Z0bWF4IGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5heGlzID0gYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAxKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXhpczogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNwbGl0IGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgbnVtT3V0cHV0cz86IG51bWJlcikge31cblxuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5heGlzID0gYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAwKTtcbiAgICB0aGlzLnNwbGl0ID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzcGxpdCcsIFtdKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQ4JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQ4JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDE2JyAmJlxuICAgICAgICBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQxNicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Jvb2wnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3BsaXQ6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgYXhpczogbnVtYmVyO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNxdWVlemUgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShhdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHtcbiAgICB0aGlzLmF4ZXMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyB0eXBlXG4gICAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF4ZXM6IG51bWJlcltdO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN1bSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKF9hdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHt9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsZW5ndGggIT09IGlucHV0c1tpXS5kaW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGlucHV0c1swXS5kaW1zW2pdICE9PSBpbnB1dHNbaV0uZGltc1tqXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbaV0udHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge05VTUJFUl9UWVBFUywgT3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRpbGUgaW1wbGVtZW50cyBPcGVyYXRvciB7XG4gIGFic3RyYWN0IHJ1bihpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW118UHJvbWlzZTxUZW5zb3JbXT47XG5cbiAgaW5pdGlhbGl6ZShfYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7fVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChOVU1CRVJfVFlQRVMuaW5kZXhPZihpbnB1dHNbMF0udHlwZSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDMyJyAmJiBpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDE2Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlfSBmcm9tICcuLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRyYW5zcG9zZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSk6IHZvaWQge1xuICAgIHRoaXMucGVybSA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGVybScsIFtdKTtcbiAgfVxuXG4gIGNoZWNrSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2hlY2tJbnB1dFR5cGVzKGlucHV0cyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFR5cGVzKGlucHV0czogVGVuc29yW10pOiBib29sZWFuIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgcGVybTogbnVtYmVyW107XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVW5hcnlPcCBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHR5cGVDb25zdHJhaW50OiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSwgcHJvdGVjdGVkIHJlc3VsdFR5cGU/OiBUZW5zb3IuRGF0YVR5cGUpIHt9XG5cbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKF9hdHRyaWJ1dGVzOiBBdHRyaWJ1dGUpOiB2b2lkIHt9XG5cbiAgY2hlY2tJbnB1dHMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnR5cGVDb25zdHJhaW50LmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGV9IGZyb20gJy4uL2F0dHJpYnV0ZSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVW5zcXVlZXplIGltcGxlbWVudHMgT3BlcmF0b3Ige1xuICBhYnN0cmFjdCBydW4oaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdfFByb21pc2U8VGVuc29yW10+O1xuXG4gIGluaXRpYWxpemUoYXR0cmlidXRlczogQXR0cmlidXRlKTogdm9pZCB7XG4gICAgdGhpcy5heGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdheGVzJyk7XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrSW5wdXRUeXBlcyhpbnB1dHMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNoZWNrSW5wdXRUeXBlcyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogU3VwcG9ydCBzdHJpbmcgdHlwZVxuICAgIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBheGVzOiBudW1iZXJbXTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vYXR0cmlidXRlJztcbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vYmFja2VuZCc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVcHNhbXBsZSBpbXBsZW1lbnRzIE9wZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIG9wc2V0OiBudW1iZXIpIHt9XG5cbiAgYWJzdHJhY3QgcnVuKGluZmVyZW5jZUhhbmRsZXI6IEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXXxQcm9taXNlPFRlbnNvcltdPjtcblxuICBpbml0aWFsaXplKGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZSwgX25vZGU6IEdyYXBoLk5vZGUsIF9ncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICB0aGlzLmlzUmVzaXplID0gKHRoaXMub3BzZXQgPj0gMTApO1xuXG4gICAgLy8gcHJvY2Vzc2luZyBub2RlIGF0dHJpYnV0ZXNcbiAgICB0aGlzLm1vZGUgPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnbW9kZScsICduZWFyZXN0Jyk7XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ25lYXJlc3QnICYmIHRoaXMubW9kZSAhPT0gJ2xpbmVhcicgJiYgKHRoaXMub3BzZXQgPCAxMSB8fCB0aGlzLm1vZGUgIT09ICdjdWJpYycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBtb2RlOiAke3RoaXMubW9kZX1gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHNldCA8IDkpIHtcbiAgICAgIHRoaXMuc2NhbGVzID0gYXR0cmlidXRlcy5nZXRGbG9hdHMoJ3NjYWxlcycpO1xuICAgICAgc2NhbGVzVmFsaWRhdGFpb24odGhpcy5zY2FsZXMsIHRoaXMubW9kZSwgdGhpcy5pc1Jlc2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5leHRyYXBvbGF0aW9uVmFsdWUgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdleHRyYXBvbGF0aW9uX3ZhbHVlJywgMC4wKTtcblxuICAgIHRoaXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPVxuICAgICAgICB0aGlzLm9wc2V0ID4gMTAgPyBhdHRyaWJ1dGVzLmdldFN0cmluZygnY29vcmRpbmF0ZV90cmFuc2Zvcm1hdGlvbl9tb2RlJywgJ2hhbGZfcGl4ZWwnKSA6ICdhc3ltbWV0cmljJztcbiAgICBpZiAoW1xuICAgICAgICAgICdhc3ltbWV0cmljJywgJ3B5dG9yY2hfaGFsZl9waXhlbCcsICd0Zl9oYWxmX3BpeGVsX2Zvcl9ubicsICdhbGlnbl9jb3JuZXJzJywgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZScsXG4gICAgICAgICAgJ2hhbGZfcGl4ZWwnXG4gICAgICAgIF0uaW5kZXhPZih0aGlzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY29vcmRpbmF0ZV90cmFuc2Zvcm1fbW9kZSAnJHt0aGlzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgICB0aGlzLnVzZUV4dHJhcG9sYXRpb24gPSB0aGlzLm5lZWRSb2lJbnB1dCA9ICh0aGlzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAndGZfY3JvcF9hbmRfcmVzaXplJyk7XG5cbiAgICB0aGlzLm5lYXJlc3RNb2RlID1cbiAgICAgICAgKHRoaXMubW9kZSA9PT0gJ25lYXJlc3QnICYmIHRoaXMub3BzZXQgPj0gMTEpID8gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ25lYXJlc3RfbW9kZScsICdyb3VuZF9wcmVmZXJfZmxvb3InKSA6ICcnO1xuICAgIGlmIChbJ3JvdW5kX3ByZWZlcl9mbG9vcicsICdyb3VuZF9wcmVmZXJfY2VpbCcsICdmbG9vcicsICdjZWlsJywgJyddLmluZGV4T2YodGhpcy5uZWFyZXN0TW9kZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5lYXJlc3RfbW9kZSAnJHt0aGlzLm5lYXJlc3RNb2RlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cblxuICAgIHRoaXMuY3ViaWNDb2VmZmljaWVudEEgPSBhdHRyaWJ1dGVzLmdldEZsb2F0KCdjdWJpY19jb2VmZl9hJywgLTAuNzUpO1xuICAgIHRoaXMuZXhjbHVkZU91dHNpZGUgPSBhdHRyaWJ1dGVzLmdldEludCgnZXhjbHVkZV9vdXRzaWRlJywgMCkgIT09IDA7XG4gICAgaWYgKHRoaXMuZXhjbHVkZU91dHNpZGUgJiYgdGhpcy5tb2RlICE9PSAnY3ViaWMnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVfb3V0c2lkZSBjYW4gYmUgc2V0IHRvIDEgb25seSB3aGVuIG1vZGUgaXMgQ1VCSUMuJyk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VOZWFyZXN0MnhPcHRpbWl6YXRpb24gPSAodGhpcy5vcHNldCA8IDExKSA/XG4gICAgICAgIHRydWUgOlxuICAgICAgICAodGhpcy5tb2RlID09PSAnbmVhcmVzdCcgJiYgdGhpcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ2FzeW1tZXRyaWMnICYmIHRoaXMubmVhcmVzdE1vZGUgPT09ICdmbG9vcicpO1xuXG4gICAgaWYgKHRoaXMub3BzZXQgPiAxMCkge1xuICAgICAgdGhpcy5yb2lJbnB1dElkeCA9IDE7XG4gICAgICB0aGlzLnNjYWxlc0lucHV0SWR4ID0gMjtcbiAgICAgIHRoaXMuc2l6ZXNJbnB1dElkeCA9IDM7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wc2V0ID09PSA5KSB7XG4gICAgICB0aGlzLnNjYWxlc0lucHV0SWR4ID0gMTtcbiAgICB9XG4gIH1cblxuICBjaGVja0lucHV0cyhpbnB1dHM6IFRlbnNvcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKCFpbnB1dHMgfHwgKHRoaXMub3BzZXQgPCA5ICYmIGlucHV0cy5sZW5ndGggIT09IDEpIHx8XG4gICAgICAgICh0aGlzLm9wc2V0ID49IDkgJiYgdGhpcy5vcHNldCA8IDExICYmIGlucHV0cy5sZW5ndGggIT09IDIpIHx8XG4gICAgICAgICh0aGlzLm9wc2V0ID49IDExICYmIGlucHV0cy5sZW5ndGggIT09IDMgJiYgaW5wdXRzLmxlbmd0aCAhPT0gNCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zY2FsZXMgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSB0aGlzLnNjYWxlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGVja0lucHV0VHlwZXMoaW5wdXRzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjaGVja0lucHV0VHlwZXMoaW5wdXRzOiBUZW5zb3JbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBwcmVwYXJlSW5wdXRzKGlucHV0czogVGVuc29yW10pOiBbbnVtYmVyW10sIG51bWJlcltdLCByZWFkb25seSBudW1iZXJbXV0ge1xuICAgIGNvbnN0IHggPSBpbnB1dHNbMF07XG4gICAgY29uc3QgeERpbXMgPSB4LmRpbXM7XG5cbiAgICAvLyBnZXQgcm9pIGRhdGFcbiAgICBsZXQgcm9pID0gdGhpcy5yb2k7XG4gICAgaWYgKCFyb2kpIHtcbiAgICAgIGlmICh0aGlzLm5lZWRSb2lJbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5yb2lJbnB1dElkeCA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvaSBpbnB1dCBpbmRleC4nKTtcbiAgICAgICAgfVxuICAgICAgICByb2kgPSBwYXJzZVJvaURhdGEoaW5wdXRzW3RoaXMucm9pSW5wdXRJZHhdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvaSA9IG5ldyBBcnJheSh4RGltcy5sZW5ndGggKiAyKS5maWxsKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBsZXQgb3V0cHV0U2l6ZXM6IG51bWJlcltdfHVuZGVmaW5lZDtcbiAgICBpZiAoIXNjYWxlcykge1xuICAgICAgY29uc3Qgc2NhbGVzVGVuc29yID0gaW5wdXRzW3RoaXMuc2NhbGVzSW5wdXRJZHhdO1xuICAgICAgaWYgKHNjYWxlc1RlbnNvciAmJiBzY2FsZXNUZW5zb3Iuc2l6ZSAhPT0gMCkge1xuICAgICAgICBpZiAoaW5wdXRzW3RoaXMuc2l6ZXNJbnB1dElkeF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlcyA9IHBhcnNlU2NhbGVzRGF0YShzY2FsZXNUZW5zb3IsIHRoaXMubW9kZSwgdGhpcy5pc1Jlc2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzaXplc1RlbnNvciA9IGlucHV0c1t0aGlzLnNpemVzSW5wdXRJZHhdO1xuICAgICAgICBpZiAoIXNpemVzVGVuc29yIHx8IHNpemVzVGVuc29yLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dFNpemVzID0gQXJyYXkuZnJvbShzaXplc1RlbnNvci5pbnRlZ2VyRGF0YSk7XG4gICAgICAgIHNjYWxlcyA9IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplKG91dHB1dFNpemVzLCB4RGltcywgdGhpcy5tb2RlLCB0aGlzLmlzUmVzaXplKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlucHV0c1t0aGlzLnNpemVzSW5wdXRJZHhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2Ygc2NhbGVzIG9yIHNpemVzIG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeURpbXMgPSBvdXRwdXRTaXplcyB8fCBjb21wdXRlT3V0cHV0U2hhcGUoc2NhbGVzLCB4RGltcyk7XG5cbiAgICByZXR1cm4gW3JvaSwgc2NhbGVzLCB5RGltc107XG4gIH1cblxuICBwcm90ZWN0ZWQgaXNSZXNpemU6IGJvb2xlYW47XG4gIHByb3RlY3RlZCBtb2RlOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBzY2FsZXM6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXI7XG4gIHByb3RlY3RlZCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogc3RyaW5nO1xuICBwcm90ZWN0ZWQgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIG5lZWRSb2lJbnB1dDogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIG5lYXJlc3RNb2RlOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBjdWJpY0NvZWZmaWNpZW50QTogbnVtYmVyO1xuICBwcm90ZWN0ZWQgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW47XG4gIHByb3RlY3RlZCB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb246IGJvb2xlYW47XG4gIHByb3RlY3RlZCByb2lJbnB1dElkeDogbnVtYmVyO1xuICBwcm90ZWN0ZWQgc2NhbGVzSW5wdXRJZHg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIHNpemVzSW5wdXRJZHg6IG51bWJlcjtcbiAgcHJvdGVjdGVkIHJvaTogbnVtYmVyW107XG59XG5cbmZ1bmN0aW9uIHNjYWxlc1ZhbGlkYXRhaW9uKHNjYWxlczogbnVtYmVyW10sIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pIHtcbiAgaWYgKCFpc1Jlc2l6ZSkge1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICBpZiAoc2NhbGUgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IHNjYWxlIG9mIHNjYWxlcykge1xuICAgICAgaWYgKHNjYWxlIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChtb2RlID09PSAnbGluZWFyJyB8fCBtb2RlID09PSAnY3ViaWMnKSB7XG4gICAgaWYgKHNjYWxlcy5sZW5ndGggIT09IDIgJiYgKHNjYWxlcy5sZW5ndGggIT09IDQgfHwgc2NhbGVzWzBdICE9PSAxIHx8IHNjYWxlc1sxXSAhPT0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ0xpbmVhcicgbW9kZSBhbmQgJ0N1YmljJyBtb2RlIG9ubHkgc3VwcG9ydCAyLUQgaW5wdXRzICgnQmlsaW5lYXInLCAnQmljdWJpYycpIG9yIDQtRCBpbnB1dHNcXFxud2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSBpbiB0aGUgJHtpc1Jlc2l6ZSA/ICdSZXNpemUnIDogJ1Vwc2FtcGxlJ30gb3BlYXJ0b3IuYCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJvaURhdGEocm9pOiBUZW5zb3IpOiBudW1iZXJbXSB7XG4gIHJldHVybiByb2kuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHJvaS5mbG9hdERhdGEpIDogW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNjYWxlc0RhdGEoc2NhbGU6IFRlbnNvciwgbW9kZTogc3RyaW5nLCBpc1Jlc2l6ZTogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgY29uc3Qgc2NhbGVzID0gQXJyYXkuZnJvbShzY2FsZS5mbG9hdERhdGEpO1xuICBzY2FsZXNWYWxpZGF0YWlvbihzY2FsZXMsIG1vZGUsIGlzUmVzaXplKTtcbiAgcmV0dXJuIHNjYWxlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplKFxuICAgIHlEaW1zOiByZWFkb25seSBudW1iZXJbXSwgeERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBtb2RlOiBzdHJpbmcsIGlzUmVzaXplOiBib29sZWFuKTogbnVtYmVyW10ge1xuICBjb25zdCBsZW5ndGggPSB4RGltcy5sZW5ndGg7XG4gIGNvbnN0IHNjYWxlcyA9IG5ldyBBcnJheTxudW1iZXI+KGxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGVuZCA9IGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKHhEaW1zW2ldID09PSAwKSB7XG4gICAgICBpZiAoeURpbXNbaV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkaW0gaXMgemVybyBidXQgcmVxdWlyZWQgb3V0cHV0IGRpbSBpcyBub24temVyby4nKTtcbiAgICAgIH1cbiAgICAgIHNjYWxlc1tpXSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlc1tpXSA9IHlEaW1zW2ldIC8geERpbXNbaV07XG4gICAgfVxuICB9XG4gIHNjYWxlc1ZhbGlkYXRhaW9uKHNjYWxlcywgbW9kZSwgaXNSZXNpemUpO1xuICByZXR1cm4gc2NhbGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZU91dHB1dFNoYXBlKHNjYWxlczogcmVhZG9ubHkgbnVtYmVyW10sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSB7XG4gIHJldHVybiBpbnB1dERpbXMubWFwKChkaW0sIGkpID0+IE1hdGguZmxvb3IoZGltICogc2NhbGVzW2ldKSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BTZXQge1xuICBkb21haW46IHN0cmluZztcbiAgdmVyc2lvbjogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgT3BTZXQge1xuICBpbnRlcmZhY2UgT3BlcmF0b3JDb25zdHJ1Y3RvciB7XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBPcGVyYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb21haW4gb2YgYW4gb3BzZXQsIGl0IGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcoZGVmYXVsdCB2YWx1ZSwgcmVwcmVzZW50IGZvciBhaS5vbm54KSwgb3IgJ2FpLm9ubngubWwnXG4gICAqL1xuICB0eXBlIERvbWFpbiA9ICcnfCdhaS5vbm54Lm1sJztcblxuICAvKipcbiAgICogQSByZXNvbHZlIHJ1bGUgY29uc2lzdHMgb2YgNCBpdGVtczogb3BUeXBlLCBvcFNldERvbWFpbiwgdmVyc2lvblNlbGVjdG9yIGFuZCBvcGVyYXRvckNvbnN0cnVjdG9yXG4gICAqL1xuICB0eXBlIFJlc29sdmVSdWxlID0gW3N0cmluZywgRG9tYWluLCBzdHJpbmcsIE9wZXJhdG9yQ29uc3RydWN0b3JdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9wZXJhdG9yKG5vZGU6IEdyYXBoLk5vZGUsIG9wc2V0czogcmVhZG9ubHkgT3BTZXRbXSwgcnVsZXM6IHJlYWRvbmx5IE9wU2V0LlJlc29sdmVSdWxlW10pIHtcbiAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgY29uc3Qgb3BUeXBlID0gcnVsZVswXTtcbiAgICBjb25zdCBkb21haW4gPSBydWxlWzFdO1xuICAgIGNvbnN0IHZlcnNpb25TZWxlY3RvciA9IHJ1bGVbMl07XG4gICAgY29uc3Qgb3BDb25zdHJ1Y3RvciA9IHJ1bGVbM107XG5cbiAgICBpZiAobm9kZS5vcFR5cGUgPT09IG9wVHlwZSkgeyAgLy8gb3BlcmF0b3IgdHlwZSBtYXRjaGVzXG4gICAgICBmb3IgKGNvbnN0IG9wc2V0IG9mIG9wc2V0cykge1xuICAgICAgICAvLyBvcHNldCAnJyBhbmQgJ2FpLm9ubngnIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lLlxuICAgICAgICBpZiAob3BzZXQuZG9tYWluID09PSBkb21haW4gfHwgKG9wc2V0LmRvbWFpbiA9PT0gJ2FpLm9ubngnICYmIGRvbWFpbiA9PT0gJycpKSB7ICAvLyBvcHNldCBkb21haW4gZm91bmRcbiAgICAgICAgICBpZiAobWF0Y2hTZWxlY3RvcihvcHNldC52ZXJzaW9uLCB2ZXJzaW9uU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BDb25zdHJ1Y3Rvcihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYW5ub3QgcmVzb2x2ZSBvcGVyYXRvciAnJHtub2RlLm9wVHlwZX0nIHdpdGggb3BzZXRzOiAke1xuICAgICAgb3BzZXRzLm1hcChzZXQgPT4gYCR7c2V0LmRvbWFpbiB8fCAnYWkub25ueCd9IHYke3NldC52ZXJzaW9ufWApLmpvaW4oJywgJyl9YCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IodmVyc2lvbjogbnVtYmVyLCBzZWxlY3Rvcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChzZWxlY3Rvci5lbmRzV2l0aCgnKycpKSB7XG4gICAgLy8gbWluaW11bSB2ZXJzaW9uIG1hdGNoICgnNysnIGV4cGVjdHMgdmVyc2lvbj49NylcbiAgICBjb25zdCByYW5nZVN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHNlbGVjdG9yLnN1YnN0cmluZygwLCBzZWxlY3Rvci5sZW5ndGggLSAxKSwgMTApO1xuICAgIHJldHVybiAhaXNOYU4ocmFuZ2VTdGFydCkgJiYgcmFuZ2VTdGFydCA8PSB2ZXJzaW9uO1xuICB9IGVsc2UgaWYgKHNlbGVjdG9yLnNwbGl0KCctJykubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gcmFuZ2UgbWF0Y2ggKCc2LTgnIGV4cGVjdHMgNjw9dmVyc2lvbjw9OClcbiAgICBjb25zdCBwYWlyID0gc2VsZWN0b3Iuc3BsaXQoJy0nKTtcbiAgICBjb25zdCByYW5nZVN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHBhaXJbMF0sIDEwKTtcbiAgICBjb25zdCByYW5nZUVuZCA9IE51bWJlci5wYXJzZUludChwYWlyWzFdLCAxMCk7XG4gICAgcmV0dXJuICFpc05hTihyYW5nZVN0YXJ0KSAmJiAhaXNOYU4ocmFuZ2VFbmQpICYmIHJhbmdlU3RhcnQgPD0gdmVyc2lvbiAmJiB2ZXJzaW9uIDw9IHJhbmdlRW5kO1xuICB9IGVsc2Uge1xuICAgIC8vIGV4YWN0IG1hdGNoICgnNycgZXhwZWN0cyB2ZXJzaW9uPT09NylcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHNlbGVjdG9yLCAxMCkgPT09IHZlcnNpb247XG4gIH1cbn1cbiIsIi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuaW1wb3J0IHtmbGF0YnVmZmVyc30gZnJvbSAnZmxhdGJ1ZmZlcnMnO1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIEF0dHJpYnV0ZVR5cGUge1xuICAgIFVOREVGSU5FRCA9IDAsXG4gICAgRkxPQVQgPSAxLFxuICAgIElOVCA9IDIsXG4gICAgU1RSSU5HID0gMyxcbiAgICBURU5TT1IgPSA0LFxuICAgIEdSQVBIID0gNSxcbiAgICBGTE9BVFMgPSA2LFxuICAgIElOVFMgPSA3LFxuICAgIFNUUklOR1MgPSA4LFxuICAgIFRFTlNPUlMgPSA5LFxuICAgIEdSQVBIUyA9IDEwLFxuICAgIFNQQVJTRV9URU5TT1IgPSAxMSxcbiAgICBTUEFSU0VfVEVOU09SUyA9IDEyXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBEaW1lbnNpb25WYWx1ZVR5cGUge1VOS05PV04gPSAwLCBWQUxVRSA9IDEsIFBBUkFNID0gMn1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBUZW5zb3JEYXRhVHlwZSB7XG4gICAgVU5ERUZJTkVEID0gMCxcbiAgICBGTE9BVCA9IDEsXG4gICAgVUlOVDggPSAyLFxuICAgIElOVDggPSAzLFxuICAgIFVJTlQxNiA9IDQsXG4gICAgSU5UMTYgPSA1LFxuICAgIElOVDMyID0gNixcbiAgICBJTlQ2NCA9IDcsXG4gICAgU1RSSU5HID0gOCxcbiAgICBCT09MID0gOSxcbiAgICBGTE9BVDE2ID0gMTAsXG4gICAgRE9VQkxFID0gMTEsXG4gICAgVUlOVDMyID0gMTIsXG4gICAgVUlOVDY0ID0gMTMsXG4gICAgQ09NUExFWDY0ID0gMTQsXG4gICAgQ09NUExFWDEyOCA9IDE1LFxuICAgIEJGTE9BVDE2ID0gMTZcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIE5vZGVUeXBlIHtQcmltaXRpdmUgPSAwLCBGdXNlZCA9IDF9XG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gVHlwZUluZm9WYWx1ZSB7Tk9ORSA9IDAsIHRlbnNvcl90eXBlID0gMSwgc2VxdWVuY2VfdHlwZSA9IDIsIG1hcF90eXBlID0gM31cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNoYXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTaGFwZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU2hhcGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1NoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTaGFwZSk6IFNoYXBlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTaGFwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTaGFwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2hhcGUpOiBTaGFwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb249IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uXG4gICAgICovXG4gICAgZGltKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb258bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW0oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZGltT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGltVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTaGFwZS5zdGFydFNoYXBlKGJ1aWxkZXIpO1xuICAgICAgU2hhcGUuYWRkRGltKGJ1aWxkZXIsIGRpbU9mZnNldCk7XG4gICAgICByZXR1cm4gU2hhcGUuZW5kU2hhcGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRGltZW5zaW9uIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IERpbWVuc2lvbiB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb249IG9ialxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNEaW1lbnNpb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvbik6IERpbWVuc2lvbiB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb24pOiBEaW1lbnNpb24ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgRGltZW5zaW9uKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWV8bnVsbFxuICAgICAqL1xuICAgIHZhbHVlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZGVub3RhdGlvbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkZW5vdGF0aW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltZW5zaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdmFsdWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCB2YWx1ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGVub3RhdGlvbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREZW5vdGF0aW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkZW5vdGF0aW9uT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZERpbWVuc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlRGltZW5zaW9uKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgRGltZW5zaW9uLnN0YXJ0RGltZW5zaW9uKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uLmFkZFZhbHVlKGJ1aWxkZXIsIHZhbHVlT2Zmc2V0KTtcbiAgICAgIERpbWVuc2lvbi5hZGREZW5vdGF0aW9uKGJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvbi5lbmREaW1lbnNpb24oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRGltZW5zaW9uVmFsdWUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblZhbHVlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBEaW1lbnNpb25WYWx1ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBEaW1lbnNpb25WYWx1ZT0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IERpbWVuc2lvblZhbHVlKTogRGltZW5zaW9uVmFsdWUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvblZhbHVlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uVmFsdWU9IG9ialxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvblZhbHVlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb25WYWx1ZSk6IERpbWVuc2lvblZhbHVlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvblZhbHVlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGVcbiAgICAgKi9cbiAgICBkaW1UeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDgodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUuVU5LTk9XTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltVmFsdWUoKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkaW1QYXJhbSgpOiBzdHJpbmd8bnVsbDtcbiAgICBkaW1QYXJhbShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZGltUGFyYW0ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1lbnNpb25WYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUgZGltVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50OCgwLCBkaW1UeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgZGltVmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVmFsdWU6IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgxLCBkaW1WYWx1ZSwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1QYXJhbU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1QYXJhbShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1QYXJhbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRpbVBhcmFtT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZERpbWVuc2lvblZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVEaW1lbnNpb25WYWx1ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUsXG4gICAgICAgIGRpbVZhbHVlOiBmbGF0YnVmZmVycy5Mb25nLCBkaW1QYXJhbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIERpbWVuc2lvblZhbHVlLnN0YXJ0RGltZW5zaW9uVmFsdWUoYnVpbGRlcik7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5hZGREaW1UeXBlKGJ1aWxkZXIsIGRpbVR5cGUpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltVmFsdWUoYnVpbGRlciwgZGltVmFsdWUpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltUGFyYW0oYnVpbGRlciwgZGltUGFyYW1PZmZzZXQpO1xuICAgICAgcmV0dXJuIERpbWVuc2lvblZhbHVlLmVuZERpbWVuc2lvblZhbHVlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yVHlwZUFuZFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JUeXBlQW5kU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3JUeXBlQW5kU2hhcGUpOiBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvclR5cGVBbmRTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvclR5cGVBbmRTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yVHlwZUFuZFNoYXBlKTpcbiAgICAgICAgVGVuc29yVHlwZUFuZFNoYXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvclR5cGVBbmRTaGFwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGVcbiAgICAgKi9cbiAgICBlbGVtVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlfG51bGxcbiAgICAgKi9cbiAgICBzaGFwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSBlbGVtVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRFbGVtVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBlbGVtVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIGVsZW1UeXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc2hhcGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2hhcGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzaGFwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUZW5zb3JUeXBlQW5kU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVRlbnNvclR5cGVBbmRTaGFwZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICAgIHNoYXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXIpO1xuICAgICAgVGVuc29yVHlwZUFuZFNoYXBlLmFkZEVsZW1UeXBlKGJ1aWxkZXIsIGVsZW1UeXBlKTtcbiAgICAgIFRlbnNvclR5cGVBbmRTaGFwZS5hZGRTaGFwZShidWlsZGVyLCBzaGFwZU9mZnNldCk7XG4gICAgICByZXR1cm4gVGVuc29yVHlwZUFuZFNoYXBlLmVuZFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNYXBUeXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBNYXBUeXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBNYXBUeXBlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1hcFR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIE1hcFR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzTWFwVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTWFwVHlwZSk6IE1hcFR5cGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE1hcFR5cGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBNYXBUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNYXBUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE1hcFR5cGUpOiBNYXBUeXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE1hcFR5cGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAga2V5VHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGxcbiAgICAgKi9cbiAgICB2YWx1ZVR5cGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRNYXBUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIGtleVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2V5VHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXlUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMCwga2V5VHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlVHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgdmFsdWVUeXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE1hcFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU1hcFR5cGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtleVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE1hcFR5cGUuc3RhcnRNYXBUeXBlKGJ1aWxkZXIpO1xuICAgICAgTWFwVHlwZS5hZGRLZXlUeXBlKGJ1aWxkZXIsIGtleVR5cGUpO1xuICAgICAgTWFwVHlwZS5hZGRWYWx1ZVR5cGUoYnVpbGRlciwgdmFsdWVUeXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBNYXBUeXBlLmVuZE1hcFR5cGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU2VxdWVuY2VUeXBlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNlcXVlbmNlVHlwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXF1ZW5jZVR5cGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlcXVlbmNlVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTZXF1ZW5jZVR5cGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlcXVlbmNlVHlwZSk6IFNlcXVlbmNlVHlwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2VxdWVuY2VUeXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2VxdWVuY2VUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2VxdWVuY2VUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXF1ZW5jZVR5cGUpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2VxdWVuY2VUeXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbFxuICAgICAqL1xuICAgIGVsZW1UeXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U2VxdWVuY2VUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZWxlbVR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRWxlbVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBlbGVtVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTZXF1ZW5jZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNlcXVlbmNlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBlbGVtVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNlcXVlbmNlVHlwZS5zdGFydFNlcXVlbmNlVHlwZShidWlsZGVyKTtcbiAgICAgIFNlcXVlbmNlVHlwZS5hZGRFbGVtVHlwZShidWlsZGVyLCBlbGVtVHlwZU9mZnNldCk7XG4gICAgICByZXR1cm4gU2VxdWVuY2VUeXBlLmVuZFNlcXVlbmNlVHlwZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBFZGdlRW5kIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBFZGdlRW5kXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBFZGdlRW5kIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNyY0FyZ0luZGV4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZHN0QXJnSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBub2RlX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBzcmNfYXJnX2luZGV4XG4gICAgICogQHBhcmFtIG51bWJlciBkc3RfYXJnX2luZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUVkZ2VFbmQoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVfaW5kZXg6IG51bWJlciwgc3JjX2FyZ19pbmRleDogbnVtYmVyLFxuICAgICAgICBkc3RfYXJnX2luZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5wcmVwKDQsIDEyKTtcbiAgICAgIGJ1aWxkZXIud3JpdGVJbnQzMihkc3RfYXJnX2luZGV4KTtcbiAgICAgIGJ1aWxkZXIud3JpdGVJbnQzMihzcmNfYXJnX2luZGV4KTtcbiAgICAgIGJ1aWxkZXIud3JpdGVJbnQzMihub2RlX2luZGV4KTtcbiAgICAgIHJldHVybiBidWlsZGVyLm9mZnNldCgpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE5vZGVFZGdlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTm9kZUVkZ2Uge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZUVkZ2U9IG9ialxuICAgICAqIEByZXR1cm5zIE5vZGVFZGdlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc05vZGVFZGdlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlRWRnZSk6IE5vZGVFZGdlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlRWRnZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGVFZGdlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZUVkZ2UpOiBOb2RlRWRnZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlRWRnZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQ9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZFxuICAgICAqL1xuICAgIGlucHV0RWRnZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDEyLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRFZGdlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kXG4gICAgICovXG4gICAgb3V0cHV0RWRnZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDEyLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0RWRnZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVFZGdlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbm9kZUluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kZXg6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIG5vZGVJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRFZGdlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dEVkZ2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBpbnB1dEVkZ2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0RWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3RvcigxMiwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dEVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dEVkZ2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG91dHB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgb3V0cHV0RWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0RWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3RvcigxMiwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kTm9kZUVkZ2UoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVFZGdlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kZXg6IG51bWJlciwgaW5wdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBvdXRwdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE5vZGVFZGdlLnN0YXJ0Tm9kZUVkZ2UoYnVpbGRlcik7XG4gICAgICBOb2RlRWRnZS5hZGROb2RlSW5kZXgoYnVpbGRlciwgbm9kZUluZGV4KTtcbiAgICAgIE5vZGVFZGdlLmFkZElucHV0RWRnZXMoYnVpbGRlciwgaW5wdXRFZGdlc09mZnNldCk7XG4gICAgICBOb2RlRWRnZS5hZGRPdXRwdXRFZGdlcyhidWlsZGVyLCBvdXRwdXRFZGdlc09mZnNldCk7XG4gICAgICByZXR1cm4gTm9kZUVkZ2UuZW5kTm9kZUVkZ2UoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTm9kZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTm9kZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc05vZGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGUpOiBOb2RlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlKTogTm9kZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBOb2RlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc2luY2VWZXJzaW9uKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbmRleCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBvcFR5cGUoKTogc3RyaW5nfG51bGw7XG4gICAgb3BUeXBlKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBvcFR5cGUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlXG4gICAgICovXG4gICAgdHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKCk6IHN0cmluZ3xudWxsO1xuICAgIGV4ZWN1dGlvblByb3ZpZGVyVHlwZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJUeXBlKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG91dHB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlXG4gICAgICovXG4gICAgYXR0cmlidXRlcyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlXG4gICAgICAgIHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgYXR0cmlidXRlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0QXJnQ291bnRzKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRBcmdDb3VudHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEludDMyQXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50c0FycmF5KCk6IEludDMyQXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgP1xuICAgICAgICAgIG5ldyBJbnQzMkFycmF5KFxuICAgICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlciwgdGhpcy5iYiEuYnl0ZXMoKS5ieXRlT2Zmc2V0ICsgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbXBsaWNpdElucHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgaW1wbGljaXRJbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW1wbGljaXRJbnB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMTMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvbWFpbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb21haW4oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZG9tYWluT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBzaW5jZVZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU2luY2VWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNpbmNlVmVyc2lvbjogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMywgc2luY2VWZXJzaW9uLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoNCwgaW5kZXgsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG9wVHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPcFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3BUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgb3BUeXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUgdHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMig2LCB0eXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlLlByaW1pdGl2ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOCwgaW5wdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvdXRwdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDksIG91dHB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgYXR0cmlidXRlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRBdHRyaWJ1dGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGF0dHJpYnV0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMCwgYXR0cmlidXRlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dEFyZ0NvdW50c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dEFyZ0NvdW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDExLCBpbnB1dEFyZ0NvdW50c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlucHV0QXJnQ291bnRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IG51bWJlcltdfFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbXBsaWNpdElucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbXBsaWNpdElucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEyLCBpbXBsaWNpdElucHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUltcGxpY2l0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEltcGxpY2l0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kTm9kZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTm9kZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHNpbmNlVmVyc2lvbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBvcFR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSwgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGF0dHJpYnV0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgaW5wdXRBcmdDb3VudHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBOb2RlLnN0YXJ0Tm9kZShidWlsZGVyKTtcbiAgICAgIE5vZGUuYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBOb2RlLmFkZERvbWFpbihidWlsZGVyLCBkb21haW5PZmZzZXQpO1xuICAgICAgTm9kZS5hZGRTaW5jZVZlcnNpb24oYnVpbGRlciwgc2luY2VWZXJzaW9uKTtcbiAgICAgIE5vZGUuYWRkSW5kZXgoYnVpbGRlciwgaW5kZXgpO1xuICAgICAgTm9kZS5hZGRPcFR5cGUoYnVpbGRlciwgb3BUeXBlT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkVHlwZShidWlsZGVyLCB0eXBlKTtcbiAgICAgIE5vZGUuYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGJ1aWxkZXIsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZElucHV0cyhidWlsZGVyLCBpbnB1dHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRPdXRwdXRzKGJ1aWxkZXIsIG91dHB1dHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRBdHRyaWJ1dGVzKGJ1aWxkZXIsIGF0dHJpYnV0ZXNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbnB1dEFyZ0NvdW50cyhidWlsZGVyLCBpbnB1dEFyZ0NvdW50c09mZnNldCk7XG4gICAgICBOb2RlLmFkZEltcGxpY2l0SW5wdXRzKGJ1aWxkZXIsIGltcGxpY2l0SW5wdXRzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBOb2RlLmVuZE5vZGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVmFsdWVJbmZvIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFZhbHVlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBWYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFZhbHVlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNWYWx1ZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFZhbHVlSW5mbyk6IFZhbHVlSW5mbyB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVmFsdWVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBWYWx1ZUluZm8pOiBWYWx1ZUluZm8ge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFsdWVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbFxuICAgICAqL1xuICAgIHR5cGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbyk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm98bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRWYWx1ZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBuYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0eXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIHR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kVmFsdWVJbmZvKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVWYWx1ZUluZm8oXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBWYWx1ZUluZm8uc3RhcnRWYWx1ZUluZm8oYnVpbGRlcik7XG4gICAgICBWYWx1ZUluZm8uYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIFZhbHVlSW5mby5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIFZhbHVlSW5mby5hZGRUeXBlKGJ1aWxkZXIsIHR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFZhbHVlSW5mby5lbmRWYWx1ZUluZm8oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgVHlwZUluZm8ge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUeXBlSW5mbyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVHlwZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVHlwZUluZm8oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFR5cGVJbmZvKTogVHlwZUluZm8ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1R5cGVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUeXBlSW5mbyk6IFR5cGVJbmZvIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFR5cGVJbmZvKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nfG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlXG4gICAgICovXG4gICAgdmFsdWVUeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuVGFibGUgb2JqXG4gICAgICogQHJldHVybnMgP2ZsYXRidWZmZXJzLlRhYmxlXG4gICAgICovXG4gICAgdmFsdWU8VCBleHRlbmRzIGZsYXRidWZmZXJzLlRhYmxlPihvYmo6IFQpOiBUfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3VuaW9uKG9iaiwgdGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VHlwZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkZW5vdGF0aW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERlbm90YXRpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGRlbm90YXRpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlIHZhbHVlVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ4KDEsIHZhbHVlVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLk5PTkUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgdmFsdWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kVHlwZUluZm8oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVR5cGVJbmZvKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHZhbHVlVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFR5cGVJbmZvLnN0YXJ0VHlwZUluZm8oYnVpbGRlcik7XG4gICAgICBUeXBlSW5mby5hZGREZW5vdGF0aW9uKGJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQpO1xuICAgICAgVHlwZUluZm8uYWRkVmFsdWVUeXBlKGJ1aWxkZXIsIHZhbHVlVHlwZSk7XG4gICAgICBUeXBlSW5mby5hZGRWYWx1ZShidWlsZGVyLCB2YWx1ZU9mZnNldCk7XG4gICAgICByZXR1cm4gVHlwZUluZm8uZW5kVHlwZUluZm8oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgT3BlcmF0b3JTZXRJZCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBPcGVyYXRvclNldElkPSBvYmpcbiAgICAgKiBAcmV0dXJucyBPcGVyYXRvclNldElkXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE9wZXJhdG9yU2V0SWQpOiBPcGVyYXRvclNldElkIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNPcGVyYXRvclNldElkKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBPcGVyYXRvclNldElkKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBPcGVyYXRvclNldElkKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIHZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPcGVyYXRvclNldElkKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyB2ZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDEsIHZlcnNpb24sIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRPcGVyYXRvclNldElkKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgdmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZyk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBPcGVyYXRvclNldElkLnN0YXJ0T3BlcmF0b3JTZXRJZChidWlsZGVyKTtcbiAgICAgIE9wZXJhdG9yU2V0SWQuYWRkRG9tYWluKGJ1aWxkZXIsIGRvbWFpbk9mZnNldCk7XG4gICAgICBPcGVyYXRvclNldElkLmFkZFZlcnNpb24oYnVpbGRlciwgdmVyc2lvbik7XG4gICAgICByZXR1cm4gT3BlcmF0b3JTZXRJZC5lbmRPcGVyYXRvclNldElkKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFRlbnNvciB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBUZW5zb3Ige1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvcigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yKTogVGVuc29yIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFRlbnNvcigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgZGltcyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZ3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZGltc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZGF0YVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHJhd0RhdGEoaW5kZXg6IG51bWJlcik6IG51bWJlcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50OCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHJhd0RhdGFMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICByYXdEYXRhQXJyYXkoKTogVWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/XG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnVmZmVyLCB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIHN0cmluZ0RhdGEoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgc3RyaW5nRGF0YShpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdHJpbmdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoNik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREaW1zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkaW1zT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5Mb25nPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUgZGF0YVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGF0YVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigzLCBkYXRhVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHJhd0RhdGFPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUmF3RGF0YShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCByYXdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNCwgcmF3RGF0YU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW118VWludDhBcnJheSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEsIGRhdGEubGVuZ3RoLCAxKTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50OChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0UmF3RGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDEsIG51bUVsZW1zLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzdHJpbmdEYXRhT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN0cmluZ0RhdGEoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3RyaW5nRGF0YU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDUsIHN0cmluZ0RhdGFPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVRlbnNvcihcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkYXRhVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSxcbiAgICAgICAgcmF3RGF0YU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBzdHJpbmdEYXRhT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVGVuc29yLnN0YXJ0VGVuc29yKGJ1aWxkZXIpO1xuICAgICAgVGVuc29yLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRGltcyhidWlsZGVyLCBkaW1zT2Zmc2V0KTtcbiAgICAgIFRlbnNvci5hZGREYXRhVHlwZShidWlsZGVyLCBkYXRhVHlwZSk7XG4gICAgICBUZW5zb3IuYWRkUmF3RGF0YShidWlsZGVyLCByYXdEYXRhT2Zmc2V0KTtcbiAgICAgIFRlbnNvci5hZGRTdHJpbmdEYXRhKGJ1aWxkZXIsIHN0cmluZ0RhdGFPZmZzZXQpO1xuICAgICAgcmV0dXJuIFRlbnNvci5lbmRUZW5zb3IoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU3BhcnNlVGVuc29yIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTcGFyc2VUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFNwYXJzZVRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNwYXJzZVRlbnNvcik6IFNwYXJzZVRlbnNvciB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3BhcnNlVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTcGFyc2VUZW5zb3IpOiBTcGFyc2VUZW5zb3Ige1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU3BhcnNlVGVuc29yKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdmFsdWVzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGxcbiAgICAgKi9cbiAgICBpbmRpY2VzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGRpbXMoaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLkxvbmd8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpIDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGRpbXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgdmFsdWVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbmRpY2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluZGljZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5kaWNlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGluZGljZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZGltc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLkxvbmdbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIGRhdGEubGVuZ3RoLCA4KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50NjQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBudW1FbGVtcywgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTcGFyc2VUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVNwYXJzZVRlbnNvcihcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNwYXJzZVRlbnNvci5zdGFydFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRWYWx1ZXMoYnVpbGRlciwgdmFsdWVzT2Zmc2V0KTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGRJbmRpY2VzKGJ1aWxkZXIsIGluZGljZXNPZmZzZXQpO1xuICAgICAgU3BhcnNlVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICByZXR1cm4gU3BhcnNlVGVuc29yLmVuZFNwYXJzZVRlbnNvcihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogQXR0cmlidXRlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEF0dHJpYnV0ZT0gb2JqXG4gICAgICogQHJldHVybnMgQXR0cmlidXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0F0dHJpYnV0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogQXR0cmlidXRlKTogQXR0cmlidXRlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBBdHRyaWJ1dGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBBdHRyaWJ1dGU9IG9ialxuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNBdHRyaWJ1dGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEF0dHJpYnV0ZSk6IEF0dHJpYnV0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBBdHRyaWJ1dGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGVcbiAgICAgKi9cbiAgICB0eXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGYoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaSgpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBzKCk6IHN0cmluZ3xudWxsO1xuICAgIHMob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIHMob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGxcbiAgICAgKi9cbiAgICB0KG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbFxuICAgICAqL1xuICAgIGcob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZmxvYXRzKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkRmxvYXQzMih0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBmbG9hdHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEZsb2F0MzJBcnJheVxuICAgICAqL1xuICAgIGZsb2F0c0FycmF5KCk6IEZsb2F0MzJBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/XG4gICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBpbnRzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW50c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgc3RyaW5ncyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBzdHJpbmdzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHN0cmluZ3NMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yXG4gICAgICovXG4gICAgdGVuc29ycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICB0ZW5zb3JzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGhcbiAgICAgKi9cbiAgICBncmFwaHMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZ3JhcGhzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0QXR0cmlidXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMTMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigyLCB0eXBlLCBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBmXG4gICAgICovXG4gICAgc3RhdGljIGFkZEYoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZjogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkRmxvYXQzMigzLCBmLCAwLjApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBpXG4gICAgICovXG4gICAgc3RhdGljIGFkZEkoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaTogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDQsIGksIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0T2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIHRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBnT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZmxvYXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEZsb2F0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBmbG9hdHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBmbG9hdHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGbG9hdHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogbnVtYmVyW118VWludDhBcnJheSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkRmxvYXQzMihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RmxvYXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGludHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW50cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOSwgaW50c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLkxvbmdbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIGRhdGEubGVuZ3RoLCA4KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50NjQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEludHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBudW1FbGVtcywgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3RyaW5nc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTdHJpbmdzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHN0cmluZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMCwgc3RyaW5nc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVN0cmluZ3NWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3RyaW5nc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB0ZW5zb3JzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFRlbnNvcnMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdGVuc29yc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDExLCB0ZW5zb3JzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGdyYXBoc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTIsIGdyYXBoc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUdyYXBoc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRHcmFwaHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRBdHRyaWJ1dGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUF0dHJpYnV0ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLCBmOiBudW1iZXIsIGk6IGZsYXRidWZmZXJzLkxvbmcsIHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgdE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBnT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGZsb2F0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBpbnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHN0cmluZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgdGVuc29yc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBncmFwaHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBBdHRyaWJ1dGUuc3RhcnRBdHRyaWJ1dGUoYnVpbGRlcik7XG4gICAgICBBdHRyaWJ1dGUuYWRkTmFtZShidWlsZGVyLCBuYW1lT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGREb2NTdHJpbmcoYnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRUeXBlKGJ1aWxkZXIsIHR5cGUpO1xuICAgICAgQXR0cmlidXRlLmFkZEYoYnVpbGRlciwgZik7XG4gICAgICBBdHRyaWJ1dGUuYWRkSShidWlsZGVyLCBpKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRTKGJ1aWxkZXIsIHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFQoYnVpbGRlciwgdE9mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRyhidWlsZGVyLCBnT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRGbG9hdHMoYnVpbGRlciwgZmxvYXRzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRJbnRzKGJ1aWxkZXIsIGludHNPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFN0cmluZ3MoYnVpbGRlciwgc3RyaW5nc09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkVGVuc29ycyhidWlsZGVyLCB0ZW5zb3JzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRHcmFwaHMoYnVpbGRlciwgZ3JhcGhzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBBdHRyaWJ1dGUuZW5kQXR0cmlidXRlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIEdyYXBoIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogR3JhcGgge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIEdyYXBoXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0dyYXBoKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBHcmFwaCk6IEdyYXBoIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBHcmFwaCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNHcmFwaChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogR3JhcGgpOiBHcmFwaCB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBHcmFwaCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZXJzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZXJzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvXG4gICAgICovXG4gICAgbm9kZUFyZ3MoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mb3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm8oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlQXJnc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlXG4gICAgICovXG4gICAgbm9kZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2Rlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBtYXhOb2RlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2U9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBub2RlRWRnZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2V8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUVkZ2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBpbnB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5wdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3V0cHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzcGFyc2VJbml0aWFsaXplcnMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpOlxuICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0R3JhcGgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCg4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbml0aWFsaXplcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5pdGlhbGl6ZXJzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGluaXRpYWxpemVyc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUFyZ3NPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUFyZ3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUFyZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBub2RlQXJnc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVBcmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE5vZGVBcmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgbm9kZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2Rlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBtYXhOb2RlSW5kZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTWF4Tm9kZUluZGV4KGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1heE5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMywgbWF4Tm9kZUluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2RlRWRnZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUVkZ2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDQsIG5vZGVFZGdlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVFZGdlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlRWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZElucHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBpbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG91dHB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3V0cHV0cyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNiwgb3V0cHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNwYXJzZUluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIHNwYXJzZUluaXRpYWxpemVyc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6XG4gICAgICAgIGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRHcmFwaChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlR3JhcGgoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBub2RlQXJnc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBtYXhOb2RlSW5kZXg6IG51bWJlciwgbm9kZUVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBvdXRwdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHNwYXJzZUluaXRpYWxpemVyc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEdyYXBoLnN0YXJ0R3JhcGgoYnVpbGRlcik7XG4gICAgICBHcmFwaC5hZGRJbml0aWFsaXplcnMoYnVpbGRlciwgaW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVBcmdzKGJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVzKGJ1aWxkZXIsIG5vZGVzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE1heE5vZGVJbmRleChidWlsZGVyLCBtYXhOb2RlSW5kZXgpO1xuICAgICAgR3JhcGguYWRkTm9kZUVkZ2VzKGJ1aWxkZXIsIG5vZGVFZGdlc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIEdyYXBoLmFkZE91dHB1dHMoYnVpbGRlciwgb3V0cHV0c09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRTcGFyc2VJbml0aWFsaXplcnMoYnVpbGRlciwgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0KTtcbiAgICAgIHJldHVybiBHcmFwaC5lbmRHcmFwaChidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBNb2RlbCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTW9kZWxcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE1vZGVsIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE1vZGVsPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNb2RlbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNNb2RlbChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTW9kZWwpOiBNb2RlbCB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTW9kZWwoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBNb2RlbD0gb2JqXG4gICAgICogQHJldHVybnMgTW9kZWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE1vZGVsKTogTW9kZWwge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTW9kZWwoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaXJWZXJzaW9uKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkXG4gICAgICovXG4gICAgb3BzZXRJbXBvcnQoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkKTpcbiAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvcHNldEltcG9ydExlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcHJvZHVjZXJOYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIHByb2R1Y2VyTmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgcHJvZHVjZXJOYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcHJvZHVjZXJWZXJzaW9uKCk6IHN0cmluZ3xudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgcHJvZHVjZXJWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvbWFpbigpOiBzdHJpbmd8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvbWFpbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBtb2RlbFZlcnNpb24oKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGg9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGh8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoRG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGdyYXBoRG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBncmFwaERvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRNb2RlbChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBpclZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSXJWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlyVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDAsIGlyVmVyc2lvbiwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcHNldEltcG9ydE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPcHNldEltcG9ydChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcHNldEltcG9ydE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIG9wc2V0SW1wb3J0T2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgcHJvZHVjZXJOYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb2R1Y2VyTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBwcm9kdWNlck5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBwcm9kdWNlck5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHByb2R1Y2VyVmVyc2lvbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9kdWNlclZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMywgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb21haW5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9tYWluKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDQsIGRvbWFpbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5Mb25nIG1vZGVsVmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRNb2RlbFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbW9kZWxWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50NjQoNSwgbW9kZWxWZXJzaW9uLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNiwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIGdyYXBoT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaERvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBncmFwaERvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDgsIGdyYXBoRG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVNb2RlbChcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaXJWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nLCBvcHNldEltcG9ydE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBwcm9kdWNlck5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgcHJvZHVjZXJWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBtb2RlbFZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBncmFwaE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBncmFwaERvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIE1vZGVsLnN0YXJ0TW9kZWwoYnVpbGRlcik7XG4gICAgICBNb2RlbC5hZGRJclZlcnNpb24oYnVpbGRlciwgaXJWZXJzaW9uKTtcbiAgICAgIE1vZGVsLmFkZE9wc2V0SW1wb3J0KGJ1aWxkZXIsIG9wc2V0SW1wb3J0T2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZFByb2R1Y2VyTmFtZShidWlsZGVyLCBwcm9kdWNlck5hbWVPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCk7XG4gICAgICBNb2RlbC5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZE1vZGVsVmVyc2lvbihidWlsZGVyLCBtb2RlbFZlcnNpb24pO1xuICAgICAgTW9kZWwuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaChidWlsZGVyLCBncmFwaE9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRHcmFwaERvY1N0cmluZyhidWlsZGVyLCBncmFwaERvY1N0cmluZ09mZnNldCk7XG4gICAgICByZXR1cm4gTW9kZWwuZW5kTW9kZWwoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIEtlcm5lbENyZWF0ZUluZm9zXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBLZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgS2VybmVsQ3JlYXRlSW5mb3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzS2VybmVsQ3JlYXRlSW5mb3MoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEtlcm5lbENyZWF0ZUluZm9zKTogS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEtlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gS2VybmVsQ3JlYXRlSW5mb3M9IG9ialxuICAgICAqIEByZXR1cm5zIEtlcm5lbENyZWF0ZUluZm9zXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0tlcm5lbENyZWF0ZUluZm9zKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBLZXJuZWxDcmVhdGVJbmZvcyk6XG4gICAgICAgIEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEtlcm5lbENyZWF0ZUluZm9zKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUluZGljZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVWludDMyQXJyYXlcbiAgICAgKi9cbiAgICBub2RlSW5kaWNlc0FycmF5KCk6IFVpbnQzMkFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgP1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBrZXJuZWxEZWZIYXNoZXMoaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLkxvbmd8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KSA6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBrZXJuZWxEZWZIYXNoZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUluZGljZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTm9kZUluZGljZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBub2RlSW5kaWNlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48bnVtYmVyPiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU5vZGVJbmRpY2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IG51bWJlcltdfFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDMyKGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBrZXJuZWxEZWZIYXNoZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2VybmVsRGVmSGFzaGVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbERlZkhhc2hlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGtlcm5lbERlZkhhc2hlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuTG9uZ1tdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgZGF0YS5sZW5ndGgsIDgpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQ2NChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlSW5kaWNlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBrZXJuZWxEZWZIYXNoZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBLZXJuZWxDcmVhdGVJbmZvcy5zdGFydEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXIpO1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3MuYWRkTm9kZUluZGljZXMoYnVpbGRlciwgbm9kZUluZGljZXNPZmZzZXQpO1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3MuYWRkS2VybmVsRGVmSGFzaGVzKGJ1aWxkZXIsIGtlcm5lbERlZkhhc2hlc09mZnNldCk7XG4gICAgICByZXR1cm4gS2VybmVsQ3JlYXRlSW5mb3MuZW5kS2VybmVsQ3JlYXRlSW5mb3MoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTdWJHcmFwaFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFN1YkdyYXBoU2Vzc2lvblN0YXRlKTogU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTdWJHcmFwaFNlc3Npb25TdGF0ZSk6XG4gICAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGdyYXBoSWQoKTogc3RyaW5nfG51bGw7XG4gICAgZ3JhcGhJZChvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZ3JhcGhJZChvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZXxudWxsXG4gICAgICovXG4gICAgc2Vzc2lvblN0YXRlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaElkT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEdyYXBoSWQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhJZE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGdyYXBoSWRPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNlc3Npb25TdGF0ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgc2Vzc2lvblN0YXRlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICBidWlsZGVyLnJlcXVpcmVkRmllbGQob2Zmc2V0LCA0KTsgIC8vIGdyYXBoX2lkXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTdWJHcmFwaFNlc3Npb25TdGF0ZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhJZE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZS5zdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUuYWRkR3JhcGhJZChidWlsZGVyLCBncmFwaElkT2Zmc2V0KTtcbiAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlLmFkZFNlc3Npb25TdGF0ZShidWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFN1YkdyYXBoU2Vzc2lvblN0YXRlLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNlc3Npb25TdGF0ZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTZXNzaW9uU3RhdGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2Vzc2lvblN0YXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXNzaW9uU3RhdGUpOiBTZXNzaW9uU3RhdGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1Nlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2Vzc2lvblN0YXRlKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zfG51bGxcbiAgICAgKi9cbiAgICBrZXJuZWxzKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGVcbiAgICAgKi9cbiAgICBzdWJHcmFwaFNlc3Npb25TdGF0ZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TdWJHcmFwaFNlc3Npb25TdGF0ZSk6XG4gICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdWJHcmFwaFNlc3Npb25TdGF0ZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGtlcm5lbHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkS2VybmVscyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXJuZWxzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwga2VybmVsc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOlxuICAgICAgICBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXNzaW9uU3RhdGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgU2Vzc2lvblN0YXRlLnN0YXJ0U2Vzc2lvblN0YXRlKGJ1aWxkZXIpO1xuICAgICAgU2Vzc2lvblN0YXRlLmFkZEtlcm5lbHMoYnVpbGRlciwga2VybmVsc09mZnNldCk7XG4gICAgICBTZXNzaW9uU3RhdGUuYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzKGJ1aWxkZXIsIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldCk7XG4gICAgICByZXR1cm4gU2Vzc2lvblN0YXRlLmVuZFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEluZmVyZW5jZVNlc3Npb249IG9ialxuICAgICAqIEByZXR1cm5zIEluZmVyZW5jZVNlc3Npb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogSW5mZXJlbmNlU2Vzc2lvbik6IEluZmVyZW5jZVNlc3Npb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBJbmZlcmVuY2VTZXNzaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0luZmVyZW5jZVNlc3Npb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEluZmVyZW5jZVNlc3Npb24pOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IEluZmVyZW5jZVNlc3Npb24oKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVmZmVySGFzSWRlbnRpZmllcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGJiLl9faGFzX2lkZW50aWZpZXIoJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgb3J0VmVyc2lvbigpOiBzdHJpbmd8bnVsbDtcbiAgICBvcnRWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBvcnRWZXJzaW9uKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbD0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbHxudWxsXG4gICAgICovXG4gICAgbW9kZWwob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Nb2RlbCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWx8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbFxuICAgICAqL1xuICAgIHNlc3Npb25TdGF0ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcnRWZXJzaW9uT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE9ydFZlcnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG9ydFZlcnNpb25PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG1vZGVsT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1vZGVsKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbW9kZWxPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNlc3Npb25TdGF0ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgc2Vzc2lvblN0YXRlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuZmluaXNoKG9mZnNldCwgJ09SVE0nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5maW5pc2gob2Zmc2V0LCAnT1JUTScsIHRydWUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvcnRWZXJzaW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIG1vZGVsT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHNlc3Npb25TdGF0ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uc3RhcnRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXIpO1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5hZGRPcnRWZXJzaW9uKGJ1aWxkZXIsIG9ydFZlcnNpb25PZmZzZXQpO1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5hZGRNb2RlbChidWlsZGVyLCBtb2RlbE9mZnNldCk7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLmFkZFNlc3Npb25TdGF0ZShidWlsZGVyLCBzZXNzaW9uU3RhdGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIEluZmVyZW5jZVNlc3Npb24uZW5kSW5mZXJlbmNlU2Vzc2lvbihidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24sIFNlc3Npb25IYW5kbGVyLCBUZW5zb3J9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQge1Nlc3Npb259IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQge1RlbnNvciBhcyBPbm54anNUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGNsYXNzIE9ubnhqc1Nlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgU2Vzc2lvbkhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlc3Npb246IFNlc3Npb24pIHtcbiAgICB0aGlzLmlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb24uaW5wdXROYW1lcztcbiAgICB0aGlzLm91dHB1dE5hbWVzID0gdGhpcy5zZXNzaW9uLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHt9XG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFzeW5jIHJ1bihcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIF9mZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICAgIF9vcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBjb25zdCBpbnB1dE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBPbm54anNUZW5zb3I+KCk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGZlZWRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZmVlZHMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZlZWQgPSBmZWVkc1tuYW1lXTtcbiAgICAgICAgaW5wdXRNYXAuc2V0KFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG5ldyBPbm54anNUZW5zb3IoXG4gICAgICAgICAgICAgICAgZmVlZC5kaW1zLCBmZWVkLnR5cGUgYXMgT25ueGpzVGVuc29yLkRhdGFUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmZWVkLmRhdGEgYXMgT25ueGpzVGVuc29yLk51bWJlclR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0TWFwID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihpbnB1dE1hcCk7XG4gICAgY29uc3Qgb3V0cHV0OiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgb3V0cHV0TWFwLmZvckVhY2goKHRlbnNvciwgbmFtZSkgPT4ge1xuICAgICAgb3V0cHV0W25hbWVdID0gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIHRlbnNvci5kaW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24uZW5kUHJvZmlsaW5nKCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3JlYWRGaWxlfSBmcm9tICdmcyc7XG5pbXBvcnQge3Byb21pc2lmeX0gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7cmVzb2x2ZUJhY2tlbmQsIFNlc3Npb25IYW5kbGVyVHlwZX0gZnJvbSAnLi9iYWNrZW5kJztcbmltcG9ydCB7RXhlY3V0aW9uUGxhbn0gZnJvbSAnLi9leGVjdXRpb24tcGxhbic7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7UHJvZmlsZXJ9IGZyb20gJy4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge01vZGVsfSBmcm9tICcuL21vZGVsJztcbmltcG9ydCB7T3BlcmF0b3J9IGZyb20gJy4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBTZXNzaW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICAgIGJhY2tlbmRIaW50Pzogc3RyaW5nO1xuICAgIHByb2ZpbGVyPzogUHJvZmlsZXIuQ29uZmlnO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBDb250ZXh0IHtcbiAgICBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+O1xuICAgIGdyYXBoSW5wdXRUeXBlcz86IFRlbnNvci5EYXRhVHlwZVtdO1xuICAgIGdyYXBoSW5wdXREaW1zPzogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnOiBTZXNzaW9uLkNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tlbmRIaW50ID0gY29uZmlnLmJhY2tlbmRIaW50O1xuICAgIHRoaXMucHJvZmlsZXIgPSBQcm9maWxlci5jcmVhdGUoY29uZmlnLnByb2ZpbGVyKTtcbiAgICB0aGlzLmNvbnRleHQgPSB7cHJvZmlsZXI6IHRoaXMucHJvZmlsZXIsIGdyYXBoSW5wdXRUeXBlczogW10sIGdyYXBoSW5wdXREaW1zOiBbXX07XG4gIH1cblxuICBnZXQgaW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKTtcbiAgfVxuICBnZXQgb3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO1xuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKSB7XG4gICAgdGhpcy5wcm9maWxlci5zdGFydCgpO1xuICB9XG5cbiAgZW5kUHJvZmlsaW5nKCkge1xuICAgIHRoaXMucHJvZmlsZXIuc3RvcCgpO1xuICB9XG5cbiAgYXN5bmMgbG9hZE1vZGVsKHVyaTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcbiAgYXN5bmMgbG9hZE1vZGVsKGJ1ZmZlcjogQXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQ/OiBudW1iZXIsIGxlbmd0aD86IG51bWJlcik6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGxvYWRNb2RlbChidWZmZXI6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBsb2FkTW9kZWwoYXJnOiBzdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheSwgYnl0ZU9mZnNldD86IG51bWJlciwgbGVuZ3RoPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdTZXNzaW9uLmxvYWRNb2RlbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIHJlc29sdmUgYmFja2VuZCBhbmQgc2Vzc2lvbiBoYW5kbGVyXG4gICAgICBjb25zdCBiYWNrZW5kID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmQodGhpcy5iYWNrZW5kSGludCk7XG4gICAgICB0aGlzLnNlc3Npb25IYW5kbGVyID0gYmFja2VuZC5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpO1xuXG4gICAgICB0aGlzLl9tb2RlbCA9IG5ldyBNb2RlbCgpO1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGlzT3J0Rm9ybWF0ID0gYXJnLmVuZHNXaXRoKCcub3J0Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gbm9kZVxuICAgICAgICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IHByb21pc2lmeShyZWFkRmlsZSkoYXJnKTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemUoQnVmZmVyLmZyb20oYnVmKSwgaXNPcnRGb3JtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJyb3dzZXJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFyZyk7XG4gICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemUobmV3IFVpbnQ4QXJyYXkoYnVmKSwgaXNPcnRGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKSkge1xuICAgICAgICAvLyBsb2FkIG1vZGVsIGZyb20gQXJyYXlCdWZmZXJcbiAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYXJnLCBieXRlT2Zmc2V0IHx8IDAsIGxlbmd0aCB8fCBhcmcuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShhcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9hZCBtb2RlbCBmcm9tIFVpbnQ4YXJyYXlcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGFyZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemUobW9kZWxQcm90b0Jsb2I6IFVpbnQ4QXJyYXksIGlzT3J0Rm9ybWF0PzogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdTZXNzaW9uLmluaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgICAvLyBsb2FkIGdyYXBoXG4gICAgICBjb25zdCBncmFwaEluaXRpYWxpemVyID1cbiAgICAgICAgICB0aGlzLnNlc3Npb25IYW5kbGVyLnRyYW5zZm9ybUdyYXBoID8gdGhpcy5zZXNzaW9uSGFuZGxlciBhcyBHcmFwaC5Jbml0aWFsaXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX21vZGVsLmxvYWQobW9kZWxQcm90b0Jsb2IsIGdyYXBoSW5pdGlhbGl6ZXIsIGlzT3J0Rm9ybWF0KTtcblxuICAgICAgLy8gZ3JhcGggaXMgY29tcGxldGVseSBpbml0aWFsemllZCBhdCB0aGlzIHN0YWdlICwgbGV0IHRoZSBpbnRlcmVzdGVkIGhhbmRsZXJzIGtub3dcbiAgICAgIGlmICh0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnNlc3Npb25IYW5kbGVyLm9uR3JhcGhJbml0aWFsaXplZCh0aGlzLl9tb2RlbC5ncmFwaCk7XG4gICAgICB9XG4gICAgICAvLyBpbml0aWFsaXplIGVhY2ggb3BlcmF0b3IgaW4gdGhlIGdyYXBoXG4gICAgICB0aGlzLmluaXRpYWxpemVPcHModGhpcy5fbW9kZWwuZ3JhcGgpO1xuXG4gICAgICAvLyBpbnN0YW50aWF0ZSBhbiBFeGVjdXRpb25QbGFuIG9iamVjdCB0byBiZSB1c2VkIGJ5IHRoZSBTZXNzaW9uIG9iamVjdFxuICAgICAgdGhpcy5fZXhlY3V0aW9uUGxhbiA9IG5ldyBFeGVjdXRpb25QbGFuKHRoaXMuX21vZGVsLmdyYXBoLCB0aGlzLl9vcHMsIHRoaXMucHJvZmlsZXIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgYXN5bmMgcnVuKGlucHV0czogTWFwPHN0cmluZywgVGVuc29yPnxUZW5zb3JbXSk6IFByb21pc2U8TWFwPHN0cmluZywgVGVuc29yPj4ge1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBub3QgaW5pdGlhbGl6ZWQgeWV0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ3Nlc3Npb24nLCAnU2Vzc2lvbi5ydW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dFRlbnNvcnMgPSB0aGlzLm5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgICAgIGNvbnN0IG91dHB1dFRlbnNvcnMgPSBhd2FpdCB0aGlzLl9leGVjdXRpb25QbGFuLmV4ZWN1dGUodGhpcy5zZXNzaW9uSGFuZGxlciwgaW5wdXRUZW5zb3JzKTtcblxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3V0cHV0KG91dHB1dFRlbnNvcnMpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBub3JtYWxpemVBbmRWYWxpZGF0ZUlucHV0cyhpbnB1dHM6IE1hcDxzdHJpbmcsIFRlbnNvcj58VGVuc29yW10pOiBUZW5zb3JbXSB7XG4gICAgY29uc3QgbW9kZWxJbnB1dE5hbWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO1xuXG4gICAgLy8gbm9ybWFsaXplIGlucHV0c1xuICAgIC8vIGlucHV0czogVGVuc29yW11cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gbW9kZWxJbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBhcnJheSBsZW5ndGg6IGV4cGVjdGVkICR7bW9kZWxJbnB1dE5hbWVzLmxlbmd0aH0gYnV0IGdvdCAke2lucHV0cy5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgbWFwIHRvIGFycmF5XG4gICAgLy8gaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+XG4gICAgZWxzZSB7XG4gICAgICBpZiAoaW5wdXRzLnNpemUgIT09IG1vZGVsSW5wdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgbWFwIHNpemU6IGV4cGVjdGVkICR7bW9kZWxJbnB1dE5hbWVzLmxlbmd0aH0gYnV0IGdvdCAke2lucHV0cy5zaXplfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzb3J0ZWRJbnB1dHMgPSBuZXcgQXJyYXk8VGVuc29yPihpbnB1dHMuc2l6ZSk7XG4gICAgICBsZXQgc29ydGVkSW5wdXRzSW5kZXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbElucHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGVuc29yID0gaW5wdXRzLmdldChtb2RlbElucHV0TmFtZXNbaV0pO1xuICAgICAgICBpZiAoIXRlbnNvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCB0ZW5zb3IgZm9yOiAnJHtuYW1lfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3J0ZWRJbnB1dHNbc29ydGVkSW5wdXRzSW5kZXgrK10gPSB0ZW5zb3I7XG4gICAgICB9XG5cbiAgICAgIGlucHV0cyA9IHNvcnRlZElucHV0cztcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBkaW1zIHJlcXVpcmVtZW50c1xuICAgIC8vIEZpcnN0IHNlc3Npb24gcnVuIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBub3QgY2FjaGVkIGZvciB0aGUgc2Vzc2lvblxuICAgIGlmICghdGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcyB8fCB0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zIHx8XG4gICAgICAgIHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IG1vZGVsSW5wdXRJbmRpY2VzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXRJbmRpY2VzKCk7XG4gICAgICBjb25zdCBtb2RlbFZhbHVlcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldFZhbHVlcygpO1xuXG4gICAgICBjb25zdCBncmFwaElucHV0RGltcyA9IG5ldyBBcnJheTxyZWFkb25seSBudW1iZXJbXT4obW9kZWxJbnB1dEluZGljZXMubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbElucHV0SW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBncmFwaElucHV0ID0gbW9kZWxWYWx1ZXNbbW9kZWxJbnB1dEluZGljZXNbaV1dO1xuICAgICAgICBncmFwaElucHV0RGltc1tpXSA9IGdyYXBoSW5wdXQudHlwZSEuc2hhcGUuZGltcztcblxuICAgICAgICAvLyBjYWNoZWQgZm9yIHNlY29uZCBhbmQgc3Vic2VxdWVudCBydW5zLlxuICAgICAgICAvLyBTb21lIHBhcnRzIG9mIHRoZSBmcmFtZXdvcmsgd29ya3Mgb24gdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgZ3JhcGggYW5kIHR5cGVzIGFuZCBzaGFwZXMgYXJlIHN0YXRpY1xuICAgICAgICB0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzIS5wdXNoKGdyYXBoSW5wdXQudHlwZSEudGVuc29yVHlwZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyEucHVzaChpbnB1dHNbaV0uZGltcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmFsaWRhdGVJbnB1dFRlbnNvckRpbXMoZ3JhcGhJbnB1dERpbXMsIGlucHV0cywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gU2Vjb25kIGFuZCBzdWJzZXF1ZW50IHNlc3Npb24gcnVucyAtIGdyYXBoIGlucHV0IGRhdGEgaXMgY2FjaGVkIGZvciB0aGUgc2Vzc2lvblxuICAgIGVsc2Uge1xuICAgICAgdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMsIGlucHV0cywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHR5cGVzIHJlcXVpcmVtZW50XG4gICAgdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yVHlwZXModGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcyEsIGlucHV0cyk7XG5cbiAgICByZXR1cm4gaW5wdXRzO1xuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZUlucHV0VGVuc29yVHlwZXMoZ3JhcGhJbnB1dFR5cGVzOiBUZW5zb3IuRGF0YVR5cGVbXSwgZ2l2ZW5JbnB1dHM6IFRlbnNvcltdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnaXZlbklucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ3JhcGhJbnB1dFR5cGVzW2ldO1xuICAgICAgY29uc3QgYWN0dWFsVHlwZSA9IGdpdmVuSW5wdXRzW2ldLnR5cGU7XG4gICAgICBpZiAoZXhwZWN0ZWRUeXBlICE9PSBhY3R1YWxUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7aX1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgdHlwZSAnJHtleHBlY3RlZFR5cGV9JyBidXQgZ290ICR7YWN0dWFsVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKFxuICAgICAgZ3JhcGhJbnB1dERpbXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPiwgZ2l2ZW5JbnB1dHM6IFRlbnNvcltdLCBub25lRGltU3VwcG9ydGVkOiBib29sZWFuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnaXZlbklucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwZWN0ZWREaW1zID0gZ3JhcGhJbnB1dERpbXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxEaW1zID0gZ2l2ZW5JbnB1dHNbaV0uZGltcztcbiAgICAgIGlmICghdGhpcy5jb21wYXJlVGVuc29yRGltcyhleHBlY3RlZERpbXMsIGFjdHVhbERpbXMsIG5vbmVEaW1TdXBwb3J0ZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgdGVuc29yWyR7aX1dIGNoZWNrIGZhaWxlZDogZXhwZWN0ZWQgc2hhcGUgJ1ske2V4cGVjdGVkRGltcy5qb2luKCcsJyl9XScgYnV0IGdvdCBbJHtcbiAgICAgICAgICAgIGFjdHVhbERpbXMuam9pbignLCcpfV1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbXBhcmVUZW5zb3JEaW1zKGV4cGVjdGVkRGltczogcmVhZG9ubHkgbnVtYmVyW10sIGFjdHVhbERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBub25lRGltU3VwcG9ydGVkOiBib29sZWFuKTpcbiAgICAgIGJvb2xlYW4ge1xuICAgIGlmIChleHBlY3RlZERpbXMubGVuZ3RoICE9PSBhY3R1YWxEaW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwZWN0ZWREaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoZXhwZWN0ZWREaW1zW2ldICE9PSBhY3R1YWxEaW1zW2ldICYmICghbm9uZURpbVN1cHBvcnRlZCB8fCBleHBlY3RlZERpbXNbaV0gIT09IDApKSB7XG4gICAgICAgIC8vIGRhdGEgc2hhcGUgbWlzLW1hdGNoIEFORCBub3QgYSAnTm9uZScgZGltZW5zaW9uLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU91dHB1dChvdXRwdXRUZW5zb3JzOiBUZW5zb3JbXSk6IE1hcDxzdHJpbmcsIFRlbnNvcj4ge1xuICAgIGNvbnN0IG1vZGVsT3V0cHV0TmFtZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRPdXRwdXROYW1lcygpO1xuICAgIGlmIChvdXRwdXRUZW5zb3JzLmxlbmd0aCAhPT0gbW9kZWxPdXRwdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgbnVtYmVyIG9mIG91dHB1dHMgZG8gbm90IG1hdGNoIG51bWJlciBvZiBnZW5lcmF0ZWQgb3V0cHV0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBNYXA8c3RyaW5nLCBUZW5zb3I+KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbE91dHB1dE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBvdXRwdXQuc2V0KG1vZGVsT3V0cHV0TmFtZXNbaV0sIG91dHB1dFRlbnNvcnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVPcHMoZ3JhcGg6IEdyYXBoKTogdm9pZCB7XG4gICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXROb2RlcygpO1xuICAgIHRoaXMuX29wcyA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fb3BzW2ldID0gdGhpcy5zZXNzaW9uSGFuZGxlci5yZXNvbHZlKG5vZGVzW2ldLCB0aGlzLl9tb2RlbC5vcHNldHMsIGdyYXBoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9tb2RlbDogTW9kZWw7XG4gIHByaXZhdGUgX2luaXRpYWxpemVkOiBib29sZWFuO1xuXG4gIHByaXZhdGUgX29wczogT3BlcmF0b3JbXTtcbiAgcHJpdmF0ZSBfZXhlY3V0aW9uUGxhbjogRXhlY3V0aW9uUGxhbjtcblxuICBwcml2YXRlIGJhY2tlbmRIaW50Pzogc3RyaW5nO1xuXG4gIHByaXZhdGUgc2Vzc2lvbkhhbmRsZXI6IFNlc3Npb25IYW5kbGVyVHlwZTtcbiAgcHJpdmF0ZSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQ7XG4gIHByaXZhdGUgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPjtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0d1aWR9IGZyb20gJ2d1aWQtdHlwZXNjcmlwdCc7XG5pbXBvcnQgTG9uZyBmcm9tICdsb25nJztcbmltcG9ydCB7b25ueH0gZnJvbSAnb25ueC1wcm90byc7XG5cbmltcG9ydCB7b25ueHJ1bnRpbWV9IGZyb20gJy4vb3J0LXNjaGVtYS9vcnQtZ2VuZXJhdGVkJztcblxuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5cbmltcG9ydCB7UHJvdG9VdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUZW5zb3Ige1xuICBleHBvcnQgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MzI6IEZsb2F0MzJBcnJheTtcbiAgICBmbG9hdDY0OiBGbG9hdDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBpbnQ4OiBJbnQ4QXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgdWludDE2OiBVaW50MTZBcnJheTtcbiAgICBpbnQzMjogSW50MzJBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcblxuICBleHBvcnQgdHlwZSBTdHJpbmdUeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXTtcbiAgZXhwb3J0IHR5cGUgQm9vbGVhblR5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Jvb2wnXTtcbiAgZXhwb3J0IHR5cGUgSW50ZWdlclR5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ2ludDgnXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQ4J118VGVuc29yLkRhdGFUeXBlTWFwWydpbnQxNiddfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRlbnNvci5EYXRhVHlwZU1hcFsndWludDE2J118VGVuc29yLkRhdGFUeXBlTWFwWydpbnQzMiddfFRlbnNvci5EYXRhVHlwZU1hcFsndWludDMyJ107XG4gIGV4cG9ydCB0eXBlIEZsb2F0VHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnZmxvYXQzMiddfFRlbnNvci5EYXRhVHlwZU1hcFsnZmxvYXQ2NCddO1xuICBleHBvcnQgdHlwZSBOdW1iZXJUeXBlID0gQm9vbGVhblR5cGV8SW50ZWdlclR5cGV8RmxvYXRUeXBlO1xuXG4gIGV4cG9ydCB0eXBlIElkID0gR3VpZDtcbn1cblxudHlwZSBUZW5zb3JEYXRhID0gVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV07XG5cbnR5cGUgRGF0YVByb3ZpZGVyID0gKGlkOiBUZW5zb3IuSWQpID0+IFRlbnNvckRhdGE7XG50eXBlIEFzeW5jRGF0YVByb3ZpZGVyID0gKGlkOiBUZW5zb3IuSWQpID0+IFByb21pc2U8VGVuc29yRGF0YT47XG5cbmV4cG9ydCBjbGFzcyBUZW5zb3Ige1xuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHRlbnNvciBkYXRhXG4gICAqL1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhIHtcbiAgICBpZiAodGhpcy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhUHJvdmlkZXIhKHRoaXMuZGF0YUlkKTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIG9mIGRhdGEgcHJvdmlkZWQgYnkgdGhlIERhdGEgUHJvdmlkZXIgaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIGRpbXMgb2YgdGhpcyBUZW5zb3IuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHN0cmluZyB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBTVFJJTkdcbiAgICovXG4gIGdldCBzdHJpbmdEYXRhKCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIHR5cGUgaXMgbm90IHN0cmluZycpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLlN0cmluZ1R5cGU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIGludGVnZXIgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6IChVSU5UOCwgSU5UOCwgVUlOVDE2LFxuICAgKiBJTlQxNiwgSU5UMzIsIFVJTlQzMiwgQk9PTClcbiAgICovXG4gIGdldCBpbnRlZ2VyRGF0YSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5JbnRlZ2VyVHlwZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBpbnRlZ2VyICh1aW50OCwgaW50OCwgdWludDE2LCBpbnQxNiwgaW50MzIsIHVpbnQzMiwgYm9vbCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIGZsb2F0IHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAoRkxPQVQsIERPVUJMRSlcbiAgICovXG4gIGdldCBmbG9hdERhdGEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLkZsb2F0VHlwZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBmbG9hdCAoZmxvYXQzMiwgZmxvYXQ2NCknKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIG51bWJlciB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzogKFVJTlQ4LCBJTlQ4LCBVSU5UMTYsXG4gICAqIElOVDE2LCBJTlQzMiwgVUlOVDMyLCBCT09MLCBGTE9BVCwgRE9VQkxFKVxuICAgKi9cbiAgZ2V0IG51bWJlckRhdGEoKSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEgYXMgVGVuc29yLk51bWJlclR5cGU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R5cGUgY2Fubm90IGJlIG5vbi1udW1iZXIgKHN0cmluZyknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdmFsdWUgb2YgYW4gZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kaWNlc1xuICAgKi9cbiAgZ2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV1bbnVtYmVyXSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXMsIHRoaXMuc3RyaWRlcyldO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCB2YWx1ZSBvZiBhbiBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRpY2VzXG4gICAqL1xuICBzZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIHZhbHVlOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXVtudW1iZXJdKSB7XG4gICAgdGhpcy5kYXRhW1NoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoaW5kaWNlcywgdGhpcy5zdHJpZGVzKV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHVuZGVybHlpbmcgdGVuc29yIGRhdGEgYXN5bmNocm9ub3VzbHlcbiAgICovXG4gIGFzeW5jIGdldERhdGEoKTogUHJvbWlzZTxUZW5zb3JEYXRhPiB7XG4gICAgLy8gVEJEOiBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIGZvciB1c2FnZSB3aGVuIGFueSBiYWNrZW5kIGRhdGEgcHJvdmlkZXIgb2ZmZXJzIGEgd2F5IHRvIHJldHJpZXZlIGRhdGEgaW4gYW5cbiAgICAvLyAgICAgIGFzeW5jaHJvbm91cyB3YXkuIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBmdW5jdGlvbiB3aGVuIGVuYWJsaW5nIHdlYmdsIGFzeW5jIHJlYWQgZGF0YS5cblxuICAgIGlmICh0aGlzLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBhd2FpdCB0aGlzLmFzeW5jRGF0YVByb3ZpZGVyISh0aGlzLmRhdGFJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzaXplOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0cmlkZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAqL1xuICBnZXQgc3RyaWRlcygpOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKCF0aGlzLl9zdHJpZGVzKSB7XG4gICAgICB0aGlzLl9zdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHRoaXMuZGltcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpZGVzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFRlbnNvci5EYXRhVHlwZSwgcHJpdmF0ZSBkYXRhUHJvdmlkZXI/OiBEYXRhUHJvdmlkZXIsXG4gICAgICBwcml2YXRlIGFzeW5jRGF0YVByb3ZpZGVyPzogQXN5bmNEYXRhUHJvdmlkZXIsIHByaXZhdGUgY2FjaGU/OiBUZW5zb3JEYXRhLFxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIGRhdGEgSUQgdGhhdCB1c2VkIHRvIG1hcCB0byBhIHRlbnNvciBkYXRhXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkYXRhSWQ6IEd1aWQgPSBHdWlkLmNyZWF0ZSgpKSB7XG4gICAgdGhpcy5zaXplID0gU2hhcGVVdGlsLnZhbGlkYXRlRGltc0FuZENhbGNTaXplKGRpbXMpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgZW1wdHkgPSAoZGF0YVByb3ZpZGVyID09PSB1bmRlZmluZWQgJiYgYXN5bmNEYXRhUHJvdmlkZXIgPT09IHVuZGVmaW5lZCAmJiBjYWNoZSA9PT0gdW5kZWZpbmVkKTtcblxuICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY2FjaGUubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnB1dCBkaW1zIGRvZXNuXFwndCBtYXRjaCBkYXRhIGxlbmd0aC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkICYmICghQXJyYXkuaXNBcnJheShjYWNoZSkgfHwgIWNhY2hlLmV2ZXJ5KGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IEFycmF5PHN0cmluZz4oc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgaWYgKCEoY2FjaGUgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZSBzaG91bGQgYmUgdHlwZSAke2NvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzaXplICogc2l6ZW9mKHR5cGUpKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNyZWF0ZVZpZXcoYnVmLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW5zb3IgZnJvbSBhIE9OTlggVGVuc29yIG9iamVjdFxuICAgKiBAcGFyYW0gdGVuc29yUHJvdG8gdGhlIE9OTlggVGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbVByb3RvKHRlbnNvclByb3RvOiBvbm54LklUZW5zb3JQcm90byk6IFRlbnNvciB7XG4gICAgaWYgKCF0ZW5zb3JQcm90bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odGVuc29yUHJvdG8uZGF0YVR5cGUhKTtcbiAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odGVuc29yUHJvdG8uZGltcyEpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICB0ZW5zb3JQcm90by5zdHJpbmdEYXRhIS5mb3JFYWNoKChzdHIsIGkpID0+IHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oc3RyLmJ1ZmZlciwgc3RyLmJ5dGVPZmZzZXQsIHN0ci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IGJ1Zi50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0ZW5zb3JQcm90by5yYXdEYXRhICYmIHR5cGVvZiB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggPT09ICdudW1iZXInICYmXG4gICAgICAgIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgIC8vIE5PVCBjb25zaWRlcmluZyBzZWdtZW50IGZvciBub3cgKElNUE9SVEFOVClcblxuICAgICAgLy8gcG9wdWxhdGUgdmFsdWUgZnJvbSByYXdEYXRhXG4gICAgICBjb25zdCBkYXRhRGVzdCA9IHZhbHVlLmRhdGE7XG4gICAgICBjb25zdCBkYXRhU291cmNlID1cbiAgICAgICAgICBuZXcgRGF0YVZpZXcodGVuc29yUHJvdG8ucmF3RGF0YS5idWZmZXIsIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZU9mZnNldCwgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gc2l6ZW9mUHJvdG8odGVuc29yUHJvdG8uZGF0YVR5cGUhKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCAvIGVsZW1lbnRTaXplO1xuXG4gICAgICBpZiAodGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoICUgZWxlbWVudFNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhRGVzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gcmVhZFByb3RvKGRhdGFTb3VyY2UsIHRlbnNvclByb3RvLmRhdGFUeXBlISwgaSAqIGVsZW1lbnRTaXplKTtcbiAgICAgICAgZGF0YURlc3RbaV0gPSBuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIGFycmF5XG4gICAgICBsZXQgYXJyYXk6IEFycmF5PG51bWJlcnxMb25nPjtcbiAgICAgIHN3aXRjaCAodGVuc29yUHJvdG8uZGF0YVR5cGUpIHtcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uZmxvYXREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uaW50MzJEYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8uaW50NjREYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmRvdWJsZURhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgICAgIGFycmF5ID0gdGVuc29yUHJvdG8udWludDY0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biBoZXJlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNwZWNpZmljIGVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJheSA9PT0gbnVsbCB8fCBhcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHBvcHVsYXRlIGRhdGEgZnJvbSBhIHRlbnNvcnByb3RvIHZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5kYXRhO1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBsZW5ndGggbWlzbWF0Y2gnKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhlbGVtZW50KSkge1xuICAgICAgICAgIGRhdGFbaV0gPSBsb25nVG9OdW1iZXIoZWxlbWVudCwgdGVuc29yUHJvdG8uZGF0YVR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbaV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBuZXcgVGVuc29yIGZyb20gcmF3IGRhdGFcbiAgICogQHBhcmFtIGRhdGEgdGhlIHJhdyBkYXRhIG9iamVjdC4gU2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5IGZvciAnc3RyaW5nJyB0ZW5zb3IsIGFuZCB0aGUgY29ycmVzcG9uZGluZyB0eXBlZCBhcnJheVxuICAgKiBmb3Igb3RoZXIgdHlwZXMgb2YgdGVuc29yLlxuICAgKiBAcGFyYW0gZGltcyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICovXG4gIHN0YXRpYyBmcm9tRGF0YShkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVGVuc29yLkRhdGFUeXBlXSwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHR5cGU6IFRlbnNvci5EYXRhVHlwZSkge1xuICAgIHJldHVybiBuZXcgVGVuc29yKGRpbXMsIHR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkYXRhKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tT3J0VGVuc29yKG9ydFRlbnNvcjogb3J0RmJzLlRlbnNvcikge1xuICAgIGlmICghb3J0VGVuc29yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3InKTtcbiAgICB9XG4gICAgY29uc3QgZGltcyA9IFByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChvcnRUZW5zb3IpO1xuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8ob3J0VGVuc29yLmRhdGFUeXBlKCkpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ydFRlbnNvci5zdHJpbmdEYXRhTGVuZ3RoKCk7IGkrKykge1xuICAgICAgICB2YWx1ZS5kYXRhW2ldID0gb3J0VGVuc29yLnN0cmluZ0RhdGEoaSk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBvcnRUZW5zb3IucmF3RGF0YUFycmF5KCkgJiYgdHlwZW9mIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgPT09ICdudW1iZXInICYmIG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgPiAwKSB7XG4gICAgICAvLyBOT1QgY29uc2lkZXJpbmcgc2VnbWVudCBmb3Igbm93IChJTVBPUlRBTlQpXG5cbiAgICAgIC8vIHBvcHVsYXRlIHZhbHVlIGZyb20gcmF3RGF0YVxuICAgICAgY29uc3QgZGF0YURlc3QgPSB2YWx1ZS5kYXRhO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBEYXRhVmlldyhcbiAgICAgICAgICBvcnRUZW5zb3IucmF3RGF0YUFycmF5KCkhLmJ1ZmZlciwgb3J0VGVuc29yLnJhd0RhdGFBcnJheSgpIS5ieXRlT2Zmc2V0LCBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gc2l6ZW9mUHJvdG8ob3J0VGVuc29yLmRhdGFUeXBlKCkpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gb3J0VGVuc29yLnJhd0RhdGFMZW5ndGgoKSAvIGVsZW1lbnRTaXplO1xuXG4gICAgICBpZiAob3J0VGVuc29yLnJhd0RhdGFMZW5ndGgoKSAlIGVsZW1lbnRTaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBidWZmZXIgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YURlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IHJlYWRQcm90byhkYXRhU291cmNlLCBvcnRUZW5zb3IuZGF0YVR5cGUoKSwgaSAqIGVsZW1lbnRTaXplKTtcbiAgICAgICAgZGF0YURlc3RbaV0gPSBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2l6ZW9mKHR5cGU6IFRlbnNvci5EYXRhVHlwZSk6IG51bWJlciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgIGNhc2UgJ2ludDgnOlxuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnaW50MzInOlxuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgIHJldHVybiA4O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBjYWxjdWxhdGUgc2l6ZW9mKCkgb24gdHlwZSAke3R5cGV9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2l6ZW9mUHJvdG8odHlwZTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZXxvcnRGYnMuVGVuc29yRGF0YVR5cGUpOiBudW1iZXIge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpZXcoZGF0YUJ1ZmZlcjogQXJyYXlCdWZmZXIsIHR5cGU6IFRlbnNvci5EYXRhVHlwZSkge1xuICByZXR1cm4gbmV3IChkYXRhdmlld0NvbnN0cnVjdG9yKHR5cGUpKShkYXRhQnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBzaG91bGQgbmV2ZXIgcnVuIHRvIGhlcmVcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zcGVjaWZpZWQgZXJyb3InKTtcbiAgfVxufVxuXG4vLyBjb252ZXJ0IGEgbG9uZyBudW1iZXIgdG8gYSAzMi1iaXQgaW50ZWdlciAoY2FzdC1kb3duKVxuZnVuY3Rpb24gbG9uZ1RvTnVtYmVyKGk6IExvbmcsIHR5cGU6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGV8b3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgLy8gSU5UNjQsIFVJTlQzMiwgVUlOVDY0XG4gIGlmICh0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0IHx8IHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5JTlQ2NCkge1xuICAgIGlmIChpLmdyZWF0ZXJUaGFuT3JFcXVhbCgyMTQ3NDgzNjQ4KSB8fCBpLmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW50NjQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGUgPT09IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyIHx8IHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5VSU5UMzIgfHxcbiAgICAgIHR5cGUgPT09IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0IHx8IHR5cGUgPT09IG9ydEZicy5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpIHtcbiAgICBpZiAoaS5ncmVhdGVyVGhhbk9yRXF1YWwoNDI5NDk2NzI5NikgfHwgaS5sZXNzVGhhbigwKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndWludDY0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke29ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdHlwZV19YCk7XG4gIH1cblxuICByZXR1cm4gaS50b051bWJlcigpO1xufVxuXG4vLyByZWFkIG9uZSB2YWx1ZSBmcm9tIFRlbnNvclByb3RvXG5mdW5jdGlvbiByZWFkUHJvdG8odmlldzogRGF0YVZpZXcsIHR5cGU6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGV8b3J0RmJzLlRlbnNvckRhdGFUeXBlLCBieXRlT2Zmc2V0OiBudW1iZXIpOiBudW1iZXIge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgICByZXR1cm4gdmlldy5nZXRVaW50OChieXRlT2Zmc2V0KTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpcbiAgICAgIHJldHVybiB2aWV3LmdldEludDgoYnl0ZU9mZnNldCk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICAgIHJldHVybiB2aWV3LmdldFVpbnQxNihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQxNihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgIHJldHVybiB2aWV3LmdldEludDMyKGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OlxuICAgICAgcmV0dXJuIGxvbmdUb051bWJlcihcbiAgICAgICAgICBMb25nLmZyb21CaXRzKHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIHRydWUpLCB2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0ICsgNCwgdHJ1ZSksIGZhbHNlKSwgdHlwZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICAgIHJldHVybiB2aWV3LmdldEZsb2F0NjQoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgIHJldHVybiBsb25nVG9OdW1iZXIoXG4gICAgICAgICAgTG9uZy5mcm9tQml0cyh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKSwgdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIHRydWUpLCB0cnVlKSwgdHlwZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlYWQgZnJvbSBEYXRhVmlldyBmb3IgdHlwZSAke29ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdHlwZV19YCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2ZsYXRidWZmZXJzfSBmcm9tICdmbGF0YnVmZmVycyc7XG5pbXBvcnQgTG9uZyBmcm9tICdsb25nJztcbmltcG9ydCB7b25ueH0gZnJvbSAnb25ueC1wcm90byc7XG5cbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtvbm54cnVudGltZX0gZnJvbSAnLi9vcnQtc2NoZW1hL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuLy8gY2hlY2sgdGhlIGlucHV0cyBzaGFwZSBiZWZvcmUgcnVubmluZyBhbiBPUC5cbi8vIHJldHVybiB0cnVlIHdoZW4gdGhlIGlucHV0cyBwYXNzIHRoZSBjaGVja1xuLy8gcmV0dXJuIGZhbHNlIHdoZW4gdGhlIGlucHV0cyBkbyBub3QgZml0IHRoZSByZXF1aXJlbWVudFxuLy8gdGhyb3cgZXhjZXB0aW9uIHdoZW4gZmF0YWwgZXJyb3Igb3Igbm90IGltcGxlbWVudGVkXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJbnB1dHNTaGFwZShpbnB1dHM6IFRlbnNvcltdLCAuLi5leHBlY3RlZERpbWVuc2lvbnM6IG51bWJlcltdKTogYm9vbGVhbiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IGV4cGVjdGVkRGltZW5zaW9ucy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWlucHV0c1tpXS5kaW1zIHx8IGlucHV0c1tpXS5kaW1zLmxlbmd0aCAhPT0gZXhwZWN0ZWREaW1lbnNpb25zW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBFdmFsdWF0ZXMgdGhlIGdpdmVuIGV4cHJlc3Npb24gYW5kIGFzc2VydHMgZXJyb3IgbWVzc2FnZSBpZiBjb25kaXRpb24gaXMgdW5tZXQuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGV4cHI6IGJvb2xlYW4sIG1zZzogKCkgPT4gc3RyaW5nKSB7XG4gIGlmICghZXhwcikge1xuICAgIHRocm93IG5ldyBFcnJvcih0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IG1zZyA6IG1zZygpKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXJyYXlVdGlsIHtcbiAgLyoqXG4gICAqIFZlcmlmaWVzIGlmIDIgaW5wdXQgYXJyYXlzIGNvbnRhaW4gdGhlIHNhbWUgZWxlbWVudHMuXG4gICAqIEBwYXJhbSBuMSBBcnJheSAxXG4gICAqIEBwYXJhbSBuMiBBcnJheSAyXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlc2UgMiBhcmUgZXF1YWxcbiAgICovXG4gIHN0YXRpYyBhcnJheXNFcXVhbChcbiAgICAgIG4xOiByZWFkb25seSBudW1iZXJbXXxJbnQ4QXJyYXl8VWludDhBcnJheXxJbnQxNkFycmF5fFVpbnQxNkFycmF5fEludDMyQXJyYXl8VWludDMyQXJyYXl8VWludDhDbGFtcGVkQXJyYXl8XG4gICAgICBGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5LFxuICAgICAgbjI6IHJlYWRvbmx5IG51bWJlcltdfEludDhBcnJheXxVaW50OEFycmF5fEludDE2QXJyYXl8VWludDE2QXJyYXl8SW50MzJBcnJheXxVaW50MzJBcnJheXxVaW50OENsYW1wZWRBcnJheXxcbiAgICAgIEZsb2F0MzJBcnJheXxGbG9hdDY0QXJyYXkpIHtcbiAgICBpZiAobjEubGVuZ3RoICE9PSBuMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG4xW2ldICE9PSBuMltpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXRNdWxVdGlsIHtcbiAgLyoqXG4gICAqIEZpeCB0aGUgaW5wdXQgc2hhcGVzIGZvciBNYXRNdWwgb3BlcmF0aW9uIGlmIHRoZXkgbmVlZCBmaXhpbmdcbiAgICogQHBhcmFtIGRpbXNBIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBkaW1zQiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHByZXByb2Nlc3NlZCBpbnB1dCBzaGFwZXMgYXMgcmVxdWlyZWQgYnkgT05OWCBzcGVjaWZpY2F0aW9uc1xuICAgKi9cbiAgc3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyhkaW1zQTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbXNCOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICBbcmVhZG9ubHkgbnVtYmVyW10sIHJlYWRvbmx5IG51bWJlcltdXSB7XG4gICAgLy8gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIDEtRCwgaXQgaXMgcHJvbW90ZWQgdG8gYSBtYXRyaXggYnkgcHJlcGVuZGluZ1xuICAgIC8vIGEgMSB0byBpdHMgZGltZW5zaW9ucy4gQWZ0ZXIgbWF0cml4IG11bHRpcGxpY2F0aW9uIHRoZSBwcmVwZW5kZWQgMSBpc1xuICAgIC8vIHJlbW92ZWQuXG4gICAgY29uc3QgYSA9IChkaW1zQS5sZW5ndGggPT09IDEpID8gWzEsIGRpbXNBWzBdXSA6IGRpbXNBO1xuXG4gICAgLy8gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyAxLUQsIGl0IGlzIHByb21vdGVkIHRvIGEgbWF0cml4IGJ5IGFwcGVuZGluZ1xuICAgIC8vIGEgMSB0byBpdHMgZGltZW5zaW9ucy4gQWZ0ZXIgbWF0cml4IG11bHRpcGxpY2F0aW9uIHRoZSBhcHBlbmRlZCAxIGlzXG4gICAgLy8gcmVtb3ZlZC5cbiAgICBjb25zdCBiID0gKGRpbXNCLmxlbmd0aCA9PT0gMSkgPyBbZGltc0JbMF0sIDFdIDogZGltc0I7XG5cbiAgICByZXR1cm4gW2EsIGJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpeCB0aGUgb3V0cHV0IHNoYXBlIGNvbXB1dGVkIGZvciBNYXRNdWwgb3BlcmF0aW9uIGlmIGl0IG5lZWRzIGZpeGluZ1xuICAgKiBAcGFyYW0gb3V0cHV0U2hhcGUgVGhlIGNvbXB1dGVkIG91dHB1dFNoYXBlLiBTaG91bGQgYmUgYW4gYXJyYXkgKGF0bGVhc3Qgb2YgbGVuZ3RoIDIpIG9mIHBvc2l0aXZlIGludGVnZXJzLlxuICAgKiBUaGlzIHdpbGwgYmUgbXV0YXRlZC5cbiAgICogQHBhcmFtIGFSYW5rIFRoZSByYW5rIG9mIHRlbnNvciBBLlxuICAgKiBAcGFyYW0gYlJhbmsgVGhlIHJhbmsgb2YgdGVuc29yIEIuXG4gICAqL1xuICBzdGF0aWMgcG9zdHByb2Nlc3NPdXRwdXRTaGFwZShvdXRwdXRTaGFwZTogbnVtYmVyW10sIGFSYW5rOiBudW1iZXIsIGJSYW5rOiBudW1iZXIpIHtcbiAgICAvLyBSZW1vdmUgcHJlcGVuZGVkIGRpbWVuc2lvbiBpZiBmaXJzdCBpbnB1dCBpcyAxZFxuICAgIGlmIChhUmFuayA9PT0gMSkge1xuICAgICAgLy8gb3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5zbGljZSgwLCBvdXRwdXRTaGFwZS5sZW5ndGggLSAyKS5jb25jYXQob3V0cHV0U2hhcGUuc2xpY2Uob3V0cHV0U2hhcGUubGVuZ3RoIC0gMSkpO1xuICAgICAgb3V0cHV0U2hhcGUuc3BsaWNlKG91dHB1dFNoYXBlLmxlbmd0aCAtIDIsIDEpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYXBwZW5kZWQgZGltZW5zaW9uIGlmIHNlY29uZCBpbnB1dCBpcyAxZFxuICAgIGlmIChiUmFuayA9PT0gMSkge1xuICAgICAgb3V0cHV0U2hhcGUucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICogQHBhcmFtIGEgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNNYXRNdWxTaGFwZShhOiBbbnVtYmVyLCBudW1iZXJdLCBiOiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXXx1bmRlZmluZWQge1xuICAgIHJldHVybiAoYVsxXSAhPT0gYlswXSkgPyB1bmRlZmluZWQgOiBbYVswXSwgYlsxXV07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJyb2FkY2FzdFV0aWwge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIGJyb2FkY2FzdGluZyAyIHRlbnNvcnNcbiAgICogQHBhcmFtIGEgVGhlIHNoYXBlIG9mIHRlbnNvciBBLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGlzTWF0TXVsIFdoZXRoZXIgdGhlIG9wZXJhdGlvbiBpcyBNYXRNdWxcbiAgICogQHJldHVybnMgVGhlIGV4cGVjdGVkIHNoYXBlIG9mIHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCBpZiBOL0FcbiAgICovXG4gIHN0YXRpYyBjYWxjU2hhcGUoYWRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBiZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGlzTWF0TXVsID0gZmFsc2UpOiByZWFkb25seSBudW1iZXJbXXx1bmRlZmluZWQge1xuICAgIGNvbnN0IGFyYW5rID0gYWRpbXMubGVuZ3RoO1xuICAgIGNvbnN0IGJyYW5rID0gYmRpbXMubGVuZ3RoO1xuICAgIGlmIChhcmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJkaW1zO1xuICAgIH1cbiAgICBpZiAoYnJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBhZGltcztcbiAgICB9XG4gICAgY29uc3QgY3JhbmsgPSBNYXRoLm1heChhZGltcy5sZW5ndGgsIGJkaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgY2RpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihjcmFuayk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGxhc3QgMiBkaW1lbnNpb24gaWYgaXQgaXMgTWF0TXVsXG4gICAgaWYgKGlzTWF0TXVsKSB7XG4gICAgICBpZiAoYXJhbmsgPCAyIHx8IGJyYW5rIDwgMikge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3QgY1NoYXBlTWF0TXVsID1cbiAgICAgICAgICBNYXRNdWxVdGlsLmNhbGNNYXRNdWxTaGFwZShbYWRpbXNbYXJhbmsgLSAyXSwgYWRpbXNbYXJhbmsgLSAxXV0sIFtiZGltc1ticmFuayAtIDJdLCBiZGltc1ticmFuayAtIDFdXSk7XG4gICAgICBpZiAoY1NoYXBlTWF0TXVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFtjZGltc1tjcmFuayAtIDJdLCBjZGltc1tjcmFuayAtIDFdXSA9IGNTaGFwZU1hdE11bDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaXNNYXRNdWwgPyAzIDogMTsgaSA8PSBjcmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBhTGVuID0gYXJhbmsgLSBpIDwgMCA/IDEgOiBhZGltc1thcmFuayAtIGldO1xuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcblxuICAgICAgaWYgKGFMZW4gIT09IGJMZW4gJiYgYUxlbiA+IDEgJiYgYkxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNkaW1zW2NyYW5rIC0gaV0gPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2RpbXM7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gdGhlIGluZGljZXMgb2YgYSBicm9hZGNhc3RlZCB0ZW5zb3IsIGNhbGN1bGF0ZSB0aGUgb3JpZ2luYWwgaW5kaWNlc1xuICAgKiBAcGFyYW0gYnJvYWRjYXN0ZWRJbmRpY2VzIFRoZSBnaXZlbiBpbmRpY2VzIG9mIHRoZSBicm9hZGNhc3RlZCB0ZW5zb3IuXG4gICAqIEBwYXJhbSBvcmlnaW5hbFNoYXBlIFRoZSBvcmlnaW5hbCBzaGFwZSBvZiB0aGUgdGVuc29yIGJlZm9yZSBicm9hZGNhc1xuICAgKiBAcmV0dXJucyBUaGUgY2FsY3VsYXRlZCBpbmRpY2VzIHRoYXQgbWFwcyB0byB0aGUgb3JpZ2luYWwgdGVuc29yLlxuICAgKi9cbiAgc3RhdGljIGluZGV4KGJyb2FkY2FzdGVkSW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIG9yaWdpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIC8vIE5PVEUgMTogd2UgYXNzdW1lIHRoZSBwYXJhbWV0ZXIgYnJvYWRjYXN0ZWRJbmRpY2VzIGlzIHZhbGlkLiBpZS4gaXQgc2hvdWxkIGhhdmUgdGhlIHNhbWVcbiAgICAvLyBsZW5ndGggYXMgdGhlIGJyb2FkY2FzdGVkIHNoYXBlLCBhbmQgZm9yIGVhY2ggZGltZW5zaW9uIHRoZSBpbmRleCBzaG91bGRcbiAgICAvLyBub3QgYmUgb3V0IG9mIHJhbmdlLlxuICAgIGNvbnN0IG9yaWdpbmFsSW5kaWNlcyA9IG5ldyBBcnJheShvcmlnaW5hbFNoYXBlLmxlbmd0aCk7XG4gICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgoYnJvYWRjYXN0ZWRJbmRpY2VzLCBvcmlnaW5hbFNoYXBlLCBvcmlnaW5hbEluZGljZXMpO1xuICAgIHJldHVybiBvcmlnaW5hbEluZGljZXM7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gdGhlIGluZGljZXMgb2YgYSBicm9hZGNhc3RlZCB0ZW5zb3IsIGNhbGN1bGF0ZSB0aGUgb3JpZ2luYWwgaW5kaWNlc1xuICAgKiBAcGFyYW0gYnJvYWRjYXN0ZWRJbmRpY2VzIFRoZSBnaXZlbiBpbmRpY2VzIG9mIHRoZSBicm9hZGNhc3RlZCB0ZW5zb3IuXG4gICAqIEBwYXJhbSBvcmlnaW5hbFNoYXBlIFRoZSBvcmlnaW5hbCBzaGFwZSBvZiB0aGUgdGVuc29yIGJlZm9yZSBicm9hZGNhc3RcbiAgICogQHBhcmFtIG9yaWdpbmFsSW5kaWNlcyBUaGUgbWFwcGluZyBvZiBicm9hZGNhc3RlZEluZGljZXMgdG8gdGhlIG9yaWdpbmFsSW5kaWNlcyAob3V0cHV0IHBhcmFtZXRlciAtIHdpbGwgYmVcbiAgICogICAgIG11dGF0ZWQpLlxuICAgKi9cbiAgc3RhdGljIGZpbGxJbmRleChicm9hZGNhc3RlZEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCBvcmlnaW5hbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3JpZ2luYWxJbmRpY2VzOiBudW1iZXJbXSkge1xuICAgIC8vIE5PVEUgMTogd2UgYXNzdW1lIHRoZSBwYXJhbWV0ZXIgYnJvYWRjYXN0ZWRJbmRpY2VzIGlzIHZhbGlkLiBpZS4gaXQgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuICAgIC8vIGJyb2FkY2FzdGVkIHNoYXBlLCBhbmQgZm9yIGVhY2ggZGltZW5zaW9uIHRoZSBpbmRleCBzaG91bGQgbm90IGJlIG91dCBvZiByYW5nZS5cbiAgICAvLyBOT1RFIDI6IHdlIGFzc3VtZSB0aGUgcGFyYW1ldGVyIG9yaWdpbmFsSW5kaWNlcyBoYXMgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBvcmlnaW5hbFNoYXBlXG4gICAgY29uc3QgZGltT2Zmc2V0ID0gYnJvYWRjYXN0ZWRJbmRpY2VzLmxlbmd0aCAtIG9yaWdpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWxTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgb3JpZ2luYWxJbmRpY2VzW2ldID0gYnJvYWRjYXN0ZWRJbmRpY2VzW2RpbU9mZnNldCArIGldICUgb3JpZ2luYWxTaGFwZVtpXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSB0aGUgYnJvYWRjYXN0aW5nIG9wZXJhdGlvbiBvbiB0aGUgc3BlY2lmaWMgb3BlcmF0b3JcbiAgICogQHBhcmFtIGEgVGhlIGlucHV0IHRlbnNvciBBXG4gICAqIEBwYXJhbSBiIFRoZSBpbnB1dCB0ZW5zb3IgQlxuICAgKiBAcGFyYW0gb3AgVGhlIG9wZXJhdG9yIGxhbWJkYSBmdW5jdGlvblxuICAgKiBAcGFyYW0gaW5wbGFjZSBXaGV0aGVyIHRvIHdyaXRlIHRoZSByZXN1bHQgYmFjayB0byBBLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IHRlbnNvciwgb3IgdW5kZWZpbmVkIGlmIGlucHV0IG5vdCBicm9hZGNhc3RhYmxlLlxuICAgKi9cbiAgc3RhdGljIGNhbGMoXG4gICAgICBhOiBUZW5zb3IsIGI6IFRlbnNvciwgb3A6IChhOiBzdHJpbmd8bnVtYmVyLCBiOiBzdHJpbmd8bnVtYmVyKSA9PiAoc3RyaW5nIHwgbnVtYmVyKSwgaW5wbGFjZTogYm9vbGVhbixcbiAgICAgIHJlc3VsdFR5cGU/OiBUZW5zb3IuRGF0YVR5cGUpOiBUZW5zb3J8dW5kZWZpbmVkIHtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGEuZGltcywgYi5kaW1zKTtcblxuICAgIGlmIChvdXRwdXRTaGFwZSkge1xuICAgICAgaWYgKGlucGxhY2UgJiYgIVNoYXBlVXRpbC5hcmVFcXVhbChvdXRwdXRTaGFwZSwgYS5kaW1zKSkge1xuICAgICAgICAvLyBCIGlzIG5vdCBicm9hZGNhc3RhYmxlIHRvIEEsIGZhaWxlZCB0byBjYWxjdWxhdGUgaW5wbGFjZS5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IGMgPSBpbnBsYWNlID8gYSA6IG5ldyBUZW5zb3Iob3V0cHV0U2hhcGUsIHJlc3VsdFR5cGUgfHwgYS50eXBlKTtcblxuICAgICAgLy8gYm90aCBpbnB1dHMgYXJlIHNjYWxhcnNcbiAgICAgIGlmIChvdXRwdXRTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYy5zZXQoW10sIG9wKGEuZ2V0KFtdKSwgYi5nZXQoW10pKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0bGVhc3Qgb25lIGlucHV0IGlzIGEgbm9uLXNjYWxhclxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNBID0gbmV3IEFycmF5KGEuZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNCID0gbmV3IEFycmF5KGIuZGltcy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmFsQTogc3RyaW5nfG51bWJlciA9IDA7XG4gICAgICAgIGxldCB2YWxCOiBzdHJpbmd8bnVtYmVyID0gMDtcbiAgICAgICAgbGV0IGlzQVNjYWxhciA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNCU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChhLmRpbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdmFsQSA9IGEuZ2V0KFtdKTtcbiAgICAgICAgICBpc0FTY2FsYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiLmRpbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdmFsQiA9IGIuZ2V0KFtdKTtcbiAgICAgICAgICBpc0JTY2FsYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN0OiBudW1iZXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgLy8gdHJhdmVyc2FsIGluZGljZXNcbiAgICAgICAgICByZXN0ID0gaTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gb3V0cHV0U2hhcGUubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIG91dHB1dEluZGljZXNbal0gPSByZXN0ICUgb3V0cHV0U2hhcGVbal07XG4gICAgICAgICAgICByZXN0ID0gTWF0aC5mbG9vcihyZXN0IC8gb3V0cHV0U2hhcGVbal0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNBU2NhbGFyKSB7XG4gICAgICAgICAgICAvLyBtYXAgb3V0cHV0SW5kaWNlcyAod2hpY2ggaXMgYWN0dWFsbHkgYnJvYWRjYXN0ZWQpIHRvIHRoZSBvcmlnaW5hbEluZGljZXNcbiAgICAgICAgICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KG91dHB1dEluZGljZXMsIGEuZGltcywgb3JpZ2luYWxJbmRpY2VzQSk7XG4gICAgICAgICAgICB2YWxBID0gYS5nZXQob3JpZ2luYWxJbmRpY2VzQSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNCU2NhbGFyKSB7XG4gICAgICAgICAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChvdXRwdXRJbmRpY2VzLCBiLmRpbXMsIG9yaWdpbmFsSW5kaWNlc0IpO1xuICAgICAgICAgICAgdmFsQiA9IGIuZ2V0KG9yaWdpbmFsSW5kaWNlc0IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMuc2V0KG91dHB1dEluZGljZXMsIG9wKHZhbEEsIHZhbEIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHNoYXBlIGlzIHVuaWRpcmVjdGlvbmFsIGJyb2FkY2FzdGFibGUgdG8gYW5vdGhlciBzaGFwZVxuICAgKiBAcGFyYW0gc2hhcGUgVGhlIGlucHV0IHNoYXBlXG4gICAqIEBwYXJhbSBmaW5hbFNoYXBlIFRoZSBkZXNpcmVkIHNoYXBlIGFmdGVyIGJyb2FkY2FzdGluZ1xuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRCcm9hZGNhc3Qoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBmaW5hbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIC8vIGFsaWduIHNoYXBlIHRvIHRoZSByaWdodFxuICAgIGNvbnN0IGlucHV0UmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBmaW5hbFJhbmsgPSBmaW5hbFNoYXBlLmxlbmd0aDtcbiAgICBpZiAoaW5wdXRSYW5rID4gZmluYWxSYW5rKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGlucHV0UmFuazsgaSsrKSB7XG4gICAgICBpZiAoc2hhcGVbaW5wdXRSYW5rIC0gaV0gIT09IDEgJiYgc2hhcGVbaW5wdXRSYW5rIC0gaV0gIT09IGZpbmFsU2hhcGVbZmluYWxSYW5rIC0gaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGJyb2FkY2FzdGVkIGRpbXMgaW4gaW5wdXQgc2hhcGUgYmFzZWQgb24gdGhlIGdpdmVuIG91dHB1dCBzaGFwZS5cbiAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gb25seSByZXR1cm5zIHRoZSBicm9hZGNhc3RlZCBkaW1zLlxuICAgKiBAcGFyYW0gaW5wdXRTaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIG91dHB1dFNoYXBlIFRoZSBvdXRwdXQgc2hhcGVcbiAgICogQHJldHVybnMgVGhlIGJyb2FkY2FzdGVkIGRpbXMgaW4gaW5wdXQgc2hhcGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0QnJvYWRjYXN0RGltcyhpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGluUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblJhbms7IGkrKykge1xuICAgICAgY29uc3QgZGltID0gaW5SYW5rIC0gMSAtIGk7XG4gICAgICBjb25zdCBhID0gaW5wdXRTaGFwZVtkaW1dIHx8IDE7XG4gICAgICBjb25zdCBiID0gb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMSAtIGldIHx8IDE7XG4gICAgICBpZiAoYiA+IDEgJiYgYSA9PT0gMSkge1xuICAgICAgICBkaW1zLnVuc2hpZnQoZGltKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpbXM7XG4gIH1cbn1cblxuLy8gY29weSBhcnJheSBoZWxwZXJcbi8vIG1pbWljcyBtZW1jcHkgYXMgbXVjaCBhcyBwb3NzaWJsZVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5Q29weUhlbHBlcihcbiAgICB0YXJnZXQ6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCBzb3VyY2U6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCB0YXJnZXRJbmRleDogbnVtYmVyLCBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgIGJsb2NrU2l6ZTogbnVtYmVyKSB7XG4gIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICB9XG4gIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICB9XG4gIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgfVxuICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gIH1cblxuICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdlbW1VdGlsIHtcbiAgLy8gd2lsbCBtYWtlIHN1cmUgaW5wdXQgc2hhcGVzIGFyZSBjb21wYXRpYmxlIGZvciB0aGlzIG9wXG4gIC8vIGFuZCByZXR1cm4gYmFjayB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCBpbiB0aGUgZm9ybSBvZiBhIHR1cGxlXG4gIC8vIHdpbGwgdGhyb3cgZXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBzaGFwZXMgYXJlIG5vdCBjb21wYXRpYmxlXG4gIHN0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRyYW5zTGVmdDogYm9vbGVhbiwgcmlnaHRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgICBiaWFzU2hhcGU/OiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJvdG9VdGlsIHtcbiAgc3RhdGljIHRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHR5cGVQcm90bzogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZXxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpOiBUZW5zb3IuRGF0YVR5cGUge1xuICAgIHN3aXRjaCAodHlwZVByb3RvKSB7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpcbiAgICAgICAgcmV0dXJuICdpbnQ4JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpcbiAgICAgICAgcmV0dXJuICd1aW50OCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpcbiAgICAgICAgcmV0dXJuICdib29sJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpcbiAgICAgICAgcmV0dXJuICdpbnQxNic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OlxuICAgICAgICByZXR1cm4gJ3VpbnQxNic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgICAgIHJldHVybiAnaW50MzInO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpcbiAgICAgICAgcmV0dXJuICd1aW50MzInO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICAgICAgcmV0dXJuICdmbG9hdDY0JztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcblxuICAgICAgLy8gRm9yIElOVDY0L1VJTlQ2NCwgcmVkdWNlIHRoZWlyIHZhbHVlIHRvIDMyLWJpdHMuXG4gICAgICAvLyBTaG91bGQgdGhyb3cgZXhjZXB0aW9uIHdoZW4gb3ZlcmZsb3dcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgICByZXR1cm4gJ3VpbnQzMic7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke29ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdHlwZVByb3RvXX1gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0odHlwZTogc3RyaW5nKTogb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg7XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDtcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY7XG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY7XG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyO1xuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyO1xuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUO1xuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlNUUklORztcbiAgICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ7XG4gICAgICBjYXNlICd1aW50NjQnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8oZGltczogQXJyYXk8bnVtYmVyfExvbmc+KTogbnVtYmVyW10ge1xuICAgIC8vIGdldCByaWQgb2YgTG9uZyB0eXBlIGZvciBkaW1zXG4gICAgcmV0dXJuIGRpbXMubWFwKGQgPT4gTG9uZy5pc0xvbmcoZCkgPyBkLnRvTnVtYmVyKCkgOiBkKTtcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8odmFsdWVUeXBlOiBvbm54LlR5cGVQcm90by5JVGVuc29yKTogR3JhcGguVmFsdWVUeXBlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVuc29yVHlwZTogUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKHZhbHVlVHlwZS5lbGVtVHlwZSEpLFxuICAgICAgc2hhcGU6IHtkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byh2YWx1ZVR5cGUuc2hhcGUhLmRpbSEubWFwKGQgPT4gZC5kaW1WYWx1ZSEpKX1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIHRlbnNvckRpbXNGcm9tT1JURm9ybWF0KHRlbnNvcjogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpIHtcbiAgICBjb25zdCBkaW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW5zb3IuZGltc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGRpbXMucHVzaChMb25nVXRpbC5sb25nVG9OdW1iZXIodGVuc29yLmRpbXMoaSkhKSk7XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xuICB9XG5cbiAgc3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KG5vZGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChub2RlLmF0dHJpYnV0ZXMoaSkhKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIExvbmdVdGlsIHtcbiAgc3RhdGljIGxvbmdUb051bWJlcihuOiBMb25nfGZsYXRidWZmZXJzLkxvbmd8bnVtYmVyKSB7XG4gICAgaWYgKExvbmcuaXNMb25nKG4pKSB7XG4gICAgICByZXR1cm4gbi50b051bWJlcigpO1xuICAgIH0gZWxzZSBpZiAobiBpbnN0YW5jZW9mIGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIHJldHVybiBMb25nLmZyb21WYWx1ZSh7bG93OiBuLmxvdywgaGlnaDogbi5oaWdoLCB1bnNpZ25lZDogdHJ1ZX0pLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHN0YXRpYyBpc0xvbmcobjogdW5rbm93bikge1xuICAgIHJldHVybiBMb25nLmlzTG9uZyhuKSB8fCBuIGluc3RhbmNlb2YgZmxhdGJ1ZmZlcnMuTG9uZztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2hhcGVVdGlsIHtcbiAgc3RhdGljIHNpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCAwLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvLyBgYXhpc2AgaW5jbHVzaXZlXG4gIHN0YXRpYyBzaXplRnJvbURpbWVuc2lvbihkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IDAgfHwgYXhpcyA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIGF4aXMsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGBheGlzYCBleGNsdXNpdmVcbiAgc3RhdGljIHNpemVUb0RpbWVuc2lvbihkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IDAgfHwgYXhpcyA+IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7YXhpc30gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCAwLCBheGlzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBzYWZldHkgY2hlY2sgYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IG11bHRpcGxlIG90aGVyIG1ldGhvZHMgcmVxdWlyaW5nIHNpemUuXG4gICAgICAvLyBzaXplIGNhbm5vdCBiZSAwIG9yIG5lZ2F0aXZlLlxuICAgICAgaWYgKGRpbXNbaV0gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgJ2Nhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyAwIG9yIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicpO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBkaW1zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIHN0YXRpYyBjb21wdXRlU3RyaWRlcyhkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbMV07XG4gICAgfVxuICAgIGNvbnN0IHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMV0gPSAxO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gZGltc1tyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogZGltc1tpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGVzO1xuICB9XG5cbiAgc3RhdGljIHRyYW5zcG9zZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCBjb3B5ID0gZGltcy5zbGljZSgpO1xuICAgIHJldHVybiBjb3B5LnJldmVyc2UoKTtcbiAgfVxuXG4gIHN0YXRpYyBpbmRpY2VzVG9PZmZzZXQoaW5kaWNlczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBheGlzID0gaW5kaWNlcy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpczsgKytpKSB7XG4gICAgICBvZmZzZXQgKz0gc3RyaWRlc1tpXSAqIGluZGljZXNbaV07XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICBzdGF0aWMgb2Zmc2V0VG9JbmRpY2VzKG9mZnNldDogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gc3RyaWRlcy5sZW5ndGg7XG4gICAgaWYgKHJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgIHJldHVybiBbb2Zmc2V0ICogc3RyaWRlc1swXV07XG4gICAgfVxuICAgIGNvbnN0IGluZGljZXM6IG51bWJlcltdID0gbmV3IEFycmF5KHN0cmlkZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpbmRpY2VzW2ldID0gTWF0aC5mbG9vcihvZmZzZXQgLyBzdHJpZGVzW2ldKTtcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICB9XG4gICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdID0gb2Zmc2V0O1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIG5vcm1haWx6ZSBheGlzIG9mIHJhbmdlIFstciwgcikgaW50byBbMCwgcikuXG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplQXhpcyhheGlzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayAmJiBheGlzID49IHRlbnNvclJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXhpcyBmb3IgdGhpcyBvcGVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiBheGlzIDwgMCA/IGF4aXMgKyB0ZW5zb3JSYW5rIDogYXhpcztcbiAgfVxuXG4gIHN0YXRpYyBub3JtYWxpemVBeGVzKGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKHggPT4gdGhpcy5ub3JtYWxpemVBeGlzKHgsIHRlbnNvclJhbmspKTtcbiAgfVxuXG4gIC8vIEluY3JlbWVudCBhbiBpbmRleCBpbnRvIGEgdGVuc29yIChpbiBsZXhpY29ncmFwaGljXG4gIC8vIG9yZGVyaW5nKSwgd3JhcHBpbmcgYXJvdW5kIHRoZSBzcGVjaWZpZWQgdXBwZXJfYm91bmQuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgYW4gaW5kZXggaW50byBhIHRlbnNvciAoaW4gbGV4aWNvZ3JhcGhpYyBvcmRlcmluZyksIHdyYXBwaW5nIGFyb3VuZCB0aGUgc3BlY2lmaWVkIHVwcGVyX2JvdW5kLlxuICAgKiBAcGFyYW0gaW5kZXggR2l2ZW4gaW5kZXggdG8gaW5jcmVtZW50IChXaWxsIGJlIG11dGF0ZWQpXG4gICAqIEBwYXJhbSBkaW1zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IgZm9yIHdoaWNoIHRoZSBnaXZlbiBpbmRleCBjb3JyZXNwb25kcyB0b1xuICAgKiBAcGFyYW0gYXhpc1RvSW5jcmVtZW50T24gVGhlIDEtaW5kZXhlZCBheGlzIHRvIGluY3JlbWVudCBvbi4gSWYgdW5kZWZpbmVkLCBheGlzVG9JbmNyZW1lbnRPbiA9PSByYW5rXG4gICAqL1xuICBzdGF0aWMgaW5jcmVtZW50SW5kZXgoaW5kZXg6IG51bWJlcltdLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpc1RvSW5jcmVtZW50T24/OiBudW1iZXIpIHtcbiAgICBpZiAoZGltcy5sZW5ndGggPT09IDAgfHwgaW5kZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IGluY3JlbWVudGluZyB1bnN1cHBvcnRlZCBmb3Igc2NhbGFyIFRlbnNvcicpO1xuICAgIH1cbiAgICBpZiAoYXhpc1RvSW5jcmVtZW50T24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXhpc1RvSW5jcmVtZW50T24gPSBkaW1zLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF4aXNUb0luY3JlbWVudE9uIDw9IDAgfHwgYXhpc1RvSW5jcmVtZW50T24gPiBkaW1zLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBheGlzIHRvIGluY3JlbWVudCBvbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGsgPSBheGlzVG9JbmNyZW1lbnRPbiAtIDE7IGsgPj0gMDsgLS1rKSB7XG4gICAgICBpbmRleFtrXSsrO1xuICAgICAgaWYgKGluZGV4W2tdIDwgZGltc1trXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4W2tdID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBuZXcgZGltZW5zaW9ucyBhcnJheSBiYXNlZCBvbiB0aGUgdmFsdWVzIGluIHRoZSAnb3JpZ2luYWxEaW1lbnNpb25zJyBhbmQgJ3NoYXBlJyBhcnJheVxuICAgKiBVc2VkIGluIFJlc2hhcGVcbiAgICogQHBhcmFtIG9yaWdpbmFsRGltcyBPcmlnaW5hbCBTaGFwZSBhcnJheVxuICAgKiBAcGFyYW0gc2hhcGVIaW50cyBhcnJheSBjb250YWluaW5nIHZhbHVlcyB0byBjb21wdXRlIHRoZSBuZXcgZGltZW5zaW9uc1xuICAgKiBGb3IgZXhhbXBsZTpcbiAgICogb3JpZ2luYWxEaW1zID0gWzIsMl0gYW5kIHNoYXBlSGludHMgPSBbMCwtMV0gd2lsbCByZXR1cm4gWzIsMl1cbiAgICogb3JpZ2luYWxEaW1zID0gWzIsMl0gYW5kIHNoYXBlSGludHMgPSBbNF0gd2lsbCByZXR1cm4gWzRdXG4gICAqIG9yaWdpbmFsRGltcyA9IFsyLDJdIGFuZCBzaGFwZUhpbnRzID0gWzVdIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYXN0ZXIvZG9jcy9PcGVyYXRvcnMubWQjUmVzaGFwZVxuICAgKi9cblxuICBzdGF0aWMgY2FsY3VsYXRlUmVzaGFwZWREaW1zKFxuICAgICAgb3JpZ2luYWxEaW1zOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGVIaW50czogbnVtYmVyW118cmVhZG9ubHkgbnVtYmVyW118VGVuc29yLkludGVnZXJUeXBlKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIC8vIHJlc2hhcGUgdG8gYSBTY2FsYXIgVGVuc29yXG4gICAgaWYgKHNoYXBlSGludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAob3JpZ2luYWxEaW1zLmxlbmd0aCA9PT0gMCB8fCBTaGFwZVV0aWwuc2l6ZShvcmlnaW5hbERpbXMpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHJlc2hhcGUgdG8gYSBzY2FsYXIgVGVuc29yJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbkRpbXMgPSBzaGFwZUhpbnRzLmxlbmd0aDtcbiAgICBjb25zdCByZXNoYXBlZERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihuRGltcyk7XG4gICAgbGV0IHVua25vd25EaW1lbnNpb24gPSAtMTtcbiAgICBsZXQgbmV3VGVuc29yU2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuRGltczsgaSsrKSB7XG4gICAgICBpZiAoc2hhcGVIaW50c1tpXSA8IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2Fubm90IGJlIGxlc3MgdGhhbiAtMScpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlSGludHNbaV0gPT09IC0xKSB7XG4gICAgICAgIGlmICh1bmtub3duRGltZW5zaW9uICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMScpO1xuICAgICAgICB9XG4gICAgICAgIHVua25vd25EaW1lbnNpb24gPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNoYXBlSGludHNbaV0gPT09IDApIHtcbiAgICAgICAgICBpZiAoaSA+PSBvcmlnaW5hbERpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBkaW1lbnNpb24gd2l0aCB2YWx1ZSB6ZXJvIGV4Y2VlZHMgdGhlIGRpbWVuc2lvbiBzaXplIG9mIHRoZSBpbnB1dCB0ZW5zb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzaGFwZWREaW1zW2ldID0gb3JpZ2luYWxEaW1zW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2hhcGVkRGltc1tpXSA9IHNoYXBlSGludHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbmV3VGVuc29yU2l6ZSAqPSByZXNoYXBlZERpbXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkVGVuc29yU2l6ZSA9IFNoYXBlVXRpbC5zaXplKG9yaWdpbmFsRGltcyk7XG4gICAgaWYgKHVua25vd25EaW1lbnNpb24gIT09IC0xKSB7XG4gICAgICBpZiAob2xkVGVuc29yU2l6ZSAlIG5ld1RlbnNvclNpemUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7XG4gICAgICAgICAgICBvcmlnaW5hbERpbXN9XSBPdXRwdXQgc2hhcGU6IFske3NoYXBlSGludHN9XWApO1xuICAgICAgfVxuICAgICAgcmVzaGFwZWREaW1zW3Vua25vd25EaW1lbnNpb25dID0gb2xkVGVuc29yU2l6ZSAvIG5ld1RlbnNvclNpemU7XG4gICAgfVxuICAgIC8vIHZhbGlkYXRlIHNpemVzIGZyb20gb3JpZ2luYWxEaW1zIGFuZCByZXNoYXBlZERpbXMgbWF0Y2hcbiAgICBlbHNlIHtcbiAgICAgIGlmIChuZXdUZW5zb3JTaXplICE9PSBvbGRUZW5zb3JTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzaGFwZWREaW1zIGFuZCBvcmlnaW5hbERpbXMgZG9uXFwndCBoYXZlIG1hdGNoaW5nIHNpemVzJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNoYXBlZERpbXM7XG4gIH1cblxuICAvKipcbiAgICogU29ydHMgYSBnaXZlbiBhcnJheSBiYXNlZCBvbiB0aGUgaW5kaWNlcyBpbiB0aGUgUGVybSBhcnJheVxuICAgKiBVc2VkIGluIFRyYW5zcG9zZVxuICAgKiBAcGFyYW0gYSBBcnJheSB0byBiZSBzb3J0ZWQgc3VjaCBhcyBkaW1zIG9yIHN0cmlkZXNcbiAgICogQHBhcmFtIHBlcm0gUGVybSBnaXZlbjsgaWYgbnVsbCBhIHdpbGwgYmUgcmV2ZXJzZWRcbiAgICovXG4gIHN0YXRpYyBzb3J0QmFzZWRPblBlcm0oYTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm0/OiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAocGVybSkge1xuICAgICAgcmV0dXJuIHBlcm0ubWFwKCh2KSA9PiBhW3ZdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGEuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhZHMgYSBnaXZlbiBzaGFwZSBhY2NvcmRpbmcgdG8gdGhlIHBhZGRpbmcgdmFsdWVzXG4gICAqIEBwYXJhbSBkaW1zIHNoYXBlIG9mIHRoZSBUZW5zb3IgdG8gYmUgcGFkZGVkXG4gICAqIEBwYXJhbSBwYWQgcGFkIHZhbHVlc1xuICAgKi9cbiAgc3RhdGljIHBhZFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBwYWQ6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICByZXR1cm4gZGltcy5tYXAoKHYsIGkpID0+IHYgKyBwYWRbaV0gKyBwYWRbaSArIHJhbmtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSB0d28gc2hhcGVzIGFyZSBpZGVudGljYWxcbiAgICogQHBhcmFtIHNoYXBlMVxuICAgKiBAcGFyYW0gc2hhcGUyXG4gICAqL1xuICBzdGF0aWMgYXJlRXF1YWwoc2hhcGUxOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGUyOiByZWFkb25seSBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChzaGFwZTEubGVuZ3RoICE9PSBzaGFwZTIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaGFwZTEuZXZlcnkoKHYsIGkpID0+IHYgPT09IHNoYXBlMltpXSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBnaXZlbiBgZGltc2Agb3IgYHNoYXBlYCBpcyB2YWxpZCBpbiBPTk5YLmpzIGNvbnRleHQgYW5kIHJldHVybnMgZGF0YSBzaXplXG4gICAqIEBwYXJhbSBkaW1zIC0gaW5wdXQgYGRpbXNgIHRoYXQgbmVlZHMgdG8gYmUgY2hlY2tlZFxuICAgKi9cbiAgc3RhdGljIHZhbGlkYXRlRGltc0FuZENhbGNTaXplKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBpZiAoZGltcy5sZW5ndGggPiA2KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLicpO1xuICAgIH1cbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChjb25zdCBuIG9mIGRpbXMpIHtcbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiAke259IGlzIG5vdCBhbiBpbnRlZ2VyYCk7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDAgfHwgbiA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzaGFwZTogbGVuZ3RoICR7bn0gaXMgbm90IGFsbG93ZWRgKTtcbiAgICAgIH1cbiAgICAgIHNpemUgKj0gbjtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgc2hhcGUgb2Ygb3V0cHV0IHRlbnNvciB5ID0gZmxhdHRlbih4LCBheGlzKVxuICAgKiBAcGFyYW0gZGltcyAtIHNoYXBlIG9mIGlucHV0IHRlbnNvclxuICAgKiBAcGFyYW0gYXhpcyAtIGZsYXR0ZW4gYXhpcywgaW4gdGhlIHJhbmdlIFstciwgcl1cbiAgICovXG4gIHN0YXRpYyBmbGF0dGVuU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAoYXhpcyA8IDApIHtcbiAgICAgIGF4aXMgKz0gZGltcy5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsID0gZGltcy5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcbiAgICBjb25zdCByaWdodCA9IGRpbXMuc2xpY2UoYXhpcykucmVkdWNlKCh4LCB5KSA9PiB4ICogeSwgMSk7XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFt0b3RhbCAvIHJpZ2h0LCByaWdodF07XG5cbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSBzcXVlZXplKHgsIGF4ZXMpXG4gICAqIEBwYXJhbSBkaW1zIC0gc2hhcGUgb2YgaW5wdXQgdGVuc29yXG4gICAqIEBwYXJhbSBheGVzIC0gc3F1ZWV6ZSBheGVzXG4gICAqL1xuICBzdGF0aWMgc3F1ZWV6ZVNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gbmV3IEFycmF5PG51bWJlcj4oKTtcblxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGF4ZXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhlcyhheGVzLCBkaW1zLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluU3F1ZWV6ZUxpc3QgPSBheGVzLmluZGV4T2YoaSkgPj0gMDtcbiAgICAgIGlmIChpblNxdWVlemVMaXN0ICYmIGRpbXNbaV0gIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcXVlZXplIGFuIGF4aXMgb2Ygc2l6ZSBkaWZmZXJlbnQgdGhhbiAxJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYXhlcy5sZW5ndGggPT09IDAgJiYgZGltc1tpXSA+IDEpIHx8IChheGVzLmxlbmd0aCA+IDAgJiYgIWluU3F1ZWV6ZUxpc3QpKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChkaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSB1bnNxdWVlemUoeCwgYXhlcylcbiAgICogQHBhcmFtIGRpbXMgLSBzaGFwZSBvZiBpbnB1dCB0ZW5zb3JcbiAgICogQHBhcmFtIGF4ZXMgLSB1bnNxdWVlemUgYXhlc1xuICAgKi9cbiAgc3RhdGljIHVuc3F1ZWV6ZVNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gbmV3IEFycmF5PG51bWJlcj4oZGltcy5sZW5ndGggKyBheGVzLmxlbmd0aCk7XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSBhcnJheSBlbGVtZW50cyB0byAwXG4gICAgb3V0cHV0RGltcy5maWxsKDApO1xuXG4gICAgLy8gc2V0IGFsbCBheGVzIGluZGljZXMgdG8gMSBpbiBvdXRwdXREaW1zIGFuZCBjaGVjayBmb3IgZHVwbGljYXRlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4ZXNbaV0sIGRpbXMubGVuZ3RoKTtcbiAgICAgIGlmIChheGlzID49IG91dHB1dERpbXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnYXhlc1xcJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRwdXREaW1zW2F4aXNdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXFwnYXhlc1xcJyBoYXMgYSBkdXBsaWNhdGUgYXhpcycpO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXREaW1zW2F4aXNdID0gMTtcbiAgICB9XG5cbiAgICAvLyBmaWxsIGluIHRoZSB6ZXJvIGVudHJpZXMgb2Ygb3V0cHV0RGltcyB3aXRoIHRoZSBpbnB1dCB0ZW5zb3IncyBzaGFwZVxuICAgIGxldCBpbnB1dERpbXNJdGVyYXRvciA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXREaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3V0cHV0RGltc1tpXSA9PT0gMCkge1xuICAgICAgICBvdXRwdXREaW1zW2ldID0gZGltc1tpbnB1dERpbXNJdGVyYXRvcisrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2sgYXNzZXJ0aW9uLiAnaW5wdXREaW1zSXRlcmF0b3InXG4gICAgLy8gc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgJ2RpbXMnXG4gICAgaWYgKGlucHV0RGltc0l0ZXJhdG9yICE9PSBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dERpbXM7XG4gIH1cbn1cblxuLy8gYnVuY2ggb2YgaGVscGVyIG1ldGhvZHMgdGhhdCBkbyBhIHZhcmlldHkgb2YgbWF0aCBvcGVyYXRpb25zXG5leHBvcnQgY2xhc3MgTWF0aFV0aWwge1xuICAvLyB5ID0gKHgqeCkgKyB5XG4gIHN0YXRpYyBzcXIoXG4gICAgICB0YXJnZXQ6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCBzb3VyY2U6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCB0YXJnZXRJbmRleDogbnVtYmVyLCBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgICAgYmxvY2tTaXplOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSArPSBNYXRoLnBvdyhzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdLCAyKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gYXggKyB5XG4gIHN0YXRpYyBheHB5KFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyLCBhbHBoYTogbnVtYmVyKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gKz0gKGFscGhhICogc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XSk7XG4gICAgfVxuICB9XG5cbiAgLy8geSA9IHBvdyh4LCBiKVxuICBzdGF0aWMgcG93eChcbiAgICAgIHRhcmdldDogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHNvdXJjZTogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHRhcmdldEluZGV4OiBudW1iZXIsIHNvdXJjZUluZGV4OiBudW1iZXIsXG4gICAgICBibG9ja1NpemU6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBNYXRoLnBvdyhzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdLCBiKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0geCAqIHlcbiAgc3RhdGljIG11bChcbiAgICAgIHRhcmdldDogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHNvdXJjZTogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHRhcmdldEluZGV4OiBudW1iZXIsIHNvdXJjZUluZGV4OiBudW1iZXIsXG4gICAgICBibG9ja1NpemU6IG51bWJlcikge1xuICAgIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdID0gKHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0gKiB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNwbGl0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIG5ldyBTaGFwZXMgZnJvbSBleGlzdGluZyBvbmUgYW5kIHRoZSBzcGxpdHMgZ2l2ZW4gYWxvbmcgdGhlIGF4aXMgcHJvdmlkZXNcbiAgICogQHBhcmFtIGRpbXMgU2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBzcGxpdHRlZCBpbnRvIHR3byBvciBtb3JlIFNoYXBlc1xuICAgKiBAcGFyYW0gYXhpcyBUaGUgZGltZW5zaW9uIGFsb25nIHdoaWNoIHRoZSBUZW5zb3Igd2lsbCBiZSBzcGxpdFxuICAgKiBAcGFyYW0gc3BsaXRzIE9mZnNldHMgZm9yIHRoZSBzdGFydCBvZiBlYWNoIHNwbGl0XG4gICAqL1xuICBzdGF0aWMgc3BsaXRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyLCBzcGxpdDogbnVtYmVyW10sIG51bU91dHB1dHM/OiBudW1iZXIpOlxuICAgICAgW251bWJlcltdW10sIG51bWJlcltdXSB7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCFudW1PdXRwdXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlIFxcJ3NwbGl0XFwnIGF0dHJpYnV0ZSBpcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICB9XG4gICAgICBTcGxpdFV0aWwuZGV0ZXJtaW5lU3BsaXQoZGltc1theGlzXSwgbnVtT3V0cHV0cywgc3BsaXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYXBlczogbnVtYmVyW11bXSA9IFtdO1xuICAgIGNvbnN0IG9mZnNldHMgPSBbMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldHNbaSAtIDFdICsgc3BsaXRbaSAtIDFdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNoYXBlID0gZGltcy5zbGljZSgpO1xuICAgICAgc2hhcGVbYXhpc10gPSBzcGxpdFtpXTtcbiAgICAgIHNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzaGFwZXMsIG9mZnNldHNdO1xuICB9XG5cbiAgc3RhdGljIGRldGVybWluZVNwbGl0KG51bUVsZW1lbnRzQWxvbmdBeGlzOiBudW1iZXIsIG51bU91dHB1dHM6IG51bWJlciwgc3BsaXQ6IG51bWJlcltdKSB7XG4gICAgLy8gSWYgJ3NwbGl0JyBpcyBub3Qgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLCB3ZSBuZWVkIHRvIHBhcnRpdGlvbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGVxdWFsbHkgYW1vbmcgdGhlIG91dHB1dHNcbiAgICBpZiAobnVtRWxlbWVudHNBbG9uZ0F4aXMgJSBudW1PdXRwdXRzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHMnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PdXRwdXRzOyArK2kpIHtcbiAgICAgIHNwbGl0LnB1c2gobnVtRWxlbWVudHNBbG9uZ0F4aXMgLyBudW1PdXRwdXRzKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZHVjZVV0aWwge1xuICAvKipcbiAgICogUGVyZm9ybSByZWR1Y2Ugb3BlcmF0aW9ucyBvbiB0aGUgc3BlY2lmaWMgb3BlcmF0b3JcbiAgICogQHBhcmFtIGEgSW5wdXQgdGVuc29yIGRhdGFcbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGtlZXBkaW1zIElmIHNldCB0byB0cnVlLCB0aGUgYXhlcyB3aGljaCBhcmUgcmVkdWNlZCBhcmUgbGVmdCBpbiB0aGVcbiAgICogICAgcmVzdWx0IGFzIGRpbWVuc2lvbnMgd2l0aCBzaXplIG9uZS5cbiAgICogQHBhcmFtIG9wMSBUaGUgb3BlcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIHRlbnNvclxuICAgKiBAcGFyYW0gb3AyIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIGJldHdlZW4gZWxlbWVudHMgaW4gdGhlIHRlbnNvclxuICAgKi9cbiAgc3RhdGljIGNhbGNSZWR1Y2UoXG4gICAgICBhOiBUZW5zb3IsIGF4ZXM6IG51bWJlcltdLCBrZWVwZGltczogYm9vbGVhbiwgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsXG4gICAgICBvcDI6IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gbnVtYmVyKTogVGVuc29yIHtcbiAgICBjb25zdCBkaW1zID0gYS5kaW1zLnNsaWNlKDApO1xuICAgIC8vIGlmIGF4ZXMgaXMgbm90IHNldCwgcGVyZm9ybSByZWR1Y2Ugb24gYWxsIGF4ZXNcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRpbXMuZm9yRWFjaCgoZCwgaW5kKSA9PiBheGVzLnB1c2goaW5kKSk7XG4gICAgfVxuICAgIC8vIGdldCBhIHRlbXBvcmFyeSBicm9hZGNhc3RhYmxlIG91dHB1dCBzaGFwZVxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VTaGFwZShkaW1zLCBheGVzLCB0cnVlKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgb3V0cHV0IGFuZCBjYWxjdWxhdGUgcmVzdWx0IG9uZSBieSBvbmVcbiAgICBjb25zdCBzaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0RGltcyk7XG4gICAgY29uc3QgeSA9IG5ldyBUZW5zb3Iob3V0cHV0RGltcywgYS50eXBlKTtcbiAgICBjb25zdCBzdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKG91dHB1dERpbXMpO1xuICAgIGNvbnN0IGlucHV0U3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkaW1zKTtcbiAgICBjb25zdCBpbmRpY2VzWSA9IG5ldyBBcnJheShkaW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBTaGFwZVV0aWwub2Zmc2V0VG9JbmRpY2VzKGksIHN0cmlkZXMpO1xuICAgICAgLy8gbWFwIGluZGV4XG4gICAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChpbmRpY2VzLCBkaW1zLCBpbmRpY2VzWSk7XG4gICAgICB5LnNldChcbiAgICAgICAgICBpbmRpY2VzLFxuICAgICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgICAgICAgICAgYS5udW1iZXJEYXRhLCBheGVzLCBkaW1zLCAwLCBTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXNZLCBpbnB1dFN0cmlkZXMpLCBvcDEsIG9wMikpO1xuICAgIH1cblxuICAgIGlmIChrZWVwZGltcykge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtlZXBkaW1zID09IDAsIGNhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGVcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZVNoYXBlKGRpbXMsIGF4ZXMsIGtlZXBkaW1zKSwgeS50eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeS5kYXRhLCB5LmRhdGFJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gcmVkdWNlIG9wZXJhdGlvbnMgb24gdGhlIHNwZWNpZmljIG9wZXJhdG9yIG9uIHNwZWNpZmljIGF4ZXNcbiAgICogQHBhcmFtIGEgSW5wdXQgdGVuc29yIGRhdGFcbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGN1ckF4aXNJbmQgSW5kZXggaW4gYXhlcyBzcGVjaWZ5aW5nIHRoZSBjdXJyZW50IGRpbWVuc2lvbiBhbG9uZ1xuICAgKiAgICAgIHdoaWNoIHRoZSB0ZW5zb3Igd2lsbCBiZSByZWR1Y2VkXG4gICAqIEBwYXJhbSBwb3MgVGhlIGN1cnJlbnQgaW5kZXggb2YgZWxlbWVudCB0byBwZXJmb3JtIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgIGlucHV0OiBUZW5zb3IuTnVtYmVyVHlwZSwgYXhlczogbnVtYmVyW10sIGRpbXM6IG51bWJlcltdLCBjdXJBeGlzSW5kOiBudW1iZXIsIHBvczogbnVtYmVyLFxuICAgICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsIG9wMjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGlmIChjdXJBeGlzSW5kID49IGF4ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gb3AxKGlucHV0W3Bvc10pO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gYXhlc1tjdXJBeGlzSW5kXTtcbiAgICBjb25zdCBzdGVwID0gYXhpcyA+PSBkaW1zLmxlbmd0aCA/IDEgOiBTaGFwZVV0aWwuc2l6ZShkaW1zLnNsaWNlKGF4aXMgKyAxKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zW2F4aXNdOyBpKyspIHtcbiAgICAgIHJlcyA9IGkgPT09IDAgPyBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VCeUF4aXMoaW5wdXQsIGF4ZXMsIGRpbXMsIGN1ckF4aXNJbmQgKyAxLCBwb3MsIG9wMSwgb3AyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb3AyKHJlcywgUmVkdWNlVXRpbC5jYWxjUmVkdWNlQnlBeGlzKGlucHV0LCBheGVzLCBkaW1zLCBjdXJBeGlzSW5kICsgMSwgcG9zLCBvcDEsIG9wMikpO1xuICAgICAgcG9zICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSBvZiBhIHJlZHVjZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb25cbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGtlZXBkaW1zIElmIHNldCB0byB0cnVlLCB0aGUgYXhlcyB3aGljaCBhcmUgcmVkdWNlZCBhcmUgbGVmdCBpbiB0aGVcbiAgICogICAgcmVzdWx0IGFzIGRpbWVuc2lvbnMgd2l0aCBzaXplIG9uZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZWVwRGltczogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gZGltcy5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dERpbXNbYXhlc1tpXV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0RGltc1theGVzW2ldXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXREaW1zLmZpbHRlcihkaW0gPT4gZGltICE9PSAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9vbENvbnZVdGlsIHtcbiAgLyoqXG4gICAqIEFkanVzdCB0aGUga2VybmVsLCBzdHJpZGVzLCBwYWRzIHRvIGNvcnJlY3QgcmFuay4gU2V0IHRvIGRlZmF1bHQgdmFsdWUgaWYgbm90IHByZXNlbnRcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICAgIHBhZHM6IG51bWJlcltdKSB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHBhZHMgbGVuZ3RoIHRvIG1hdGNoIDIgKiBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoICogMjsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBwYWRzLmxlbmd0aCkge1xuICAgICAgICBpZiAocGFkc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrcyBmb3IgdmFsdWVzIGluIGtlcm5lbCBzaGFwZXMgYW5kIHBhZHNcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoa2VybmVsU2hhcGVbZGltXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWRzW2RpbV0gPj0ga2VybmVsU2hhcGVbZGltXSB8fCBwYWRzW2RpbSArIGtlcm5lbFNoYXBlLmxlbmd0aF0gPj0ga2VybmVsU2hhcGVbZGltXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGp1c3QgcGFkIHZhbHVlcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlXG4gIHN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSwga2VybmVsU2hhcGU6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSxcbiAgICAgIGF1dG9QYWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoIWF1dG9QYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFkcy5sZW5ndGggIT09IDIgKiAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAyXSwgc3RyaWRlc1tkaW1dLCBkaWxhdGlvbnNbZGltXSwga2VybmVsU2hhcGVbZGltXSwgcGFkcywgZGltLCBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcbiAgICAgICAgICBhdXRvUGFkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IG51bWJlcltdLCBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLFxuICAgICAgYXV0b1BhZD86IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICAvLyBUT0RPOiBzdXBwb3J0IGRpbGF0aW9ucyBmb3IgcG9vbCBvcGVyYXRvcnNcbiAgICBjb25zdCBkaWxhdGlvbnMgPSBuZXcgQXJyYXk8bnVtYmVyPihrZXJuZWxTaGFwZS5sZW5ndGgpLmZpbGwoMSk7XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgICBpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dERpbXMsIG91dHB1dERpbXMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gICAgaWYgKGlucHV0RGltcy5sZW5ndGggPD0gMCB8fCBmaWx0ZXJEaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXMnKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBbaW5wdXREaW1zWzBdLCBmaWx0ZXJEaW1zWzBdXTtcblxuICAgIFBvb2xDb252VXRpbC5jb21wdXRlU2hhcGVIZWxwZXIoZmFsc2UsIGlucHV0RGltcywgb3V0cHV0RGltcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXV0b1BhZCk7XG4gICAgcmV0dXJuIG91dHB1dERpbXM7XG4gIH1cblxuICAvLyB3aWxsIGNvbXB1dGUgb3V0cHV0IHNoYXBlcyBmb3IgZGF0YSBkaW1lbnNpb25zIE9OTFkgKGkuZS4pIG5vIGJhdGNoIHNpemUgYW5kIGNoYW5uZWxzXG4gIC8vIGNhbGxlZCBieSBjb21wdXRlUG9vbE91dHB1dFNoYXBlKCkgYW5kIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoKVxuICAvLyBhZGp1c3QgcGFkcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlIHByaW9yIHRvIHNoYXBlIGNvbXB1dGF0aW9uXG4gIHByaXZhdGUgc3RhdGljIGNvbXB1dGVTaGFwZUhlbHBlcihcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dERpbXM6IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sIHN0cmlkZXNbZGltXSwgZGlsYXRpb25zW2RpbV0sIGtlcm5lbFNoYXBlW2RpbV0sIHBhZHMsIGRpbSwgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgaW5TaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyLCBrZXJuZWw6IG51bWJlciwgcGFkczogbnVtYmVyW10sIHBhZEhlYWRJbmRleDogbnVtYmVyLFxuICAgICAgcGFkVGFpbEluZGV4OiBudW1iZXIsIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGRrZXJuZWwgPSBkaWxhdGlvbiAqIChrZXJuZWwgLSAxKSArIDE7XG4gICAgaWYgKGF1dG9QYWQgJiYgYXV0b1BhZCAhPT0gJ05PVFNFVCcpIHtcbiAgICAgIHN3aXRjaCAoYXV0b1BhZCkge1xuICAgICAgICBjYXNlICdWQUxJRCc6XG4gICAgICAgICAgcGFkc1twYWRIZWFkSW5kZXhdID0gMDtcbiAgICAgICAgICBwYWRzW3BhZFRhaWxJbmRleF0gPSAwO1xuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUpICsgMSk7XG4gICAgICAgIGNhc2UgJ1NBTUVfTE9XRVInOlxuICAgICAgICBjYXNlICdTQU1FX1VQUEVSJzpcbiAgICAgICAgICBpZiAoZGlsYXRpb24gIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGlsYXRpb24gbm90IHN1cHBvcnRlZCBmb3IgU0FNRV9VUFBFUiBvciBTQU1FX0xPV0VSJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2FjeVRhcmdldFNpemUgPSAoaW5TaXplICsgc3RyaWRlIC0gMSkgLyBzdHJpZGU7XG4gICAgICAgICAgICBjb25zdCBwYWROZWVkZWQgPSAobGVnYWN5VGFyZ2V0U2l6ZSAtIDEpICogc3RyaWRlICsga2VybmVsIC0gaW5TaXplO1xuICAgICAgICAgICAgcGFkc1twYWRIZWFkSW5kZXhdID1cbiAgICAgICAgICAgICAgICAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSA/IE1hdGguZmxvb3IoKHBhZE5lZWRlZCArIDEpIC8gMikgOiBNYXRoLmZsb29yKHBhZE5lZWRlZCAvIDIpO1xuICAgICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gcGFkTmVlZGVkIC0gcGFkc1twYWRIZWFkSW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEF1dG9QYWQgdHlwZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSArIHBhZHNbcGFkSGVhZEluZGV4XSArIHBhZHNbcGFkVGFpbEluZGV4XSAtIGRrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmludGVyZmFjZSBFeHRyYU9wdGlvbnNIYW5kbGVyIHtcbiAgKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBpdGVyYXRlRXh0cmFPcHRpb25zID1cbiAgICAob3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHByZWZpeDogc3RyaW5nLCBzZWVuOiBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PixcbiAgICAgaGFuZGxlcjogRXh0cmFPcHRpb25zSGFuZGxlcik6IHZvaWQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNlZW4uaGFzKG9wdGlvbnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9ucycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW4uYWRkKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gKHByZWZpeCkgPyBwcmVmaXggKyBrZXkgOiBrZXk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyh2YWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgbmFtZSArICcuJywgc2VlbiwgaGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIGhhbmRsZXIobmFtZSwgKHZhbHVlKSA/ICcxJyA6ICcwJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtpdGVyYXRlRXh0cmFPcHRpb25zfSBmcm9tICcuL29wdGlvbnMtdXRpbHMnO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmd9IGZyb20gJy4vc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IHNldFJ1bk9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBydW5PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHJ1bk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucz8ubG9nU2V2ZXJpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPSAyOyAgLy8gRGVmYXVsdCB0byB3YXJuaW5nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dTZXZlcml0eUxldmVsKSB8fFxuICAgICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5sb2dWZXJib3NpdHlMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgIC8vIERlZmF1bHQgdG8gMFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LnRlcm1pbmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLnRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB0YWdEYXRhT2Zmc2V0ID0gMDtcbiAgICBpZiAob3B0aW9ucz8udGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhZ0RhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcob3B0aW9ucy50YWcsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgcnVuT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVJ1bk9wdGlvbnMoXG4gICAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwhLCAhIXJ1bk9wdGlvbnMudGVybWluYXRlISwgdGFnRGF0YU9mZnNldCk7XG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhvcHRpb25zLmV4dHJhLCAnJywgbmV3IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+KCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoa2V5LCBhbGxvY3MpO1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcodmFsdWUsIGFsbG9jcyk7XG5cbiAgICAgICAgaWYgKHdhc20uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHJ1bk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbcnVuT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlUnVuT3B0aW9ucyhydW5PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2god2FzbS5fZnJlZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge29ubnh9IGZyb20gJ29ubngtcHJvdG8nO1xuaW1wb3J0IHtlbnYsIEluZmVyZW5jZVNlc3Npb24sIFNlc3Npb25IYW5kbGVyLCBUZW5zb3IsIFR5cGVkVGVuc29yfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge3NldFJ1bk9wdGlvbnN9IGZyb20gJy4vcnVuLW9wdGlvbnMnO1xuaW1wb3J0IHtzZXRTZXNzaW9uT3B0aW9uc30gZnJvbSAnLi9zZXNzaW9uLW9wdGlvbnMnO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmd9IGZyb20gJy4vc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxubGV0IG9ydEluaXQ6IGJvb2xlYW47XG5cbmNvbnN0IHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtID0gKHR5cGU6IHN0cmluZyk6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MO1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI7XG4gICAgY2FzZSAndWludDMyJzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtcbiAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUO1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ7XG4gICAgY2FzZSAndWludDY0JzpcbiAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG5jb25zdCB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyA9ICh0eXBlUHJvdG86IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUpOiBUZW5zb3IuVHlwZSA9PiB7XG4gIHN3aXRjaCAodHlwZVByb3RvKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICByZXR1cm4gJ2ludDgnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpcbiAgICAgIHJldHVybiAndWludDgnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgcmV0dXJuICdib29sJztcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OlxuICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgIHJldHVybiAnaW50MzInO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOlxuICAgICAgcmV0dXJuICdmbG9hdDY0JztcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgIHJldHVybiAnaW50MzInO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gJ3VpbnQzMic7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlUHJvdG9dfWApO1xuICB9XG59O1xuXG5jb25zdCBudW1lcmljVGVuc29yVHlwZVRvVHlwZWRBcnJheSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IEZsb2F0MzJBcnJheUNvbnN0cnVjdG9yfFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxcbiAgICBJbnQ4QXJyYXlDb25zdHJ1Y3RvcnxVaW50MTZBcnJheUNvbnN0cnVjdG9yfEludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfFxuICAgIFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvcnxVaW50MzJBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IgPT4ge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICByZXR1cm4gVWludDhBcnJheTtcbiAgICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgICByZXR1cm4gQmlnSW50NjRBcnJheTtcbiAgICAgICAgY2FzZSAndWludDY0JzpcbiAgICAgICAgICByZXR1cm4gQmlnVWludDY0QXJyYXk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfTtcblxuY29uc3QgZ2V0TG9nTGV2ZWwgPSAobG9nTGV2ZWw6ICd2ZXJib3NlJ3wnaW5mbyd8J3dhcm5pbmcnfCdlcnJvcid8J2ZhdGFsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcbiAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlICdmYXRhbCc6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2xvZ0xldmVsfWApO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgU2Vzc2lvbkhhbmRsZXIge1xuICBwcml2YXRlIHNlc3Npb25IYW5kbGU6IG51bWJlcjtcblxuICBpbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBpbnB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdO1xuICBvdXRwdXROYW1lczogc3RyaW5nW107XG4gIHByaXZhdGUgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW107XG5cbiAgbG9hZE1vZGVsKG1vZGVsOiBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQge1xuICAgIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICAgIGlmICghb3J0SW5pdCkge1xuICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0SW5pdChlbnYud2FzbS5udW1UaHJlYWRzISwgZ2V0TG9nTGV2ZWwoZW52LmxvZ0xldmVsISkpO1xuICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuIGVycm9yIGNvZGUgPSAke2Vycm9yQ29kZX1gKTtcbiAgICAgIH1cbiAgICAgIG9ydEluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICAgIGxldCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgICB0cnkge1xuICAgICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHdhc20uSEVBUFU4LnNldChtb2RlbCwgbW9kZWxEYXRhT2Zmc2V0KTtcbiAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZSA9IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoLCBzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgICBpZiAodGhpcy5zZXNzaW9uSGFuZGxlID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uJyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgICBhbGxvY3MuZm9yRWFjaCh3YXNtLl9mcmVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dENvdW50ID0gd2FzbS5fT3J0R2V0SW5wdXRDb3VudCh0aGlzLnNlc3Npb25IYW5kbGUpO1xuICAgIGNvbnN0IG91dHB1dENvdW50ID0gd2FzbS5fT3J0R2V0T3V0cHV0Q291bnQodGhpcy5zZXNzaW9uSGFuZGxlKTtcblxuICAgIHRoaXMuaW5wdXROYW1lcyA9IFtdO1xuICAgIHRoaXMuaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gICAgdGhpcy5vdXRwdXROYW1lcyA9IFtdO1xuICAgIHRoaXMub3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBuYW1lID0gd2FzbS5fT3J0R2V0SW5wdXROYW1lKHRoaXMuc2Vzc2lvbkhhbmRsZSwgaSk7XG4gICAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5wdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLmlucHV0TmFtZXMucHVzaCh3YXNtLlVURjhUb1N0cmluZyhuYW1lKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldE91dHB1dE5hbWUodGhpcy5zZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWUnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5vdXRwdXROYW1lcy5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICAgIGlmICh0aGlzLmlucHV0TmFtZXNVVEY4RW5jb2RlZCkge1xuICAgICAgdGhpcy5pbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCh3YXNtLl9PcnRGcmVlKTtcbiAgICAgIHRoaXMuaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gICAgfVxuICAgIGlmICh0aGlzLm91dHB1dE5hbWVzVVRGOEVuY29kZWQpIHtcbiAgICAgIHRoaXMub3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKHdhc20uX09ydEZyZWUpO1xuICAgICAgdGhpcy5vdXRwdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gICAgfVxuICAgIGlmICh0aGlzLnNlc3Npb25IYW5kbGUpIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHRoaXMuc2Vzc2lvbkhhbmRsZSk7XG4gICAgICB0aGlzLnNlc3Npb25IYW5kbGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHJ1bihmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLCBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTpcbiAgICAgIFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuXG4gICAgY29uc3QgaW5wdXRBcnJheTogVGVuc29yW10gPSBbXTtcbiAgICBjb25zdCBpbnB1dEluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoZmVlZHMpLmZvckVhY2goa3ZwID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBrdnBbMF07XG4gICAgICBjb25zdCB0ZW5zb3IgPSBrdnBbMV07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5wdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7bmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBpbnB1dEFycmF5LnB1c2godGVuc29yKTtcbiAgICAgIGlucHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG91dHB1dEluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoZmV0Y2hlcykuZm9yRWFjaChrdnAgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgcHJlLWFsbG9jYXRlZCBvdXRwdXRcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0Q291bnQgPSBpbnB1dEluZGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IG91dHB1dENvdW50ID0gb3V0cHV0SW5kaWNlcy5sZW5ndGg7XG5cbiAgICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gICAgbGV0IHJ1bk9wdGlvbnNBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgICBjb25zdCBpbnB1dFZhbHVlczogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBpbnB1dEFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICAgIHRyeSB7XG4gICAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAvLyBjcmVhdGUgaW5wdXQgdGVuc29yc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGlucHV0QXJyYXlbaV0uZGF0YTtcblxuICAgICAgICBsZXQgZGF0YU9mZnNldDogbnVtYmVyO1xuICAgICAgICBsZXQgZGF0YUJ5dGVMZW5ndGg6IG51bWJlcjtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IDQgKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgICAgICBpbnB1dEFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtpfSBpcyBub3QgYSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK10gPSBhbGxvY1dhc21TdHJpbmcoZGF0YVtpXSwgaW5wdXRBbGxvY3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgICAgICBpbnB1dEFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xuICAgICAgICAgIHdhc20uSEVBUFU4LnNldChuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhQnl0ZUxlbmd0aCksIGRhdGFPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGltcyA9IGlucHV0QXJyYXlbaV0uZGltcztcblxuICAgICAgICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gICAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIGRpbXMubGVuZ3RoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgZGltSW5kZXggPSBkaW1zT2Zmc2V0IC8gNDtcbiAgICAgICAgICBkaW1zLmZvckVhY2goZCA9PiB3YXNtLkhFQVAzMltkaW1JbmRleCsrXSA9IGQpO1xuICAgICAgICAgIGNvbnN0IHRlbnNvciA9IHdhc20uX09ydENyZWF0ZVRlbnNvcihcbiAgICAgICAgICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oaW5wdXRBcnJheVtpXS50eXBlKSwgZGF0YU9mZnNldCwgZGF0YUJ5dGVMZW5ndGgsIGRpbXNPZmZzZXQsIGRpbXMubGVuZ3RoKTtcbiAgICAgICAgICBpZiAodGVuc29yID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIGEgdGVuc29yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0VmFsdWVzLnB1c2godGVuc29yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlUnVuU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIDQpO1xuICAgICAgY29uc3QgaW5wdXROYW1lc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gICAgICBjb25zdCBvdXRwdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiA0KTtcbiAgICAgIGNvbnN0IG91dHB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKG91dHB1dENvdW50ICogNCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBpbnB1dFZhbHVlc0luZGV4ID0gaW5wdXRWYWx1ZXNPZmZzZXQgLyA0O1xuICAgICAgICBsZXQgaW5wdXROYW1lc0luZGV4ID0gaW5wdXROYW1lc09mZnNldCAvIDQ7XG4gICAgICAgIGxldCBvdXRwdXRWYWx1ZXNJbmRleCA9IG91dHB1dFZhbHVlc09mZnNldCAvIDQ7XG4gICAgICAgIGxldCBvdXRwdXROYW1lc0luZGV4ID0gb3V0cHV0TmFtZXNPZmZzZXQgLyA0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICAgIHdhc20uSEVBUFUzMltpbnB1dFZhbHVlc0luZGV4KytdID0gaW5wdXRWYWx1ZXNbaV07XG4gICAgICAgICAgd2FzbS5IRUFQVTMyW2lucHV0TmFtZXNJbmRleCsrXSA9IHRoaXMuaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc0luZGV4KytdID0gMDtcbiAgICAgICAgICB3YXNtLkhFQVBVMzJbb3V0cHV0TmFtZXNJbmRleCsrXSA9IHRoaXMub3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN1cHBvcnQgUnVuT3B0aW9uc1xuICAgICAgICBsZXQgZXJyb3JDb2RlID0gd2FzbS5fT3J0UnVuKFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzT2Zmc2V0LCBpbnB1dFZhbHVlc09mZnNldCwgaW5wdXRDb3VudCwgb3V0cHV0TmFtZXNPZmZzZXQsIG91dHB1dENvdW50LFxuICAgICAgICAgICAgb3V0cHV0VmFsdWVzT2Zmc2V0LCBydW5PcHRpb25zSGFuZGxlKTtcblxuICAgICAgICBjb25zdCBvdXRwdXQ6IHtbbmFtZTogc3RyaW5nXTogVGVuc29yfSA9IHt9O1xuXG4gICAgICAgIGlmIChlcnJvckNvZGUgPT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbnNvciA9IHdhc20uSEVBUFUzMltvdXRwdXRWYWx1ZXNPZmZzZXQgLyA0ICsgaV07XG5cbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gICAgICAgICAgICAvLyBzdGFjayBhbGxvY2F0ZSA0IHBvaW50ZXIgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHRlbnNvckRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIDQpO1xuXG4gICAgICAgICAgICBsZXQgdHlwZTogVGVuc29yLlR5cGV8dW5kZWZpbmVkLCBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yQ29kZSA9IHdhc20uX09ydEdldFRlbnNvckRhdGEoXG4gICAgICAgICAgICAgICAgICB0ZW5zb3IsIHRlbnNvckRhdGFPZmZzZXQsIHRlbnNvckRhdGFPZmZzZXQgKyA0LCB0ZW5zb3JEYXRhT2Zmc2V0ICsgOCwgdGVuc29yRGF0YU9mZnNldCArIDEyKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZ2V0IGEgdGVuc29yIGRhdGEuIGVycm9yIGNvZGUgPSAke2Vycm9yQ29kZX1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgdGVuc29yRGF0YUluZGV4ID0gdGVuc29yRGF0YU9mZnNldCAvIDQ7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGFUeXBlID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgICAgICAgZGF0YU9mZnNldCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgICAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICAgICAgICBjb25zdCBkaW1zTGVuZ3RoID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgICAgICAgY29uc3QgZGltcyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRpbXMucHVzaCh3YXNtLkhFQVBVMzJbZGltc09mZnNldCAvIDQgKyBpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2FzbS5fT3J0RnJlZShkaW1zT2Zmc2V0KTtcblxuICAgICAgICAgICAgICBjb25zdCBzaXplID0gZGltcy5sZW5ndGggPT09IDAgPyAxIDogZGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgICAgICAgICAgdHlwZSA9IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKGRhdGFUeXBlKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nRGF0YTogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YU9mZnNldCAvIDQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXhCeXRlc1RvUmVhZCA9IGkgPT09IHNpemUgLSAxID8gdW5kZWZpbmVkIDogd2FzbS5IRUFQVTMyW2RhdGFJbmRleF0gLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBzdHJpbmdEYXRhLnB1c2god2FzbS5VVEY4VG9TdHJpbmcob2Zmc2V0LCBtYXhCeXRlc1RvUmVhZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXRbdGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRpY2VzW2ldXV0gPSBuZXcgVGVuc29yKCdzdHJpbmcnLCBzdHJpbmdEYXRhLCBkaW1zKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5ID0gbnVtZXJpY1RlbnNvclR5cGVUb1R5cGVkQXJyYXkodHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IG5ldyBUZW5zb3IodHlwZSwgbmV3IHR5cGVkQXJyYXkoc2l6ZSksIGRpbXMpIGFzIFR5cGVkVGVuc29yPEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPj47XG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodC5kYXRhLmJ1ZmZlciwgdC5kYXRhLmJ5dGVPZmZzZXQsIHQuZGF0YS5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAuc2V0KHdhc20uSEVBUFU4LnN1YmFycmF5KGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyB0LmRhdGEuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIG91dHB1dFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZUdldFRlbnNvckRhdGFTdGFjayk7XG4gICAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiBkYXRhT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2FzbS5fZnJlZShkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4gZXJyb3IgY29kZSA9ICR7ZXJyb3JDb2RlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlUnVuU3RhY2spO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpbnB1dFZhbHVlcy5mb3JFYWNoKHdhc20uX09ydFJlbGVhc2VUZW5zb3IpO1xuICAgICAgaW5wdXRBbGxvY3MuZm9yRWFjaCh3YXNtLl9mcmVlKTtcblxuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgICBydW5PcHRpb25zQWxsb2NzLmZvckVhY2god2FzbS5fZnJlZSk7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHByb2ZpbGluZ1xuICB9XG5cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBwcm9maWxpbmdcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtpdGVyYXRlRXh0cmFPcHRpb25zfSBmcm9tICcuL29wdGlvbnMtdXRpbHMnO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmd9IGZyb20gJy4vc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuY29uc3QgZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsID0gKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IHN0cmluZ3x1bmtub3duKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChncmFwaE9wdGltaXphdGlvbkxldmVsKSB7XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnZXh0ZW5kZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHJldHVybiA5OTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7Z3JhcGhPcHRpbWl6YXRpb25MZXZlbH1gKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0RXhlY3V0aW9uTW9kZSA9IChleGVjdXRpb25Nb2RlOiAnc2VxdWVudGlhbCd8J3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNldFNlc3Npb25PcHRpb25zID0gKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBzZXNzaW9uT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucz8uZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXNzaW9uT3B0aW9ucy5ncmFwaE9wdGltaXphdGlvbkxldmVsID0gJ2FsbCc7XG4gICAgfVxuICAgIGNvbnN0IGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPSBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwoc2Vzc2lvbk9wdGlvbnMuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCEpO1xuXG4gICAgaWYgKG9wdGlvbnM/LmVuYWJsZUNwdU1lbUFyZW5hID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlc3Npb25PcHRpb25zLmVuYWJsZUNwdU1lbUFyZW5hID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uZW5hYmxlTWVtUGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8uZXhlY3V0aW9uTW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Nb2RlID0gJ3NlcXVlbnRpYWwnO1xuICAgIH1cbiAgICBjb25zdCBleGVjdXRpb25Nb2RlID0gZ2V0RXhlY3V0aW9uTW9kZShzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Nb2RlISk7XG5cbiAgICBsZXQgbG9nSWREYXRhT2Zmc2V0ID0gMDtcbiAgICBpZiAob3B0aW9ucz8ubG9nSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nSWREYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG9wdGlvbnMubG9nSWQsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2Vzc2lvbk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA9IDI7ICAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwpIHx8XG4gICAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHwgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1ZlcmJvc2l0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlc3Npb25PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID0gMDsgIC8vIERlZmF1bHQgdG8gMFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogU3VwcG9ydCBwcm9maWxpbmdcbiAgICBzZXNzaW9uT3B0aW9ucy5lbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcblxuICAgIHNlc3Npb25PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoXG4gICAgICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwsICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlQ3B1TWVtQXJlbmEhLCAhIXNlc3Npb25PcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4hLCBleGVjdXRpb25Nb2RlLFxuICAgICAgICBzZXNzaW9uT3B0aW9ucy5lbmFibGVQcm9maWxpbmcsIDAsIGxvZ0lkRGF0YU9mZnNldCwgc2Vzc2lvbk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCEsXG4gICAgICAgIHNlc3Npb25PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKG9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcblxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHtrZXl9IC0gJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgICAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnM7XG4gICAgICBjb25zdCBlcHNOYW1lcyA9IGVwcy5tYXAoaSA9PiB0eXBlb2YgaSA9PT0gJ3N0cmluZycgPyBpIDogaS5uYW1lKTtcbiAgICAgIGlmIChlcHNOYW1lcy5pbmRleE9mKCd3ZWJubicpICE9PSAtMSkge1xuICAgICAgICBpZiAod2FzbS5fT3J0U2Vzc2lvbk9wdGlvbnNBcHBlbmRFeGVjdXRpb25Qcm92aWRlcldlYk5OKHNlc3Npb25PcHRpb25zSGFuZGxlLCAwKSAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgYXBwZW5kIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlcmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2god2FzbS5fZnJlZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2dldEluc3RhbmNlfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5cbmV4cG9ydCBjb25zdCBhbGxvY1dhc21TdHJpbmcgPSAoZGF0YTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogbnVtYmVyID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YUxlbmd0aCA9IHdhc20ubGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMTtcbiAgY29uc3QgZGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhkYXRhTGVuZ3RoKTtcbiAgd2FzbS5zdHJpbmdUb1VURjgoZGF0YSwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG4gIGFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xuXG4gIHJldHVybiBkYXRhT2Zmc2V0O1xufTtcbiIsIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7T3J0V2FzbU1vZHVsZX0gZnJvbSAnLi9iaW5kaW5nL29ydC13YXNtJztcbmltcG9ydCB7T3J0V2FzbVRocmVhZGVkTW9kdWxlfSBmcm9tICcuL2JpbmRpbmcvb3J0LXdhc20tdGhyZWFkZWQnO1xuaW1wb3J0IG9ydFdhc21GYWN0b3J5VGhyZWFkZWQgZnJvbSAnLi9iaW5kaW5nL29ydC13YXNtLXRocmVhZGVkLmpzJztcbmltcG9ydCBvcnRXYXNtRmFjdG9yeSBmcm9tICcuL2JpbmRpbmcvb3J0LXdhc20uanMnO1xuXG5sZXQgd2FzbTogT3J0V2FzbU1vZHVsZTtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuY29uc3QgaXNNdWx0aVRocmVhZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgKHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgKHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1RocmVhZHMgaXMgbm90IHN1cHBvcnRlZCBpbiBOb2RlLmpzJyk7XG4gICAgfVxuICAgIC8vIFRlc3QgZm9yIHRyYW5zZmVyYWJpbGl0eSBvZiBTQUJzIChmb3IgYnJvd3NlcnMuIG5lZWRlZCBmb3IgRmlyZWZveClcbiAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhbXNnL21vemlsbGEuZGV2LnBsYXRmb3JtL0lIa0JabEhFVHBBL2R3c01OY2hXRVFBSlxuICAgIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpO1xuICAgIH1cblxuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IHRocmVhZHMgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyB0aHJlYWRlZCBpbnN0cnVjdGlvbnMuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgIDAsICAwLCAxLCA0LCAxLCAgOTYsIDAsICAgMCwgIDMsIDIsIDEsICAwLCA1LFxuICAgICAgNCwgMSwgIDMsICAgMSwgICAxLCAxMCwgMTEsIDEsIDksIDAsIDY1LCAwLCAgMjU0LCAxNiwgMiwgMCwgMjYsIDExXG4gICAgXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBpc1NpbWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgU0lNRCBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIFNJTUQgaW5zdHJ1Y3Rpb25zLlxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShcbiAgICAgICAgWzAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgNCwgMSwgOTYsIDAsIDAsIDMsIDIsIDEsIDAsIDEwLCA5LCAxLCA3LCAwLCA2NSwgMCwgMjUzLCAxNSwgMjYsIDExXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBkZXRlY3RlZC4nKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJldmlvdXMgY2FsbCB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBmYWlsZWQuJyk7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIC8vIHdhc20gZmxhZ3MgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgY29uc3QgdGltZW91dCA9IGVudi53YXNtLmluaXRUaW1lb3V0ITtcbiAgY29uc3QgbnVtVGhyZWFkcyA9IGVudi53YXNtLm51bVRocmVhZHMhO1xuICBjb25zdCBzaW1kID0gZW52Lndhc20uc2ltZCE7XG5cbiAgY29uc3QgdXNlVGhyZWFkcyA9IG51bVRocmVhZHMgPiAxICYmIGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQoKTtcbiAgY29uc3QgdXNlU2ltZCA9IHNpbWQgJiYgaXNTaW1kU3VwcG9ydGVkKCk7XG4gIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcblxuICBjb25zdCB0YXNrczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBbXTtcblxuICAvLyBwcm9taXNlIGZvciB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ID4gMCkge1xuICAgIHRhc2tzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KSk7XG4gIH1cblxuICAvLyBwcm9taXNlIGZvciBtb2R1bGUgaW5pdGlhbGl6YXRpb25cbiAgdGFza3MucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmFjdG9yeSA9IHVzZVRocmVhZHMgPyBvcnRXYXNtRmFjdG9yeVRocmVhZGVkIDogb3J0V2FzbUZhY3Rvcnk7XG4gICAgY29uc3QgY29uZmlnOiBQYXJ0aWFsPE9ydFdhc21Nb2R1bGU+ID0ge307XG5cbiAgICBpZiAoIXVzZVRocmVhZHMpIHtcbiAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lOiBzdHJpbmcsIHNjcmlwdERpcmVjdG9yeTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh1c2VTaW1kICYmIGZpbGVOYW1lID09PSAnb3J0LXdhc20ud2FzbScpIHtcbiAgICAgICAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgJ29ydC13YXNtLXNpbWQud2FzbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIGZpbGVOYW1lO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25maWcubWFpblNjcmlwdFVybE9yQmxvYiA9IHBhdGguam9pbihfX2Rpcm5hbWUsICdvcnQtd2FzbS10aHJlYWRlZC5qcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0U291cmNlQ29kZSA9XG4gICAgICAgICAgICBgdmFyIG9ydFdhc21UaHJlYWRlZD0oZnVuY3Rpb24oKXt2YXIgX3NjcmlwdERpcjtyZXR1cm4gJHtvcnRXYXNtRmFjdG9yeVRocmVhZGVkLnRvU3RyaW5nKCl9fSkoKTtgO1xuICAgICAgICBjb25maWcubWFpblNjcmlwdFVybE9yQmxvYiA9IG5ldyBCbG9iKFtzY3JpcHRTb3VyY2VDb2RlXSwge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSk7XG4gICAgICAgIGNvbmZpZy5sb2NhdGVGaWxlID0gKGZpbGVOYW1lOiBzdHJpbmcsIHNjcmlwdERpcmVjdG9yeTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgaWYgKGZpbGVOYW1lLmVuZHNXaXRoKCcud29ya2VyLmpzJykpIHtcbiAgICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVxdWlyZSgpIGZ1bmN0aW9uIGlzIGhhbmRsZWQgYnkgd2VicGFjayB0byBsb2FkIGZpbGUgY29udGVudCBvZiB0aGUgY29ycmVzcG9uZGluZyAud29ya2VyLmpzXG4gICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9iaW5kaW5nL29ydC13YXNtLXRocmVhZGVkLndvcmtlci5qcycpXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ3RleHQvamF2YXNjcmlwdCd9KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVzZVNpbWQgJiYgZmlsZU5hbWUgPT09ICdvcnQtd2FzbS10aHJlYWRlZC53YXNtJykge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLndhc20nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgZmlsZU5hbWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmFjdG9yeShjb25maWcpLnRoZW4oXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBtb2R1bGUgPT4ge1xuICAgICAgICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXNtID0gbW9kdWxlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0pO1xuICB9KSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHRhc2tzKTtcblxuICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dGltZW91dH1tc2ApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2UgPSAoKTogT3J0V2FzbU1vZHVsZSA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybiB3YXNtO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc3Bvc2UgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiAhaW5pdGlhbGl6aW5nICYmICFhYm9ydGVkKSB7XG4gICAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAgICh3YXNtIGFzIE9ydFdhc21UaHJlYWRlZE1vZHVsZSkuUFRocmVhZD8udGVybWluYXRlQWxsVGhyZWFkcygpO1xuXG4gICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9vbm54cnVudGltZV9jb21tb25fXzsiLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9saWIvaW5kZXgudHNcIik7XG4iXSwic291cmNlUm9vdCI6IiJ9